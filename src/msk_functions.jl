# Contents of this file is generated. Do not edit by hand
# Target: Mosek 10.1.11
export
  analyzeproblem,
  analyzenames,
  analyzesolution,
  initbasissolve,
  solvewithbasis,
  basiscond,
  appendcons,
  appendvars,
  removecons,
  removevars,
  removebarvars,
  removecones,
  appendbarvars,
  appendcone,
  appendconeseq,
  appendconesseq,
  bktostr,
  chgconbound,
  chgvarbound,
  conetypetostr,
  getaij,
  getapiecenumnz,
  getacolnumnz,
  getacol,
  getacolslice,
  getarownumnz,
  getarow,
  getacolslicenumnz,
  getarowslicenumnz,
  getarowslice,
  getatrip,
  getarowslicetrip,
  getacolslicetrip,
  getconbound,
  getvarbound,
  getconboundslice,
  getvarboundslice,
  getcj,
  getc,
  getcfix,
  getcone,
  getconeinfo,
  getclist,
  getcslice,
  getdouinf,
  getdouparam,
  getdualobj,
  getinfname,
  getintinf,
  getlintinf,
  getintparam,
  getmaxnumanz,
  getmaxnumcon,
  getmaxnumvar,
  getnadouinf,
  getnadouparam,
  getnaintinf,
  getnaintparam,
  getbarvarnamelen,
  getbarvarname,
  getbarvarnameindex,
  putconname,
  putvarname,
  putconename,
  putbarvarname,
  putdomainname,
  putdjcname,
  putaccname,
  getvarnamelen,
  getvarname,
  getconnamelen,
  getconname,
  getconnameindex,
  getvarnameindex,
  getconenamelen,
  getconename,
  getconenameindex,
  getdomainnamelen,
  getdomainname,
  getdjcnamelen,
  getdjcname,
  getaccnamelen,
  getaccname,
  getnastrparam,
  getnumanz,
  getnumanz64,
  getnumcon,
  getnumcone,
  getnumconemem,
  getnumintvar,
  getnumparam,
  getnumqconknz,
  getnumqobjnz,
  getnumvar,
  getnumbarvar,
  getmaxnumbarvar,
  getdimbarvarj,
  getlenbarvarj,
  getobjname,
  getobjnamelen,
  getparamname,
  getprimalobj,
  getprobtype,
  getqconk,
  getqobj,
  getqobjij,
  getsolution,
  getsolutionnew,
  getsolsta,
  getprosta,
  getskc,
  getskx,
  getskn,
  getxc,
  getxx,
  gety,
  getslc,
  getaccdoty,
  getaccdotys,
  evaluateacc,
  evaluateaccs,
  getsuc,
  getslx,
  getsux,
  getsnx,
  getskcslice,
  getskxslice,
  getxcslice,
  getxxslice,
  getyslice,
  getslcslice,
  getsucslice,
  getslxslice,
  getsuxslice,
  getsnxslice,
  getbarxj,
  getbarxslice,
  getbarsj,
  getbarsslice,
  putskc,
  putskx,
  putxc,
  putxx,
  puty,
  putslc,
  putsuc,
  putslx,
  putsux,
  putsnx,
  putaccdoty,
  putskcslice,
  putskxslice,
  putxcslice,
  putxxslice,
  putyslice,
  putslcslice,
  putsucslice,
  putslxslice,
  putsuxslice,
  putsnxslice,
  putbarxj,
  putbarsj,
  getpviolcon,
  getpviolvar,
  getpviolbarvar,
  getpviolcones,
  getpviolacc,
  getpvioldjc,
  getdviolcon,
  getdviolvar,
  getdviolbarvar,
  getdviolcones,
  getdviolacc,
  getsolutioninfo,
  getsolutioninfonew,
  getdualsolutionnorms,
  getprimalsolutionnorms,
  getsolutionslice,
  getreducedcosts,
  getstrparam,
  getstrparamlen,
  gettasknamelen,
  gettaskname,
  getvartype,
  getvartypelist,
  inputdata,
  isdouparname,
  isintparname,
  isstrparname,
  linkfiletostream,
  primalrepair,
  infeasibilityreport,
  optimize,
  printparam,
  probtypetostr,
  prostatostr,
  commitchanges,
  getatruncatetol,
  putatruncatetol,
  putaij,
  putaijlist,
  putacol,
  putarow,
  putarowslice,
  putarowlist,
  putacolslice,
  putacollist,
  putbaraij,
  putbaraijlist,
  putbararowlist,
  getnumbarcnz,
  getnumbaranz,
  getbarcsparsity,
  getbarasparsity,
  getbarcidxinfo,
  getbarcidxj,
  getbarcidx,
  getbaraidxinfo,
  getbaraidxij,
  getbaraidx,
  getnumbarcblocktriplets,
  putbarcblocktriplet,
  getbarcblocktriplet,
  putbarablocktriplet,
  getnumbarablocktriplets,
  getbarablocktriplet,
  putmaxnumafe,
  getnumafe,
  appendafes,
  putafefentry,
  putafefentrylist,
  emptyafefrow,
  emptyafefcol,
  emptyafefrowlist,
  emptyafefcollist,
  putafefrow,
  putafefrowlist,
  putafefcol,
  getafefrownumnz,
  getafefnumnz,
  getafefrow,
  getafeftrip,
  putafebarfentry,
  putafebarfentrylist,
  putafebarfrow,
  emptyafebarfrow,
  emptyafebarfrowlist,
  putafebarfblocktriplet,
  getafebarfnumblocktriplets,
  getafebarfblocktriplet,
  getafebarfnumrowentries,
  getafebarfrowinfo,
  getafebarfrow,
  putafeg,
  putafeglist,
  getafeg,
  getafegslice,
  putafegslice,
  putmaxnumdjc,
  getnumdjc,
  getdjcnumdomain,
  getdjcnumdomaintot,
  getdjcnumafe,
  getdjcnumafetot,
  getdjcnumterm,
  getdjcnumtermtot,
  putmaxnumacc,
  getnumacc,
  appendacc,
  appendaccs,
  appendaccseq,
  appendaccsseq,
  putacc,
  putacclist,
  putaccb,
  putaccbj,
  getaccdomain,
  getaccn,
  getaccntot,
  getaccafeidxlist,
  getaccb,
  getaccs,
  getaccfnumnz,
  getaccftrip,
  getaccgvector,
  getaccbarfnumblocktriplets,
  getaccbarfblocktriplet,
  appenddjcs,
  putdjc,
  putdjcslice,
  getdjcdomainidxlist,
  getdjcafeidxlist,
  getdjcb,
  getdjctermsizelist,
  getdjcs,
  putconbound,
  putconboundlist,
  putconboundlistconst,
  putconboundslice,
  putconboundsliceconst,
  putvarbound,
  putvarboundlist,
  putvarboundlistconst,
  putvarboundslice,
  putvarboundsliceconst,
  putcfix,
  putcj,
  putobjsense,
  getobjsense,
  putclist,
  putcslice,
  putbarcj,
  putcone,
  putmaxnumdomain,
  getnumdomain,
  appendrplusdomain,
  appendrminusdomain,
  appendrdomain,
  appendrzerodomain,
  appendquadraticconedomain,
  appendrquadraticconedomain,
  appendprimalexpconedomain,
  appenddualexpconedomain,
  appendprimalgeomeanconedomain,
  appenddualgeomeanconedomain,
  appendprimalpowerconedomain,
  appenddualpowerconedomain,
  appendsvecpsdconedomain,
  getdomaintype,
  getdomainn,
  getpowerdomaininfo,
  getpowerdomainalpha,
  appendsparsesymmat,
  appendsparsesymmatlist,
  getsymmatinfo,
  getnumsymmat,
  getsparsesymmat,
  putdouparam,
  putintparam,
  putmaxnumcon,
  putmaxnumcone,
  getmaxnumcone,
  putmaxnumvar,
  putmaxnumbarvar,
  putmaxnumanz,
  putmaxnumqnz,
  getmaxnumqnz,
  putnadouparam,
  putnaintparam,
  putnastrparam,
  putobjname,
  putparam,
  putqcon,
  putqconk,
  putqobj,
  putqobjij,
  putsolution,
  putsolutionnew,
  putconsolutioni,
  putvarsolutionj,
  putsolutionyi,
  putstrparam,
  puttaskname,
  putvartype,
  putvartypelist,
  readdataformat,
  readdata,
  readparamfile,
  readsolution,
  readjsonsol,
  readsummary,
  resizetask,
  checkmem,
  getmemusage,
  setdefaults,
  solutiondef,
  deletesolution,
  onesolutionsummary,
  solutionsummary,
  updatesolutioninfo,
  optimizersummary,
  strtoconetype,
  strtosk,
  writedata,
  writetask,
  writebsolution,
  readbsolution,
  writesolutionfile,
  readsolutionfile,
  readtask,
  readopfstring,
  readlpstring,
  readjsonstring,
  readptfstring,
  writeparamfile,
  getinfeasiblesubproblem,
  writesolution,
  writejsonsol,
  primalsensitivity,
  sensitivityreport,
  dualsensitivity,
  getlasterror,
  optimizermt,
  asyncoptimize,
  asyncstop,
  asyncpoll,
  asyncgetresult,
  putoptserverhost,
  optimizebatch,
  callbackcodetostr,
  checkoutlicense,
  checkinlicense,
  checkinall,
  expirylicenses,
  resetexpirylicenses,
  echointro,
  getcodedesc,
  rescodetostr,
  iinfitemtostr,
  dinfitemtostr,
  liinfitemtostr,
  getversion,
  linkfiletostream,
  putlicensedebug,
  putlicensecode,
  putlicensewait,
  putlicensepath,
  computesparsecholesky,
  sparsetriangularsolvedense,
  licensecleanup

macro MSK_analyzeproblem(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_analyzeproblem,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_analyzenames(task,whichstream,nametype)
  quote
     local res = disable_sigint(()->ccall((:MSK_analyzenames,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(nametype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_analyzesolution(task,whichstream,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_analyzesolution,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_initbasissolve(task,basis)
  quote
     local res = disable_sigint(()->ccall((:MSK_initbasissolve,libmosek),Int32,(Ptr{Nothing},Ptr{Int32},),$(esc(task)),$(esc(basis))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solvewithbasis(task,transp,numnz,sub,val,numnzout)
  quote
     local res = disable_sigint(()->ccall((:MSK_solvewithbasis,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ref{Int32},),$(esc(task)),$(esc(transp)),$(esc(numnz)),$(esc(sub)),$(esc(val)),$(esc(numnzout))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_basiscond(task,nrmbasis,nrminvbasis)
  quote
     local res = disable_sigint(()->ccall((:MSK_basiscond,libmosek),Int32,(Ptr{Nothing},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(nrmbasis)),$(esc(nrminvbasis))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendcons(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendcons,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendvars(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendvars,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removecons(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removecons,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removevars(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removevars,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removebarvars(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removebarvars,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removecones(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removecones,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendbarvars(task,num,dim)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendbarvars,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(dim))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendcone(task,ct,conepar,nummem,submem)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendcone,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Int32,Ptr{Int32},),$(esc(task)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(submem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendconeseq(task,ct,conepar,nummem,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendconeseq,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Int32,Int32,),$(esc(task)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendconesseq(task,num,ct,conepar,nummem,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendconesseq,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Int32},Int32,),$(esc(task)),$(esc(num)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_bktostr(task,bk,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_bktostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(bk)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_chgconbound(task,i,lower,finite,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_chgconbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(lower)),$(esc(finite)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_chgvarbound(task,j,lower,finite,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_chgvarbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,),$(esc(task)),$(esc(j)),$(esc(lower)),$(esc(finite)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_conetypetostr(task,ct,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_conetypetostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(ct)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_deletetask(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_deletetask,libmosek),Int32,(Ref{Ptr{Nothing}},),$(esc(task))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_freetask(task,buffer)
  quote
     disable_sigint(()->ccall((:MSK_freetask,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},),$(esc(task)),$(esc(buffer))))
  end
end
macro MSK_freedbgtask(task,buffer,file,line)
  quote
     disable_sigint(()->ccall((:MSK_freedbgtask,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},Ptr{UInt8},UInt32,),$(esc(task)),$(esc(buffer)),$(esc(file)),$(esc(line))))
  end
end
macro MSK_getaij(task,i,j,aij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(aij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getapiecenumnz(task,firsti,lasti,firstj,lastj,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getapiecenumnz,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ref{Int32},),$(esc(task)),$(esc(firsti)),$(esc(lasti)),$(esc(firstj)),$(esc(lastj)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolnumnz(task,i,nzj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolnumnz,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(nzj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacol(task,j,nzj,subj,valj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacol,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(j)),$(esc(nzj)),$(esc(subj)),$(esc(valj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslice(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslice64(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarownumnz(task,i,nzi)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarownumnz,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(nzi))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarow(task,i,nzi,subi,vali)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarow,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(i)),$(esc(nzi)),$(esc(subi)),$(esc(vali))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslicenumnz(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslicenumnz,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslicenumnz64(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslicenumnz64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslicenumnz(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslicenumnz,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslicenumnz64(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslicenumnz64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslice(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslice64(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getatrip(task,maxnumnz,subi,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getatrip,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumnz)),$(esc(subi)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslicetrip(task,first,last,maxnumnz,subi,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslicetrip,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(subi)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslicetrip(task,first,last,maxnumnz,subi,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslicetrip,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(subi)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconbound(task,i,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconbound,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarbound(task,i,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarbound,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconboundslice(task,first,last,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarboundslice(task,first,last,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcj(task,j,cj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(j)),$(esc(cj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getc(task,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_getc,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},),$(esc(task)),$(esc(c))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcallbackfunc(task,func,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcallbackfunc,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Cvoid}},Ref{Any},),$(esc(task)),$(esc(func)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcfix(task,cfix)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcfix,libmosek),Int32,(Ptr{Nothing},Ref{Float64},),$(esc(task)),$(esc(cfix))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcone(task,k,ct,conepar,nummem,submem)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcone,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Int32},Ptr{Int32},),$(esc(task)),$(esc(k)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(submem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconeinfo(task,k,ct,conepar,nummem)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconeinfo,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Int32},),$(esc(task)),$(esc(k)),$(esc(ct)),$(esc(conepar)),$(esc(nummem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getclist(task,num,subj,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_getclist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(c))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcslice(task,first,last,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(c))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdouinf(task,whichdinf,dvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdouinf,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(whichdinf)),$(esc(dvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdouparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdouparam,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdualobj(task,whichsol,dualobj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdualobj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(dualobj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getenv(task,env)
  quote
     local res = disable_sigint(()->ccall((:MSK_getenv,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Nothing}},),$(esc(task)),$(esc(env))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfindex(task,inftype,infname,infindex)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfindex,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(inftype)),$(esc(infname)),$(esc(infindex))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfmax(task,inftype,infmax)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfmax,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(inftype)),$(esc(infmax))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfname(task,inftype,whichinf,infname)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(inftype)),$(esc(whichinf)),$(esc(infname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getintinf(task,whichiinf,ivalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getintinf,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichiinf)),$(esc(ivalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getlintinf(task,whichliinf,ivalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getlintinf,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int64},),$(esc(task)),$(esc(whichliinf)),$(esc(ivalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getintparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getintparam,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnamelen(task,maxlen)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnamelen,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxlen))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumanz(task,maxnumanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumanz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumanz64(task,maxnumanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumanz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(maxnumanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumcon(task,maxnumcon)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumcon,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumcon))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumvar(task,maxnumvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnadouinf(task,infitemname,dvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnadouinf,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Float64},),$(esc(task)),$(esc(infitemname)),$(esc(dvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnadouparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnadouparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Float64},),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnaintinf(task,infitemname,ivalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnaintinf,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(infitemname)),$(esc(ivalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnaintparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnaintparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarvarnamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarvarnamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarvarname(task,i,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarvarname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarvarnameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarvarnameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconname(task,i,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarname(task,j,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconename(task,j,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconename,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarvarname(task,j,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarvarname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdomainname(task,domidx,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdomainname,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{UInt8},),$(esc(task)),$(esc(domidx)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdjcname(task,djcidx,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdjcname,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{UInt8},),$(esc(task)),$(esc(djcidx)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccname(task,accidx,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccname,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{UInt8},),$(esc(task)),$(esc(accidx)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarnamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarnamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarname(task,j,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconnamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconnamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconname(task,i,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconnameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconnameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarnameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarnameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconenamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconenamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconename(task,i,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconename,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconenameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconenameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomainnamelen(task,domidx,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomainnamelen,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(domidx)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomainname(task,domidx,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomainname,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{UInt8},),$(esc(task)),$(esc(domidx)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnamelen(task,djcidx,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnamelen,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(djcidx)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcname(task,djcidx,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcname,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{UInt8},),$(esc(task)),$(esc(djcidx)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccnamelen(task,accidx,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccnamelen,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(accidx)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccname(task,accidx,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccname,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{UInt8},),$(esc(task)),$(esc(accidx)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnastrparam(task,paramname,sizeparamname,len,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnastrparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,Ref{Int32},Ptr{UInt8},),$(esc(task)),$(esc(paramname)),$(esc(sizeparamname)),$(esc(len)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumanz(task,numanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumanz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumanz64(task,numanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumanz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumcon(task,numcon)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumcon,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numcon))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumcone(task,numcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumcone,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumconemem(task,k,nummem)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumconemem,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(k)),$(esc(nummem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumintvar(task,numintvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumintvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numintvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumparam(task,partype,numparam)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumparam,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(partype)),$(esc(numparam))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqconknz(task,k,numqcnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqconknz,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(k)),$(esc(numqcnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqconknz64(task,k,numqcnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqconknz64,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int64},),$(esc(task)),$(esc(k)),$(esc(numqcnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqobjnz(task,numqonz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqobjnz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numqonz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqobjnz64(task,numqonz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqobjnz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numqonz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumvar(task,numvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarvar(task,numbarvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numbarvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumbarvar(task,maxnumbarvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumbarvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumbarvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdimbarvarj(task,j,dimbarvarj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdimbarvarj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(j)),$(esc(dimbarvarj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getlenbarvarj(task,j,lenbarvarj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getlenbarvarj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int64},),$(esc(task)),$(esc(j)),$(esc(lenbarvarj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getobjname(task,sizeobjname,objname)
  quote
     local res = disable_sigint(()->ccall((:MSK_getobjname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(sizeobjname)),$(esc(objname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getobjnamelen(task,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getobjnamelen,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getparamname(task,partype,param,parname)
  quote
     local res = disable_sigint(()->ccall((:MSK_getparamname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(partype)),$(esc(param)),$(esc(parname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getparammax(task,partype,parammax)
  quote
     local res = disable_sigint(()->ccall((:MSK_getparammax,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(partype)),$(esc(parammax))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprimalobj(task,whichsol,primalobj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprimalobj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(primalobj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprobtype(task,probtype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprobtype,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(probtype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqconk64(task,k,maxnumqcnz,numqcnz,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqconk64,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(k)),$(esc(maxnumqcnz)),$(esc(numqcnz)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqconk(task,k,maxnumqcnz,numqcnz,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqconk,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(k)),$(esc(maxnumqcnz)),$(esc(numqcnz)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqobj(task,maxnumqonz,numqonz,qosubi,qosubj,qoval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqobj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumqonz)),$(esc(numqonz)),$(esc(qosubi)),$(esc(qosubj)),$(esc(qoval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqobj64(task,maxnumqonz,numqonz,qosubi,qosubj,qoval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqobj64,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumqonz)),$(esc(numqonz)),$(esc(qosubi)),$(esc(qosubj)),$(esc(qoval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqobjij(task,i,j,qoij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqobjij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(qoij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolution(task,whichsol,problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolution,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(problemsta)),$(esc(solutionsta)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutionnew(task,whichsol,problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutionnew,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(problemsta)),$(esc(solutionsta)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolsta(task,whichsol,solutionsta)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolsta,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(solutionsta))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprosta(task,whichsol,problemsta)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprosta,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(problemsta))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskc(task,whichsol,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskx(task,whichsol,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskn(task,whichsol,skn)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskn,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skn))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxc(task,whichsol,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxx(task,whichsol,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_gety(task,whichsol,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_gety,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslc(task,whichsol,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccdoty(task,whichsol,accidx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccdoty,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(accidx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccdotys(task,whichsol,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccdotys,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_evaluateacc(task,whichsol,accidx,activity)
  quote
     local res = disable_sigint(()->ccall((:MSK_evaluateacc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(accidx)),$(esc(activity))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_evaluateaccs(task,whichsol,activity)
  quote
     local res = disable_sigint(()->ccall((:MSK_evaluateaccs,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(activity))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsuc(task,whichsol,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsuc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslx(task,whichsol,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsux(task,whichsol,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsux,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsnx(task,whichsol,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsnx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskcslice(task,whichsol,first,last,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskxslice(task,whichsol,first,last,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxcslice(task,whichsol,first,last,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxxslice(task,whichsol,first,last,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getyslice(task,whichsol,first,last,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_getyslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslcslice(task,whichsol,first,last,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsucslice(task,whichsol,first,last,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsucslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslxslice(task,whichsol,first,last,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsuxslice(task,whichsol,first,last,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsuxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsnxslice(task,whichsol,first,last,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsnxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarxj(task,whichsol,j,barxj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarxj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barxj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarxslice(task,whichsol,first,last,slicesize,barxslice)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slicesize)),$(esc(barxslice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarsj(task,whichsol,j,barsj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarsj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barsj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarsslice(task,whichsol,first,last,slicesize,barsslice)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarsslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slicesize)),$(esc(barsslice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskc(task,whichsol,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskx(task,whichsol,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxc(task,whichsol,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxx(task,whichsol,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_puty(task,whichsol,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_puty,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslc(task,whichsol,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsuc(task,whichsol,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsuc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslx(task,whichsol,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsux(task,whichsol,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsux,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsnx(task,whichsol,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsnx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccdoty(task,whichsol,accidx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccdoty,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(accidx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskcslice(task,whichsol,first,last,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskxslice(task,whichsol,first,last,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxcslice(task,whichsol,first,last,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxxslice(task,whichsol,first,last,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putyslice(task,whichsol,first,last,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_putyslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslcslice(task,whichsol,first,last,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsucslice(task,whichsol,first,last,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsucslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslxslice(task,whichsol,first,last,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsuxslice(task,whichsol,first,last,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsuxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsnxslice(task,whichsol,first,last,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsnxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarxj(task,whichsol,j,barxj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarxj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barxj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarsj(task,whichsol,j,barsj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarsj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barsj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolcon(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolcon,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolbarvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolbarvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolcones(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolcones,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolacc(task,whichsol,numaccidx,accidxlist,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolacc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(numaccidx)),$(esc(accidxlist)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpvioldjc(task,whichsol,numdjcidx,djcidxlist,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpvioldjc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(numdjcidx)),$(esc(djcidxlist)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolcon(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolcon,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolbarvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolbarvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolcones(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolcones,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolacc(task,whichsol,numaccidx,accidxlist,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolacc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(numaccidx)),$(esc(accidxlist)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutioninfo(task,whichsol,pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutioninfo,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(pobj)),$(esc(pviolcon)),$(esc(pviolvar)),$(esc(pviolbarvar)),$(esc(pviolcone)),$(esc(pviolitg)),$(esc(dobj)),$(esc(dviolcon)),$(esc(dviolvar)),$(esc(dviolbarvar)),$(esc(dviolcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutioninfonew(task,whichsol,pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolacc,pvioldjc,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone,dviolacc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutioninfonew,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(pobj)),$(esc(pviolcon)),$(esc(pviolvar)),$(esc(pviolbarvar)),$(esc(pviolcone)),$(esc(pviolacc)),$(esc(pvioldjc)),$(esc(pviolitg)),$(esc(dobj)),$(esc(dviolcon)),$(esc(dviolvar)),$(esc(dviolbarvar)),$(esc(dviolcone)),$(esc(dviolacc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdualsolutionnorms(task,whichsol,nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdualsolutionnorms,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(nrmy)),$(esc(nrmslc)),$(esc(nrmsuc)),$(esc(nrmslx)),$(esc(nrmsux)),$(esc(nrmsnx)),$(esc(nrmbars))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprimalsolutionnorms(task,whichsol,nrmxc,nrmxx,nrmbarx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprimalsolutionnorms,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(nrmxc)),$(esc(nrmxx)),$(esc(nrmbarx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutionslice(task,whichsol,solitem,first,last,values)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutionslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(solitem)),$(esc(first)),$(esc(last)),$(esc(values))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getreducedcosts(task,whichsol,first,last,redcosts)
  quote
     local res = disable_sigint(()->ccall((:MSK_getreducedcosts,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(redcosts))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getstrparam(task,param,maxlen,len,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getstrparam,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},Ptr{UInt8},),$(esc(task)),$(esc(param)),$(esc(maxlen)),$(esc(len)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getstrparamlen(task,param,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getstrparamlen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(param)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsymbcon(task,i,sizevalue,name,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsymbcon,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(sizevalue)),$(esc(name)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_gettasknamelen(task,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_gettasknamelen,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_gettaskname(task,sizetaskname,taskname)
  quote
     local res = disable_sigint(()->ccall((:MSK_gettaskname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(sizetaskname)),$(esc(taskname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvartype(task,j,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvartype,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(j)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvartypelist(task,num,subj,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvartypelist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_inputdata(task,maxnumcon,maxnumvar,numcon,numvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_inputdata,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},Float64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(numcon)),$(esc(numvar)),$(esc(c)),$(esc(cfix)),$(esc(aptrb)),$(esc(aptre)),$(esc(asub)),$(esc(aval)),$(esc(bkc)),$(esc(blc)),$(esc(buc)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_inputdata64(task,maxnumcon,maxnumvar,numcon,numvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_inputdata64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},Float64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(numcon)),$(esc(numvar)),$(esc(c)),$(esc(cfix)),$(esc(aptrb)),$(esc(aptre)),$(esc(asub)),$(esc(aval)),$(esc(bkc)),$(esc(blc)),$(esc(buc)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_isdouparname(task,parname,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_isdouparname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_isintparname(task,parname,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_isintparname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_isstrparname(task,parname,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_isstrparname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_linkfiletotaskstream(task,whichstream,filename,append)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfiletotaskstream,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Int32,),$(esc(task)),$(esc(whichstream)),$(esc(filename)),$(esc(append))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_linkfunctotaskstream(task,whichstream,handle,func)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfunctotaskstream,libmosek),Int32,(Ptr{Nothing},Int32,Any,Ptr{Cvoid},),$(esc(task)),$(esc(whichstream)),$(esc(handle)),$(esc(func))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_unlinkfuncfromtaskstream(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_unlinkfuncfromtaskstream,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_clonetask(task,clonedtask)
  quote
     local res = disable_sigint(()->ccall((:MSK_clonetask,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Nothing}},),$(esc(task)),$(esc(clonedtask))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_primalrepair(task,wlc,wuc,wlx,wux)
  quote
     local res = disable_sigint(()->ccall((:MSK_primalrepair,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(wlc)),$(esc(wuc)),$(esc(wlx)),$(esc(wux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_infeasibilityreport(task,whichstream,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_infeasibilityreport,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_toconic(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_toconic,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimize(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimize,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizetrm(task,trmcode)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizetrm,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(trmcode))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_printparam(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_printparam,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_probtypetostr(task,probtype,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_probtypetostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(probtype)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_prostatostr(task,problemsta,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_prostatostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(problemsta)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putresponsefunc(task,responsefunc,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_putresponsefunc,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,),$(esc(task)),$(esc(responsefunc)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_commitchanges(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_commitchanges,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getatruncatetol(task,tolzero)
  quote
     local res = disable_sigint(()->ccall((:MSK_getatruncatetol,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},),$(esc(task)),$(esc(tolzero))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putatruncatetol(task,tolzero)
  quote
     local res = disable_sigint(()->ccall((:MSK_putatruncatetol,libmosek),Int32,(Ptr{Nothing},Float64,),$(esc(task)),$(esc(tolzero))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaij(task,i,j,aij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(aij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaijlist(task,num,subi,subj,valij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaijlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(valij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaijlist64(task,num,subi,subj,valij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaijlist64,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(valij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacol(task,j,nzj,subj,valj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacol,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(j)),$(esc(nzj)),$(esc(subj)),$(esc(valj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarow(task,i,nzi,subi,vali)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarow,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(i)),$(esc(nzi)),$(esc(subi)),$(esc(vali))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowslice(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowslice64(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowlist(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowlist64(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowlist64,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacolslice(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacolslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacolslice64(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacolslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacollist(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacollist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacollist64(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacollist64,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbaraij(task,i,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbaraij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbaraijlist(task,num,subi,subj,alphaptrb,alphaptre,matidx,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbaraijlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(alphaptrb)),$(esc(alphaptre)),$(esc(matidx)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbararowlist(task,num,subi,ptrb,ptre,subj,nummat,matidx,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbararowlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(ptrb)),$(esc(ptre)),$(esc(subj)),$(esc(nummat)),$(esc(matidx)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarcnz(task,nz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarcnz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(nz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbaranz(task,nz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbaranz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(nz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcsparsity(task,maxnumnz,numnz,idxj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcsparsity,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},),$(esc(task)),$(esc(maxnumnz)),$(esc(numnz)),$(esc(idxj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarasparsity(task,maxnumnz,numnz,idxij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarasparsity,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},),$(esc(task)),$(esc(maxnumnz)),$(esc(numnz)),$(esc(idxij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcidxinfo(task,idx,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcidxinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(idx)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcidxj(task,idx,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcidxj,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(idx)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcidx(task,idx,maxnum,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcidx,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ref{Int32},Ref{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(idx)),$(esc(maxnum)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbaraidxinfo(task,idx,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbaraidxinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(idx)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbaraidxij(task,idx,i,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbaraidxij,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(idx)),$(esc(i)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbaraidx(task,idx,maxnum,i,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbaraidx,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ref{Int32},Ref{Int32},Ref{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(idx)),$(esc(maxnum)),$(esc(i)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarcblocktriplets(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarcblocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarcblocktriplet(task,num,subj,subk,subl,valjkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarcblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valjkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcblocktriplet(task,maxnum,num,subj,subk,subl,valjkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnum)),$(esc(num)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valjkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarablocktriplet(task,num,subi,subj,subk,subl,valijkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarablocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valijkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarablocktriplets(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarablocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarablocktriplet(task,maxnum,num,subi,subj,subk,subl,valijkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarablocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnum)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valijkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumafe(task,maxnumafe)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumafe,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumafe))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumafe(task,numafe)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumafe,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numafe))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendafes(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendafes,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefentry(task,afeidx,varidx,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefentry,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Float64,),$(esc(task)),$(esc(afeidx)),$(esc(varidx)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefentrylist(task,numentr,afeidx,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefentrylist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numentr)),$(esc(afeidx)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefrow(task,afeidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefrow,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(afeidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefcol(task,varidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefcol,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(varidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefrowlist(task,numafeidx,afeidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefrowlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefcollist(task,numvaridx,varidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefcollist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},),$(esc(task)),$(esc(numvaridx)),$(esc(varidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefrow(task,afeidx,numnz,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefrow,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(numnz)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefrowlist(task,numafeidx,afeidx,numnzrow,ptrrow,lenidxval,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefrowlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int64},Int64,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx)),$(esc(numnzrow)),$(esc(ptrrow)),$(esc(lenidxval)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefcol(task,varidx,numnz,afeidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefcol,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(varidx)),$(esc(numnz)),$(esc(afeidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafefrownumnz(task,afeidx,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafefrownumnz,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(afeidx)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafefnumnz(task,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafefnumnz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafefrow(task,afeidx,numnz,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafefrow,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(numnz)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafeftrip(task,afeidx,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafeftrip,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfentry(task,afeidx,barvaridx,numterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfentry,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(numterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfentrylist(task,numafeidx,afeidx,barvaridx,numterm,ptrterm,lenterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfentrylist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(numterm)),$(esc(ptrterm)),$(esc(lenterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfrow(task,afeidx,numentr,barvaridx,numterm,ptrterm,lenterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfrow,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(numentr)),$(esc(barvaridx)),$(esc(numterm)),$(esc(ptrterm)),$(esc(lenterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafebarfrow(task,afeidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafebarfrow,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(afeidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafebarfrowlist(task,numafeidx,afeidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafebarfrowlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfblocktriplet(task,numtrip,afeidx,barvaridx,subk,subl,valkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numtrip)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(subk)),$(esc(subl)),$(esc(valkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfnumblocktriplets(task,numtrip)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfnumblocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numtrip))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfblocktriplet(task,maxnumtrip,numtrip,afeidx,barvaridx,subk,subl,valkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumtrip)),$(esc(numtrip)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(subk)),$(esc(subl)),$(esc(valkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfnumrowentries(task,afeidx,numentr)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfnumrowentries,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(afeidx)),$(esc(numentr))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfrowinfo(task,afeidx,numentr,numterm)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfrowinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ref{Int64},),$(esc(task)),$(esc(afeidx)),$(esc(numentr)),$(esc(numterm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfrow(task,afeidx,barvaridx,ptrterm,numterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfrow,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(ptrterm)),$(esc(numterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafeg(task,afeidx,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafeg,libmosek),Int32,(Ptr{Nothing},Int64,Float64,),$(esc(task)),$(esc(afeidx)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafeglist(task,numafeidx,afeidx,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafeglist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafeg(task,afeidx,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafeg,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafegslice(task,first,last,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafegslice,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafegslice(task,first,last,slice)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafegslice,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(slice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumdjc(task,maxnumdjc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumdjc,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumdjc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumdjc(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumdjc,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumdomain(task,djcidx,numdomain)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numdomain))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumdomaintot(task,numdomaintot)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumdomaintot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numdomaintot))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumafe(task,djcidx,numafe)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumafe,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numafe))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumafetot(task,numafetot)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumafetot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numafetot))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumterm(task,djcidx,numterm)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumterm,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numterm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumtermtot(task,numtermtot)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumtermtot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numtermtot))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumacc(task,maxnumacc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumacc,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumacc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumacc(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumacc,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendacc(task,domidx,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendacc,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(domidx)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendaccs(task,numaccs,domidxs,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendaccs,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numaccs)),$(esc(domidxs)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendaccseq(task,domidx,numafeidx,afeidxfirst,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendaccseq,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(domidx)),$(esc(numafeidx)),$(esc(afeidxfirst)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendaccsseq(task,numaccs,domidxs,numafeidx,afeidxfirst,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendaccsseq,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(numaccs)),$(esc(domidxs)),$(esc(numafeidx)),$(esc(afeidxfirst)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacc(task,accidx,domidx,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacc,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(accidx)),$(esc(domidx)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacclist(task,numaccs,accidxs,domidxs,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacclist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numaccs)),$(esc(accidxs)),$(esc(domidxs)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccb(task,accidx,lengthb,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccb,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(accidx)),$(esc(lengthb)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccbj(task,accidx,j,bj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccbj,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Float64,),$(esc(task)),$(esc(accidx)),$(esc(j)),$(esc(bj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccdomain(task,accidx,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(accidx)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccn(task,accidx,n)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccn,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(accidx)),$(esc(n))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccntot(task,n)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccntot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(n))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccafeidxlist(task,accidx,afeidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccafeidxlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(accidx)),$(esc(afeidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccb(task,accidx,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccb,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Float64},),$(esc(task)),$(esc(accidx)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccs(task,domidxlist,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccs,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(domidxlist)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccfnumnz(task,accfnnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccfnumnz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(accfnnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccftrip(task,frow,fcol,fval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccftrip,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(frow)),$(esc(fcol)),$(esc(fval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccgvector(task,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccgvector,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},),$(esc(task)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccbarfnumblocktriplets(task,numtrip)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccbarfnumblocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numtrip))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccbarfblocktriplet(task,maxnumtrip,numtrip,acc_afe,bar_var,blk_row,blk_col,blk_val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccbarfblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumtrip)),$(esc(numtrip)),$(esc(acc_afe)),$(esc(bar_var)),$(esc(blk_row)),$(esc(blk_col)),$(esc(blk_val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddjcs(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddjcs,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdjc(task,djcidx,numdomidx,domidxlist,numafeidx,afeidxlist,b,numterms,termsizelist)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdjc,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numdomidx)),$(esc(domidxlist)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b)),$(esc(numterms)),$(esc(termsizelist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdjcslice(task,idxfirst,idxlast,numdomidx,domidxlist,numafeidx,afeidxlist,b,numterms,termsizelist,termsindjc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdjcslice,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},Int64,Ptr{Int64},Ptr{Int64},),$(esc(task)),$(esc(idxfirst)),$(esc(idxlast)),$(esc(numdomidx)),$(esc(domidxlist)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b)),$(esc(numterms)),$(esc(termsizelist)),$(esc(termsindjc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcdomainidxlist(task,djcidx,domidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcdomainidxlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(domidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcafeidxlist(task,djcidx,afeidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcafeidxlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(afeidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcb(task,djcidx,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcb,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Float64},),$(esc(task)),$(esc(djcidx)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjctermsizelist(task,djcidx,termsizelist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjctermsizelist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(termsizelist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcs(task,domidxlist,afeidxlist,b,termsizelist,numterms)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcs,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int64},Ptr{Float64},Ptr{Int64},Ptr{Int64},),$(esc(task)),$(esc(domidxlist)),$(esc(afeidxlist)),$(esc(b)),$(esc(termsizelist)),$(esc(numterms))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconbound(task,i,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(i)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundlist(task,num,sub,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundlistconst(task,num,sub,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundlistconst,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Int32,Float64,Float64,),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundslice(task,first,last,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundsliceconst(task,first,last,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundsliceconst,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarbound(task,j,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(j)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundlist(task,num,sub,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundlistconst(task,num,sub,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundlistconst,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Int32,Float64,Float64,),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundslice(task,first,last,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundsliceconst(task,first,last,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundsliceconst,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcallbackfunc(task,func,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcallbackfunc,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,),$(esc(task)),$(esc(func)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcfix(task,cfix)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcfix,libmosek),Int32,(Ptr{Nothing},Float64,),$(esc(task)),$(esc(cfix))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcj(task,j,cj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcj,libmosek),Int32,(Ptr{Nothing},Int32,Float64,),$(esc(task)),$(esc(j)),$(esc(cj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putobjsense(task,sense)
  quote
     local res = disable_sigint(()->ccall((:MSK_putobjsense,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(sense))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getobjsense(task,sense)
  quote
     local res = disable_sigint(()->ccall((:MSK_getobjsense,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(sense))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putclist(task,num,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putclist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcslice(task,first,last,slice)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(slice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarcj(task,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarcj,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcone(task,k,ct,conepar,nummem,submem)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcone,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Int32,Ptr{Int32},),$(esc(task)),$(esc(k)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(submem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumdomain(task,maxnumdomain)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumdomain,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumdomain))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumdomain(task,numdomain)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumdomain,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numdomain))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrplusdomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrplusdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrminusdomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrminusdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrdomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrzerodomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrzerodomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendquadraticconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendquadraticconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrquadraticconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrquadraticconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendprimalexpconedomain(task,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendprimalexpconedomain,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddualexpconedomain(task,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddualexpconedomain,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendprimalgeomeanconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendprimalgeomeanconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddualgeomeanconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddualgeomeanconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendprimalpowerconedomain(task,n,nleft,alpha,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendprimalpowerconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(nleft)),$(esc(alpha)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddualpowerconedomain(task,n,nleft,alpha,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddualpowerconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(nleft)),$(esc(alpha)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendsvecpsdconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendsvecpsdconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomaintype(task,domidx,domtype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomaintype,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(domidx)),$(esc(domtype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomainn(task,domidx,n)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomainn,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(domidx)),$(esc(n))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpowerdomaininfo(task,domidx,n,nleft)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpowerdomaininfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ref{Int64},),$(esc(task)),$(esc(domidx)),$(esc(n)),$(esc(nleft))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpowerdomainalpha(task,domidx,alpha)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpowerdomainalpha,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Float64},),$(esc(task)),$(esc(domidx)),$(esc(alpha))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendsparsesymmat(task,dim,nz,subi,subj,valij,idx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendsparsesymmat,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ref{Int64},),$(esc(task)),$(esc(dim)),$(esc(nz)),$(esc(subi)),$(esc(subj)),$(esc(valij)),$(esc(idx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendsparsesymmatlist(task,num,dims,nz,subi,subj,valij,idx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendsparsesymmatlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Int64},),$(esc(task)),$(esc(num)),$(esc(dims)),$(esc(nz)),$(esc(subi)),$(esc(subj)),$(esc(valij)),$(esc(idx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsymmatinfo(task,idx,dim,nz,mattype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsymmatinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ref{Int64},Ref{Int32},),$(esc(task)),$(esc(idx)),$(esc(dim)),$(esc(nz)),$(esc(mattype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumsymmat(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumsymmat,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsparsesymmat(task,idx,maxlen,subi,subj,valij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsparsesymmat,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(idx)),$(esc(maxlen)),$(esc(subi)),$(esc(subj)),$(esc(valij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdouparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdouparam,libmosek),Int32,(Ptr{Nothing},Int32,Float64,),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putintparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putintparam,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumcon(task,maxnumcon)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumcon,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumcon))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumcone(task,maxnumcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumcone,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumcone(task,maxnumcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumcone,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumvar(task,maxnumvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumvar,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumbarvar(task,maxnumbarvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumbarvar,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumbarvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumanz(task,maxnumanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumanz,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumqnz(task,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumqnz,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumqnz(task,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumqnz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumqnz64(task,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumqnz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putnadouparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putnadouparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Float64,),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putnaintparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putnaintparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putnastrparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putnastrparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putobjname(task,objname)
  quote
     local res = disable_sigint(()->ccall((:MSK_putobjname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(objname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putparam(task,parname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(parname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqcon(task,numqcnz,qcsubk,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqcon,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numqcnz)),$(esc(qcsubk)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqconk(task,k,numqcnz,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqconk,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(k)),$(esc(numqcnz)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqobj(task,numqonz,qosubi,qosubj,qoval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqobj,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numqonz)),$(esc(qosubi)),$(esc(qosubj)),$(esc(qoval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqobjij(task,i,j,qoij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqobjij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(qoij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsolution(task,whichsol,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsolution,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsolutionnew(task,whichsol,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsolutionnew,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconsolutioni(task,i,whichsol,sk,x,sl,su)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconsolutioni,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,Float64,),$(esc(task)),$(esc(i)),$(esc(whichsol)),$(esc(sk)),$(esc(x)),$(esc(sl)),$(esc(su))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarsolutionj(task,j,whichsol,sk,x,sl,su,sn)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarsolutionj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,Float64,Float64,),$(esc(task)),$(esc(j)),$(esc(whichsol)),$(esc(sk)),$(esc(x)),$(esc(sl)),$(esc(su)),$(esc(sn))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsolutionyi(task,i,whichsol,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsolutionyi,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(whichsol)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putstrparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putstrparam,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_puttaskname(task,taskname)
  quote
     local res = disable_sigint(()->ccall((:MSK_puttaskname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(taskname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvartype(task,j,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvartype,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(j)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvartypelist(task,num,subj,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvartypelist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdata(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdata,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdatacb(task,hread,h,format,compress,path)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdatacb,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(hread)),$(esc(h)),$(esc(format)),$(esc(compress)),$(esc(path))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writedatahandle(task,func,handle,format,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_writedatahandle,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,Int32,Int32,),$(esc(task)),$(esc(func)),$(esc(handle)),$(esc(format)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdataformat(task,filename,format,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdataformat,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,Int32,),$(esc(task)),$(esc(filename)),$(esc(format)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdataautoformat(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdataautoformat,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readparamfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readparamfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readsolution(task,whichsol,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readsolution,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(whichsol)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readjsonsol(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readjsonsol,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readsummary(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_readsummary,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_resizetask(task,maxnumcon,maxnumvar,maxnumcone,maxnumanz,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_resizetask,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Int64,),$(esc(task)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(maxnumcone)),$(esc(maxnumanz)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_checkmemtask(task,file,line)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkmemtask,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(file)),$(esc(line))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmemusagetask(task,meminuse,maxmemuse)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmemusagetask,libmosek),Int32,(Ptr{Nothing},Ref{Int64},Ref{Int64},),$(esc(task)),$(esc(meminuse)),$(esc(maxmemuse))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_setdefaults(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_setdefaults,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_sktostr(task,sk,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_sktostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(sk)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solstatostr(task,solutionsta,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_solstatostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(solutionsta)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solutiondef(task,whichsol,isdef)
  quote
     local res = disable_sigint(()->ccall((:MSK_solutiondef,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(isdef))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_deletesolution(task,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_deletesolution,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_onesolutionsummary(task,whichstream,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_onesolutionsummary,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solutionsummary(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_solutionsummary,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_updatesolutioninfo(task,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_updatesolutioninfo,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizersummary(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizersummary,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_strtoconetype(task,str,conetype)
  quote
     local res = disable_sigint(()->ccall((:MSK_strtoconetype,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(str)),$(esc(conetype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_strtosk(task,str,sk)
  quote
     local res = disable_sigint(()->ccall((:MSK_strtosk,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(str)),$(esc(sk))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_whichparam(task,parname,partype,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_whichparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(partype)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writedata(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writedata,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writetask(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writetask,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writebsolution(task,filename,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_writebsolution,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(filename)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writebsolutionhandle(task,func,handle,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_writebsolutionhandle,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,Int32,),$(esc(task)),$(esc(func)),$(esc(handle)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readbsolution(task,filename,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_readbsolution,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(filename)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writesolutionfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writesolutionfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readsolutionfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readsolutionfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readtask(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readtask,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readopfstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readopfstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readlpstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readlpstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readjsonstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readjsonstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readptfstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readptfstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writeparamfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writeparamfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfeasiblesubproblem(task,whichsol,inftask)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfeasiblesubproblem,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Ptr{Nothing}},),$(esc(task)),$(esc(whichsol)),$(esc(inftask))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writesolution(task,whichsol,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writesolution,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(whichsol)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writejsonsol(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writejsonsol,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_primalsensitivity(task,numi,subi,marki,numj,subj,markj,leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej)
  quote
     local res = disable_sigint(()->ccall((:MSK_primalsensitivity,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(numi)),$(esc(subi)),$(esc(marki)),$(esc(numj)),$(esc(subj)),$(esc(markj)),$(esc(leftpricei)),$(esc(rightpricei)),$(esc(leftrangei)),$(esc(rightrangei)),$(esc(leftpricej)),$(esc(rightpricej)),$(esc(leftrangej)),$(esc(rightrangej))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_sensitivityreport(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_sensitivityreport,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_dualsensitivity(task,numj,subj,leftpricej,rightpricej,leftrangej,rightrangej)
  quote
     local res = disable_sigint(()->ccall((:MSK_dualsensitivity,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(numj)),$(esc(subj)),$(esc(leftpricej)),$(esc(rightpricej)),$(esc(leftrangej)),$(esc(rightrangej))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getlasterror64(task,lastrescode,sizelastmsg,lastmsglen,lastmsg)
  quote
     local res = disable_sigint(()->ccall((:MSK_getlasterror64,libmosek),Int32,(Ptr{Nothing},Ref{Int32},Int64,Ref{Int64},Ptr{UInt8},),$(esc(task)),$(esc(lastrescode)),$(esc(sizelastmsg)),$(esc(lastmsglen)),$(esc(lastmsg))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizermt(task,address,accesstoken,trmcode)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizermt,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(trmcode))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncoptimize(task,address,accesstoken,token)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncoptimize,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncstop(task,address,accesstoken,token)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncstop,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncpoll(task,address,accesstoken,token,respavailable,resp,trm)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncpoll,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ref{Int32},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token)),$(esc(respavailable)),$(esc(resp)),$(esc(trm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncgetresult(task,address,accesstoken,token,respavailable,resp,trm)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncgetresult,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ref{Int32},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token)),$(esc(respavailable)),$(esc(resp)),$(esc(trm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putoptserverhost(task,host)
  quote
     local res = disable_sigint(()->ccall((:MSK_putoptserverhost,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(host))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizebatch(env,israce,maxtime,numthreads,numtask,task,trmcode,rcode)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizebatch,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Int32,Int64,Ptr{Ptr{Nothing}},Ptr{Int32},Ptr{Int32},),$(esc(env)),$(esc(israce)),$(esc(maxtime)),$(esc(numthreads)),$(esc(numtask)),$(esc(task)),$(esc(trmcode)),$(esc(rcode))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_callbackcodetostr(code,callbackcodestr)
  quote
     local res = disable_sigint(()->ccall((:MSK_callbackcodetostr,libmosek),Int32,(Int32,Ptr{UInt8},),$(esc(code)),$(esc(callbackcodestr))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkoutlicense(env,feature)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkoutlicense,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(feature))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkinlicense(env,feature)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkinlicense,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(feature))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkinall(env)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkinall,libmosek),Int32,(Ptr{Nothing},),$(esc(env))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_expirylicenses(env,expiry)
  quote
     local res = disable_sigint(()->ccall((:MSK_expirylicenses,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(env)),$(esc(expiry))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_resetexpirylicenses(env)
  quote
     local res = disable_sigint(()->ccall((:MSK_resetexpirylicenses,libmosek),Int32,(Ptr{Nothing},),$(esc(env))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getbuildinfo(buildstate,builddate)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbuildinfo,libmosek),Int32,(Ptr{UInt8},Ptr{UInt8},),$(esc(buildstate)),$(esc(builddate))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getresponseclass(r,rc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getresponseclass,libmosek),Int32,(Int32,Ref{Int32},),$(esc(r)),$(esc(rc))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_deleteenv(env)
  quote
     local res = disable_sigint(()->ccall((:MSK_deleteenv,libmosek),Int32,(Ref{Ptr{Nothing}},),$(esc(env))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_echointro(env,longver)
  quote
     local res = disable_sigint(()->ccall((:MSK_echointro,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(longver))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_freeenv(env,buffer)
  quote
     disable_sigint(()->ccall((:MSK_freeenv,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},),$(esc(env)),$(esc(buffer))))
  end
end
macro MSK_freedbgenv(env,buffer,file,line)
  quote
     disable_sigint(()->ccall((:MSK_freedbgenv,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},Ptr{UInt8},UInt32,),$(esc(env)),$(esc(buffer)),$(esc(file)),$(esc(line))))
  end
end
macro MSK_getcodedesc(code,symname,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcodedesc,libmosek),Int32,(Int32,Ptr{UInt8},Ptr{UInt8},),$(esc(code)),$(esc(symname)),$(esc(str))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getsymbcondim(env,num,maxlen)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsymbcondim,libmosek),Int32,(Ptr{Nothing},Ref{Int32},Ref{CSize},),$(esc(env)),$(esc(num)),$(esc(maxlen))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_rescodetostr(res,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_rescodetostr,libmosek),Int32,(Int32,Ptr{UInt8},),$(esc(res)),$(esc(str))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_iinfitemtostr(item,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_iinfitemtostr,libmosek),Int32,(Int32,Ptr{UInt8},),$(esc(item)),$(esc(str))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_dinfitemtostr(item,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_dinfitemtostr,libmosek),Int32,(Int32,Ptr{UInt8},),$(esc(item)),$(esc(str))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_liinfitemtostr(item,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_liinfitemtostr,libmosek),Int32,(Int32,Ptr{UInt8},),$(esc(item)),$(esc(str))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getversion(major,minor,revision)
  quote
     local res = disable_sigint(()->ccall((:MSK_getversion,libmosek),Int32,(Ref{Int32},Ref{Int32},Ref{Int32},),$(esc(major)),$(esc(minor)),$(esc(revision))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkversion(env,major,minor,revision)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkversion,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,),$(esc(env)),$(esc(major)),$(esc(minor)),$(esc(revision))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_linkfiletoenvstream(env,whichstream,filename,append)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfiletoenvstream,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Int32,),$(esc(env)),$(esc(whichstream)),$(esc(filename)),$(esc(append))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_linkfunctoenvstream(env,whichstream,handle,func)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfunctoenvstream,libmosek),Int32,(Ptr{Nothing},Int32,Any,Ptr{Cvoid},),$(esc(env)),$(esc(whichstream)),$(esc(handle)),$(esc(func))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_unlinkfuncfromenvstream(env,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_unlinkfuncfromenvstream,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_makeenv(env,dbgfile)
  quote
     local res = disable_sigint(()->ccall((:MSK_makeenv,libmosek),Int32,(Ref{Ptr{Nothing}},Ptr{UInt8},),$(esc(env)),$(esc(dbgfile))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensedebug(env,licdebug)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensedebug,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(licdebug))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensecode(env,code)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensecode,libmosek),Int32,(Ptr{Nothing},Ptr{Int32},),$(esc(env)),$(esc(code))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensewait(env,licwait)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensewait,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(licwait))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensepath(env,licensepath)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensepath,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(env)),$(esc(licensepath))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_maketask(env,maxnumcon,maxnumvar,task)
  quote
     local res = disable_sigint(()->ccall((:MSK_maketask,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Ptr{Nothing}},),$(esc(env)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(task))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_makeemptytask(env,task)
  quote
     local res = disable_sigint(()->ccall((:MSK_makeemptytask,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Nothing}},),$(esc(env)),$(esc(task))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putexitfunc(env,exitfunc,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_putexitfunc,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,),$(esc(env)),$(esc(exitfunc)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkmemenv(env,file,line)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkmemenv,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(env)),$(esc(file)),$(esc(line))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_axpy(env,n,alpha,x,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_axpy,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(n)),$(esc(alpha)),$(esc(x)),$(esc(y))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_dot(env,n,x,y,xty)
  quote
     local res = disable_sigint(()->ccall((:MSK_dot,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},Ptr{Float64},Ref{Float64},),$(esc(env)),$(esc(n)),$(esc(x)),$(esc(y)),$(esc(xty))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_gemv(env,transa,m,n,alpha,a,x,beta,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_gemv,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Ptr{Float64},Ptr{Float64},Float64,Ptr{Float64},),$(esc(env)),$(esc(transa)),$(esc(m)),$(esc(n)),$(esc(alpha)),$(esc(a)),$(esc(x)),$(esc(beta)),$(esc(y))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_gemm(env,transa,transb,m,n,k,alpha,a,b,beta,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_gemm,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Int32,Float64,Ptr{Float64},Ptr{Float64},Float64,Ptr{Float64},),$(esc(env)),$(esc(transa)),$(esc(transb)),$(esc(m)),$(esc(n)),$(esc(k)),$(esc(alpha)),$(esc(a)),$(esc(b)),$(esc(beta)),$(esc(c))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_syrk(env,uplo,trans,n,k,alpha,a,beta,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_syrk,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Float64,Ptr{Float64},Float64,Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(trans)),$(esc(n)),$(esc(k)),$(esc(alpha)),$(esc(a)),$(esc(beta)),$(esc(c))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_computesparsecholesky(env,numthreads,ordermethod,tolsingular,n,anzc,aptrc,asubc,avalc,perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)
  quote
     local res = disable_sigint(()->ccall((:MSK_computesparsecholesky,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Int32,Ptr{Int32},Ptr{Int64},Ptr{Int32},Ptr{Float64},Ref{Ptr{Int32}},Ref{Ptr{Float64}},Ref{Ptr{Int32}},Ref{Ptr{Int64}},Ref{Int64},Ref{Ptr{Int32}},Ref{Ptr{Float64}},),$(esc(env)),$(esc(numthreads)),$(esc(ordermethod)),$(esc(tolsingular)),$(esc(n)),$(esc(anzc)),$(esc(aptrc)),$(esc(asubc)),$(esc(avalc)),$(esc(perm)),$(esc(diag)),$(esc(lnzc)),$(esc(lptrc)),$(esc(lensubnval)),$(esc(lsubc)),$(esc(lvalc))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_sparsetriangularsolvedense(env,transposed,n,lnzc,lptrc,lensubnval,lsubc,lvalc,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_sparsetriangularsolvedense,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int64},Int64,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(transposed)),$(esc(n)),$(esc(lnzc)),$(esc(lptrc)),$(esc(lensubnval)),$(esc(lsubc)),$(esc(lvalc)),$(esc(b))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_potrf(env,uplo,n,a)
  quote
     local res = disable_sigint(()->ccall((:MSK_potrf,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(n)),$(esc(a))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_syeig(env,uplo,n,a,w)
  quote
     local res = disable_sigint(()->ccall((:MSK_syeig,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(n)),$(esc(a)),$(esc(w))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_syevd(env,uplo,n,a,w)
  quote
     local res = disable_sigint(()->ccall((:MSK_syevd,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(n)),$(esc(a)),$(esc(w))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_licensecleanup()
  quote
     local res = disable_sigint(()->ccall((:MSK_licensecleanup,libmosek),Int32,()))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end

"""
Analyze the names and issue an error for the first invalid name.

    analyzenames(task::MSKtask,whichstream::Streamtype,nametype::Nametype)

Arguments:
    nametype::Nametype The type of names e.g. valid in MPS or LP files.
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function analyzenames end

"""
Analyze the data of a task.

    analyzeproblem(task::MSKtask,whichstream::Streamtype)

Arguments:
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function analyzeproblem end

"""
Print information related to the quality of the solution.

    analyzesolution(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    whichstream::Streamtype Index of the stream.
"""
function analyzesolution end

"""
Appends an affine conic constraint to the task.

    appendacc(task::MSKtask,domidx::Int64,afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
    appendacc(task::MSKtask,domidx::T0,afeidxlist::T1,b::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    domidx::Int64 Domain index.
    task::MSKtask An optimization task.
"""
function appendacc end

"""
Appends a number of affine conic constraint to the task.

    appendaccs(task::MSKtask,domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
    appendaccs(task::MSKtask,domidxs::T0,afeidxlist::T1,b::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    domidxs::Vector{Int64} Domain indices.
    task::MSKtask An optimization task.
"""
function appendaccs end

"""
Appends an affine conic constraint to the task.

    appendaccseq(task::MSKtask,domidx::Int64,afeidxfirst::Int64,b::Union{Nothing,Vector{Float64}})
    appendaccseq(task::MSKtask,domidx::T0,afeidxfirst::T1,b::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    afeidxfirst::Int64 Index of the first affine expression.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    domidx::Int64 Domain index.
    task::MSKtask An optimization task.
"""
function appendaccseq end

"""
Appends a number of affine conic constraint to the task.

    appendaccsseq(task::MSKtask,domidxs::Vector{Int64},numafeidx::Int64,afeidxfirst::Int64,b::Union{Nothing,Vector{Float64}})
    appendaccsseq(task::MSKtask,domidxs::T0,numafeidx::T1,afeidxfirst::T2,b::T3) where {T0<:AbstractVector{<:Integer},T1<:Integer,T2<:Integer,T3<:AbstractVector{<:Number}} 

Arguments:
    afeidxfirst::Int64 Index of the first affine expression.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    domidxs::Vector{Int64} Domain indices.
    numafeidx::Int64 Number of affine expressions in the affine expression list (must equal the sum of dimensions of the domains).
    task::MSKtask An optimization task.
"""
function appendaccsseq end

"""
Appends a number of empty affine expressions to the optimization task.

    appendafes(task::MSKtask,num::Int64)
    appendafes(task::MSKtask,num::T0) where {T0<:Integer} 

Arguments:
    num::Int64 Number of empty affine expressions which should be appended.
    task::MSKtask An optimization task.
"""
function appendafes end

"""
Appends semidefinite variables to the problem.

    appendbarvars(task::MSKtask,dim::Vector{Int32})
    appendbarvars(task::MSKtask,dim::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    dim::Vector{Int32} Dimensions of symmetric matrix variables to be added.
    task::MSKtask An optimization task.
"""
function appendbarvars end

"""
Appends a new conic constraint to the problem.

    appendcone(task::MSKtask,ct::Conetype,conepar::Float64,submem::Vector{Int32})
    appendcone(task::MSKtask,ct::Conetype,conepar::T0,submem::T1) where {T0<:Number,T1<:AbstractVector{<:Integer}} 

Arguments:
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    ct::Conetype Specifies the type of the cone.
    submem::Vector{Int32} Variable subscripts of the members in the cone.
    task::MSKtask An optimization task.
"""
function appendcone end

"""
Appends a new conic constraint to the problem.

    appendconeseq(task::MSKtask,ct::Conetype,conepar::Float64,nummem::Int32,j::Int32)
    appendconeseq(task::MSKtask,ct::Conetype,conepar::T0,nummem::T1,j::T2) where {T0<:Number,T1<:Integer,T2<:Integer} 

Arguments:
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    ct::Conetype Specifies the type of the cone.
    j::Int32 Index of the first variable in the conic constraint.
    nummem::Int32 Number of member variables in the cone.
    task::MSKtask An optimization task.
"""
function appendconeseq end

"""
Appends multiple conic constraints to the problem.

    appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::Vector{Float64},nummem::Vector{Int32},j::Int32)
    appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::T0,nummem::T1,j::T2) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Integer},T2<:Integer} 

Arguments:
    conepar::Vector{Float64} For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    ct::Vector{Conetype} Specifies the type of the cone.
    j::Int32 Index of the first variable in the first cone to be appended.
    nummem::Vector{Int32} Numbers of member variables in the cones.
    task::MSKtask An optimization task.
"""
function appendconesseq end

"""
Appends a number of constraints to the optimization task.

    appendcons(task::MSKtask,num::Int32)
    appendcons(task::MSKtask,num::T0) where {T0<:Integer} 

Arguments:
    num::Int32 Number of constraints which should be appended.
    task::MSKtask An optimization task.
"""
function appendcons end

"""
Appends a number of empty disjunctive constraints to the task.

    appenddjcs(task::MSKtask,num::Int64)
    appenddjcs(task::MSKtask,num::T0) where {T0<:Integer} 

Arguments:
    num::Int64 Number of empty disjunctive constraints which should be appended.
    task::MSKtask An optimization task.
"""
function appenddjcs end

"""
Appends the dual exponential cone domain.

    appenddualexpconedomain(task::MSKtask) :: domidx

Arguments:
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appenddualexpconedomain end

"""
Appends the dual geometric mean cone domain.

    appenddualgeomeanconedomain(task::MSKtask,n::Int64) :: domidx
    appenddualgeomeanconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appenddualgeomeanconedomain end

"""
Appends the dual power cone domain.

    appenddualpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64}) :: domidx
    appenddualpowerconedomain(task::MSKtask,n::T0,alpha::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}}  :: domidx

Arguments:
    alpha::Vector{Float64} The sequence proportional to exponents. Must be positive.
    n::Int64 Dimension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appenddualpowerconedomain end

"""
Appends the primal exponential cone domain.

    appendprimalexpconedomain(task::MSKtask) :: domidx

Arguments:
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendprimalexpconedomain end

"""
Appends the primal geometric mean cone domain.

    appendprimalgeomeanconedomain(task::MSKtask,n::Int64) :: domidx
    appendprimalgeomeanconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendprimalgeomeanconedomain end

"""
Appends the primal power cone domain.

    appendprimalpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64}) :: domidx
    appendprimalpowerconedomain(task::MSKtask,n::T0,alpha::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}}  :: domidx

Arguments:
    alpha::Vector{Float64} The sequence proportional to exponents. Must be positive.
    n::Int64 Dimension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendprimalpowerconedomain end

"""
Appends the n dimensional quadratic cone domain.

    appendquadraticconedomain(task::MSKtask,n::Int64) :: domidx
    appendquadraticconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendquadraticconedomain end

"""
Appends the n dimensional real number domain.

    appendrdomain(task::MSKtask,n::Int64) :: domidx
    appendrdomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendrdomain end

"""
Appends the n dimensional negative orthant to the list of domains.

    appendrminusdomain(task::MSKtask,n::Int64) :: domidx
    appendrminusdomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendrminusdomain end

"""
Appends the n dimensional positive orthant to the list of domains.

    appendrplusdomain(task::MSKtask,n::Int64) :: domidx
    appendrplusdomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendrplusdomain end

"""
Appends the n dimensional rotated quadratic cone domain.

    appendrquadraticconedomain(task::MSKtask,n::Int64) :: domidx
    appendrquadraticconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendrquadraticconedomain end

"""
Appends the n dimensional 0 domain.

    appendrzerodomain(task::MSKtask,n::Int64) :: domidx
    appendrzerodomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimmension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendrzerodomain end

"""
Appends a general sparse symmetric matrix to the storage of symmetric matrices.

    appendsparsesymmat(task::MSKtask,dim::Int32,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64}) :: idx
    appendsparsesymmat(task::MSKtask,dim::T0,subi::T1,subj::T2,valij::T3) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}}  :: idx
    appendsparsesymmat(task::MSKtask,dim::T0,data:: SparseMatrixCSC{Float64}) :: idx

Arguments:
    dim::Int32 Dimension of the symmetric matrix that is appended.
    subi::SparseMatrixCSC{Float64} Sparse matrix defining the column values
    subj::Vector{Int32} Column subscripts in the triplets.
    task::MSKtask An optimization task.
    valij::Vector{Float64} Values of each triplet.

Returns:
    idx::Int64 Unique index assigned to the inputted matrix.
"""
function appendsparsesymmat end

"""
Appends a general sparse symmetric matrix to the storage of symmetric matrices.

    appendsparsesymmatlist(task::MSKtask,dims::Vector{Int32},nz::Vector{Int64},subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64}) :: idx
    appendsparsesymmatlist(task::MSKtask,dims::T0,nz::T1,subi::T2,subj::T3,valij::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}}  :: idx

Arguments:
    dims::Vector{Int32} Dimensions of the symmetric matrixes.
    nz::Vector{Int64} Number of nonzeros for each matrix.
    subi::Vector{Int32} Row subscript in the triplets.
    subj::Vector{Int32} Column subscripts in the triplets.
    task::MSKtask An optimization task.
    valij::Vector{Float64} Values of each triplet.

Returns:
    idx::Vector{Int64} Unique index assigned to the inputted matrix.
"""
function appendsparsesymmatlist end

"""
Appends the vectorized SVEC PSD cone domain.

    appendsvecpsdconedomain(task::MSKtask,n::Int64) :: domidx
    appendsvecpsdconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

Arguments:
    n::Int64 Dimension of the domain.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 Index of the domain.
"""
function appendsvecpsdconedomain end

"""
Appends a number of variables to the optimization task.

    appendvars(task::MSKtask,num::Int32)
    appendvars(task::MSKtask,num::T0) where {T0<:Integer} 

Arguments:
    num::Int32 Number of variables which should be appended.
    task::MSKtask An optimization task.
"""
function appendvars end

"""
Request a solution from a remote job.

    asyncgetresult(task::MSKtask,address::AbstractString,accesstoken::AbstractString,token::AbstractString) :: (respavailable,resp,trm)

Arguments:
    accesstoken::AbstractString Access token.
    address::AbstractString Address of the OptServer.
    task::MSKtask An optimization task.
    token::AbstractString The task token.

Returns:
    resp::Rescode Is the response code from the remote solver.
    respavailable::Bool Indicates if a remote response is available.
    trm::Rescode Is either OK or a termination response code.
"""
function asyncgetresult end

"""
Offload the optimization task to a solver server in asynchronous mode.

    asyncoptimize(task::MSKtask,address::AbstractString,accesstoken::AbstractString) :: token

Arguments:
    accesstoken::AbstractString Access token.
    address::AbstractString Address of the OptServer.
    task::MSKtask An optimization task.

Returns:
    token::String Returns the task token.
"""
function asyncoptimize end

"""
Requests information about the status of the remote job.

    asyncpoll(task::MSKtask,address::AbstractString,accesstoken::AbstractString,token::AbstractString) :: (respavailable,resp,trm)

Arguments:
    accesstoken::AbstractString Access token.
    address::AbstractString Address of the OptServer.
    task::MSKtask An optimization task.
    token::AbstractString The task token.

Returns:
    resp::Rescode Is the response code from the remote solver.
    respavailable::Bool Indicates if a remote response is available.
    trm::Rescode Is either OK or a termination response code.
"""
function asyncpoll end

"""
Request that the job identified by the token is terminated.

    asyncstop(task::MSKtask,address::AbstractString,accesstoken::AbstractString,token::AbstractString)

Arguments:
    accesstoken::AbstractString Access token.
    address::AbstractString Address of the OptServer.
    task::MSKtask An optimization task.
    token::AbstractString The task token.
"""
function asyncstop end

"""
Computes conditioning information for the basis matrix.

    basiscond(task::MSKtask) :: (nrmbasis,nrminvbasis)

Arguments:
    task::MSKtask An optimization task.

Returns:
    nrmbasis::Float64 An estimate for the 1-norm of the basis.
    nrminvbasis::Float64 An estimate for the 1-norm of the inverse of the basis.
"""
function basiscond end

"""
Obtains a bound key string identifier.

    bktostr(task::MSKtask,bk::Boundkey) :: str

Arguments:
    bk::Boundkey Bound key.
    task::MSKtask An optimization task.

Returns:
    str::String String corresponding to the bound key.
"""
function bktostr end

"""
Obtains a callback code string identifier.

    callbackcodetostr(code::Callbackcode) :: callbackcodestr

Arguments:
    code::Callbackcode A callback code.

Returns:
    callbackcodestr::String String corresponding to the callback code.
"""
function callbackcodetostr end

"""
Check in all unused license features to the license token server.

    checkinall(env::MSKenv)
    checkinall()

Arguments:
    env::MSKenv The MOSEK environment.
"""
function checkinall end

"""
Check in a license feature back to the license server ahead of time.

    checkinlicense(env::MSKenv,feature::Feature)
    checkinlicense(feature::Feature)

Arguments:
    env::MSKenv The MOSEK environment.
    feature::Feature Feature to check in to the license system.
"""
function checkinlicense end

"""
Checks the memory allocated by the task.

    checkmem(task::MSKtask,file::AbstractString,line::Int32)
    checkmem(task::MSKtask,file::Union{Nothing,AbstractString},line::T0) where {T0<:Integer} 

Arguments:
    file::AbstractString File from which the function is called.
    line::Int32 Line in the file from which the function is called.
    task::MSKtask An optimization task.
"""
function checkmem end

"""
Check out a license feature from the license server ahead of time.

    checkoutlicense(env::MSKenv,feature::Feature)
    checkoutlicense(feature::Feature)

Arguments:
    env::MSKenv The MOSEK environment.
    feature::Feature Feature to check out from the license system.
"""
function checkoutlicense end

"""
Changes the bounds for one constraint.

    chgconbound(task::MSKtask,i::Int32,lower::Int32,finite::Int32,value::Float64)
    chgconbound(task::MSKtask,i::T0,lower::T1,finite::T2,value::T3) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number} 

Arguments:
    finite::Int32 If non-zero, then the given value is assumed to be finite.
    i::Int32 Index of the constraint for which the bounds should be changed.
    lower::Int32 If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
    task::MSKtask An optimization task.
    value::Float64 New value for the bound.
"""
function chgconbound end

"""
Changes the bounds for one variable.

    chgvarbound(task::MSKtask,j::Int32,lower::Int32,finite::Int32,value::Float64)
    chgvarbound(task::MSKtask,j::T0,lower::T1,finite::T2,value::T3) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number} 

Arguments:
    finite::Int32 If non-zero, then the given value is assumed to be finite.
    j::Int32 Index of the variable for which the bounds should be changed.
    lower::Int32 If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
    task::MSKtask An optimization task.
    value::Float64 New value for the bound.
"""
function chgvarbound end

"""
Commits all cached problem changes.

    commitchanges(task::MSKtask)

Arguments:
    task::MSKtask An optimization task.
"""
function commitchanges end

"""
Computes a Cholesky factorization of sparse matrix.

    computesparsecholesky(env::MSKenv,numthreads::Int32,ordermethod::Int32,tolsingular::Float64,anzc::Vector{Int32},aptrc::Vector{Int64},asubc::Vector{Int32},avalc::Vector{Float64}) :: (perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)
    computesparsecholesky(env::MSKenv,numthreads::T0,ordermethod::T1,tolsingular::T2,anzc::T3,aptrc::T4,asubc::T5,avalc::T6) where {T0<:Integer,T1<:Integer,T2<:Number,T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number}}  :: (perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)
    computesparsecholesky(numthreads::Int32,ordermethod::Int32,tolsingular::Float64,anzc::Vector{Int32},aptrc::Vector{Int64},asubc::Vector{Int32},avalc::Vector{Float64}) :: (perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)
    computesparsecholesky(numthreads::T0,ordermethod::T1,tolsingular::T2,anzc::T3,aptrc::T4,asubc::T5,avalc::T6) where {T0<:Integer,T1<:Integer,T2<:Number,T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number}}  :: (perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)

Arguments:
    anzc::Vector{Int32} anzc[j] is the number of nonzeros in the jth column of A.
    aptrc::Vector{Int64} aptrc[j] is a pointer to the first element in column j.
    asubc::Vector{Int32} Row indexes for each column stored in increasing order.
    avalc::Vector{Float64} The value corresponding to row indexed stored in asubc.
    env::MSKenv The MOSEK environment.
    numthreads::Int32 The number threads that can be used to do the computation. 0 means the code makes the choice.
    ordermethod::Int32 If nonzero, then a sparsity preserving ordering will be employed.
    tolsingular::Float64 A positive parameter controlling when a pivot is declared zero.

Returns:
    diag::Float64 The diagonal elements of matrix D.
    lensubnval::Int64 Number of elements in lsubc and lvalc.
    lnzc::Int32 lnzc[j] is the number of non zero elements in column j.
    lptrc::Int64 lptrc[j] is a pointer to the first row index and value in column j.
    lsubc::Int32 Row indexes for each column stored in increasing order.
    lvalc::Float64 The values corresponding to row indexed stored in lsubc.
    perm::Int32 Permutation array used to specify the permutation matrix P computed by the function.
"""
function computesparsecholesky end

"""
Obtains a cone type string identifier.

    conetypetostr(task::MSKtask,ct::Conetype) :: str

Arguments:
    ct::Conetype Specifies the type of the cone.
    task::MSKtask An optimization task.

Returns:
    str::String String corresponding to the cone type.
"""
function conetypetostr end

"""
Undefine a solution and free the memory it uses.

    deletesolution(task::MSKtask,whichsol::Soltype)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function deletesolution end

"""
Obtains a information item string identifier.

    dinfitemtostr(item::Dinfitem) :: str

Arguments:
    item::Dinfitem Information item.

Returns:
    str::String String corresponding to the information item.
"""
function dinfitemtostr end

"""
Performs sensitivity analysis on objective coefficients.

    dualsensitivity(task::MSKtask,subj::Vector{Int32}) :: (leftpricej,rightpricej,leftrangej,rightrangej)
    dualsensitivity(task::MSKtask,subj::T0) where {T0<:AbstractVector{<:Integer}}  :: (leftpricej,rightpricej,leftrangej,rightrangej)

Arguments:
    subj::Vector{Int32} Indexes of objective coefficients to analyze.
    task::MSKtask An optimization task.

Returns:
    leftpricej::Vector{Float64} Left shadow prices for requested coefficients.
    leftrangej::Vector{Float64} Left range for requested coefficients.
    rightpricej::Vector{Float64} Right shadow prices for requested coefficients.
    rightrangej::Vector{Float64} Right range for requested coefficients.
"""
function dualsensitivity end

"""
Prints an intro to message stream.

    echointro(env::MSKenv,longver::Int32)
    echointro(env::MSKenv,longver::T0) where {T0<:Integer} 
    echointro(longver::Int32)
    echointro(longver::T0) where {T0<:Integer} 

Arguments:
    env::MSKenv The MOSEK environment.
    longver::Int32 If non-zero, then the intro is slightly longer.
"""
function echointro end

"""
Clears a row in barF

    emptyafebarfrow(task::MSKtask,afeidx::Int64)
    emptyafebarfrow(task::MSKtask,afeidx::T0) where {T0<:Integer} 

Arguments:
    afeidx::Int64 Row index of barF.
    task::MSKtask An optimization task.
"""
function emptyafebarfrow end

"""
Clears rows in barF.

    emptyafebarfrowlist(task::MSKtask,afeidxlist::Vector{Int64})
    emptyafebarfrowlist(task::MSKtask,afeidxlist::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    afeidxlist::Vector{Int64} Indices of rows in barF to clear.
    task::MSKtask An optimization task.
"""
function emptyafebarfrowlist end

"""
Clears a column in F.

    emptyafefcol(task::MSKtask,varidx::Int32)
    emptyafefcol(task::MSKtask,varidx::T0) where {T0<:Integer} 

Arguments:
    task::MSKtask An optimization task.
    varidx::Int32 Variable index.
"""
function emptyafefcol end

"""
Clears columns in F.

    emptyafefcollist(task::MSKtask,varidx::Vector{Int32})
    emptyafefcollist(task::MSKtask,varidx::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    task::MSKtask An optimization task.
    varidx::Vector{Int32} Indices of variables in F to clear.
"""
function emptyafefcollist end

"""
Clears a row in F.

    emptyafefrow(task::MSKtask,afeidx::Int64)
    emptyafefrow(task::MSKtask,afeidx::T0) where {T0<:Integer} 

Arguments:
    afeidx::Int64 Row index.
    task::MSKtask An optimization task.
"""
function emptyafefrow end

"""
Clears rows in F.

    emptyafefrowlist(task::MSKtask,afeidx::Vector{Int64})
    emptyafefrowlist(task::MSKtask,afeidx::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    afeidx::Vector{Int64} Indices of rows in F to clear.
    task::MSKtask An optimization task.
"""
function emptyafefrowlist end

"""
Evaluates the activity of an affine conic constraint.

    evaluateacc(task::MSKtask,whichsol::Soltype,accidx::Int64) :: activity
    evaluateacc(task::MSKtask,whichsol::Soltype,accidx::T0) where {T0<:Integer}  :: activity

Arguments:
    accidx::Int64 The index of the affine conic constraint.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    activity::Vector{Float64} The activity of the affine conic constraint. The array should have length equal to the dimension of the constraint.
"""
function evaluateacc end

"""
Evaluates the activities of all affine conic constraints.

    evaluateaccs(task::MSKtask,whichsol::Soltype) :: activity

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    activity::Vector{Float64} The activity of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.
"""
function evaluateaccs end

"""
Reports when the first license feature expires.

    expirylicenses(env::MSKenv) :: expiry
    expirylicenses() :: expiry

Arguments:
    env::MSKenv The MOSEK environment.

Returns:
    expiry::Int64 If nonnegative, then it is the minimum number days to expiry of any feature that has been checked out.
"""
function expirylicenses end

"""
Obtains the list of affine expressions appearing in the affine conic constraint.

    getaccafeidxlist(task::MSKtask,accidx::Int64) :: afeidxlist
    getaccafeidxlist(task::MSKtask,accidx::T0) where {T0<:Integer}  :: afeidxlist

Arguments:
    accidx::Int64 Index of the affine conic constraint.
    task::MSKtask An optimization task.

Returns:
    afeidxlist::Vector{Int64} List of indexes of affine expressions appearing in the constraint.
"""
function getaccafeidxlist end

"""
Obtains the additional constant term vector appearing in the affine conic constraint.

    getaccb(task::MSKtask,accidx::Int64) :: b
    getaccb(task::MSKtask,accidx::T0) where {T0<:Integer}  :: b

Arguments:
    accidx::Int64 Index of the affine conic constraint.
    task::MSKtask An optimization task.

Returns:
    b::Vector{Float64} The vector b appearing in the constraint.
"""
function getaccb end

"""
Obtains barF, implied by the ACCs, in block triplet form.

    getaccbarfblocktriplet(task::MSKtask) :: (numtrip,acc_afe,bar_var,blk_row,blk_col,blk_val)

Arguments:
    task::MSKtask An optimization task.

Returns:
    acc_afe::Vector{Int64} Index of the AFE within the concatenated list of AFEs in ACCs.
    bar_var::Vector{Int32} Symmetric matrix variable index.
    blk_col::Vector{Int32} Block column index.
    blk_row::Vector{Int32} Block row index.
    blk_val::Vector{Float64} The numerical value associated with each block triplet.
    numtrip::Int64 Number of elements in the block triplet form.
"""
function getaccbarfblocktriplet end

"""
Obtains an upper bound on the number of elements in the block triplet form of barf, as used within the ACCs.

    getaccbarfnumblocktriplets(task::MSKtask) :: numtrip

Arguments:
    task::MSKtask An optimization task.

Returns:
    numtrip::Int64 An upper bound on the number of elements in the block triplet form of barf, as used within the ACCs.
"""
function getaccbarfnumblocktriplets end

"""
Obtains the domain appearing in the affine conic constraint.

    getaccdomain(task::MSKtask,accidx::Int64) :: domidx
    getaccdomain(task::MSKtask,accidx::T0) where {T0<:Integer}  :: domidx

Arguments:
    accidx::Int64 The index of the affine conic constraint.
    task::MSKtask An optimization task.

Returns:
    domidx::Int64 The index of domain in the affine conic constraint.
"""
function getaccdomain end

"""
Obtains the doty vector for an affine conic constraint.

    getaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64) :: doty
    getaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where {T0<:Integer}  :: doty

Arguments:
    accidx::Int64 The index of the affine conic constraint.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    doty::Vector{Float64} The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.
"""
function getaccdoty end

"""
Obtains the doty vector for a solution.

    getaccdotys(task::MSKtask,whichsol::Soltype) :: doty

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    doty::Vector{Float64} The dual values of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.
"""
function getaccdotys end

"""
Obtains the total number of nonzeros in the ACC implied F matrix.

    getaccfnumnz(task::MSKtask) :: accfnnz

Arguments:
    task::MSKtask An optimization task.

Returns:
    accfnnz::Int64 Number of nonzeros in the F matrix implied by ACCs.
"""
function getaccfnumnz end

"""
Obtains the F matrix (implied by the AFE ordering within the ACCs) in triplet format.

    getaccftrip(task::MSKtask) :: (frow,fcol,fval)

Arguments:
    task::MSKtask An optimization task.

Returns:
    fcol::Vector{Int32} Column indices of nonzeros in the implied F matrix.
    frow::Vector{Int64} Row indices of nonzeros in the implied F matrix.
    fval::Vector{Float64} Values of nonzero entries in the implied F matrix.
"""
function getaccftrip end

"""
The g vector as used within the ACCs.

    getaccgvector(task::MSKtask) :: g

Arguments:
    task::MSKtask An optimization task.

Returns:
    g::Vector{Float64} The g vector as used within the ACCs.
"""
function getaccgvector end

"""
Obtains the dimension of the affine conic constraint.

    getaccn(task::MSKtask,accidx::Int64) :: n
    getaccn(task::MSKtask,accidx::T0) where {T0<:Integer}  :: n

Arguments:
    accidx::Int64 The index of the affine conic constraint.
    task::MSKtask An optimization task.

Returns:
    n::Int64 The dimension of the affine conic constraint (equal to the dimension of its domain).
"""
function getaccn end

"""
Obtains the name of an affine conic constraint.

    getaccname(task::MSKtask,accidx::Int64) :: name
    getaccname(task::MSKtask,accidx::T0) where {T0<:Integer}  :: name

Arguments:
    accidx::Int64 Index of an affine conic constraint.
    task::MSKtask An optimization task.

Returns:
    name::String Returns the required name.
"""
function getaccname end

"""
Obtains the length of the name of an affine conic constraint.

    getaccnamelen(task::MSKtask,accidx::Int64) :: len
    getaccnamelen(task::MSKtask,accidx::T0) where {T0<:Integer}  :: len

Arguments:
    accidx::Int64 Index of an affine conic constraint.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the indicated name.
"""
function getaccnamelen end

"""
Obtains the total dimension of all affine conic constraints.

    getaccntot(task::MSKtask) :: n

Arguments:
    task::MSKtask An optimization task.

Returns:
    n::Int64 The total dimension of all affine conic constraints.
"""
function getaccntot end

"""
Obtains full data of all affine conic constraints.

    getaccs(task::MSKtask) :: (domidxlist,afeidxlist,b)

Arguments:
    task::MSKtask An optimization task.

Returns:
    afeidxlist::Vector{Int64} The concatenation of index lists of affine expressions appearing in all affine conic constraints.
    b::Vector{Float64} The concatenation of vectors b appearing in all affine conic constraints.
    domidxlist::Vector{Int64} The list of domains appearing in all affine conic constraints.
"""
function getaccs end

"""
Obtains one column of the linear constraint matrix.

    getacol(task::MSKtask,j::Int32) :: (nzj,subj,valj)
    getacol(task::MSKtask,j::T0) where {T0<:Integer}  :: (nzj,subj,valj)

Arguments:
    j::Int32 Index of the column.
    task::MSKtask An optimization task.

Returns:
    nzj::Int32 Number of non-zeros in the column obtained.
    subj::Vector{Int32} Row indices of the non-zeros in the column obtained.
    valj::Vector{Float64} Numerical values in the column obtained.
"""
function getacol end

"""
Obtains the number of non-zero elements in one column of the linear constraint matrix

    getacolnumnz(task::MSKtask,i::Int32) :: nzj
    getacolnumnz(task::MSKtask,i::T0) where {T0<:Integer}  :: nzj

Arguments:
    i::Int32 Index of the column.
    task::MSKtask An optimization task.

Returns:
    nzj::Int32 Number of non-zeros in the j'th column of (A).
"""
function getacolnumnz end

"""
Obtains a sequence of columns from the coefficient matrix.

    getacolslice(task::MSKtask,first::Int32,last::Int32) :: (ptrb,ptre,sub,val)
    getacolslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (ptrb,ptre,sub,val)

Arguments:
    first::Int32 Index of the first column in the sequence.
    last::Int32 Index of the last column in the sequence plus one.
    task::MSKtask An optimization task.

Returns:
    ptrb::Vector{Int64} Column start pointers.
    ptre::Vector{Int64} Column end pointers.
    sub::Vector{Int32} Contains the row subscripts.
    val::Vector{Float64} Contains the coefficient values.
"""
function getacolslice end

"""
Obtains the number of non-zeros in a slice of columns of the coefficient matrix.

    getacolslicenumnz(task::MSKtask,first::Int32,last::Int32) :: numnz
    getacolslicenumnz(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: numnz

Arguments:
    first::Int32 Index of the first column in the sequence.
    last::Int32 Index of the last column plus one in the sequence.
    task::MSKtask An optimization task.

Returns:
    numnz::Int64 Number of non-zeros in the slice.
"""
function getacolslicenumnz end

"""
Obtains a sequence of columns from the coefficient matrix in triplet format.

    getacolslicetrip(task::MSKtask,first::Int32,last::Int32) :: (subi,subj,val)
    getacolslicetrip(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (subi,subj,val)

Arguments:
    first::Int32 Index of the first column in the sequence.
    last::Int32 Index of the last column in the sequence plus one.
    task::MSKtask An optimization task.

Returns:
    subi::Vector{Int32} Constraint subscripts.
    subj::Vector{Int32} Column subscripts.
    val::Vector{Float64} Values.
"""
function getacolslicetrip end

"""
Obtains barF in block triplet form.

    getafebarfblocktriplet(task::MSKtask) :: (numtrip,afeidx,barvaridx,subk,subl,valkl)

Arguments:
    task::MSKtask An optimization task.

Returns:
    afeidx::Vector{Int64} Constraint index.
    barvaridx::Vector{Int32} Symmetric matrix variable index.
    numtrip::Int64 Number of elements in the block triplet form.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function getafebarfblocktriplet end

"""
Obtains an upper bound on the number of elements in the block triplet form of barf.

    getafebarfnumblocktriplets(task::MSKtask) :: numtrip

Arguments:
    task::MSKtask An optimization task.

Returns:
    numtrip::Int64 An upper bound on the number of elements in the block triplet form of barf.
"""
function getafebarfnumblocktriplets end

"""
Obtains the number of nonzero entries in a row of barF.

    getafebarfnumrowentries(task::MSKtask,afeidx::Int64) :: numentr
    getafebarfnumrowentries(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: numentr

Arguments:
    afeidx::Int64 Row index of barF.
    task::MSKtask An optimization task.

Returns:
    numentr::Int32 Number of nonzero entries in a row of barF.
"""
function getafebarfnumrowentries end

"""
Obtains nonzero entries in one row of barF.

    getafebarfrow(task::MSKtask,afeidx::Int64) :: (barvaridx,ptrterm,numterm,termidx,termweight)
    getafebarfrow(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: (barvaridx,ptrterm,numterm,termidx,termweight)

Arguments:
    afeidx::Int64 Row index of barF.
    task::MSKtask An optimization task.

Returns:
    barvaridx::Vector{Int32} Semidefinite variable indices.
    numterm::Vector{Int64} Number of terms in each entry.
    ptrterm::Vector{Int64} Pointers to the description of entries.
    termidx::Vector{Int64} Indices of semidefinite matrices from E.
    termweight::Vector{Float64} Weights appearing in the weighted sum representation.
"""
function getafebarfrow end

"""
Obtains information about one row of barF.

    getafebarfrowinfo(task::MSKtask,afeidx::Int64) :: (numentr,numterm)
    getafebarfrowinfo(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: (numentr,numterm)

Arguments:
    afeidx::Int64 Row index of barF.
    task::MSKtask An optimization task.

Returns:
    numentr::Int32 Number of nonzero entries in a row of barF.
    numterm::Int64 Number of terms in the weighted sums representation of the row of barF.
"""
function getafebarfrowinfo end

"""
Obtains the total number of nonzeros in F.

    getafefnumnz(task::MSKtask) :: numnz

Arguments:
    task::MSKtask An optimization task.

Returns:
    numnz::Int64 Number of nonzeros in F.
"""
function getafefnumnz end

"""
Obtains one row of F in sparse format.

    getafefrow(task::MSKtask,afeidx::Int64) :: (numnz,varidx,val)
    getafefrow(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: (numnz,varidx,val)

Arguments:
    afeidx::Int64 Row index.
    task::MSKtask An optimization task.

Returns:
    numnz::Int32 Number of non-zeros in the row obtained.
    val::Vector{Float64} Values of the non-zeros in the row obtained.
    varidx::Vector{Int32} Column indices of the non-zeros in the row obtained.
"""
function getafefrow end

"""
Obtains the number of nonzeros in a row of F.

    getafefrownumnz(task::MSKtask,afeidx::Int64) :: numnz
    getafefrownumnz(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: numnz

Arguments:
    afeidx::Int64 Row index.
    task::MSKtask An optimization task.

Returns:
    numnz::Int32 Number of non-zeros in the row.
"""
function getafefrownumnz end

"""
Obtains the F matrix in triplet format.

    getafeftrip(task::MSKtask) :: (afeidx,varidx,val)

Arguments:
    task::MSKtask An optimization task.

Returns:
    afeidx::Vector{Int64} Row indices of nonzeros.
    val::Vector{Float64} Values of nonzero entries.
    varidx::Vector{Int32} Column indices of nonzeros.
"""
function getafeftrip end

"""
Obtains a single coefficient in g.

    getafeg(task::MSKtask,afeidx::Int64) :: g
    getafeg(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: g

Arguments:
    afeidx::Int64 Element index.
    task::MSKtask An optimization task.

Returns:
    g::Float64 The entry in g.
"""
function getafeg end

"""
Obtains a sequence of coefficients from the vector g.

    getafegslice(task::MSKtask,first::Int64,last::Int64) :: g
    getafegslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: g

Arguments:
    first::Int64 First index in the sequence.
    last::Int64 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.

Returns:
    g::Vector{Float64} The slice of g as a dense vector.
"""
function getafegslice end

"""
Obtains a single coefficient in linear constraint matrix.

    getaij(task::MSKtask,i::Int32,j::Int32) :: aij
    getaij(task::MSKtask,i::T0,j::T1) where {T0<:Integer,T1<:Integer}  :: aij

Arguments:
    i::Int32 Row index of the coefficient to be returned.
    j::Int32 Column index of the coefficient to be returned.
    task::MSKtask An optimization task.

Returns:
    aij::Float64 Returns the requested coefficient.
"""
function getaij end

"""
Obtains the number non-zeros in a rectangular piece of the linear constraint matrix.

    getapiecenumnz(task::MSKtask,firsti::Int32,lasti::Int32,firstj::Int32,lastj::Int32) :: numnz
    getapiecenumnz(task::MSKtask,firsti::T0,lasti::T1,firstj::T2,lastj::T3) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer}  :: numnz

Arguments:
    firsti::Int32 Index of the first row in the rectangular piece.
    firstj::Int32 Index of the first column in the rectangular piece.
    lasti::Int32 Index of the last row plus one in the rectangular piece.
    lastj::Int32 Index of the last column plus one in the rectangular piece.
    task::MSKtask An optimization task.

Returns:
    numnz::Int32 Number of non-zero elements in the rectangular piece of the linear constraint matrix.
"""
function getapiecenumnz end

"""
Obtains one row of the linear constraint matrix.

    getarow(task::MSKtask,i::Int32) :: (nzi,subi,vali)
    getarow(task::MSKtask,i::T0) where {T0<:Integer}  :: (nzi,subi,vali)

Arguments:
    i::Int32 Index of the row.
    task::MSKtask An optimization task.

Returns:
    nzi::Int32 Number of non-zeros in the row obtained.
    subi::Vector{Int32} Column indices of the non-zeros in the row obtained.
    vali::Vector{Float64} Numerical values of the row obtained.
"""
function getarow end

"""
Obtains the number of non-zero elements in one row of the linear constraint matrix

    getarownumnz(task::MSKtask,i::Int32) :: nzi
    getarownumnz(task::MSKtask,i::T0) where {T0<:Integer}  :: nzi

Arguments:
    i::Int32 Index of the row.
    task::MSKtask An optimization task.

Returns:
    nzi::Int32 Number of non-zeros in the i'th row of `A`.
"""
function getarownumnz end

"""
Obtains a sequence of rows from the coefficient matrix.

    getarowslice(task::MSKtask,first::Int32,last::Int32) :: (ptrb,ptre,sub,val)
    getarowslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (ptrb,ptre,sub,val)

Arguments:
    first::Int32 Index of the first row in the sequence.
    last::Int32 Index of the last row in the sequence plus one.
    task::MSKtask An optimization task.

Returns:
    ptrb::Vector{Int64} Row start pointers.
    ptre::Vector{Int64} Row end pointers.
    sub::Vector{Int32} Contains the column subscripts.
    val::Vector{Float64} Contains the coefficient values.
"""
function getarowslice end

"""
Obtains the number of non-zeros in a slice of rows of the coefficient matrix.

    getarowslicenumnz(task::MSKtask,first::Int32,last::Int32) :: numnz
    getarowslicenumnz(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: numnz

Arguments:
    first::Int32 Index of the first row in the sequence.
    last::Int32 Index of the last row plus one in the sequence.
    task::MSKtask An optimization task.

Returns:
    numnz::Int64 Number of non-zeros in the slice.
"""
function getarowslicenumnz end

"""
Obtains a sequence of rows from the coefficient matrix in sparse triplet format.

    getarowslicetrip(task::MSKtask,first::Int32,last::Int32) :: (subi,subj,val)
    getarowslicetrip(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (subi,subj,val)

Arguments:
    first::Int32 Index of the first row in the sequence.
    last::Int32 Index of the last row in the sequence plus one.
    task::MSKtask An optimization task.

Returns:
    subi::Vector{Int32} Constraint subscripts.
    subj::Vector{Int32} Column subscripts.
    val::Vector{Float64} Values.
"""
function getarowslicetrip end

"""
Obtains the A matrix in sparse triplet format.

    getatrip(task::MSKtask) :: (subi,subj,val)

Arguments:
    task::MSKtask An optimization task.

Returns:
    subi::Vector{Int32} Constraint subscripts.
    subj::Vector{Int32} Column subscripts.
    val::Vector{Float64} Values.
"""
function getatrip end

"""
Gets the current A matrix truncation threshold.

    getatruncatetol(task::MSKtask) :: tolzero

Arguments:
    task::MSKtask An optimization task.

Returns:
    tolzero::Vector{Float64} Truncation tolerance.
"""
function getatruncatetol end

"""
Obtains barA in block triplet form.

    getbarablocktriplet(task::MSKtask) :: (num,subi,subj,subk,subl,valijkl)

Arguments:
    task::MSKtask An optimization task.

Returns:
    num::Int64 Number of elements in the block triplet form.
    subi::Vector{Int32} Constraint index.
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valijkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function getbarablocktriplet end

"""
Obtains information about an element in barA.

    getbaraidx(task::MSKtask,idx::Int64) :: (i,j,num,sub,weights)
    getbaraidx(task::MSKtask,idx::T0) where {T0<:Integer}  :: (i,j,num,sub,weights)

Arguments:
    idx::Int64 Position of the element in the vectorized form.
    task::MSKtask An optimization task.

Returns:
    i::Int32 Row index of the element at position idx.
    j::Int32 Column index of the element at position idx.
    num::Int64 Number of terms in weighted sum that forms the element.
    sub::Vector{Int64} A list indexes of the elements from symmetric matrix storage that appear in the weighted sum.
    weights::Vector{Float64} The weights associated with each term in the weighted sum.
"""
function getbaraidx end

"""
Obtains information about an element in barA.

    getbaraidxij(task::MSKtask,idx::Int64) :: (i,j)
    getbaraidxij(task::MSKtask,idx::T0) where {T0<:Integer}  :: (i,j)

Arguments:
    idx::Int64 Position of the element in the vectorized form.
    task::MSKtask An optimization task.

Returns:
    i::Int32 Row index of the element at position idx.
    j::Int32 Column index of the element at position idx.
"""
function getbaraidxij end

"""
Obtains the number of terms in the weighted sum that form a particular element in barA.

    getbaraidxinfo(task::MSKtask,idx::Int64) :: num
    getbaraidxinfo(task::MSKtask,idx::T0) where {T0<:Integer}  :: num

Arguments:
    idx::Int64 The internal position of the element for which information should be obtained.
    task::MSKtask An optimization task.

Returns:
    num::Int64 Number of terms in the weighted sum that form the specified element in barA.
"""
function getbaraidxinfo end

"""
Obtains the sparsity pattern of the barA matrix.

    getbarasparsity(task::MSKtask) :: (numnz,idxij)

Arguments:
    task::MSKtask An optimization task.

Returns:
    idxij::Vector{Int64} Position of each nonzero element in the vector representation of barA.
    numnz::Int64 Number of nonzero elements in barA.
"""
function getbarasparsity end

"""
Obtains barC in block triplet form.

    getbarcblocktriplet(task::MSKtask) :: (num,subj,subk,subl,valjkl)

Arguments:
    task::MSKtask An optimization task.

Returns:
    num::Int64 Number of elements in the block triplet form.
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valjkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function getbarcblocktriplet end

"""
Obtains information about an element in barc.

    getbarcidx(task::MSKtask,idx::Int64) :: (j,num,sub,weights)
    getbarcidx(task::MSKtask,idx::T0) where {T0<:Integer}  :: (j,num,sub,weights)

Arguments:
    idx::Int64 Index of the element for which information should be obtained.
    task::MSKtask An optimization task.

Returns:
    j::Int32 Row index in barc.
    num::Int64 Number of terms in the weighted sum.
    sub::Vector{Int64} Elements appearing the weighted sum.
    weights::Vector{Float64} Weights of terms in the weighted sum.
"""
function getbarcidx end

"""
Obtains information about an element in barc.

    getbarcidxinfo(task::MSKtask,idx::Int64) :: num
    getbarcidxinfo(task::MSKtask,idx::T0) where {T0<:Integer}  :: num

Arguments:
    idx::Int64 Index of the element for which information should be obtained. The value is an index of a symmetric sparse variable.
    task::MSKtask An optimization task.

Returns:
    num::Int64 Number of terms that appear in the weighted sum that forms the requested element.
"""
function getbarcidxinfo end

"""
Obtains the row index of an element in barc.

    getbarcidxj(task::MSKtask,idx::Int64) :: j
    getbarcidxj(task::MSKtask,idx::T0) where {T0<:Integer}  :: j

Arguments:
    idx::Int64 Index of the element for which information should be obtained.
    task::MSKtask An optimization task.

Returns:
    j::Int32 Row index in barc.
"""
function getbarcidxj end

"""
Get the positions of the nonzero elements in barc.

    getbarcsparsity(task::MSKtask) :: (numnz,idxj)

Arguments:
    task::MSKtask An optimization task.

Returns:
    idxj::Vector{Int64} Internal positions of the nonzeros elements in barc.
    numnz::Int64 Number of nonzero elements in barc.
"""
function getbarcsparsity end

"""
Obtains the dual solution for a semidefinite variable.

    getbarsj(task::MSKtask,whichsol::Soltype,j::Int32) :: barsj
    getbarsj(task::MSKtask,whichsol::Soltype,j::T0) where {T0<:Integer}  :: barsj

Arguments:
    j::Int32 Index of the semidefinite variable.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    barsj::Vector{Float64} Value of the j'th dual variable of barx.
"""
function getbarsj end

"""
Obtains the dual solution for a sequence of semidefinite variables.

    getbarsslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64) :: barsslice
    getbarsslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where {T0<:Integer,T1<:Integer,T2<:Integer}  :: barsslice

Arguments:
    first::Int32 Index of the first semidefinite variable in the slice.
    last::Int32 Index of the last semidefinite variable in the slice plus one.
    slicesize::Int64 Denotes the length of the array barsslice.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    barsslice::Vector{Float64} Dual solution values of symmetric matrix variables in the slice, stored sequentially.
"""
function getbarsslice end

"""
Obtains the name of a semidefinite variable.

    getbarvarname(task::MSKtask,i::Int32) :: name
    getbarvarname(task::MSKtask,i::T0) where {T0<:Integer}  :: name

Arguments:
    i::Int32 Index of the variable.
    task::MSKtask An optimization task.

Returns:
    name::String The requested name is copied to this buffer.
"""
function getbarvarname end

"""
Obtains the index of semidefinite variable from its name.

    getbarvarnameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

Arguments:
    somename::AbstractString The name of the variable.
    task::MSKtask An optimization task.

Returns:
    asgn::Int32 Non-zero if the name somename is assigned to some semidefinite variable.
    index::Int32 The index of a semidefinite variable with the name somename (if one exists).
"""
function getbarvarnameindex end

"""
Obtains the length of the name of a semidefinite variable.

    getbarvarnamelen(task::MSKtask,i::Int32) :: len
    getbarvarnamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

Arguments:
    i::Int32 Index of the variable.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the indicated name.
"""
function getbarvarnamelen end

"""
Obtains the primal solution for a semidefinite variable.

    getbarxj(task::MSKtask,whichsol::Soltype,j::Int32) :: barxj
    getbarxj(task::MSKtask,whichsol::Soltype,j::T0) where {T0<:Integer}  :: barxj

Arguments:
    j::Int32 Index of the semidefinite variable.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    barxj::Vector{Float64} Value of the j'th variable of barx.
"""
function getbarxj end

"""
Obtains the primal solution for a sequence of semidefinite variables.

    getbarxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64) :: barxslice
    getbarxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where {T0<:Integer,T1<:Integer,T2<:Integer}  :: barxslice

Arguments:
    first::Int32 Index of the first semidefinite variable in the slice.
    last::Int32 Index of the last semidefinite variable in the slice plus one.
    slicesize::Int64 Denotes the length of the array barxslice.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    barxslice::Vector{Float64} Solution values of symmetric matrix variables in the slice, stored sequentially.
"""
function getbarxslice end

"""
Obtains all objective coefficients.

    getc(task::MSKtask) :: c

Arguments:
    task::MSKtask An optimization task.

Returns:
    c::Vector{Float64} Linear terms of the objective as a dense vector. The length is the number of variables.
"""
function getc end

"""
Obtains the fixed term in the objective.

    getcfix(task::MSKtask) :: cfix

Arguments:
    task::MSKtask An optimization task.

Returns:
    cfix::Float64 Fixed term in the objective.
"""
function getcfix end

"""
Obtains one objective coefficient.

    getcj(task::MSKtask,j::Int32) :: cj
    getcj(task::MSKtask,j::T0) where {T0<:Integer}  :: cj

Arguments:
    j::Int32 Index of the variable for which the c coefficient should be obtained.
    task::MSKtask An optimization task.

Returns:
    cj::Float64 The c coefficient value.
"""
function getcj end

"""
Obtains a sequence of coefficients from the objective.

    getclist(task::MSKtask,subj::Vector{Int32}) :: c
    getclist(task::MSKtask,subj::T0) where {T0<:AbstractVector{<:Integer}}  :: c

Arguments:
    subj::Vector{Int32} A list of variable indexes.
    task::MSKtask An optimization task.

Returns:
    c::Vector{Float64} Linear terms of the requested list of the objective as a dense vector.
"""
function getclist end

"""
Obtains a short description of a response code.

    getcodedesc(code::Rescode) :: (symname,str)

Arguments:
    code::Rescode A valid response code.

Returns:
    str::String Obtains a short description of a response code.
    symname::String Symbolic name corresponding to the code.
"""
function getcodedesc end

"""
Obtains bound information for one constraint.

    getconbound(task::MSKtask,i::Int32) :: (bk,bl,bu)
    getconbound(task::MSKtask,i::T0) where {T0<:Integer}  :: (bk,bl,bu)

Arguments:
    i::Int32 Index of the constraint for which the bound information should be obtained.
    task::MSKtask An optimization task.

Returns:
    bk::Boundkey Bound keys.
    bl::Float64 Values for lower bounds.
    bu::Float64 Values for upper bounds.
"""
function getconbound end

"""
Obtains bounds information for a slice of the constraints.

    getconboundslice(task::MSKtask,first::Int32,last::Int32) :: (bk,bl,bu)
    getconboundslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (bk,bl,bu)

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.

Returns:
    bk::Vector{Boundkey} Bound keys.
    bl::Vector{Float64} Values for lower bounds.
    bu::Vector{Float64} Values for upper bounds.
"""
function getconboundslice end

"""
Obtains a cone.

    getcone(task::MSKtask,k::Int32) :: (ct,conepar,nummem,submem)
    getcone(task::MSKtask,k::T0) where {T0<:Integer}  :: (ct,conepar,nummem,submem)

Arguments:
    k::Int32 Index of the cone.
    task::MSKtask An optimization task.

Returns:
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    ct::Conetype Specifies the type of the cone.
    nummem::Int32 Number of member variables in the cone.
    submem::Vector{Int32} Variable subscripts of the members in the cone.
"""
function getcone end

"""
Obtains information about a cone.

    getconeinfo(task::MSKtask,k::Int32) :: (ct,conepar,nummem)
    getconeinfo(task::MSKtask,k::T0) where {T0<:Integer}  :: (ct,conepar,nummem)

Arguments:
    k::Int32 Index of the cone.
    task::MSKtask An optimization task.

Returns:
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    ct::Conetype Specifies the type of the cone.
    nummem::Int32 Number of member variables in the cone.
"""
function getconeinfo end

"""
Obtains the name of a cone.

    getconename(task::MSKtask,i::Int32) :: name
    getconename(task::MSKtask,i::T0) where {T0<:Integer}  :: name

Arguments:
    i::Int32 Index of the cone.
    task::MSKtask An optimization task.

Returns:
    name::String The required name.
"""
function getconename end

"""
Checks whether the name has been assigned to any cone.

    getconenameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

Arguments:
    somename::AbstractString The name which should be checked.
    task::MSKtask An optimization task.

Returns:
    asgn::Int32 Is non-zero if the name somename is assigned to some cone.
    index::Int32 If the name somename is assigned to some cone, this is the index of the cone.
"""
function getconenameindex end

"""
Obtains the length of the name of a cone.

    getconenamelen(task::MSKtask,i::Int32) :: len
    getconenamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

Arguments:
    i::Int32 Index of the cone.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the indicated name.
"""
function getconenamelen end

"""
Obtains the name of a constraint.

    getconname(task::MSKtask,i::Int32) :: name
    getconname(task::MSKtask,i::T0) where {T0<:Integer}  :: name

Arguments:
    i::Int32 Index of the constraint.
    task::MSKtask An optimization task.

Returns:
    name::String The required name.
"""
function getconname end

"""
Checks whether the name has been assigned to any constraint.

    getconnameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

Arguments:
    somename::AbstractString The name which should be checked.
    task::MSKtask An optimization task.

Returns:
    asgn::Int32 Is non-zero if the name somename is assigned to some constraint.
    index::Int32 If the name somename is assigned to a constraint, then return the index of the constraint.
"""
function getconnameindex end

"""
Obtains the length of the name of a constraint.

    getconnamelen(task::MSKtask,i::Int32) :: len
    getconnamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

Arguments:
    i::Int32 Index of the constraint.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the indicated name.
"""
function getconnamelen end

"""
Obtains a sequence of coefficients from the objective.

    getcslice(task::MSKtask,first::Int32,last::Int32) :: c
    getcslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: c

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.

Returns:
    c::Vector{Float64} Linear terms of the requested slice of the objective as a dense vector.
"""
function getcslice end

"""
Obtains the dimension of a symmetric matrix variable.

    getdimbarvarj(task::MSKtask,j::Int32) :: dimbarvarj
    getdimbarvarj(task::MSKtask,j::T0) where {T0<:Integer}  :: dimbarvarj

Arguments:
    j::Int32 Index of the semidefinite variable whose dimension is requested.
    task::MSKtask An optimization task.

Returns:
    dimbarvarj::Int32 The dimension of the j'th semidefinite variable.
"""
function getdimbarvarj end

"""
Obtains the list of affine expression indexes in a disjunctive constraint.

    getdjcafeidxlist(task::MSKtask,djcidx::Int64) :: afeidxlist
    getdjcafeidxlist(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: afeidxlist

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    afeidxlist::Vector{Int64} List of affine expression indexes.
"""
function getdjcafeidxlist end

"""
Obtains the optional constant term vector of a disjunctive constraint.

    getdjcb(task::MSKtask,djcidx::Int64) :: b
    getdjcb(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: b

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    b::Vector{Float64} The vector b.
"""
function getdjcb end

"""
Obtains the list of domain indexes in a disjunctive constraint.

    getdjcdomainidxlist(task::MSKtask,djcidx::Int64) :: domidxlist
    getdjcdomainidxlist(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: domidxlist

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    domidxlist::Vector{Int64} List of term sizes.
"""
function getdjcdomainidxlist end

"""
Obtains the name of a disjunctive constraint.

    getdjcname(task::MSKtask,djcidx::Int64) :: name
    getdjcname(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: name

Arguments:
    djcidx::Int64 Index of a disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    name::String Returns the required name.
"""
function getdjcname end

"""
Obtains the length of the name of a disjunctive constraint.

    getdjcnamelen(task::MSKtask,djcidx::Int64) :: len
    getdjcnamelen(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: len

Arguments:
    djcidx::Int64 Index of a disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the indicated name.
"""
function getdjcnamelen end

"""
Obtains the number of affine expressions in the disjunctive constraint.

    getdjcnumafe(task::MSKtask,djcidx::Int64) :: numafe
    getdjcnumafe(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: numafe

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    numafe::Int64 Number of affine expressions in the disjunctive constraint.
"""
function getdjcnumafe end

"""
Obtains the number of affine expressions in all disjunctive constraints.

    getdjcnumafetot(task::MSKtask) :: numafetot

Arguments:
    task::MSKtask An optimization task.

Returns:
    numafetot::Int64 Number of affine expressions in all disjunctive constraints.
"""
function getdjcnumafetot end

"""
Obtains the number of domains in the disjunctive constraint.

    getdjcnumdomain(task::MSKtask,djcidx::Int64) :: numdomain
    getdjcnumdomain(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: numdomain

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    numdomain::Int64 Number of domains in the disjunctive constraint.
"""
function getdjcnumdomain end

"""
Obtains the number of domains in all disjunctive constraints.

    getdjcnumdomaintot(task::MSKtask) :: numdomaintot

Arguments:
    task::MSKtask An optimization task.

Returns:
    numdomaintot::Int64 Number of domains in all disjunctive constraints.
"""
function getdjcnumdomaintot end

"""
Obtains the number terms in the disjunctive constraint.

    getdjcnumterm(task::MSKtask,djcidx::Int64) :: numterm
    getdjcnumterm(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: numterm

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    numterm::Int64 Number of terms in the disjunctive constraint.
"""
function getdjcnumterm end

"""
Obtains the number of terms in all disjunctive constraints.

    getdjcnumtermtot(task::MSKtask) :: numtermtot

Arguments:
    task::MSKtask An optimization task.

Returns:
    numtermtot::Int64 Total number of terms in all disjunctive constraints.
"""
function getdjcnumtermtot end

"""
Obtains full data of all disjunctive constraints.

    getdjcs(task::MSKtask) :: (domidxlist,afeidxlist,b,termsizelist,numterms)

Arguments:
    task::MSKtask An optimization task.

Returns:
    afeidxlist::Vector{Int64} The concatenation of index lists of affine expressions appearing in all disjunctive constraints.
    b::Vector{Float64} The concatenation of vectors b appearing in all disjunctive constraints.
    domidxlist::Vector{Int64} The concatenation of index lists of domains appearing in all disjunctive constraints.
    numterms::Vector{Int64} The number of terms in each of the disjunctive constraints.
    termsizelist::Vector{Int64} The concatenation of lists of term sizes appearing in all disjunctive constraints.
"""
function getdjcs end

"""
Obtains the list of term sizes in a disjunctive constraint.

    getdjctermsizelist(task::MSKtask,djcidx::Int64) :: termsizelist
    getdjctermsizelist(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: termsizelist

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    task::MSKtask An optimization task.

Returns:
    termsizelist::Vector{Int64} List of term sizes.
"""
function getdjctermsizelist end

"""
Obtains the dimension of the domain.

    getdomainn(task::MSKtask,domidx::Int64) :: n
    getdomainn(task::MSKtask,domidx::T0) where {T0<:Integer}  :: n

Arguments:
    domidx::Int64 Index of the domain.
    task::MSKtask An optimization task.

Returns:
    n::Int64 Dimension of the domain.
"""
function getdomainn end

"""
Obtains the name of a domain.

    getdomainname(task::MSKtask,domidx::Int64) :: name
    getdomainname(task::MSKtask,domidx::T0) where {T0<:Integer}  :: name

Arguments:
    domidx::Int64 Index of a domain.
    task::MSKtask An optimization task.

Returns:
    name::String Returns the required name.
"""
function getdomainname end

"""
Obtains the length of the name of a domain.

    getdomainnamelen(task::MSKtask,domidx::Int64) :: len
    getdomainnamelen(task::MSKtask,domidx::T0) where {T0<:Integer}  :: len

Arguments:
    domidx::Int64 Index of a domain.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the indicated name.
"""
function getdomainnamelen end

"""
Returns the type of the domain.

    getdomaintype(task::MSKtask,domidx::Int64) :: domtype
    getdomaintype(task::MSKtask,domidx::T0) where {T0<:Integer}  :: domtype

Arguments:
    domidx::Int64 Index of the domain.
    task::MSKtask An optimization task.

Returns:
    domtype::Domaintype The type of the domain.
"""
function getdomaintype end

"""
Obtains a double information item.

    getdouinf(task::MSKtask,whichdinf::Dinfitem) :: dvalue

Arguments:
    task::MSKtask An optimization task.
    whichdinf::Dinfitem Specifies a double information item.

Returns:
    dvalue::Float64 The value of the required double information item.
"""
function getdouinf end

"""
Obtains a double parameter.

    getdouparam(task::MSKtask,param::Dparam) :: parvalue

Arguments:
    param::Dparam Which parameter.
    task::MSKtask An optimization task.

Returns:
    parvalue::Float64 Parameter value.
"""
function getdouparam end

"""
Computes the dual objective value associated with the solution.

    getdualobj(task::MSKtask,whichsol::Soltype) :: dualobj

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    dualobj::Float64 Objective value corresponding to the dual solution.
"""
function getdualobj end

"""
Compute norms of the dual solution.

    getdualsolutionnorms(task::MSKtask,whichsol::Soltype) :: (nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    nrmbars::Float64 The norm of the bars vector.
    nrmslc::Float64 The norm of the slc vector.
    nrmslx::Float64 The norm of the slx vector.
    nrmsnx::Float64 The norm of the snx vector.
    nrmsuc::Float64 The norm of the suc vector.
    nrmsux::Float64 The norm of the sux vector.
    nrmy::Float64 The norm of the y vector.
"""
function getdualsolutionnorms end

"""
Computes the violation of the dual solution for set of affine conic constraints.

    getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64}) :: viol
    getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    accidxlist::Vector{Int64} An array of indexes of conic constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolacc end

"""
Computes the violation of dual solution for a set of semidefinite variables.

    getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of barx variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolbarvar end

"""
Computes the violation of a dual solution associated with a set of constraints.

    getdviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getdviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolcon end

"""
Computes the violation of a solution for set of dual conic constraints.

    getdviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getdviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of conic constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolcones end

"""
Computes the violation of a dual solution associated with a set of scalar variables.

    getdviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getdviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of x variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolvar end

"""
Obtains an infeasible subproblem.

    getinfeasiblesubproblem(task::MSKtask,whichsol::Soltype) :: inftask

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Which solution to use when determining the infeasible subproblem.

Returns:
    inftask::MSKtask A new task containing the infeasible subproblem.
"""
function getinfeasiblesubproblem end

"""
Obtains the name of an information item.

    getinfname(task::MSKtask,inftype::Inftype,whichinf::Int32) :: infname
    getinfname(task::MSKtask,inftype::Inftype,whichinf::T0) where {T0<:Integer}  :: infname

Arguments:
    inftype::Inftype Type of the information item.
    task::MSKtask An optimization task.
    whichinf::Int32 An information item.

Returns:
    infname::String Name of the information item.
"""
function getinfname end

"""
Obtains an integer information item.

    getintinf(task::MSKtask,whichiinf::Iinfitem) :: ivalue

Arguments:
    task::MSKtask An optimization task.
    whichiinf::Iinfitem Specifies an integer information item.

Returns:
    ivalue::Int32 The value of the required integer information item.
"""
function getintinf end

"""
Obtains an integer parameter.

    getintparam(task::MSKtask,param::Iparam) :: parvalue

Arguments:
    param::Iparam Which parameter.
    task::MSKtask An optimization task.

Returns:
    parvalue::Int32 Parameter value.
"""
function getintparam end

"""
Obtains the last error code and error message reported in MOSEK.

    getlasterror(task::MSKtask) :: (lastrescode,lastmsglen,lastmsg)

Arguments:
    task::MSKtask An optimization task.

Returns:
    lastmsg::String Returns the last error message reported in the task.
    lastmsglen::Int64 Returns the length of the last error message reported in the task.
    lastrescode::Rescode Returns the last error code reported in the task.
"""
function getlasterror end

"""
Obtains the length of one semidefinite variable.

    getlenbarvarj(task::MSKtask,j::Int32) :: lenbarvarj
    getlenbarvarj(task::MSKtask,j::T0) where {T0<:Integer}  :: lenbarvarj

Arguments:
    j::Int32 Index of the semidefinite variable whose length if requested.
    task::MSKtask An optimization task.

Returns:
    lenbarvarj::Int64 Number of scalar elements in the lower triangular part of the semidefinite variable.
"""
function getlenbarvarj end

"""
Obtains a long integer information item.

    getlintinf(task::MSKtask,whichliinf::Liinfitem) :: ivalue

Arguments:
    task::MSKtask An optimization task.
    whichliinf::Liinfitem Specifies a long information item.

Returns:
    ivalue::Int64 The value of the required long integer information item.
"""
function getlintinf end

"""
Obtains number of preallocated non-zeros in the linear constraint matrix.

    getmaxnumanz(task::MSKtask) :: maxnumanz

Arguments:
    task::MSKtask An optimization task.

Returns:
    maxnumanz::Int64 Number of preallocated non-zero linear matrix elements.
"""
function getmaxnumanz end

"""
Obtains maximum number of symmetric matrix variables for which space is currently preallocated.

    getmaxnumbarvar(task::MSKtask) :: maxnumbarvar

Arguments:
    task::MSKtask An optimization task.

Returns:
    maxnumbarvar::Int32 Maximum number of symmetric matrix variables for which space is currently preallocated.
"""
function getmaxnumbarvar end

"""
Obtains the number of preallocated constraints in the optimization task.

    getmaxnumcon(task::MSKtask) :: maxnumcon

Arguments:
    task::MSKtask An optimization task.

Returns:
    maxnumcon::Int32 Number of preallocated constraints in the optimization task.
"""
function getmaxnumcon end

"""
Obtains the number of preallocated cones in the optimization task.

    getmaxnumcone(task::MSKtask) :: maxnumcone

Arguments:
    task::MSKtask An optimization task.

Returns:
    maxnumcone::Int32 Number of preallocated conic constraints in the optimization task.
"""
function getmaxnumcone end

"""
Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints.

    getmaxnumqnz(task::MSKtask) :: maxnumqnz

Arguments:
    task::MSKtask An optimization task.

Returns:
    maxnumqnz::Int64 Number of non-zero elements preallocated in quadratic coefficient matrices.
"""
function getmaxnumqnz end

"""
Obtains the maximum number variables allowed.

    getmaxnumvar(task::MSKtask) :: maxnumvar

Arguments:
    task::MSKtask An optimization task.

Returns:
    maxnumvar::Int32 Number of preallocated variables in the optimization task.
"""
function getmaxnumvar end

"""
Obtains information about the amount of memory used by a task.

    getmemusage(task::MSKtask) :: (meminuse,maxmemuse)

Arguments:
    task::MSKtask An optimization task.

Returns:
    maxmemuse::Int64 Maximum amount of memory used by the task until now.
    meminuse::Int64 Amount of memory currently used by the task.
"""
function getmemusage end

"""
Obtains a named double information item.

    getnadouinf(task::MSKtask,infitemname::AbstractString) :: dvalue

Arguments:
    infitemname::AbstractString The name of a double information item.
    task::MSKtask An optimization task.

Returns:
    dvalue::Float64 The value of the required double information item.
"""
function getnadouinf end

"""
Obtains a double parameter.

    getnadouparam(task::MSKtask,paramname::AbstractString) :: parvalue

Arguments:
    paramname::AbstractString Name of a parameter.
    task::MSKtask An optimization task.

Returns:
    parvalue::Float64 Parameter value.
"""
function getnadouparam end

"""
Obtains a named integer information item.

    getnaintinf(task::MSKtask,infitemname::AbstractString) :: ivalue

Arguments:
    infitemname::AbstractString The name of an integer information item.
    task::MSKtask An optimization task.

Returns:
    ivalue::Int32 The value of the required integer information item.
"""
function getnaintinf end

"""
Obtains an integer parameter.

    getnaintparam(task::MSKtask,paramname::AbstractString) :: parvalue

Arguments:
    paramname::AbstractString Name of a parameter.
    task::MSKtask An optimization task.

Returns:
    parvalue::Int32 Parameter value.
"""
function getnaintparam end

"""
Obtains a string parameter.

    getnastrparam(task::MSKtask,paramname::AbstractString,sizeparamname::Int32) :: (len,parvalue)
    getnastrparam(task::MSKtask,paramname::Union{Nothing,AbstractString},sizeparamname::T0) where {T0<:Integer}  :: (len,parvalue)

Arguments:
    paramname::AbstractString Name of a parameter.
    sizeparamname::Int32 Size of the name buffer.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the parameter value.
    parvalue::String Parameter value.
"""
function getnastrparam end

"""
Obtains the number of affine conic constraints.

    getnumacc(task::MSKtask) :: num

Arguments:
    task::MSKtask An optimization task.

Returns:
    num::Int64 The number of affine conic constraints.
"""
function getnumacc end

"""
Obtains the number of affine expressions.

    getnumafe(task::MSKtask) :: numafe

Arguments:
    task::MSKtask An optimization task.

Returns:
    numafe::Int64 Number of affine expressions.
"""
function getnumafe end

"""
Obtains the number of non-zeros in the coefficient matrix.

    getnumanz(task::MSKtask) :: numanz

Arguments:
    task::MSKtask An optimization task.

Returns:
    numanz::Int32 Number of non-zero elements in the linear constraint matrix.
"""
function getnumanz end

"""
Obtains the number of non-zeros in the coefficient matrix.

    getnumanz64(task::MSKtask) :: numanz

Arguments:
    task::MSKtask An optimization task.

Returns:
    numanz::Int64 Number of non-zero elements in the linear constraint matrix.
"""
function getnumanz64 end

"""
Obtains an upper bound on the number of scalar elements in the block triplet form of bara.

    getnumbarablocktriplets(task::MSKtask) :: num

Arguments:
    task::MSKtask An optimization task.

Returns:
    num::Int64 An upper bound on the number of elements in the block triplet form of bara.
"""
function getnumbarablocktriplets end

"""
Get the number of nonzero elements in barA.

    getnumbaranz(task::MSKtask) :: nz

Arguments:
    task::MSKtask An optimization task.

Returns:
    nz::Int64 The number of nonzero block elements in barA.
"""
function getnumbaranz end

"""
Obtains an upper bound on the number of elements in the block triplet form of barc.

    getnumbarcblocktriplets(task::MSKtask) :: num

Arguments:
    task::MSKtask An optimization task.

Returns:
    num::Int64 An upper bound on the number of elements in the block triplet form of barc.
"""
function getnumbarcblocktriplets end

"""
Obtains the number of nonzero elements in barc.

    getnumbarcnz(task::MSKtask) :: nz

Arguments:
    task::MSKtask An optimization task.

Returns:
    nz::Int64 The number of nonzero elements in barc.
"""
function getnumbarcnz end

"""
Obtains the number of semidefinite variables.

    getnumbarvar(task::MSKtask) :: numbarvar

Arguments:
    task::MSKtask An optimization task.

Returns:
    numbarvar::Int32 Number of semidefinite variables in the problem.
"""
function getnumbarvar end

"""
Obtains the number of constraints.

    getnumcon(task::MSKtask) :: numcon

Arguments:
    task::MSKtask An optimization task.

Returns:
    numcon::Int32 Number of constraints.
"""
function getnumcon end

"""
Obtains the number of cones.

    getnumcone(task::MSKtask) :: numcone

Arguments:
    task::MSKtask An optimization task.

Returns:
    numcone::Int32 Number of conic constraints.
"""
function getnumcone end

"""
Obtains the number of members in a cone.

    getnumconemem(task::MSKtask,k::Int32) :: nummem
    getnumconemem(task::MSKtask,k::T0) where {T0<:Integer}  :: nummem

Arguments:
    k::Int32 Index of the cone.
    task::MSKtask An optimization task.

Returns:
    nummem::Int32 Number of member variables in the cone.
"""
function getnumconemem end

"""
Obtains the number of disjunctive constraints.

    getnumdjc(task::MSKtask) :: num

Arguments:
    task::MSKtask An optimization task.

Returns:
    num::Int64 The number of disjunctive constraints.
"""
function getnumdjc end

"""
Obtain the number of domains defined.

    getnumdomain(task::MSKtask) :: numdomain

Arguments:
    task::MSKtask An optimization task.

Returns:
    numdomain::Int64 Number of domains in the task.
"""
function getnumdomain end

"""
Obtains the number of integer-constrained variables.

    getnumintvar(task::MSKtask) :: numintvar

Arguments:
    task::MSKtask An optimization task.

Returns:
    numintvar::Int32 Number of integer variables.
"""
function getnumintvar end

"""
Obtains the number of parameters of a given type.

    getnumparam(task::MSKtask,partype::Parametertype) :: numparam

Arguments:
    partype::Parametertype Parameter type.
    task::MSKtask An optimization task.

Returns:
    numparam::Int32 Returns the number of parameters of the requested type.
"""
function getnumparam end

"""
Obtains the number of non-zero quadratic terms in a constraint.

    getnumqconknz(task::MSKtask,k::Int32) :: numqcnz
    getnumqconknz(task::MSKtask,k::T0) where {T0<:Integer}  :: numqcnz

Arguments:
    k::Int32 Index of the constraint for which the number quadratic terms should be obtained.
    task::MSKtask An optimization task.

Returns:
    numqcnz::Int64 Number of quadratic terms.
"""
function getnumqconknz end

"""
Obtains the number of non-zero quadratic terms in the objective.

    getnumqobjnz(task::MSKtask) :: numqonz

Arguments:
    task::MSKtask An optimization task.

Returns:
    numqonz::Int64 Number of non-zero elements in the quadratic objective terms.
"""
function getnumqobjnz end

"""
Obtains the number of symmetric matrices stored.

    getnumsymmat(task::MSKtask) :: num

Arguments:
    task::MSKtask An optimization task.

Returns:
    num::Int64 The number of symmetric sparse matrices.
"""
function getnumsymmat end

"""
Obtains the number of variables.

    getnumvar(task::MSKtask) :: numvar

Arguments:
    task::MSKtask An optimization task.

Returns:
    numvar::Int32 Number of variables.
"""
function getnumvar end

"""
Obtains the name assigned to the objective function.

    getobjname(task::MSKtask) :: objname

Arguments:
    task::MSKtask An optimization task.

Returns:
    objname::String Assigned the objective name.
"""
function getobjname end

"""
Obtains the length of the name assigned to the objective function.

    getobjnamelen(task::MSKtask) :: len

Arguments:
    task::MSKtask An optimization task.

Returns:
    len::Int32 Assigned the length of the objective name.
"""
function getobjnamelen end

"""
Gets the objective sense.

    getobjsense(task::MSKtask) :: sense

Arguments:
    task::MSKtask An optimization task.

Returns:
    sense::Objsense The returned objective sense.
"""
function getobjsense end

"""
Obtains the name of a parameter.

    getparamname(task::MSKtask,partype::Parametertype,param::Int32) :: parname
    getparamname(task::MSKtask,partype::Parametertype,param::T0) where {T0<:Integer}  :: parname

Arguments:
    param::Int32 Which parameter.
    partype::Parametertype Parameter type.
    task::MSKtask An optimization task.

Returns:
    parname::String Parameter name.
"""
function getparamname end

"""
Obtains the exponent vector of a power domain.

    getpowerdomainalpha(task::MSKtask,domidx::Int64) :: alpha
    getpowerdomainalpha(task::MSKtask,domidx::T0) where {T0<:Integer}  :: alpha

Arguments:
    domidx::Int64 Index of the domain.
    task::MSKtask An optimization task.

Returns:
    alpha::Vector{Float64} The exponent vector of the domain.
"""
function getpowerdomainalpha end

"""
Obtains structural information about a power domain.

    getpowerdomaininfo(task::MSKtask,domidx::Int64) :: (n,nleft)
    getpowerdomaininfo(task::MSKtask,domidx::T0) where {T0<:Integer}  :: (n,nleft)

Arguments:
    domidx::Int64 Index of the domain.
    task::MSKtask An optimization task.

Returns:
    n::Int64 Dimension of the domain.
    nleft::Int64 Number of variables on the left hand side.
"""
function getpowerdomaininfo end

"""
Computes the primal objective value for the desired solution.

    getprimalobj(task::MSKtask,whichsol::Soltype) :: primalobj

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    primalobj::Float64 Objective value corresponding to the primal solution.
"""
function getprimalobj end

"""
Compute norms of the primal solution.

    getprimalsolutionnorms(task::MSKtask,whichsol::Soltype) :: (nrmxc,nrmxx,nrmbarx)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    nrmbarx::Float64 The norm of the barX vector.
    nrmxc::Float64 The norm of the xc vector.
    nrmxx::Float64 The norm of the xx vector.
"""
function getprimalsolutionnorms end

"""
Obtains the problem type.

    getprobtype(task::MSKtask) :: probtype

Arguments:
    task::MSKtask An optimization task.

Returns:
    probtype::Problemtype The problem type.
"""
function getprobtype end

"""
Obtains the problem status.

    getprosta(task::MSKtask,whichsol::Soltype) :: problemsta

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    problemsta::Prosta Problem status.
"""
function getprosta end

"""
Computes the violation of a solution for set of affine conic constraints.

    getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64}) :: viol
    getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    accidxlist::Vector{Int64} An array of indexes of conic constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolacc end

"""
Computes the violation of a primal solution for a list of semidefinite variables.

    getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of barX variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolbarvar end

"""
Computes the violation of a primal solution associated to a constraint.

    getpviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getpviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolcon end

"""
Computes the violation of a solution for set of conic constraints.

    getpviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getpviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of conic constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolcones end

"""
Computes the violation of a solution for set of disjunctive constraints.

    getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::Vector{Int64}) :: viol
    getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    djcidxlist::Vector{Int64} An array of indexes of disjunctive constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpvioldjc end

"""
Computes the violation of a primal solution for a list of scalar variables.

    getpviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
    getpviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

Arguments:
    sub::Vector{Int32} An array of indexes of x variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolvar end

"""
Obtains all the quadratic terms in a constraint.

    getqconk(task::MSKtask,k::Int32) :: (numqcnz,qcsubi,qcsubj,qcval)
    getqconk(task::MSKtask,k::T0) where {T0<:Integer}  :: (numqcnz,qcsubi,qcsubj,qcval)

Arguments:
    k::Int32 Which constraint.
    task::MSKtask An optimization task.

Returns:
    numqcnz::Int64 Number of quadratic terms.
    qcsubi::Vector{Int32} Row subscripts for quadratic constraint matrix.
    qcsubj::Vector{Int32} Column subscripts for quadratic constraint matrix.
    qcval::Vector{Float64} Quadratic constraint coefficient values.
"""
function getqconk end

"""
Obtains all the quadratic terms in the objective.

    getqobj(task::MSKtask) :: (numqonz,qosubi,qosubj,qoval)

Arguments:
    task::MSKtask An optimization task.

Returns:
    numqonz::Int64 Number of non-zero elements in the quadratic objective terms.
    qosubi::Vector{Int32} Row subscripts for quadratic objective coefficients.
    qosubj::Vector{Int32} Column subscripts for quadratic objective coefficients.
    qoval::Vector{Float64} Quadratic objective coefficient values.
"""
function getqobj end

"""
Obtains one coefficient from the quadratic term of the objective

    getqobjij(task::MSKtask,i::Int32,j::Int32) :: qoij
    getqobjij(task::MSKtask,i::T0,j::T1) where {T0<:Integer,T1<:Integer}  :: qoij

Arguments:
    i::Int32 Row index of the coefficient.
    j::Int32 Column index of coefficient.
    task::MSKtask An optimization task.

Returns:
    qoij::Float64 The required coefficient.
"""
function getqobjij end

"""
Obtains the reduced costs for a sequence of variables.

    getreducedcosts(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: redcosts
    getreducedcosts(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: redcosts

Arguments:
    first::Int32 The index of the first variable in the sequence.
    last::Int32 The index of the last variable in the sequence plus 1.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    redcosts::Vector{Float64} Returns the requested reduced costs.
"""
function getreducedcosts end

"""
Obtains the status keys for the constraints.

    getskc(task::MSKtask,whichsol::Soltype) :: skc

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    skc::Vector{Stakey} Status keys for the constraints.
"""
function getskc end

"""
Obtains the status keys for a slice of the constraints.

    getskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: skc
    getskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: skc

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    skc::Vector{Stakey} Status keys for the constraints.
"""
function getskcslice end

"""
Obtains the status keys for the conic constraints.

    getskn(task::MSKtask,whichsol::Soltype) :: skn

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    skn::Vector{Stakey} Status keys for the conic constraints.
"""
function getskn end

"""
Obtains the status keys for the scalar variables.

    getskx(task::MSKtask,whichsol::Soltype) :: skx

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    skx::Vector{Stakey} Status keys for the variables.
"""
function getskx end

"""
Obtains the status keys for a slice of the scalar variables.

    getskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: skx
    getskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: skx

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    skx::Vector{Stakey} Status keys for the variables.
"""
function getskxslice end

"""
Obtains the slc vector for a solution.

    getslc(task::MSKtask,whichsol::Soltype) :: slc

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
"""
function getslc end

"""
Obtains a slice of the slc vector for a solution.

    getslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: slc
    getslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: slc

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
"""
function getslcslice end

"""
Obtains the slx vector for a solution.

    getslx(task::MSKtask,whichsol::Soltype) :: slx

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
"""
function getslx end

"""
Obtains a slice of the slx vector for a solution.

    getslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: slx
    getslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: slx

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
"""
function getslxslice end

"""
Obtains the snx vector for a solution.

    getsnx(task::MSKtask,whichsol::Soltype) :: snx

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
"""
function getsnx end

"""
Obtains a slice of the snx vector for a solution.

    getsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: snx
    getsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: snx

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
"""
function getsnxslice end

"""
Obtains the solution status.

    getsolsta(task::MSKtask,whichsol::Soltype) :: solutionsta

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    solutionsta::Solsta Solution status.
"""
function getsolsta end

"""
Obtains the complete solution.

    getsolution(task::MSKtask,whichsol::Soltype) :: (problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    problemsta::Prosta Problem status.
    skc::Vector{Stakey} Status keys for the constraints.
    skn::Vector{Stakey} Status keys for the conic constraints.
    skx::Vector{Stakey} Status keys for the variables.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
    solutionsta::Solsta Solution status.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    xc::Vector{Float64} Primal constraint solution.
    xx::Vector{Float64} Primal variable solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function getsolution end

"""
Obtains information about of a solution.

    getsolutioninfo(task::MSKtask,whichsol::Soltype) :: (pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    dobj::Float64 Dual objective value.
    dviolbarvar::Float64 Maximal dual bound violation for a bars variable.
    dviolcon::Float64 Maximal dual bound violation for a xc variable.
    dviolcone::Float64 Maximum violation of the dual solution in the dual conic constraints.
    dviolvar::Float64 Maximal dual bound violation for a xx variable.
    pobj::Float64 The primal objective value.
    pviolbarvar::Float64 Maximal primal bound violation for a barx variable.
    pviolcon::Float64 Maximal primal bound violation for a xc variable.
    pviolcone::Float64 Maximal primal violation of the solution with respect to the conic constraints.
    pviolitg::Float64 Maximal violation in the integer constraints.
    pviolvar::Float64 Maximal primal bound violation for a xx variable.
"""
function getsolutioninfo end

"""
Obtains information about of a solution.

    getsolutioninfonew(task::MSKtask,whichsol::Soltype) :: (pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolacc,pvioldjc,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone,dviolacc)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    dobj::Float64 Dual objective value.
    dviolacc::Float64 Maximum violation of the dual solution in the dual affine conic constraints.
    dviolbarvar::Float64 Maximal dual bound violation for a bars variable.
    dviolcon::Float64 Maximal dual bound violation for a xc variable.
    dviolcone::Float64 Maximum violation of the dual solution in the dual conic constraints.
    dviolvar::Float64 Maximal dual bound violation for a xx variable.
    pobj::Float64 The primal objective value.
    pviolacc::Float64 Maximal primal violation of the solution with respect to the affine conic constraints.
    pviolbarvar::Float64 Maximal primal bound violation for a barx variable.
    pviolcon::Float64 Maximal primal bound violation for a xc variable.
    pviolcone::Float64 Maximal primal violation of the solution with respect to the conic constraints.
    pvioldjc::Float64 Maximal primal violation of the solution with respect to the disjunctive constraints.
    pviolitg::Float64 Maximal violation in the integer constraints.
    pviolvar::Float64 Maximal primal bound violation for a xx variable.
"""
function getsolutioninfonew end

"""
Obtains the complete solution.

    getsolutionnew(task::MSKtask,whichsol::Soltype) :: (problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    doty::Vector{Float64} Dual variables corresponding to affine conic constraints.
    problemsta::Prosta Problem status.
    skc::Vector{Stakey} Status keys for the constraints.
    skn::Vector{Stakey} Status keys for the conic constraints.
    skx::Vector{Stakey} Status keys for the variables.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
    solutionsta::Solsta Solution status.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    xc::Vector{Float64} Primal constraint solution.
    xx::Vector{Float64} Primal variable solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function getsolutionnew end

"""
Obtains a slice of the solution.

    getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::Int32,last::Int32) :: values
    getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: values

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    solitem::Solitem Which part of the solution is required.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    values::Vector{Float64} The values of the requested solution elements.
"""
function getsolutionslice end

"""
Gets a single symmetric matrix from the matrix store.

    getsparsesymmat(task::MSKtask,idx::Int64) :: (subi,subj,valij)
    getsparsesymmat(task::MSKtask,idx::T0) where {T0<:Integer}  :: (subi,subj,valij)

Arguments:
    idx::Int64 Index of the matrix to retrieve.
    task::MSKtask An optimization task.

Returns:
    subi::Vector{Int32} Row subscripts of the matrix non-zero elements.
    subj::Vector{Int32} Column subscripts of the matrix non-zero elements.
    valij::Vector{Float64} Coefficients of the matrix non-zero elements.
"""
function getsparsesymmat end

"""
Obtains the value of a string parameter.

    getstrparam(task::MSKtask,param::Sparam) :: (len,parvalue)

Arguments:
    param::Sparam Which parameter.
    task::MSKtask An optimization task.

Returns:
    len::Int32 The length of the parameter value.
    parvalue::String If this is not a null pointer, the parameter value is stored here.
"""
function getstrparam end

"""
Obtains the length of a string parameter.

    getstrparamlen(task::MSKtask,param::Sparam) :: len

Arguments:
    param::Sparam Which parameter.
    task::MSKtask An optimization task.

Returns:
    len::Int32 The length of the parameter value.
"""
function getstrparamlen end

"""
Obtains the suc vector for a solution.

    getsuc(task::MSKtask,whichsol::Soltype) :: suc

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
"""
function getsuc end

"""
Obtains a slice of the suc vector for a solution.

    getsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: suc
    getsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: suc

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
"""
function getsucslice end

"""
Obtains the sux vector for a solution.

    getsux(task::MSKtask,whichsol::Soltype) :: sux

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
"""
function getsux end

"""
Obtains a slice of the sux vector for a solution.

    getsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: sux
    getsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: sux

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
"""
function getsuxslice end

"""
Obtains information about a matrix from the symmetric matrix storage.

    getsymmatinfo(task::MSKtask,idx::Int64) :: (dim,nz,mattype)
    getsymmatinfo(task::MSKtask,idx::T0) where {T0<:Integer}  :: (dim,nz,mattype)

Arguments:
    idx::Int64 Index of the matrix for which information is requested.
    task::MSKtask An optimization task.

Returns:
    dim::Int32 Returns the dimension of the requested matrix.
    mattype::Symmattype Returns the type of the requested matrix.
    nz::Int64 Returns the number of non-zeros in the requested matrix.
"""
function getsymmatinfo end

"""
Obtains the task name.

    gettaskname(task::MSKtask) :: taskname

Arguments:
    task::MSKtask An optimization task.

Returns:
    taskname::String Returns the task name.
"""
function gettaskname end

"""
Obtains the length the task name.

    gettasknamelen(task::MSKtask) :: len

Arguments:
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the task name.
"""
function gettasknamelen end

"""
Obtains bound information for one variable.

    getvarbound(task::MSKtask,i::Int32) :: (bk,bl,bu)
    getvarbound(task::MSKtask,i::T0) where {T0<:Integer}  :: (bk,bl,bu)

Arguments:
    i::Int32 Index of the variable for which the bound information should be obtained.
    task::MSKtask An optimization task.

Returns:
    bk::Boundkey Bound keys.
    bl::Float64 Values for lower bounds.
    bu::Float64 Values for upper bounds.
"""
function getvarbound end

"""
Obtains bounds information for a slice of the variables.

    getvarboundslice(task::MSKtask,first::Int32,last::Int32) :: (bk,bl,bu)
    getvarboundslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (bk,bl,bu)

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.

Returns:
    bk::Vector{Boundkey} Bound keys.
    bl::Vector{Float64} Values for lower bounds.
    bu::Vector{Float64} Values for upper bounds.
"""
function getvarboundslice end

"""
Obtains the name of a variable.

    getvarname(task::MSKtask,j::Int32) :: name
    getvarname(task::MSKtask,j::T0) where {T0<:Integer}  :: name

Arguments:
    j::Int32 Index of a variable.
    task::MSKtask An optimization task.

Returns:
    name::String Returns the required name.
"""
function getvarname end

"""
Checks whether the name has been assigned to any variable.

    getvarnameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

Arguments:
    somename::AbstractString The name which should be checked.
    task::MSKtask An optimization task.

Returns:
    asgn::Int32 Is non-zero if the name somename is assigned to a variable.
    index::Int32 If the name somename is assigned to a variable, then return the index of the variable.
"""
function getvarnameindex end

"""
Obtains the length of the name of a variable.

    getvarnamelen(task::MSKtask,i::Int32) :: len
    getvarnamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

Arguments:
    i::Int32 Index of a variable.
    task::MSKtask An optimization task.

Returns:
    len::Int32 Returns the length of the indicated name.
"""
function getvarnamelen end

"""
Gets the variable type of one variable.

    getvartype(task::MSKtask,j::Int32) :: vartype
    getvartype(task::MSKtask,j::T0) where {T0<:Integer}  :: vartype

Arguments:
    j::Int32 Index of the variable.
    task::MSKtask An optimization task.

Returns:
    vartype::Variabletype Variable type of variable index j.
"""
function getvartype end

"""
Obtains the variable type for one or more variables.

    getvartypelist(task::MSKtask,subj::Vector{Int32}) :: vartype
    getvartypelist(task::MSKtask,subj::T0) where {T0<:AbstractVector{<:Integer}}  :: vartype

Arguments:
    subj::Vector{Int32} A list of variable indexes.
    task::MSKtask An optimization task.

Returns:
    vartype::Vector{Variabletype} Returns the variables types corresponding the variable indexes requested.
"""
function getvartypelist end

"""
Obtains MOSEK version information.

    getversion() :: (major,minor,revision)

Returns:
    major::Int32 Major version number.
    minor::Int32 Minor version number.
    revision::Int32 Revision number.
"""
function getversion end

"""
Obtains the xc vector for a solution.

    getxc(task::MSKtask,whichsol::Soltype) :: xc

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    xc::Vector{Float64} Primal constraint solution.
"""
function getxc end

"""
Obtains a slice of the xc vector for a solution.

    getxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: xc
    getxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: xc

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    xc::Vector{Float64} Primal constraint solution.
"""
function getxcslice end

"""
Obtains the xx vector for a solution.

    getxx(task::MSKtask,whichsol::Soltype) :: xx

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    xx::Vector{Float64} Primal variable solution.
"""
function getxx end

"""
Obtains a slice of the xx vector for a solution.

    getxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: xx
    getxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: xx

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    xx::Vector{Float64} Primal variable solution.
"""
function getxxslice end

"""
Obtains the y vector for a solution.

    gety(task::MSKtask,whichsol::Soltype) :: y

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function gety end

"""
Obtains a slice of the y vector for a solution.

    getyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: y
    getyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: y

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function getyslice end

"""
Obtains a information item string identifier.

    iinfitemtostr(item::Iinfitem) :: str

Arguments:
    item::Iinfitem Information item.

Returns:
    str::String String corresponding to the information item.
"""
function iinfitemtostr end

"""
Prints the infeasibility report to an output stream.

    infeasibilityreport(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    whichstream::Streamtype Index of the stream.
"""
function infeasibilityreport end

"""
Prepare a task for basis solver.

    initbasissolve(task::MSKtask) :: basis

Arguments:
    task::MSKtask An optimization task.

Returns:
    basis::Vector{Int32} The array of basis indexes to use.
"""
function initbasissolve end

"""
Input the linear part of an optimization task in one function call.

    inputdata(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,c::Union{Nothing,Vector{Float64}},cfix::Float64,aptrb::Vector{Int64},aptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
    inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,aptrb::T4,aptre::T5,asub::T6,aval::T7,bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:Number,T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number},T9<:AbstractVector{<:Number},T10<:AbstractVector{<:Number},T11<:AbstractVector{<:Number}} 
    inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,A:: SparseMatrixCSC{Float64},bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11)

Arguments:
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
    aptrb::Vector{Int64} Row or column start pointers.
    aptre::Vector{Int64} Row or column end pointers.
    asub::Vector{Int32} Coefficient subscripts.
    aval::Vector{Float64} Coefficient values.
    bkc::Vector{Boundkey} Bound keys for the constraints.
    bkx::Vector{Boundkey} Bound keys for the variables.
    blc::Vector{Float64} Lower bounds for the constraints.
    blx::Vector{Float64} Lower bounds for the variables.
    buc::Vector{Float64} Upper bounds for the constraints.
    bux::Vector{Float64} Upper bounds for the variables.
    c::Union{Nothing,Vector{Float64}} Linear terms of the objective as a dense vector. The length is the number of variables.
    cfix::Float64 Fixed term in the objective.
    maxnumcon::Int32 Number of preallocated constraints in the optimization task.
    maxnumvar::Int32 Number of preallocated variables in the optimization task.
    task::MSKtask An optimization task.
"""
function inputdata end

"""
Checks a double parameter name.

    isdouparname(task::MSKtask,parname::AbstractString) :: param

Arguments:
    parname::AbstractString Parameter name.
    task::MSKtask An optimization task.

Returns:
    param::Dparam Returns the parameter corresponding to the name, if one exists.
"""
function isdouparname end

"""
Checks an integer parameter name.

    isintparname(task::MSKtask,parname::AbstractString) :: param

Arguments:
    parname::AbstractString Parameter name.
    task::MSKtask An optimization task.

Returns:
    param::Iparam Returns the parameter corresponding to the name, if one exists.
"""
function isintparname end

"""
Checks a string parameter name.

    isstrparname(task::MSKtask,parname::AbstractString) :: param

Arguments:
    parname::AbstractString Parameter name.
    task::MSKtask An optimization task.

Returns:
    param::Sparam Returns the parameter corresponding to the name, if one exists.
"""
function isstrparname end

"""
Stops all threads and delete all handles used by the license system.

    licensecleanup()
"""
function licensecleanup end

"""
Obtains a information item string identifier.

    liinfitemtostr(item::Liinfitem) :: str

Arguments:
    item::Liinfitem Information item.

Returns:
    str::String String corresponding to the information item.
"""
function liinfitemtostr end

"""
Directs all output from a stream to a file.

    linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::AbstractString,append::Int32)
    linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::Union{Nothing,AbstractString},append::T0) where {T0<:Integer} 
    linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::AbstractString,append::Int32)
    linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::Union{Nothing,AbstractString},append::T0) where {T0<:Integer} 
    linkfiletostream(whichstream::Streamtype,filename::AbstractString,append::Int32)
    linkfiletostream(whichstream::Streamtype,filename::Union{Nothing,AbstractString},append::T0) where {T0<:Integer} 

Arguments:
    append::Int32 If this argument is 0 the file will be overwritten, otherwise it will be appended to.
    env::MSKenv The MOSEK environment.
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function linkfiletostream end

"""
Prints a short summary of a specified solution.

    onesolutionsummary(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    whichstream::Streamtype Index of the stream.
"""
function onesolutionsummary end

"""
Optimizes the problem.

    optimize(task::MSKtask) :: trmcode

Arguments:
    task::MSKtask An optimization task.

Returns:
    trmcode::Rescode Is either OK or a termination response code.
"""
function optimize end

"""
Optimize a number of tasks in parallel using a specified number of threads.

    optimizebatch(env::MSKenv,israce::Bool,maxtime::Float64,numthreads::Int32,task::Vector{MSKtask}) :: (trmcode,rcode)
    optimizebatch(env::MSKenv,israce::Bool,maxtime::T0,numthreads::T1,task::Vector{MSKtask}) where {T0<:Number,T1<:Integer}  :: (trmcode,rcode)
    optimizebatch(israce::Bool,maxtime::Float64,numthreads::Int32,task::Vector{MSKtask}) :: (trmcode,rcode)
    optimizebatch(israce::Bool,maxtime::T0,numthreads::T1,task::Vector{MSKtask}) where {T0<:Number,T1<:Integer}  :: (trmcode,rcode)

Arguments:
    env::MSKenv The MOSEK environment.
    israce::Bool If nonzero, then the function is terminated after the first task has been completed.
    maxtime::Float64 Time limit for the function.
    numthreads::Int32 Number of threads to be employed.
    task::Vector{MSKtask} An array of tasks to optimize in parallel.

Returns:
    rcode::Vector{Rescode} The response code for each task.
    trmcode::Vector{Rescode} The termination code for each task.
"""
function optimizebatch end

"""
Offload the optimization task to a solver server and wait for the solution.

    optimizermt(task::MSKtask,address::AbstractString,accesstoken::AbstractString) :: trmcode

Arguments:
    accesstoken::AbstractString Access token.
    address::AbstractString Address of the OptServer.
    task::MSKtask An optimization task.

Returns:
    trmcode::Rescode Is either OK or a termination response code.
"""
function optimizermt end

"""
Prints a short summary with optimizer statistics from last optimization.

    optimizersummary(task::MSKtask,whichstream::Streamtype)

Arguments:
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function optimizersummary end

"""
Repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables.

    primalrepair(task::MSKtask,wlc::Union{Nothing,Vector{Float64}},wuc::Union{Nothing,Vector{Float64}},wlx::Union{Nothing,Vector{Float64}},wux::Union{Nothing,Vector{Float64}})
    primalrepair(task::MSKtask,wlc::T0,wuc::T1,wlx::T2,wux::T3) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number}} 

Arguments:
    task::MSKtask An optimization task.
    wlc::Union{Nothing,Vector{Float64}} Weights associated with relaxing lower bounds on the constraints.
    wlx::Union{Nothing,Vector{Float64}} Weights associated with relaxing the lower bounds of the variables.
    wuc::Union{Nothing,Vector{Float64}} Weights associated with relaxing the upper bound on the constraints.
    wux::Union{Nothing,Vector{Float64}} Weights associated with relaxing the upper bounds of variables.
"""
function primalrepair end

"""
Perform sensitivity analysis on bounds.

    primalsensitivity(task::MSKtask,subi::Vector{Int32},marki::Vector{Mark},subj::Vector{Int32},markj::Vector{Mark}) :: (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej)
    primalsensitivity(task::MSKtask,subi::T0,marki::Vector{Mark},subj::T1,markj::Vector{Mark}) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer}}  :: (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej)

Arguments:
    marki::Vector{Mark} Mark which constraint bounds to analyze.
    markj::Vector{Mark} Mark which variable bounds to analyze.
    subi::Vector{Int32} Indexes of constraints to analyze.
    subj::Vector{Int32} Indexes of variables to analyze.
    task::MSKtask An optimization task.

Returns:
    leftpricei::Vector{Float64} Left shadow price for constraints.
    leftpricej::Vector{Float64} Left shadow price for variables.
    leftrangei::Vector{Float64} Left range for constraints.
    leftrangej::Vector{Float64} Left range for variables.
    rightpricei::Vector{Float64} Right shadow price for constraints.
    rightpricej::Vector{Float64} Right shadow price for variables.
    rightrangei::Vector{Float64} Right range for constraints.
    rightrangej::Vector{Float64} Right range for variables.
"""
function primalsensitivity end

"""
Prints the current parameter settings.

    printparam(task::MSKtask)

Arguments:
    task::MSKtask An optimization task.
"""
function printparam end

"""
Obtains a string containing the name of a given problem type.

    probtypetostr(task::MSKtask,probtype::Problemtype) :: str

Arguments:
    probtype::Problemtype Problem type.
    task::MSKtask An optimization task.

Returns:
    str::String String corresponding to the problem type key.
"""
function probtypetostr end

"""
Obtains a string containing the name of a given problem status.

    prostatostr(task::MSKtask,problemsta::Prosta) :: str

Arguments:
    problemsta::Prosta Problem status.
    task::MSKtask An optimization task.

Returns:
    str::String String corresponding to the status key.
"""
function prostatostr end

"""
Puts an affine conic constraint.

    putacc(task::MSKtask,accidx::Int64,domidx::Int64,afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
    putacc(task::MSKtask,accidx::T0,domidx::T1,afeidxlist::T2,b::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

Arguments:
    accidx::Int64 Affine conic constraint index.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    domidx::Int64 Domain index.
    task::MSKtask An optimization task.
"""
function putacc end

"""
Puts the constant vector b in an affine conic constraint.

    putaccb(task::MSKtask,accidx::Int64,b::Union{Nothing,Vector{Float64}})
    putaccb(task::MSKtask,accidx::T0,b::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}} 

Arguments:
    accidx::Int64 Affine conic constraint index.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    task::MSKtask An optimization task.
"""
function putaccb end

"""
Sets one element in the b vector of an affine conic constraint.

    putaccbj(task::MSKtask,accidx::Int64,j::Int64,bj::Float64)
    putaccbj(task::MSKtask,accidx::T0,j::T1,bj::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

Arguments:
    accidx::Int64 Affine conic constraint index.
    bj::Float64 The new value of b[j].
    j::Int64 The index of an element in b to change.
    task::MSKtask An optimization task.
"""
function putaccbj end

"""
Puts the doty vector for a solution.

    putaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64) :: doty
    putaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where {T0<:Integer}  :: doty

Arguments:
    accidx::Int64 The index of the affine conic constraint.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    doty::Vector{Float64} The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.
"""
function putaccdoty end

"""
Puts a number of affine conic constraints.

    putacclist(task::MSKtask,accidxs::Vector{Int64},domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
    putacclist(task::MSKtask,accidxs::T0,domidxs::T1,afeidxlist::T2,b::T3) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

Arguments:
    accidxs::Vector{Int64} Affine conic constraint indices.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    domidxs::Vector{Int64} Domain indices.
    task::MSKtask An optimization task.
"""
function putacclist end

"""
Sets the name of an affine conic constraint.

    putaccname(task::MSKtask,accidx::Int64,name::Union{Nothing,AbstractString})
    putaccname(task::MSKtask,accidx::T0,name::Union{Nothing,AbstractString}) where {T0<:Integer} 

Arguments:
    accidx::Int64 Index of the affine conic constraint.
    name::Union{Nothing,AbstractString} The name of the affine conic constraint.
    task::MSKtask An optimization task.
"""
function putaccname end

"""
Replaces all elements in one column of the linear constraint matrix.

    putacol(task::MSKtask,j::Int32,subj::Vector{Int32},valj::Vector{Float64})
    putacol(task::MSKtask,j::T0,subj::T1,valj::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    j::Int32 Column index.
    subj::Vector{Int32} Row indexes of non-zero values in column.
    task::MSKtask An optimization task.
    valj::Vector{Float64} New non-zero values of column.
"""
function putacol end

"""
Replaces all elements in several columns the linear constraint matrix.

    putacollist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
    putacollist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 
    putacollist(task::MSKtask,sub::T0,A:: SparseMatrixCSC{Float64})

Arguments:
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
    asub::Vector{Int32} Row indexes
    aval::Vector{Float64} Coefficient values.
    ptrb::Vector{Int64} Array of pointers to the first element in the columns.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the columns.
    sub::Vector{Int32} Indexes of columns that should be replaced.
    task::MSKtask An optimization task.
"""
function putacollist end

"""
Replaces all elements in a sequence of columns the linear constraint matrix.

    putacolslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
    putacolslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 
    putacolslice(task::MSKtask,first::T0,last::T1,A:: SparseMatrixCSC{Float64})

Arguments:
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
    asub::Vector{Int32} Row indexes
    aval::Vector{Float64} Coefficient values.
    first::Int32 First column in the slice.
    last::Int32 Last column plus one in the slice.
    ptrb::Vector{Int64} Array of pointers to the first element in the columns.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the columns.
    task::MSKtask An optimization task.
"""
function putacolslice end

"""
Inputs barF in block triplet form.

    putafebarfblocktriplet(task::MSKtask,afeidx::Vector{Int64},barvaridx::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valkl::Vector{Float64})
    putafebarfblocktriplet(task::MSKtask,afeidx::T0,barvaridx::T1,subk::T2,subl::T3,valkl::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Vector{Int64} Constraint index.
    barvaridx::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    task::MSKtask An optimization task.
    valkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function putafebarfblocktriplet end

"""
Inputs one entry in barF.

    putafebarfentry(task::MSKtask,afeidx::Int64,barvaridx::Int32,termidx::Vector{Int64},termweight::Vector{Float64})
    putafebarfentry(task::MSKtask,afeidx::T0,barvaridx::T1,termidx::T2,termweight::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Int64 Row index of barF.
    barvaridx::Int32 Semidefinite variable index.
    task::MSKtask An optimization task.
    termidx::Vector{Int64} Element indices in matrix storage.
    termweight::Vector{Float64} Weights in the weighted sum.
"""
function putafebarfentry end

"""
Inputs a list of entries in barF.

    putafebarfentrylist(task::MSKtask,afeidx::Vector{Int64},barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
    putafebarfentrylist(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Vector{Int64} Row indexes of barF.
    barvaridx::Vector{Int32} Semidefinite variable indexes.
    numterm::Vector{Int64} Number of terms in the weighted sums.
    ptrterm::Vector{Int64} Pointer to the terms forming each entry.
    task::MSKtask An optimization task.
    termidx::Vector{Int64} Concatenated element indexes in matrix storage.
    termweight::Vector{Float64} Concatenated weights in the weighted sum.
"""
function putafebarfentrylist end

"""
Inputs a row of barF.

    putafebarfrow(task::MSKtask,afeidx::Int64,barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
    putafebarfrow(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Int64 Row index of barF.
    barvaridx::Vector{Int32} Semidefinite variable indexes.
    numterm::Vector{Int64} Number of terms in the weighted sums.
    ptrterm::Vector{Int64} Pointer to the terms forming each entry.
    task::MSKtask An optimization task.
    termidx::Vector{Int64} Concatenated element indexes in matrix storage.
    termweight::Vector{Float64} Concatenated weights in the weighted sum.
"""
function putafebarfrow end

"""
Replaces all elements in one column of the F matrix in the affine expressions.

    putafefcol(task::MSKtask,varidx::Int32,afeidx::Vector{Int64},val::Vector{Float64})
    putafefcol(task::MSKtask,varidx::T0,afeidx::T1,val::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Vector{Int64} Row indexes of non-zero values in the column.
    task::MSKtask An optimization task.
    val::Vector{Float64} New non-zero values in the column.
    varidx::Int32 Column index.
"""
function putafefcol end

"""
Replaces one entry in F.

    putafefentry(task::MSKtask,afeidx::Int64,varidx::Int32,value::Float64)
    putafefentry(task::MSKtask,afeidx::T0,varidx::T1,value::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

Arguments:
    afeidx::Int64 Row index in F.
    task::MSKtask An optimization task.
    value::Float64 Value of the entry.
    varidx::Int32 Column index in F.
"""
function putafefentry end

"""
Replaces a list of entries in F.

    putafefentrylist(task::MSKtask,afeidx::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
    putafefentrylist(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Vector{Int64} Row indices in F.
    task::MSKtask An optimization task.
    val::Vector{Float64} Values of the entries in F.
    varidx::Vector{Int32} Column indices in F.
"""
function putafefentrylist end

"""
Replaces all elements in one row of the F matrix in the affine expressions.

    putafefrow(task::MSKtask,afeidx::Int64,varidx::Vector{Int32},val::Vector{Float64})
    putafefrow(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Int64 Row index.
    task::MSKtask An optimization task.
    val::Vector{Float64} New non-zero values in the row.
    varidx::Vector{Int32} Column indexes of non-zero values in the row.
"""
function putafefrow end

"""
Replaces all elements in a number of rows of the F matrix in the affine expressions.

    putafefrowlist(task::MSKtask,afeidx::Vector{Int64},numnzrow::Vector{Int32},ptrrow::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
    putafefrowlist(task::MSKtask,afeidx::T0,numnzrow::T1,ptrrow::T2,varidx::T3,val::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Vector{Int64} Row indices.
    numnzrow::Vector{Int32} Number of non-zeros in each row.
    ptrrow::Vector{Int64} Pointer to the first nonzero in each row.
    task::MSKtask An optimization task.
    val::Vector{Float64} New non-zero values in the rows.
    varidx::Vector{Int32} Column indexes of non-zero values.
"""
function putafefrowlist end

"""
Replaces one element in the g vector in the affine expressions.

    putafeg(task::MSKtask,afeidx::Int64,g::Float64)
    putafeg(task::MSKtask,afeidx::T0,g::T1) where {T0<:Integer,T1<:Number} 

Arguments:
    afeidx::Int64 Row index.
    g::Float64 New value for the element of g.
    task::MSKtask An optimization task.
"""
function putafeg end

"""
Replaces a list of elements in the g vector in the affine expressions.

    putafeglist(task::MSKtask,afeidx::Vector{Int64},g::Vector{Float64})
    putafeglist(task::MSKtask,afeidx::T0,g::T1) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number}} 

Arguments:
    afeidx::Vector{Int64} Indices of entries in g.
    g::Vector{Float64} New values for the elements of g.
    task::MSKtask An optimization task.
"""
function putafeglist end

"""
Modifies a slice of the vector g.

    putafegslice(task::MSKtask,first::Int64,last::Int64,slice::Vector{Float64})
    putafegslice(task::MSKtask,first::T0,last::T1,slice::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int64 First index in the sequence.
    last::Int64 Last index plus 1 in the sequence.
    slice::Vector{Float64} The slice of g as a dense vector.
    task::MSKtask An optimization task.
"""
function putafegslice end

"""
Changes a single value in the linear coefficient matrix.

    putaij(task::MSKtask,i::Int32,j::Int32,aij::Float64)
    putaij(task::MSKtask,i::T0,j::T1,aij::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

Arguments:
    aij::Float64 New coefficient.
    i::Int32 Constraint (row) index.
    j::Int32 Variable (column) index.
    task::MSKtask An optimization task.
"""
function putaij end

"""
Changes one or more coefficients in the linear constraint matrix.

    putaijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
    putaijlist(task::MSKtask,subi::T0,subj::T1,valij::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    subi::Vector{Int32} Constraint (row) indices.
    subj::Vector{Int32} Variable (column) indices.
    task::MSKtask An optimization task.
    valij::Vector{Float64} New coefficient values.
"""
function putaijlist end

"""
Replaces all elements in one row of the linear constraint matrix.

    putarow(task::MSKtask,i::Int32,subi::Vector{Int32},vali::Vector{Float64})
    putarow(task::MSKtask,i::T0,subi::T1,vali::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    i::Int32 Row index.
    subi::Vector{Int32} Column indexes of non-zero values in row.
    task::MSKtask An optimization task.
    vali::Vector{Float64} New non-zero values of row.
"""
function putarow end

"""
Replaces all elements in several rows of the linear constraint matrix.

    putarowlist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
    putarowlist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 
    putarowlist(task::MSKtask,sub::T0,At:: SparseMatrixCSC{Float64})

Arguments:
    At::SparseMatrixCSC{{Float64} Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced
    asub::Vector{Int32} Variable indexes.
    aval::Vector{Float64} Coefficient values.
    ptrb::Vector{Int64} Array of pointers to the first element in the rows.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the rows.
    sub::Vector{Int32} Indexes of rows or columns that should be replaced.
    task::MSKtask An optimization task.
"""
function putarowlist end

"""
Replaces all elements in several rows the linear constraint matrix.

    putarowslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
    putarowslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 
    putarowslice(task::MSKtask,first::T0,last::T1,At:: SparseMatrixCSC{Float64})

Arguments:
    At::SparseMatrixCSC{{Float64} Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced
    asub::Vector{Int32} Column indexes of new elements.
    aval::Vector{Float64} Coefficient values.
    first::Int32 First row in the slice.
    last::Int32 Last row plus one in the slice.
    ptrb::Vector{Int64} Array of pointers to the first element in the rows.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the rows.
    task::MSKtask An optimization task.
"""
function putarowslice end

"""
Truncates all elements in A below a certain tolerance to zero.

    putatruncatetol(task::MSKtask,tolzero::Float64)
    putatruncatetol(task::MSKtask,tolzero::T0) where {T0<:Number} 

Arguments:
    task::MSKtask An optimization task.
    tolzero::Float64 Truncation tolerance.
"""
function putatruncatetol end

"""
Inputs barA in block triplet form.

    putbarablocktriplet(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valijkl::Vector{Float64})
    putbarablocktriplet(task::MSKtask,subi::T0,subj::T1,subk::T2,subl::T3,valijkl::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 

Arguments:
    subi::Vector{Int32} Constraint index.
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    task::MSKtask An optimization task.
    valijkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function putbarablocktriplet end

"""
Inputs an element of barA.

    putbaraij(task::MSKtask,i::Int32,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
    putbaraij(task::MSKtask,i::T0,j::T1,sub::T2,weights::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

Arguments:
    i::Int32 Row index of barA.
    j::Int32 Column index of barA.
    sub::Vector{Int64} Element indexes in matrix storage.
    task::MSKtask An optimization task.
    weights::Vector{Float64} Weights in the weighted sum.
"""
function putbaraij end

"""
Inputs list of elements of barA.

    putbaraijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},alphaptrb::Vector{Int64},alphaptre::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
    putbaraijlist(task::MSKtask,subi::T0,subj::T1,alphaptrb::T2,alphaptre::T3,matidx::T4,weights::T5) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 
    putbaraijlist(task::MSKtask,subi::T0,subj::T1,A:: SparseMatrixCSC{Float64})

Arguments:
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
    alphaptrb::Vector{Int64} Start entries for terms in the weighted sum.
    alphaptre::Vector{Int64} End entries for terms in the weighted sum.
    matidx::Vector{Int64} Element indexes in matrix storage.
    subi::Vector{Int32} Row index of barA.
    subj::Vector{Int32} Column index of barA.
    task::MSKtask An optimization task.
    weights::Vector{Float64} Weights in the weighted sum.
"""
function putbaraijlist end

"""
Replace a set of rows of barA

    putbararowlist(task::MSKtask,subi::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},subj::Vector{Int32},nummat::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
    putbararowlist(task::MSKtask,subi::T0,ptrb::T1,ptre::T2,subj::T3,nummat::T4,matidx::T5,weights::T6) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number}} 
    putbararowlist(task::MSKtask,subi::T0,A:: SparseMatrixCSC{Float64},matidx::T5,weights::T6)

Arguments:
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
    matidx::Vector{Int64} Matrix indexes for weighted sum of matrixes.
    nummat::Vector{Int64} Number of entries in weighted sum of matrixes.
    ptrb::Vector{Int64} Start of rows in barA.
    ptre::Vector{Int64} End of rows in barA.
    subi::Vector{Int32} Row indexes of barA.
    subj::Vector{Int32} Column index of barA.
    task::MSKtask An optimization task.
    weights::Vector{Float64} Weights for weighted sum of matrixes.
"""
function putbararowlist end

"""
Inputs barC in block triplet form.

    putbarcblocktriplet(task::MSKtask,subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valjkl::Vector{Float64})
    putbarcblocktriplet(task::MSKtask,subj::T0,subk::T1,subl::T2,valjkl::T3) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

Arguments:
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    task::MSKtask An optimization task.
    valjkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function putbarcblocktriplet end

"""
Changes one element in barc.

    putbarcj(task::MSKtask,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
    putbarcj(task::MSKtask,j::T0,sub::T1,weights::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

Arguments:
    j::Int32 Index of the element in barc` that should be changed.
    sub::Vector{Int64} sub is list of indexes of those symmetric matrices appearing in sum.
    task::MSKtask An optimization task.
    weights::Vector{Float64} The weights of the terms in the weighted sum.
"""
function putbarcj end

"""
Sets the dual solution for a semidefinite variable.

    putbarsj(task::MSKtask,whichsol::Soltype,j::Int32,barsj::Vector{Float64})
    putbarsj(task::MSKtask,whichsol::Soltype,j::T0,barsj::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}} 

Arguments:
    barsj::Vector{Float64} Value of the j'th variable of barx.
    j::Int32 Index of the semidefinite variable.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putbarsj end

"""
Sets the name of a semidefinite variable.

    putbarvarname(task::MSKtask,j::Int32,name::Union{Nothing,AbstractString})
    putbarvarname(task::MSKtask,j::T0,name::Union{Nothing,AbstractString}) where {T0<:Integer} 

Arguments:
    j::Int32 Index of the variable.
    name::Union{Nothing,AbstractString} The variable name.
    task::MSKtask An optimization task.
"""
function putbarvarname end

"""
Sets the primal solution for a semidefinite variable.

    putbarxj(task::MSKtask,whichsol::Soltype,j::Int32,barxj::Vector{Float64})
    putbarxj(task::MSKtask,whichsol::Soltype,j::T0,barxj::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}} 

Arguments:
    barxj::Vector{Float64} Value of the j'th variable of barx.
    j::Int32 Index of the semidefinite variable.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putbarxj end

"""
Replaces the fixed term in the objective.

    putcfix(task::MSKtask,cfix::Float64)
    putcfix(task::MSKtask,cfix::T0) where {T0<:Number} 

Arguments:
    cfix::Float64 Fixed term in the objective.
    task::MSKtask An optimization task.
"""
function putcfix end

"""
Modifies one linear coefficient in the objective.

    putcj(task::MSKtask,j::Int32,cj::Float64)
    putcj(task::MSKtask,j::T0,cj::T1) where {T0<:Integer,T1<:Number} 

Arguments:
    cj::Float64 New coefficient value.
    j::Int32 Index of the variable whose objective coefficient should be changed.
    task::MSKtask An optimization task.
"""
function putcj end

"""
Modifies a part of the linear objective coefficients.

    putclist(task::MSKtask,subj::Vector{Int32},val::Vector{Float64})
    putclist(task::MSKtask,subj::T0,val::T1) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number}} 

Arguments:
    subj::Vector{Int32} Indices of variables for which objective coefficients should be changed.
    task::MSKtask An optimization task.
    val::Vector{Float64} New numerical values for the objective coefficients that should be modified.
"""
function putclist end

"""
Changes the bound for one constraint.

    putconbound(task::MSKtask,i::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
    putconbound(task::MSKtask,i::T0,bkc::Boundkey,blc::T1,buc::T2) where {T0<:Integer,T1<:Number,T2<:Number} 

Arguments:
    bkc::Boundkey New bound key.
    blc::Float64 New lower bound.
    buc::Float64 New upper bound.
    i::Int32 Index of the constraint.
    task::MSKtask An optimization task.
"""
function putconbound end

"""
Changes the bounds of a list of constraints.

    putconboundlist(task::MSKtask,sub::Vector{Int32},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
    putconboundlist(task::MSKtask,sub::T0,bkc::Vector{Boundkey},blc::T1,buc::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number}} 

Arguments:
    bkc::Vector{Boundkey} Bound keys for the constraints.
    blc::Vector{Float64} Lower bounds for the constraints.
    buc::Vector{Float64} Upper bounds for the constraints.
    sub::Vector{Int32} List of constraint indexes.
    task::MSKtask An optimization task.
"""
function putconboundlist end

"""
Changes the bounds of a list of constraints.

    putconboundlistconst(task::MSKtask,sub::Vector{Int32},bkc::Boundkey,blc::Float64,buc::Float64)
    putconboundlistconst(task::MSKtask,sub::T0,bkc::Boundkey,blc::T1,buc::T2) where {T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number} 

Arguments:
    bkc::Boundkey New bound key for all constraints in the list.
    blc::Float64 New lower bound for all constraints in the list.
    buc::Float64 New upper bound for all constraints in the list.
    sub::Vector{Int32} List of constraint indexes.
    task::MSKtask An optimization task.
"""
function putconboundlistconst end

"""
Changes the bounds for a slice of the constraints.

    putconboundslice(task::MSKtask,first::Int32,last::Int32,bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
    putconboundslice(task::MSKtask,first::T0,last::T1,bkc::Vector{Boundkey},blc::T2,buc::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number}} 

Arguments:
    bkc::Vector{Boundkey} Bound keys for the constraints.
    blc::Vector{Float64} Lower bounds for the constraints.
    buc::Vector{Float64} Upper bounds for the constraints.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
"""
function putconboundslice end

"""
Changes the bounds for a slice of the constraints.

    putconboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
    putconboundsliceconst(task::MSKtask,first::T0,last::T1,bkc::Boundkey,blc::T2,buc::T3) where {T0<:Integer,T1<:Integer,T2<:Number,T3<:Number} 

Arguments:
    bkc::Boundkey New bound key for all constraints in the slice.
    blc::Float64 New lower bound for all constraints in the slice.
    buc::Float64 New upper bound for all constraints in the slice.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
"""
function putconboundsliceconst end

"""
Replaces a conic constraint.

    putcone(task::MSKtask,k::Int32,ct::Conetype,conepar::Float64,submem::Vector{Int32})
    putcone(task::MSKtask,k::T0,ct::Conetype,conepar::T1,submem::T2) where {T0<:Integer,T1<:Number,T2<:AbstractVector{<:Integer}} 

Arguments:
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    ct::Conetype Specifies the type of the cone.
    k::Int32 Index of the cone.
    submem::Vector{Int32} Variable subscripts of the members in the cone.
    task::MSKtask An optimization task.
"""
function putcone end

"""
Sets the name of a cone.

    putconename(task::MSKtask,j::Int32,name::Union{Nothing,AbstractString})
    putconename(task::MSKtask,j::T0,name::Union{Nothing,AbstractString}) where {T0<:Integer} 

Arguments:
    j::Int32 Index of the cone.
    name::Union{Nothing,AbstractString} The name of the cone.
    task::MSKtask An optimization task.
"""
function putconename end

"""
Sets the name of a constraint.

    putconname(task::MSKtask,i::Int32,name::Union{Nothing,AbstractString})
    putconname(task::MSKtask,i::T0,name::Union{Nothing,AbstractString}) where {T0<:Integer} 

Arguments:
    i::Int32 Index of the constraint.
    name::Union{Nothing,AbstractString} The name of the constraint.
    task::MSKtask An optimization task.
"""
function putconname end

"""
Sets the primal and dual solution information for a single constraint.

    putconsolutioni(task::MSKtask,i::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64)
    putconsolutioni(task::MSKtask,i::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3) where {T0<:Integer,T1<:Number,T2<:Number,T3<:Number} 

Arguments:
    i::Int32 Index of the constraint.
    sk::Stakey Status key of the constraint.
    sl::Float64 Solution value of the dual variable associated with the lower bound.
    su::Float64 Solution value of the dual variable associated with the upper bound.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    x::Float64 Primal solution value of the constraint.
"""
function putconsolutioni end

"""
Modifies a slice of the linear objective coefficients.

    putcslice(task::MSKtask,first::Int32,last::Int32,slice::Vector{Float64})
    putcslice(task::MSKtask,first::T0,last::T1,slice::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First element in the slice of c.
    last::Int32 Last element plus 1 of the slice in c to be changed.
    slice::Vector{Float64} New numerical values for the objective coefficients that should be modified.
    task::MSKtask An optimization task.
"""
function putcslice end

"""
Inputs a disjunctive constraint.

    putdjc(task::MSKtask,djcidx::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}},termsizelist::Vector{Int64})
    putdjc(task::MSKtask,djcidx::T0,domidxlist::T1,afeidxlist::T2,b::T3,termsizelist::T4) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Integer}} 

Arguments:
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions.
    djcidx::Int64 Index of the disjunctive constraint.
    domidxlist::Vector{Int64} List of domain indexes.
    task::MSKtask An optimization task.
    termsizelist::Vector{Int64} List of term sizes.
"""
function putdjc end

"""
Sets the name of a disjunctive constraint.

    putdjcname(task::MSKtask,djcidx::Int64,name::Union{Nothing,AbstractString})
    putdjcname(task::MSKtask,djcidx::T0,name::Union{Nothing,AbstractString}) where {T0<:Integer} 

Arguments:
    djcidx::Int64 Index of the disjunctive constraint.
    name::Union{Nothing,AbstractString} The name of the disjunctive constraint.
    task::MSKtask An optimization task.
"""
function putdjcname end

"""
Inputs a slice of disjunctive constraints.

    putdjcslice(task::MSKtask,idxfirst::Int64,idxlast::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}},termsizelist::Vector{Int64},termsindjc::Vector{Int64})
    putdjcslice(task::MSKtask,idxfirst::T0,idxlast::T1,domidxlist::T2,afeidxlist::T3,b::T4,termsizelist::T5,termsindjc::T6) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer}} 

Arguments:
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Union{Nothing,Vector{Float64}} The vector of constant terms added to affine expressions. Optional.
    domidxlist::Vector{Int64} List of domain indexes.
    idxfirst::Int64 Index of the first disjunctive constraint in the slice.
    idxlast::Int64 Index of the last disjunctive constraint in the slice plus 1.
    task::MSKtask An optimization task.
    termsindjc::Vector{Int64} Number of terms in each of the disjunctive constraints in the slice.
    termsizelist::Vector{Int64} List of term sizes.
"""
function putdjcslice end

"""
Sets the name of a domain.

    putdomainname(task::MSKtask,domidx::Int64,name::Union{Nothing,AbstractString})
    putdomainname(task::MSKtask,domidx::T0,name::Union{Nothing,AbstractString}) where {T0<:Integer} 

Arguments:
    domidx::Int64 Index of the domain.
    name::Union{Nothing,AbstractString} The name of the domain.
    task::MSKtask An optimization task.
"""
function putdomainname end

"""
Sets a double parameter.

    putdouparam(task::MSKtask,param::Dparam,parvalue::Float64)
    putdouparam(task::MSKtask,param::Dparam,parvalue::T0) where {T0<:Number} 

Arguments:
    param::Dparam Which parameter.
    parvalue::Float64 Parameter value.
    task::MSKtask An optimization task.
"""
function putdouparam end

"""
Sets an integer parameter.

    putintparam(task::MSKtask,param::Iparam,parvalue::Int32)
    putintparam(task::MSKtask,param::Iparam,parvalue::T0) where {T0<:Integer} 

Arguments:
    param::Iparam Which parameter.
    parvalue::Int32 Parameter value.
    task::MSKtask An optimization task.
"""
function putintparam end

"""
Input a runtime license code.

    putlicensecode(env::MSKenv,code::Union{Nothing,Vector{Int32}})
    putlicensecode(env::MSKenv,code::T0) where {T0<:AbstractVector{<:Integer}} 
    putlicensecode(code::Union{Nothing,Vector{Int32}})
    putlicensecode(code::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    code::Union{Nothing,Vector{Int32}} A license key string.
    env::MSKenv The MOSEK environment.
"""
function putlicensecode end

"""
Enables debug information for the license system.

    putlicensedebug(env::MSKenv,licdebug::Int32)
    putlicensedebug(env::MSKenv,licdebug::T0) where {T0<:Integer} 
    putlicensedebug(licdebug::Int32)
    putlicensedebug(licdebug::T0) where {T0<:Integer} 

Arguments:
    env::MSKenv The MOSEK environment.
    licdebug::Int32 Enable output of license check-out debug information.
"""
function putlicensedebug end

"""
Set the path to the license file.

    putlicensepath(env::MSKenv,licensepath::Union{Nothing,AbstractString})
    putlicensepath(licensepath::Union{Nothing,AbstractString})

Arguments:
    env::MSKenv The MOSEK environment.
    licensepath::Union{Nothing,AbstractString} A path specifying where to search for the license.
"""
function putlicensepath end

"""
Control whether mosek should wait for an available license if no license is available.

    putlicensewait(env::MSKenv,licwait::Int32)
    putlicensewait(env::MSKenv,licwait::T0) where {T0<:Integer} 
    putlicensewait(licwait::Int32)
    putlicensewait(licwait::T0) where {T0<:Integer} 

Arguments:
    env::MSKenv The MOSEK environment.
    licwait::Int32 Enable waiting for a license.
"""
function putlicensewait end

"""
Sets the number of preallocated affine conic constraints.

    putmaxnumacc(task::MSKtask,maxnumacc::Int64)
    putmaxnumacc(task::MSKtask,maxnumacc::T0) where {T0<:Integer} 

Arguments:
    maxnumacc::Int64 Number of preallocated affine conic constraints.
    task::MSKtask An optimization task.
"""
function putmaxnumacc end

"""
Sets the number of preallocated affine expressions in the optimization task.

    putmaxnumafe(task::MSKtask,maxnumafe::Int64)
    putmaxnumafe(task::MSKtask,maxnumafe::T0) where {T0<:Integer} 

Arguments:
    maxnumafe::Int64 Number of preallocated affine expressions.
    task::MSKtask An optimization task.
"""
function putmaxnumafe end

"""
Sets the number of preallocated non-zero entries in the linear coefficient matrix.

    putmaxnumanz(task::MSKtask,maxnumanz::Int64)
    putmaxnumanz(task::MSKtask,maxnumanz::T0) where {T0<:Integer} 

Arguments:
    maxnumanz::Int64 New size of the storage reserved for storing the linear coefficient matrix.
    task::MSKtask An optimization task.
"""
function putmaxnumanz end

"""
Sets the number of preallocated symmetric matrix variables.

    putmaxnumbarvar(task::MSKtask,maxnumbarvar::Int32)
    putmaxnumbarvar(task::MSKtask,maxnumbarvar::T0) where {T0<:Integer} 

Arguments:
    maxnumbarvar::Int32 Number of preallocated symmetric matrix variables.
    task::MSKtask An optimization task.
"""
function putmaxnumbarvar end

"""
Sets the number of preallocated constraints in the optimization task.

    putmaxnumcon(task::MSKtask,maxnumcon::Int32)
    putmaxnumcon(task::MSKtask,maxnumcon::T0) where {T0<:Integer} 

Arguments:
    maxnumcon::Int32 Number of preallocated constraints in the optimization task.
    task::MSKtask An optimization task.
"""
function putmaxnumcon end

"""
Sets the number of preallocated conic constraints in the optimization task.

    putmaxnumcone(task::MSKtask,maxnumcone::Int32)
    putmaxnumcone(task::MSKtask,maxnumcone::T0) where {T0<:Integer} 

Arguments:
    maxnumcone::Int32 Number of preallocated conic constraints in the optimization task.
    task::MSKtask An optimization task.
"""
function putmaxnumcone end

"""
Sets the number of preallocated disjunctive constraints.

    putmaxnumdjc(task::MSKtask,maxnumdjc::Int64)
    putmaxnumdjc(task::MSKtask,maxnumdjc::T0) where {T0<:Integer} 

Arguments:
    maxnumdjc::Int64 Number of preallocated disjunctive constraints in the task.
    task::MSKtask An optimization task.
"""
function putmaxnumdjc end

"""
Sets the number of preallocated domains in the optimization task.

    putmaxnumdomain(task::MSKtask,maxnumdomain::Int64)
    putmaxnumdomain(task::MSKtask,maxnumdomain::T0) where {T0<:Integer} 

Arguments:
    maxnumdomain::Int64 Number of preallocated domains.
    task::MSKtask An optimization task.
"""
function putmaxnumdomain end

"""
Sets the number of preallocated non-zero entries in quadratic terms.

    putmaxnumqnz(task::MSKtask,maxnumqnz::Int64)
    putmaxnumqnz(task::MSKtask,maxnumqnz::T0) where {T0<:Integer} 

Arguments:
    maxnumqnz::Int64 Number of non-zero elements preallocated in quadratic coefficient matrices.
    task::MSKtask An optimization task.
"""
function putmaxnumqnz end

"""
Sets the number of preallocated variables in the optimization task.

    putmaxnumvar(task::MSKtask,maxnumvar::Int32)
    putmaxnumvar(task::MSKtask,maxnumvar::T0) where {T0<:Integer} 

Arguments:
    maxnumvar::Int32 Number of preallocated variables in the optimization task.
    task::MSKtask An optimization task.
"""
function putmaxnumvar end

"""
Sets a double parameter.

    putnadouparam(task::MSKtask,paramname::AbstractString,parvalue::Float64)
    putnadouparam(task::MSKtask,paramname::Union{Nothing,AbstractString},parvalue::T0) where {T0<:Number} 

Arguments:
    paramname::AbstractString Name of a parameter.
    parvalue::Float64 Parameter value.
    task::MSKtask An optimization task.
"""
function putnadouparam end

"""
Sets an integer parameter.

    putnaintparam(task::MSKtask,paramname::AbstractString,parvalue::Int32)
    putnaintparam(task::MSKtask,paramname::Union{Nothing,AbstractString},parvalue::T0) where {T0<:Integer} 

Arguments:
    paramname::AbstractString Name of a parameter.
    parvalue::Int32 Parameter value.
    task::MSKtask An optimization task.
"""
function putnaintparam end

"""
Sets a string parameter.

    putnastrparam(task::MSKtask,paramname::AbstractString,parvalue::AbstractString)

Arguments:
    paramname::AbstractString Name of a parameter.
    parvalue::AbstractString Parameter value.
    task::MSKtask An optimization task.
"""
function putnastrparam end

"""
Assigns a new name to the objective.

    putobjname(task::MSKtask,objname::AbstractString)

Arguments:
    objname::AbstractString Name of the objective.
    task::MSKtask An optimization task.
"""
function putobjname end

"""
Sets the objective sense.

    putobjsense(task::MSKtask,sense::Objsense)

Arguments:
    sense::Objsense The objective sense of the task
    task::MSKtask An optimization task.
"""
function putobjsense end

"""
Specify an OptServer for remote calls.

    putoptserverhost(task::MSKtask,host::Union{Nothing,AbstractString})

Arguments:
    host::Union{Nothing,AbstractString} A URL specifying the optimization server to be used.
    task::MSKtask An optimization task.
"""
function putoptserverhost end

"""
Modifies the value of parameter.

    putparam(task::MSKtask,parname::AbstractString,parvalue::AbstractString)

Arguments:
    parname::AbstractString Parameter name.
    parvalue::AbstractString Parameter value.
    task::MSKtask An optimization task.
"""
function putparam end

"""
Replaces all quadratic terms in constraints.

    putqcon(task::MSKtask,qcsubk::Vector{Int32},qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
    putqcon(task::MSKtask,qcsubk::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

Arguments:
    qcsubi::Vector{Int32} Row subscripts for quadratic constraint matrix.
    qcsubj::Vector{Int32} Column subscripts for quadratic constraint matrix.
    qcsubk::Vector{Int32} Constraint subscripts for quadratic coefficients.
    qcval::Vector{Float64} Quadratic constraint coefficient values.
    task::MSKtask An optimization task.
"""
function putqcon end

"""
Replaces all quadratic terms in a single constraint.

    putqconk(task::MSKtask,k::Int32,qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
    putqconk(task::MSKtask,k::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 
    putqconk(task::MSKtask,k::T0,Qk:: SparseMatrixCSC{Float64})

Arguments:
    k::Int32 The constraint in which the new quadratic elements are inserted.
    qcsubi::SparseMatrixCSC{Float64} Sparse matrix defining the column values
    qcsubj::Vector{Int32} Column subscripts for quadratic constraint matrix.
    qcval::Vector{Float64} Quadratic constraint coefficient values.
    task::MSKtask An optimization task.
"""
function putqconk end

"""
Replaces all quadratic terms in the objective.

    putqobj(task::MSKtask,qosubi::Vector{Int32},qosubj::Vector{Int32},qoval::Vector{Float64})
    putqobj(task::MSKtask,qosubi::T0,qosubj::T1,qoval::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 
    putqobj(task::MSKtask,Qk:: SparseMatrixCSC{Float64})

Arguments:
    qosubi::SparseMatrixCSC{Float64} Sparse matrix defining the column values
    qosubj::Vector{Int32} Column subscripts for quadratic objective coefficients.
    qoval::Vector{Float64} Quadratic objective coefficient values.
    task::MSKtask An optimization task.
"""
function putqobj end

"""
Replaces one coefficient in the quadratic term in the objective.

    putqobjij(task::MSKtask,i::Int32,j::Int32,qoij::Float64)
    putqobjij(task::MSKtask,i::T0,j::T1,qoij::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

Arguments:
    i::Int32 Row index for the coefficient to be replaced.
    j::Int32 Column index for the coefficient to be replaced.
    qoij::Float64 The new coefficient value.
    task::MSKtask An optimization task.
"""
function putqobjij end

"""
Sets the status keys for the constraints.

    putskc(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey})

Arguments:
    skc::Vector{Stakey} Status keys for the constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putskc end

"""
Sets the status keys for a slice of the constraints.

    putskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skc::Vector{Stakey})
    putskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skc::Vector{Stakey}) where {T0<:Integer,T1<:Integer} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    skc::Vector{Stakey} Status keys for the constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putskcslice end

"""
Sets the status keys for the scalar variables.

    putskx(task::MSKtask,whichsol::Soltype,skx::Vector{Stakey})

Arguments:
    skx::Vector{Stakey} Status keys for the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putskx end

"""
Sets the status keys for a slice of the variables.

    putskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skx::Vector{Stakey})
    putskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skx::Vector{Stakey}) where {T0<:Integer,T1<:Integer} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    skx::Vector{Stakey} Status keys for the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putskxslice end

"""
Sets the slc vector for a solution.

    putslc(task::MSKtask,whichsol::Soltype,slc::Vector{Float64})
    putslc(task::MSKtask,whichsol::Soltype,slc::T0) where {T0<:AbstractVector{<:Number}} 

Arguments:
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putslc end

"""
Sets a slice of the slc vector for a solution.

    putslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slc::Vector{Float64})
    putslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slc::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putslcslice end

"""
Sets the slx vector for a solution.

    putslx(task::MSKtask,whichsol::Soltype,slx::Vector{Float64})
    putslx(task::MSKtask,whichsol::Soltype,slx::T0) where {T0<:AbstractVector{<:Number}} 

Arguments:
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putslx end

"""
Sets a slice of the slx vector for a solution.

    putslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slx::Vector{Float64})
    putslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slx::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putslxslice end

"""
Sets the snx vector for a solution.

    putsnx(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
    putsnx(task::MSKtask,whichsol::Soltype,sux::T0) where {T0<:AbstractVector{<:Number}} 

Arguments:
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putsnx end

"""
Sets a slice of the snx vector for a solution.

    putsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,snx::Vector{Float64})
    putsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,snx::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putsnxslice end

"""
Inserts a solution.

    putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Union{Nothing,Vector{Float64}},xx::Union{Nothing,Vector{Float64}},y::Union{Nothing,Vector{Float64}},slc::Union{Nothing,Vector{Float64}},suc::Union{Nothing,Vector{Float64}},slx::Union{Nothing,Vector{Float64}},sux::Union{Nothing,Vector{Float64}},snx::Union{Nothing,Vector{Float64}})
    putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number}} 

Arguments:
    skc::Vector{Stakey} Status keys for the constraints.
    skn::Vector{Stakey} Status keys for the conic constraints.
    skx::Vector{Stakey} Status keys for the variables.
    slc::Union{Nothing,Vector{Float64}} Dual variables corresponding to the lower bounds on the constraints.
    slx::Union{Nothing,Vector{Float64}} Dual variables corresponding to the lower bounds on the variables.
    snx::Union{Nothing,Vector{Float64}} Dual variables corresponding to the conic constraints on the variables.
    suc::Union{Nothing,Vector{Float64}} Dual variables corresponding to the upper bounds on the constraints.
    sux::Union{Nothing,Vector{Float64}} Dual variables corresponding to the upper bounds on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    xc::Union{Nothing,Vector{Float64}} Primal constraint solution.
    xx::Union{Nothing,Vector{Float64}} Primal variable solution.
    y::Union{Nothing,Vector{Float64}} Vector of dual variables corresponding to the constraints.
"""
function putsolution end

"""
Inserts a solution.

    putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Union{Nothing,Vector{Float64}},xx::Union{Nothing,Vector{Float64}},y::Union{Nothing,Vector{Float64}},slc::Union{Nothing,Vector{Float64}},suc::Union{Nothing,Vector{Float64}},slx::Union{Nothing,Vector{Float64}},sux::Union{Nothing,Vector{Float64}},snx::Union{Nothing,Vector{Float64}},doty::Union{Nothing,Vector{Float64}})
    putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7,doty::T8) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number}} 

Arguments:
    doty::Union{Nothing,Vector{Float64}} Dual variables corresponding to affine conic constraints.
    skc::Vector{Stakey} Status keys for the constraints.
    skn::Vector{Stakey} Status keys for the conic constraints.
    skx::Vector{Stakey} Status keys for the variables.
    slc::Union{Nothing,Vector{Float64}} Dual variables corresponding to the lower bounds on the constraints.
    slx::Union{Nothing,Vector{Float64}} Dual variables corresponding to the lower bounds on the variables.
    snx::Union{Nothing,Vector{Float64}} Dual variables corresponding to the conic constraints on the variables.
    suc::Union{Nothing,Vector{Float64}} Dual variables corresponding to the upper bounds on the constraints.
    sux::Union{Nothing,Vector{Float64}} Dual variables corresponding to the upper bounds on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    xc::Union{Nothing,Vector{Float64}} Primal constraint solution.
    xx::Union{Nothing,Vector{Float64}} Primal variable solution.
    y::Union{Nothing,Vector{Float64}} Vector of dual variables corresponding to the constraints.
"""
function putsolutionnew end

"""
Inputs the dual variable of a solution.

    putsolutionyi(task::MSKtask,i::Int32,whichsol::Soltype,y::Float64)
    putsolutionyi(task::MSKtask,i::T0,whichsol::Soltype,y::T1) where {T0<:Integer,T1<:Number} 

Arguments:
    i::Int32 Index of the dual variable.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    y::Float64 Solution value of the dual variable.
"""
function putsolutionyi end

"""
Sets a string parameter.

    putstrparam(task::MSKtask,param::Sparam,parvalue::AbstractString)

Arguments:
    param::Sparam Which parameter.
    parvalue::AbstractString Parameter value.
    task::MSKtask An optimization task.
"""
function putstrparam end

"""
Sets the suc vector for a solution.

    putsuc(task::MSKtask,whichsol::Soltype,suc::Vector{Float64})
    putsuc(task::MSKtask,whichsol::Soltype,suc::T0) where {T0<:AbstractVector{<:Number}} 

Arguments:
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putsuc end

"""
Sets a slice of the suc vector for a solution.

    putsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,suc::Vector{Float64})
    putsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,suc::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putsucslice end

"""
Sets the sux vector for a solution.

    putsux(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
    putsux(task::MSKtask,whichsol::Soltype,sux::T0) where {T0<:AbstractVector{<:Number}} 

Arguments:
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putsux end

"""
Sets a slice of the sux vector for a solution.

    putsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,sux::Vector{Float64})
    putsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,sux::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function putsuxslice end

"""
Assigns a new name to the task.

    puttaskname(task::MSKtask,taskname::AbstractString)

Arguments:
    task::MSKtask An optimization task.
    taskname::AbstractString Name assigned to the task.
"""
function puttaskname end

"""
Changes the bounds for one variable.

    putvarbound(task::MSKtask,j::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
    putvarbound(task::MSKtask,j::T0,bkx::Boundkey,blx::T1,bux::T2) where {T0<:Integer,T1<:Number,T2<:Number} 

Arguments:
    bkx::Boundkey New bound key.
    blx::Float64 New lower bound.
    bux::Float64 New upper bound.
    j::Int32 Index of the variable.
    task::MSKtask An optimization task.
"""
function putvarbound end

"""
Changes the bounds of a list of variables.

    putvarboundlist(task::MSKtask,sub::Vector{Int32},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
    putvarboundlist(task::MSKtask,sub::T0,bkx::Vector{Boundkey},blx::T1,bux::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number}} 

Arguments:
    bkx::Vector{Boundkey} Bound keys for the variables.
    blx::Vector{Float64} Lower bounds for the variables.
    bux::Vector{Float64} Upper bounds for the variables.
    sub::Vector{Int32} List of variable indexes.
    task::MSKtask An optimization task.
"""
function putvarboundlist end

"""
Changes the bounds of a list of variables.

    putvarboundlistconst(task::MSKtask,sub::Vector{Int32},bkx::Boundkey,blx::Float64,bux::Float64)
    putvarboundlistconst(task::MSKtask,sub::T0,bkx::Boundkey,blx::T1,bux::T2) where {T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number} 

Arguments:
    bkx::Boundkey New bound key for all variables in the list.
    blx::Float64 New lower bound for all variables in the list.
    bux::Float64 New upper bound for all variables in the list.
    sub::Vector{Int32} List of variable indexes.
    task::MSKtask An optimization task.
"""
function putvarboundlistconst end

"""
Changes the bounds for a slice of the variables.

    putvarboundslice(task::MSKtask,first::Int32,last::Int32,bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
    putvarboundslice(task::MSKtask,first::T0,last::T1,bkx::Vector{Boundkey},blx::T2,bux::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number}} 

Arguments:
    bkx::Vector{Boundkey} Bound keys for the variables.
    blx::Vector{Float64} Lower bounds for the variables.
    bux::Vector{Float64} Upper bounds for the variables.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
"""
function putvarboundslice end

"""
Changes the bounds for a slice of the variables.

    putvarboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
    putvarboundsliceconst(task::MSKtask,first::T0,last::T1,bkx::Boundkey,blx::T2,bux::T3) where {T0<:Integer,T1<:Integer,T2<:Number,T3<:Number} 

Arguments:
    bkx::Boundkey New bound key for all variables in the slice.
    blx::Float64 New lower bound for all variables in the slice.
    bux::Float64 New upper bound for all variables in the slice.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
"""
function putvarboundsliceconst end

"""
Sets the name of a variable.

    putvarname(task::MSKtask,j::Int32,name::Union{Nothing,AbstractString})
    putvarname(task::MSKtask,j::T0,name::Union{Nothing,AbstractString}) where {T0<:Integer} 

Arguments:
    j::Int32 Index of the variable.
    name::Union{Nothing,AbstractString} The variable name.
    task::MSKtask An optimization task.
"""
function putvarname end

"""
Sets the primal and dual solution information for a single variable.

    putvarsolutionj(task::MSKtask,j::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64,sn::Float64)
    putvarsolutionj(task::MSKtask,j::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3,sn::T4) where {T0<:Integer,T1<:Number,T2<:Number,T3<:Number,T4<:Number} 

Arguments:
    j::Int32 Index of the variable.
    sk::Stakey Status key of the variable.
    sl::Float64 Solution value of the dual variable associated with the lower bound.
    sn::Float64 Solution value of the dual variable associated with the conic constraint.
    su::Float64 Solution value of the dual variable associated with the upper bound.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    x::Float64 Primal solution value of the variable.
"""
function putvarsolutionj end

"""
Sets the variable type of one variable.

    putvartype(task::MSKtask,j::Int32,vartype::Variabletype)
    putvartype(task::MSKtask,j::T0,vartype::Variabletype) where {T0<:Integer} 

Arguments:
    j::Int32 Index of the variable.
    task::MSKtask An optimization task.
    vartype::Variabletype The new variable type.
"""
function putvartype end

"""
Sets the variable type for one or more variables.

    putvartypelist(task::MSKtask,subj::Vector{Int32},vartype::Vector{Variabletype})
    putvartypelist(task::MSKtask,subj::T0,vartype::Vector{Variabletype}) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    subj::Vector{Int32} A list of variable indexes for which the variable type should be changed.
    task::MSKtask An optimization task.
    vartype::Vector{Variabletype} A list of variable types.
"""
function putvartypelist end

"""
Sets the xc vector for a solution.

    putxc(task::MSKtask,whichsol::Soltype) :: xc

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    xc::Vector{Float64} Primal constraint solution.
"""
function putxc end

"""
Sets a slice of the xc vector for a solution.

    putxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xc::Vector{Float64})
    putxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xc::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    xc::Vector{Float64} Primal constraint solution.
"""
function putxcslice end

"""
Sets the xx vector for a solution.

    putxx(task::MSKtask,whichsol::Soltype,xx::Vector{Float64})
    putxx(task::MSKtask,whichsol::Soltype,xx::T0) where {T0<:AbstractVector{<:Number}} 

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    xx::Vector{Float64} Primal variable solution.
"""
function putxx end

"""
Sets a slice of the xx vector for a solution.

    putxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xx::Vector{Float64})
    putxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xx::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    xx::Vector{Float64} Primal variable solution.
"""
function putxxslice end

"""
Sets the y vector for a solution.

    puty(task::MSKtask,whichsol::Soltype,y::Vector{Float64})
    puty(task::MSKtask,whichsol::Soltype,y::T0) where {T0<:AbstractVector{<:Number}} 

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function puty end

"""
Sets a slice of the y vector for a solution.

    putyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,y::Vector{Float64})
    putyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,y::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

Arguments:
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function putyslice end

"""
Read a binary dump of the task solution and information items.

    readbsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)

Arguments:
    compress::Compresstype Data compression type.
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function readbsolution end

"""
Reads problem data from a file.

    readdata(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function readdata end

"""
Reads problem data from a file.

    readdataformat(task::MSKtask,filename::AbstractString,format::Dataformat,compress::Compresstype)

Arguments:
    compress::Compresstype File compression type.
    filename::AbstractString A valid file name.
    format::Dataformat File data format.
    task::MSKtask An optimization task.
"""
function readdataformat end

"""
Reads a solution from a JSOL file.

    readjsonsol(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function readjsonsol end

"""
Load task data from a string in JSON format.

    readjsonstring(task::MSKtask,data::AbstractString)

Arguments:
    data::AbstractString Problem data in text format.
    task::MSKtask An optimization task.
"""
function readjsonstring end

"""
Load task data from a string in LP format.

    readlpstring(task::MSKtask,data::AbstractString)

Arguments:
    data::AbstractString Problem data in text format.
    task::MSKtask An optimization task.
"""
function readlpstring end

"""
Load task data from a string in OPF format.

    readopfstring(task::MSKtask,data::AbstractString)

Arguments:
    data::AbstractString Problem data in text format.
    task::MSKtask An optimization task.
"""
function readopfstring end

"""
Reads a parameter file.

    readparamfile(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function readparamfile end

"""
Load task data from a string in PTF format.

    readptfstring(task::MSKtask,data::AbstractString)

Arguments:
    data::AbstractString Problem data in text format.
    task::MSKtask An optimization task.
"""
function readptfstring end

"""
Reads a solution from a file.

    readsolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function readsolution end

"""
Read solution file in format determined by the filename

    readsolutionfile(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function readsolutionfile end

"""
Prints information about last file read.

    readsummary(task::MSKtask,whichstream::Streamtype)

Arguments:
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function readsummary end

"""
Load task data from a file.

    readtask(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function readtask end

"""
Removes a number of symmetric matrices.

    removebarvars(task::MSKtask,subset::Vector{Int32})
    removebarvars(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    subset::Vector{Int32} Indexes of symmetric matrices which should be removed.
    task::MSKtask An optimization task.
"""
function removebarvars end

"""
Removes a number of conic constraints from the problem.

    removecones(task::MSKtask,subset::Vector{Int32})
    removecones(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    subset::Vector{Int32} Indexes of cones which should be removed.
    task::MSKtask An optimization task.
"""
function removecones end

"""
Removes a number of constraints.

    removecons(task::MSKtask,subset::Vector{Int32})
    removecons(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    subset::Vector{Int32} Indexes of constraints which should be removed.
    task::MSKtask An optimization task.
"""
function removecons end

"""
Removes a number of variables.

    removevars(task::MSKtask,subset::Vector{Int32})
    removevars(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

Arguments:
    subset::Vector{Int32} Indexes of variables which should be removed.
    task::MSKtask An optimization task.
"""
function removevars end

"""
Obtains a response code string identifier.

    rescodetostr(res::Rescode) :: str

Arguments:
    res::Rescode Response code.

Returns:
    str::String String corresponding to the response code.
"""
function rescodetostr end

"""
Reset the license expiry reporting startpoint.

    resetexpirylicenses(env::MSKenv)
    resetexpirylicenses()

Arguments:
    env::MSKenv The MOSEK environment.
"""
function resetexpirylicenses end

"""
Resizes an optimization task.

    resizetask(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,maxnumcone::Int32,maxnumanz::Int64,maxnumqnz::Int64)
    resizetask(task::MSKtask,maxnumcon::T0,maxnumvar::T1,maxnumcone::T2,maxnumanz::T3,maxnumqnz::T4) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer,T4<:Integer} 

Arguments:
    maxnumanz::Int64 New maximum number of linear non-zero elements.
    maxnumcon::Int32 New maximum number of constraints.
    maxnumcone::Int32 New maximum number of cones.
    maxnumqnz::Int64 New maximum number of quadratic non-zeros elements.
    maxnumvar::Int32 New maximum number of variables.
    task::MSKtask An optimization task.
"""
function resizetask end

"""
Creates a sensitivity report.

    sensitivityreport(task::MSKtask,whichstream::Streamtype)

Arguments:
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function sensitivityreport end

"""
Resets all parameter values.

    setdefaults(task::MSKtask)

Arguments:
    task::MSKtask An optimization task.
"""
function setdefaults end

"""
Checks whether a solution is defined.

    solutiondef(task::MSKtask,whichsol::Soltype) :: isdef

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.

Returns:
    isdef::Bool Is non-zero if the requested solution is defined.
"""
function solutiondef end

"""
Prints a short summary of the current solutions.

    solutionsummary(task::MSKtask,whichstream::Streamtype)

Arguments:
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function solutionsummary end

"""
Solve a linear equation system involving a basis matrix.

    solvewithbasis(task::MSKtask,transp::Bool,numnz::Int32,sub::Vector{Int32},val::Vector{Float64}) :: numnzout
    solvewithbasis(task::MSKtask,transp::Bool,numnz::T0,sub::Vector{Int32},val::Vector{Float64}) where {T0<:Integer}  :: numnzout

Arguments:
    numnz::Int32 Input (number of non-zeros in right-hand side).
    sub::Vector{Int32} Input (indexes of non-zeros in right-hand side) and output (indexes of non-zeros in solution vector).
    task::MSKtask An optimization task.
    transp::Bool Controls which problem formulation is solved.
    val::Vector{Float64} Input (right-hand side values) and output (solution vector values).

Returns:
    numnzout::Int32 Output (number of non-zeros in solution vector).
"""
function solvewithbasis end

"""
Solves a sparse triangular system of linear equations.

    sparsetriangularsolvedense(env::MSKenv,transposed::Transpose,lnzc::Vector{Int32},lptrc::Vector{Int64},lsubc::Vector{Int32},lvalc::Vector{Float64},b::Vector{Float64})
    sparsetriangularsolvedense(env::MSKenv,transposed::Transpose,lnzc::T0,lptrc::T1,lsubc::T2,lvalc::T3,b::Vector{Float64}) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 
    sparsetriangularsolvedense(transposed::Transpose,lnzc::Vector{Int32},lptrc::Vector{Int64},lsubc::Vector{Int32},lvalc::Vector{Float64},b::Vector{Float64})
    sparsetriangularsolvedense(transposed::Transpose,lnzc::T0,lptrc::T1,lsubc::T2,lvalc::T3,b::Vector{Float64}) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

Arguments:
    b::Vector{Float64} The right-hand side of linear equation system to be solved as a dense vector.
    env::MSKenv The MOSEK environment.
    lnzc::Vector{Int32} lnzc[j] is the number of nonzeros in column j.
    lptrc::Vector{Int64} lptrc[j] is a pointer to the first row index and value in column j.
    lsubc::Vector{Int32} Row indexes for each column stored sequentially.
    lvalc::Vector{Float64} The value corresponding to row indexed stored lsubc.
    transposed::Transpose Controls whether the solve is with L or the transposed L.
"""
function sparsetriangularsolvedense end

"""
Obtains a cone type code.

    strtoconetype(task::MSKtask,str::AbstractString) :: conetype

Arguments:
    str::AbstractString String corresponding to the cone type code.
    task::MSKtask An optimization task.

Returns:
    conetype::Conetype The cone type corresponding to str.
"""
function strtoconetype end

"""
Obtains a status key.

    strtosk(task::MSKtask,str::AbstractString) :: sk

Arguments:
    str::AbstractString A status key abbreviation string.
    task::MSKtask An optimization task.

Returns:
    sk::Stakey Status key corresponding to the string.
"""
function strtosk end

"""
Update the information items related to the solution.

    updatesolutioninfo(task::MSKtask,whichsol::Soltype)

Arguments:
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function updatesolutioninfo end

"""
Write a binary dump of the task solution and information items.

    writebsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)

Arguments:
    compress::Compresstype Data compression type.
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function writebsolution end

"""
Writes problem data to a file.

    writedata(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function writedata end

"""
Writes a solution to a JSON file.

    writejsonsol(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function writejsonsol end

"""
Writes all the parameters to a parameter file.

    writeparamfile(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function writeparamfile end

"""
Write a solution to a file.

    writesolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function writesolution end

"""
Write solution file in format determined by the filename

    writesolutionfile(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function writesolutionfile end

"""
Write a complete binary dump of the task data.

    writetask(task::MSKtask,filename::AbstractString)

Arguments:
    filename::AbstractString A valid file name.
    task::MSKtask An optimization task.
"""
function writetask end


function analyzeproblem(task::MSKtask,whichstream::Streamtype)
  @MSK_analyzeproblem(task.task,whichstream.value)
  nothing
end


function analyzenames(task::MSKtask,whichstream::Streamtype,nametype::Nametype)
  @MSK_analyzenames(task.task,whichstream.value,nametype.value)
  nothing
end


function analyzesolution(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)
  @MSK_analyzesolution(task.task,whichstream.value,whichsol.value)
  nothing
end


function initbasissolve(task::MSKtask)
  __tmp_4 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_4)
  __tmp_3 = __tmp_4[]
  basis_ = Vector{Int32}(undef,__tmp_3)
  @MSK_initbasissolve(task.task,basis_)
  basis = basis_;
  basis .+= 1
  basis
end


function solvewithbasis(task::MSKtask,transp::Bool,numnz::Int32,sub::Vector{Int32},val::Vector{Float64})
  __tmp_7 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_7)
  __tmp_6 = __tmp_7[]
  if sub !== nothing && length(sub) < __tmp_6
    throw(BoundsError())
  end
  sub_ = sub .- Int32(1)
  __tmp_10 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_10)
  __tmp_9 = __tmp_10[]
  if val !== nothing && length(val) < __tmp_9
    throw(BoundsError())
  end
  val_ = val
  numnzout_ = Ref{Int32}()
  @MSK_solvewithbasis(task.task,transp,numnz,sub_,val_,numnzout_)
  if sub !== nothing; sub[:] = sub_ .+ Int32(1); end
  if val !== nothing; val[:] = val_; end
  numnzout_[]
end
function solvewithbasis(task::MSKtask,transp::Bool,numnz::T0,sub::Vector{Int32},val::Vector{Float64}) where { T0<:Integer }
  solvewithbasis(
    task,
    transp,
    convert(Int32,numnz),
    sub,
    val)
end


function basiscond(task::MSKtask)
  nrmbasis_ = Ref{Float64}()
  nrminvbasis_ = Ref{Float64}()
  @MSK_basiscond(task.task,nrmbasis_,nrminvbasis_)
  nrmbasis_[],nrminvbasis_[]
end


function appendcons(task::MSKtask,num::Int32)
  @MSK_appendcons(task.task,num)
  nothing
end
function appendcons(task::MSKtask,num::T0) where { T0<:Integer }
  appendcons(
    task,
    convert(Int32,num))
end


function appendvars(task::MSKtask,num::Int32)
  @MSK_appendvars(task.task,num)
  nothing
end
function appendvars(task::MSKtask,num::T0) where { T0<:Integer }
  appendvars(
    task,
    convert(Int32,num))
end


function removecons(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset
  @MSK_removecons(task.task,num,subset_)
  nothing
end
function removecons(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removecons(
    task,
    if subset === nothing; nothing; else convert(Vector{Int32},subset); end)
end


function removevars(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset
  @MSK_removevars(task.task,num,subset_)
  nothing
end
function removevars(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removevars(
    task,
    if subset === nothing; nothing; else convert(Vector{Int32},subset); end)
end


function removebarvars(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset
  @MSK_removebarvars(task.task,num,subset_)
  nothing
end
function removebarvars(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removebarvars(
    task,
    if subset === nothing; nothing; else convert(Vector{Int32},subset); end)
end


function removecones(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset .- Int32(1)
  @MSK_removecones(task.task,num,subset_)
  nothing
end
function removecones(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removecones(
    task,
    if subset === nothing; nothing; else convert(Vector{Int32},subset); end)
end


function appendbarvars(task::MSKtask,dim::Vector{Int32})
  num = Int32(length(dim))
  dim_ = dim
  @MSK_appendbarvars(task.task,num,dim_)
  nothing
end
function appendbarvars(task::MSKtask,dim::T0) where { T0<:AbstractVector{<:Integer} }
  appendbarvars(
    task,
    if dim === nothing; nothing; else convert(Vector{Int32},dim); end)
end


function appendcone(task::MSKtask,ct::Conetype,conepar::Float64,submem::Vector{Int32})
  nummem = Int32(length(submem))
  submem_ = submem .- Int32(1)
  @MSK_appendcone(task.task,ct.value,conepar,nummem,submem_)
  nothing
end
function appendcone(task::MSKtask,ct::Conetype,conepar::T0,submem::T1) where { T0<:Number,T1<:AbstractVector{<:Integer} }
  appendcone(
    task,
    ct,
    convert(Float64,conepar),
    if submem === nothing; nothing; else convert(Vector{Int32},submem); end)
end


function appendconeseq(task::MSKtask,ct::Conetype,conepar::Float64,nummem::Int32,j::Int32)
  @MSK_appendconeseq(task.task,ct.value,conepar,nummem,j-Int32(1))
  nothing
end
function appendconeseq(task::MSKtask,ct::Conetype,conepar::T0,nummem::T1,j::T2) where { T0<:Number,T1<:Integer,T2<:Integer }
  appendconeseq(
    task,
    ct,
    convert(Float64,conepar),
    convert(Int32,nummem),
    convert(Int32,j))
end


function appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::Vector{Float64},nummem::Vector{Int32},j::Int32)
  num = Int32(min(length(ct),length(conepar),length(nummem)))
  ct_ = Int32[item.value for item in ct]
  conepar_ = conepar
  nummem_ = nummem
  @MSK_appendconesseq(task.task,num,ct_,conepar_,nummem_,j-Int32(1))
  nothing
end
function appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::T0,nummem::T1,j::T2) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Integer},T2<:Integer }
  appendconesseq(
    task,
    ct,
    if conepar === nothing; nothing; else convert(Vector{Float64},conepar); end,
    if nummem === nothing; nothing; else convert(Vector{Int32},nummem); end,
    convert(Int32,j))
end


function bktostr(task::MSKtask,bk::Boundkey)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_bktostr(task.task,bk.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function chgconbound(task::MSKtask,i::Int32,lower::Int32,finite::Int32,value::Float64)
  @MSK_chgconbound(task.task,i-Int32(1),lower,finite,value)
  nothing
end
function chgconbound(task::MSKtask,i::T0,lower::T1,finite::T2,value::T3) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number }
  chgconbound(
    task,
    convert(Int32,i),
    convert(Int32,lower),
    convert(Int32,finite),
    convert(Float64,value))
end


function chgvarbound(task::MSKtask,j::Int32,lower::Int32,finite::Int32,value::Float64)
  @MSK_chgvarbound(task.task,j-Int32(1),lower,finite,value)
  nothing
end
function chgvarbound(task::MSKtask,j::T0,lower::T1,finite::T2,value::T3) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number }
  chgvarbound(
    task,
    convert(Int32,j),
    convert(Int32,lower),
    convert(Int32,finite),
    convert(Float64,value))
end


function conetypetostr(task::MSKtask,ct::Conetype)
  str_ = Array{UInt8}(undef,1024)
  @MSK_conetypetostr(task.task,ct.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function getaij(task::MSKtask,i::Int32,j::Int32)
  aij_ = Ref{Float64}()
  @MSK_getaij(task.task,i-Int32(1),j-Int32(1),aij_)
  aij_[]
end
function getaij(task::MSKtask,i::T0,j::T1) where { T0<:Integer,T1<:Integer }
  getaij(
    task,
    convert(Int32,i),
    convert(Int32,j))
end


function getapiecenumnz(task::MSKtask,firsti::Int32,lasti::Int32,firstj::Int32,lastj::Int32)
  numnz_ = Ref{Int32}()
  @MSK_getapiecenumnz(task.task,firsti-Int32(1),lasti-Int32(1),firstj-Int32(1),lastj-Int32(1),numnz_)
  numnz_[]
end
function getapiecenumnz(task::MSKtask,firsti::T0,lasti::T1,firstj::T2,lastj::T3) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer }
  getapiecenumnz(
    task,
    convert(Int32,firsti),
    convert(Int32,lasti),
    convert(Int32,firstj),
    convert(Int32,lastj))
end


function getacolnumnz(task::MSKtask,i::Int32)
  nzj_ = Ref{Int32}()
  @MSK_getacolnumnz(task.task,i-Int32(1),nzj_)
  nzj_[]
end
function getacolnumnz(task::MSKtask,i::T0) where { T0<:Integer }
  getacolnumnz(
    task,
    convert(Int32,i))
end


function getacol(task::MSKtask,j::Int32)
  nzj_ = Ref{Int32}()
  __tmp_34 = Ref{Int32}()
  @MSK_getacolnumnz(task.task,j-Int32(1),__tmp_34)
  __tmp_33 = __tmp_34[]
  subj_ = Vector{Int32}(undef,__tmp_33)
  __tmp_36 = Ref{Int32}()
  @MSK_getacolnumnz(task.task,j-Int32(1),__tmp_36)
  __tmp_35 = __tmp_36[]
  valj_ = Vector{Float64}(undef,__tmp_35)
  @MSK_getacol(task.task,j-Int32(1),nzj_,subj_,valj_)
  subj = subj_;
  subj .+= 1
  valj = valj_;
  nzj_[],subj,valj
end
function getacol(task::MSKtask,j::T0) where { T0<:Integer }
  getacol(
    task,
    convert(Int32,j))
end


function getacolslice(task::MSKtask,first::Int32,last::Int32)
  __tmp_41 = Ref{Int64}()
  @MSK_getacolslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_41)
  __tmp_40 = __tmp_41[]
  maxnumnz = Int64(__tmp_40)
  ptrb_ = Vector{Int64}(undef,(last - first))
  ptre_ = Vector{Int64}(undef,(last - first))
  sub_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getacolslice64(task.task,first-Int32(1),last-Int32(1),maxnumnz,ptrb_,ptre_,sub_,val_)
  ptrb = ptrb_;
  ptrb .+= 1
  ptre = ptre_;
  ptre .+= 1
  sub = sub_;
  sub .+= 1
  val = val_;
  ptrb,ptre,sub,val
end
function getacolslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getacolslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getarownumnz(task::MSKtask,i::Int32)
  nzi_ = Ref{Int32}()
  @MSK_getarownumnz(task.task,i-Int32(1),nzi_)
  nzi_[]
end
function getarownumnz(task::MSKtask,i::T0) where { T0<:Integer }
  getarownumnz(
    task,
    convert(Int32,i))
end


function getarow(task::MSKtask,i::Int32)
  nzi_ = Ref{Int32}()
  __tmp_45 = Ref{Int32}()
  @MSK_getarownumnz(task.task,i-Int32(1),__tmp_45)
  __tmp_44 = __tmp_45[]
  subi_ = Vector{Int32}(undef,__tmp_44)
  __tmp_47 = Ref{Int32}()
  @MSK_getarownumnz(task.task,i-Int32(1),__tmp_47)
  __tmp_46 = __tmp_47[]
  vali_ = Vector{Float64}(undef,__tmp_46)
  @MSK_getarow(task.task,i-Int32(1),nzi_,subi_,vali_)
  subi = subi_;
  subi .+= 1
  vali = vali_;
  nzi_[],subi,vali
end
function getarow(task::MSKtask,i::T0) where { T0<:Integer }
  getarow(
    task,
    convert(Int32,i))
end


function getacolslicenumnz(task::MSKtask,first::Int32,last::Int32)
  numnz_ = Ref{Int64}()
  @MSK_getacolslicenumnz64(task.task,first-Int32(1),last-Int32(1),numnz_)
  numnz_[]
end
function getacolslicenumnz(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getacolslicenumnz(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getarowslicenumnz(task::MSKtask,first::Int32,last::Int32)
  numnz_ = Ref{Int64}()
  @MSK_getarowslicenumnz64(task.task,first-Int32(1),last-Int32(1),numnz_)
  numnz_[]
end
function getarowslicenumnz(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getarowslicenumnz(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getarowslice(task::MSKtask,first::Int32,last::Int32)
  __tmp_54 = Ref{Int64}()
  @MSK_getarowslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_54)
  __tmp_53 = __tmp_54[]
  maxnumnz = Int64(__tmp_53)
  ptrb_ = Vector{Int64}(undef,(last - first))
  ptre_ = Vector{Int64}(undef,(last - first))
  sub_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getarowslice64(task.task,first-Int32(1),last-Int32(1),maxnumnz,ptrb_,ptre_,sub_,val_)
  ptrb = ptrb_;
  ptrb .+= 1
  ptre = ptre_;
  ptre .+= 1
  sub = sub_;
  sub .+= 1
  val = val_;
  ptrb,ptre,sub,val
end
function getarowslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getarowslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getatrip(task::MSKtask)
  __tmp_57 = Ref{Int64}()
  @MSK_getnumanz64(task.task,__tmp_57)
  __tmp_56 = __tmp_57[]
  maxnumnz = Int64(__tmp_56)
  subi_ = Vector{Int32}(undef,maxnumnz)
  subj_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getatrip(task.task,maxnumnz,subi_,subj_,val_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  val = val_;
  subi,subj,val
end


function getarowslicetrip(task::MSKtask,first::Int32,last::Int32)
  __tmp_60 = Ref{Int64}()
  @MSK_getarowslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_60)
  __tmp_59 = __tmp_60[]
  maxnumnz = Int64(__tmp_59)
  subi_ = Vector{Int32}(undef,maxnumnz)
  subj_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getarowslicetrip(task.task,first-Int32(1),last-Int32(1),maxnumnz,subi_,subj_,val_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  val = val_;
  subi,subj,val
end
function getarowslicetrip(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getarowslicetrip(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getacolslicetrip(task::MSKtask,first::Int32,last::Int32)
  __tmp_63 = Ref{Int64}()
  @MSK_getacolslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_63)
  __tmp_62 = __tmp_63[]
  maxnumnz = Int64(__tmp_62)
  subi_ = Vector{Int32}(undef,maxnumnz)
  subj_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getacolslicetrip(task.task,first-Int32(1),last-Int32(1),maxnumnz,subi_,subj_,val_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  val = val_;
  subi,subj,val
end
function getacolslicetrip(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getacolslicetrip(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getconbound(task::MSKtask,i::Int32)
  bk_ = Ref{Int32}()
  bl_ = Ref{Float64}()
  bu_ = Ref{Float64}()
  @MSK_getconbound(task.task,i-Int32(1),bk_,bl_,bu_)
  bk = Boundkey(bk_[])
  bk,bl_[],bu_[]
end
function getconbound(task::MSKtask,i::T0) where { T0<:Integer }
  getconbound(
    task,
    convert(Int32,i))
end


function getvarbound(task::MSKtask,i::Int32)
  bk_ = Ref{Int32}()
  bl_ = Ref{Float64}()
  bu_ = Ref{Float64}()
  @MSK_getvarbound(task.task,i-Int32(1),bk_,bl_,bu_)
  bk = Boundkey(bk_[])
  bk,bl_[],bu_[]
end
function getvarbound(task::MSKtask,i::T0) where { T0<:Integer }
  getvarbound(
    task,
    convert(Int32,i))
end


function getconboundslice(task::MSKtask,first::Int32,last::Int32)
  bk_ = Vector{Int32}(undef,(last - first))
  bl_ = Vector{Float64}(undef,(last - first))
  bu_ = Vector{Float64}(undef,(last - first))
  @MSK_getconboundslice(task.task,first-Int32(1),last-Int32(1),bk_,bl_,bu_)
  bk = Boundkey[Boundkey(item) for item in bk_]
  bl = bl_;
  bu = bu_;
  bk,bl,bu
end
function getconboundslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getconboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getvarboundslice(task::MSKtask,first::Int32,last::Int32)
  bk_ = Vector{Int32}(undef,(last - first))
  bl_ = Vector{Float64}(undef,(last - first))
  bu_ = Vector{Float64}(undef,(last - first))
  @MSK_getvarboundslice(task.task,first-Int32(1),last-Int32(1),bk_,bl_,bu_)
  bk = Boundkey[Boundkey(item) for item in bk_]
  bl = bl_;
  bu = bu_;
  bk,bl,bu
end
function getvarboundslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getvarboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getcj(task::MSKtask,j::Int32)
  cj_ = Ref{Float64}()
  @MSK_getcj(task.task,j-Int32(1),cj_)
  cj_[]
end
function getcj(task::MSKtask,j::T0) where { T0<:Integer }
  getcj(
    task,
    convert(Int32,j))
end


function getc(task::MSKtask)
  __tmp_71 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_71)
  __tmp_70 = __tmp_71[]
  c_ = Vector{Float64}(undef,__tmp_70)
  @MSK_getc(task.task,c_)
  c = c_;
  c
end


function getcfix(task::MSKtask)
  cfix_ = Ref{Float64}()
  @MSK_getcfix(task.task,cfix_)
  cfix_[]
end


function getcone(task::MSKtask,k::Int32)
  ct_ = Ref{Int32}()
  conepar_ = Ref{Float64}()
  nummem_ = Ref{Int32}()
  __tmp_75 = Ref{Int32}()
  @MSK_getconeinfo(task.task,k-Int32(1),Ref{Int32}(),Ref{Float64}(),__tmp_75)
  __tmp_74 = __tmp_75[]
  submem_ = Vector{Int32}(undef,__tmp_74)
  @MSK_getcone(task.task,k-Int32(1),ct_,conepar_,nummem_,submem_)
  ct = Conetype(ct_[])
  submem = submem_;
  submem .+= 1
  ct,conepar_[],nummem_[],submem
end
function getcone(task::MSKtask,k::T0) where { T0<:Integer }
  getcone(
    task,
    convert(Int32,k))
end


function getconeinfo(task::MSKtask,k::Int32)
  ct_ = Ref{Int32}()
  conepar_ = Ref{Float64}()
  nummem_ = Ref{Int32}()
  @MSK_getconeinfo(task.task,k-Int32(1),ct_,conepar_,nummem_)
  ct = Conetype(ct_[])
  ct,conepar_[],nummem_[]
end
function getconeinfo(task::MSKtask,k::T0) where { T0<:Integer }
  getconeinfo(
    task,
    convert(Int32,k))
end


function getclist(task::MSKtask,subj::Vector{Int32})
  num = Int32(length(subj))
  subj_ = subj .- Int32(1)
  c_ = Vector{Float64}(undef,num)
  @MSK_getclist(task.task,num,subj_,c_)
  c = c_;
  c
end
function getclist(task::MSKtask,subj::T0) where { T0<:AbstractVector{<:Integer} }
  getclist(
    task,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end)
end


function getcslice(task::MSKtask,first::Int32,last::Int32)
  c_ = Vector{Float64}(undef,(last - first))
  @MSK_getcslice(task.task,first-Int32(1),last-Int32(1),c_)
  c = c_;
  c
end
function getcslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getcslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


function getdouinf(task::MSKtask,whichdinf::Dinfitem)
  dvalue_ = Ref{Float64}()
  @MSK_getdouinf(task.task,whichdinf.value,dvalue_)
  dvalue_[]
end


function getdouparam(task::MSKtask,param::Dparam)
  parvalue_ = Ref{Float64}()
  @MSK_getdouparam(task.task,param.value,parvalue_)
  parvalue_[]
end


function getdualobj(task::MSKtask,whichsol::Soltype)
  dualobj_ = Ref{Float64}()
  @MSK_getdualobj(task.task,whichsol.value,dualobj_)
  dualobj_[]
end


function getinfname(task::MSKtask,inftype::Inftype,whichinf::Int32)
  infname_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_getinfname(task.task,inftype.value,whichinf,infname_)
  infname_len = findfirst(_c->_c==0,infname_)
  infname = if infname_len === nothing
    String(infname_)
  else
    String(infname_[1:infname_len-1])
  end
  infname
end
function getinfname(task::MSKtask,inftype::Inftype,whichinf::T0) where { T0<:Integer }
  getinfname(
    task,
    inftype,
    convert(Int32,whichinf))
end


function getintinf(task::MSKtask,whichiinf::Iinfitem)
  ivalue_ = Ref{Int32}()
  @MSK_getintinf(task.task,whichiinf.value,ivalue_)
  ivalue_[]
end


function getlintinf(task::MSKtask,whichliinf::Liinfitem)
  ivalue_ = Ref{Int64}()
  @MSK_getlintinf(task.task,whichliinf.value,ivalue_)
  ivalue_[]
end


function getintparam(task::MSKtask,param::Iparam)
  parvalue_ = Ref{Int32}()
  @MSK_getintparam(task.task,param.value,parvalue_)
  parvalue_[]
end


function getmaxnumanz(task::MSKtask)
  maxnumanz_ = Ref{Int64}()
  @MSK_getmaxnumanz64(task.task,maxnumanz_)
  maxnumanz_[]
end


function getmaxnumcon(task::MSKtask)
  maxnumcon_ = Ref{Int32}()
  @MSK_getmaxnumcon(task.task,maxnumcon_)
  maxnumcon_[]
end


function getmaxnumvar(task::MSKtask)
  maxnumvar_ = Ref{Int32}()
  @MSK_getmaxnumvar(task.task,maxnumvar_)
  maxnumvar_[]
end


function getnadouinf(task::MSKtask,infitemname::AbstractString)
  infitemname_ = Vector{UInt8}(infitemname); push!(infitemname_,UInt8(0))
  dvalue_ = Ref{Float64}()
  @MSK_getnadouinf(task.task,infitemname_,dvalue_)
  dvalue_[]
end


function getnadouparam(task::MSKtask,paramname::AbstractString)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  parvalue_ = Ref{Float64}()
  @MSK_getnadouparam(task.task,paramname_,parvalue_)
  parvalue_[]
end


function getnaintinf(task::MSKtask,infitemname::AbstractString)
  infitemname_ = Vector{UInt8}(infitemname); push!(infitemname_,UInt8(0))
  ivalue_ = Ref{Int32}()
  @MSK_getnaintinf(task.task,infitemname_,ivalue_)
  ivalue_[]
end


function getnaintparam(task::MSKtask,paramname::AbstractString)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  parvalue_ = Ref{Int32}()
  @MSK_getnaintparam(task.task,paramname_,parvalue_)
  parvalue_[]
end


function getbarvarnamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getbarvarnamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getbarvarnamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getbarvarnamelen(
    task,
    convert(Int32,i))
end


function getbarvarname(task::MSKtask,i::Int32)
  __tmp_96 = Ref{Int32}()
  @MSK_getbarvarnamelen(task.task,i-Int32(1),__tmp_96)
  __tmp_95 = __tmp_96[]
  sizename = Int32((1 + __tmp_95))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getbarvarname(task.task,i-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getbarvarname(task::MSKtask,i::T0) where { T0<:Integer }
  getbarvarname(
    task,
    convert(Int32,i))
end


function getbarvarnameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getbarvarnameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]
end


function putconname(task::MSKtask,i::Int32,name::Union{Nothing,AbstractString})
  if name === nothing
      name_ = C_NULL
  else
      name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  end
  @MSK_putconname(task.task,i-Int32(1),name_)
  nothing
end
function putconname(task::MSKtask,i::T0,name::Union{Nothing,AbstractString}) where { T0<:Integer }
  putconname(
    task,
    convert(Int32,i),
    name)
end


function putvarname(task::MSKtask,j::Int32,name::Union{Nothing,AbstractString})
  if name === nothing
      name_ = C_NULL
  else
      name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  end
  @MSK_putvarname(task.task,j-Int32(1),name_)
  nothing
end
function putvarname(task::MSKtask,j::T0,name::Union{Nothing,AbstractString}) where { T0<:Integer }
  putvarname(
    task,
    convert(Int32,j),
    name)
end


function putconename(task::MSKtask,j::Int32,name::Union{Nothing,AbstractString})
  if name === nothing
      name_ = C_NULL
  else
      name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  end
  @MSK_putconename(task.task,j-Int32(1),name_)
  nothing
end
function putconename(task::MSKtask,j::T0,name::Union{Nothing,AbstractString}) where { T0<:Integer }
  putconename(
    task,
    convert(Int32,j),
    name)
end


function putbarvarname(task::MSKtask,j::Int32,name::Union{Nothing,AbstractString})
  if name === nothing
      name_ = C_NULL
  else
      name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  end
  @MSK_putbarvarname(task.task,j-Int32(1),name_)
  nothing
end
function putbarvarname(task::MSKtask,j::T0,name::Union{Nothing,AbstractString}) where { T0<:Integer }
  putbarvarname(
    task,
    convert(Int32,j),
    name)
end


function putdomainname(task::MSKtask,domidx::Int64,name::Union{Nothing,AbstractString})
  if name === nothing
      name_ = C_NULL
  else
      name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  end
  @MSK_putdomainname(task.task,domidx-Int64(1),name_)
  nothing
end
function putdomainname(task::MSKtask,domidx::T0,name::Union{Nothing,AbstractString}) where { T0<:Integer }
  putdomainname(
    task,
    convert(Int64,domidx),
    name)
end


function putdjcname(task::MSKtask,djcidx::Int64,name::Union{Nothing,AbstractString})
  if name === nothing
      name_ = C_NULL
  else
      name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  end
  @MSK_putdjcname(task.task,djcidx-Int64(1),name_)
  nothing
end
function putdjcname(task::MSKtask,djcidx::T0,name::Union{Nothing,AbstractString}) where { T0<:Integer }
  putdjcname(
    task,
    convert(Int64,djcidx),
    name)
end


function putaccname(task::MSKtask,accidx::Int64,name::Union{Nothing,AbstractString})
  if name === nothing
      name_ = C_NULL
  else
      name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  end
  @MSK_putaccname(task.task,accidx-Int64(1),name_)
  nothing
end
function putaccname(task::MSKtask,accidx::T0,name::Union{Nothing,AbstractString}) where { T0<:Integer }
  putaccname(
    task,
    convert(Int64,accidx),
    name)
end


function getvarnamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getvarnamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getvarnamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getvarnamelen(
    task,
    convert(Int32,i))
end


function getvarname(task::MSKtask,j::Int32)
  __tmp_108 = Ref{Int32}()
  @MSK_getvarnamelen(task.task,j-Int32(1),__tmp_108)
  __tmp_107 = __tmp_108[]
  sizename = Int32((1 + __tmp_107))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getvarname(task.task,j-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getvarname(task::MSKtask,j::T0) where { T0<:Integer }
  getvarname(
    task,
    convert(Int32,j))
end


function getconnamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getconnamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getconnamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getconnamelen(
    task,
    convert(Int32,i))
end


function getconname(task::MSKtask,i::Int32)
  __tmp_112 = Ref{Int32}()
  @MSK_getconnamelen(task.task,i-Int32(1),__tmp_112)
  __tmp_111 = __tmp_112[]
  sizename = Int32((1 + __tmp_111))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getconname(task.task,i-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getconname(task::MSKtask,i::T0) where { T0<:Integer }
  getconname(
    task,
    convert(Int32,i))
end


function getconnameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getconnameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]+Int32(1)
end


function getvarnameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getvarnameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]+Int32(1)
end


function getconenamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getconenamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getconenamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getconenamelen(
    task,
    convert(Int32,i))
end


function getconename(task::MSKtask,i::Int32)
  __tmp_118 = Ref{Int32}()
  @MSK_getconenamelen(task.task,i-Int32(1),__tmp_118)
  __tmp_117 = __tmp_118[]
  sizename = Int32((1 + __tmp_117))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getconename(task.task,i-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getconename(task::MSKtask,i::T0) where { T0<:Integer }
  getconename(
    task,
    convert(Int32,i))
end


function getconenameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getconenameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]
end


function getdomainnamelen(task::MSKtask,domidx::Int64)
  len_ = Ref{Int32}()
  @MSK_getdomainnamelen(task.task,domidx-Int64(1),len_)
  len_[]
end
function getdomainnamelen(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomainnamelen(
    task,
    convert(Int64,domidx))
end


function getdomainname(task::MSKtask,domidx::Int64)
  __tmp_123 = Ref{Int32}()
  @MSK_getdomainnamelen(task.task,domidx-Int64(1),__tmp_123)
  __tmp_122 = __tmp_123[]
  sizename = Int32((1 + __tmp_122))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getdomainname(task.task,domidx-Int64(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getdomainname(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomainname(
    task,
    convert(Int64,domidx))
end


function getdjcnamelen(task::MSKtask,djcidx::Int64)
  len_ = Ref{Int32}()
  @MSK_getdjcnamelen(task.task,djcidx-Int64(1),len_)
  len_[]
end
function getdjcnamelen(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnamelen(
    task,
    convert(Int64,djcidx))
end


function getdjcname(task::MSKtask,djcidx::Int64)
  __tmp_127 = Ref{Int32}()
  @MSK_getdjcnamelen(task.task,djcidx-Int64(1),__tmp_127)
  __tmp_126 = __tmp_127[]
  sizename = Int32((1 + __tmp_126))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getdjcname(task.task,djcidx-Int64(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getdjcname(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcname(
    task,
    convert(Int64,djcidx))
end


function getaccnamelen(task::MSKtask,accidx::Int64)
  len_ = Ref{Int32}()
  @MSK_getaccnamelen(task.task,accidx-Int64(1),len_)
  len_[]
end
function getaccnamelen(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccnamelen(
    task,
    convert(Int64,accidx))
end


function getaccname(task::MSKtask,accidx::Int64)
  __tmp_131 = Ref{Int32}()
  @MSK_getaccnamelen(task.task,accidx-Int64(1),__tmp_131)
  __tmp_130 = __tmp_131[]
  sizename = Int32((1 + __tmp_130))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getaccname(task.task,accidx-Int64(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getaccname(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccname(
    task,
    convert(Int64,accidx))
end


function getnastrparam(task::MSKtask,paramname::AbstractString,sizeparamname::Int32)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  len_ = Ref{Int32}()
  parvalue_ = Array{UInt8}(undef,sizeparamname)
  @MSK_getnastrparam(task.task,paramname_,sizeparamname,len_,parvalue_)
  parvalue_len = findfirst(_c->_c==0,parvalue_)
  parvalue = if parvalue_len === nothing
    String(parvalue_)
  else
    String(parvalue_[1:parvalue_len-1])
  end
  len_[],parvalue
end
function getnastrparam(task::MSKtask,paramname::Union{Nothing,AbstractString},sizeparamname::T0) where { T0<:Integer }
  getnastrparam(
    task,
    paramname,
    convert(Int32,sizeparamname))
end


function getnumanz(task::MSKtask)
  numanz_ = Ref{Int32}()
  @MSK_getnumanz(task.task,numanz_)
  numanz_[]
end


function getnumanz64(task::MSKtask)
  numanz_ = Ref{Int64}()
  @MSK_getnumanz64(task.task,numanz_)
  numanz_[]
end


function getnumcon(task::MSKtask)
  numcon_ = Ref{Int32}()
  @MSK_getnumcon(task.task,numcon_)
  numcon_[]
end


function getnumcone(task::MSKtask)
  numcone_ = Ref{Int32}()
  @MSK_getnumcone(task.task,numcone_)
  numcone_[]
end


function getnumconemem(task::MSKtask,k::Int32)
  nummem_ = Ref{Int32}()
  @MSK_getnumconemem(task.task,k-Int32(1),nummem_)
  nummem_[]
end
function getnumconemem(task::MSKtask,k::T0) where { T0<:Integer }
  getnumconemem(
    task,
    convert(Int32,k))
end


function getnumintvar(task::MSKtask)
  numintvar_ = Ref{Int32}()
  @MSK_getnumintvar(task.task,numintvar_)
  numintvar_[]
end


function getnumparam(task::MSKtask,partype::Parametertype)
  numparam_ = Ref{Int32}()
  @MSK_getnumparam(task.task,partype.value,numparam_)
  numparam_[]
end


function getnumqconknz(task::MSKtask,k::Int32)
  numqcnz_ = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),numqcnz_)
  numqcnz_[]
end
function getnumqconknz(task::MSKtask,k::T0) where { T0<:Integer }
  getnumqconknz(
    task,
    convert(Int32,k))
end


function getnumqobjnz(task::MSKtask)
  numqonz_ = Ref{Int64}()
  @MSK_getnumqobjnz64(task.task,numqonz_)
  numqonz_[]
end


function getnumvar(task::MSKtask)
  numvar_ = Ref{Int32}()
  @MSK_getnumvar(task.task,numvar_)
  numvar_[]
end


function getnumbarvar(task::MSKtask)
  numbarvar_ = Ref{Int32}()
  @MSK_getnumbarvar(task.task,numbarvar_)
  numbarvar_[]
end


function getmaxnumbarvar(task::MSKtask)
  maxnumbarvar_ = Ref{Int32}()
  @MSK_getmaxnumbarvar(task.task,maxnumbarvar_)
  maxnumbarvar_[]
end


function getdimbarvarj(task::MSKtask,j::Int32)
  dimbarvarj_ = Ref{Int32}()
  @MSK_getdimbarvarj(task.task,j-Int32(1),dimbarvarj_)
  dimbarvarj_[]
end
function getdimbarvarj(task::MSKtask,j::T0) where { T0<:Integer }
  getdimbarvarj(
    task,
    convert(Int32,j))
end


function getlenbarvarj(task::MSKtask,j::Int32)
  lenbarvarj_ = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),lenbarvarj_)
  lenbarvarj_[]
end
function getlenbarvarj(task::MSKtask,j::T0) where { T0<:Integer }
  getlenbarvarj(
    task,
    convert(Int32,j))
end


function getobjname(task::MSKtask)
  __tmp_149 = Ref{Int32}()
  @MSK_getobjnamelen(task.task,__tmp_149)
  __tmp_148 = __tmp_149[]
  sizeobjname = Int32((1 + __tmp_148))
  objname_ = Array{UInt8}(undef,sizeobjname)
  @MSK_getobjname(task.task,sizeobjname,objname_)
  objname_len = findfirst(_c->_c==0,objname_)
  objname = if objname_len === nothing
    String(objname_)
  else
    String(objname_[1:objname_len-1])
  end
  objname
end


function getobjnamelen(task::MSKtask)
  len_ = Ref{Int32}()
  @MSK_getobjnamelen(task.task,len_)
  len_[]
end


function getparamname(task::MSKtask,partype::Parametertype,param::Int32)
  parname_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_getparamname(task.task,partype.value,param,parname_)
  parname_len = findfirst(_c->_c==0,parname_)
  parname = if parname_len === nothing
    String(parname_)
  else
    String(parname_[1:parname_len-1])
  end
  parname
end
function getparamname(task::MSKtask,partype::Parametertype,param::T0) where { T0<:Integer }
  getparamname(
    task,
    partype,
    convert(Int32,param))
end


function getprimalobj(task::MSKtask,whichsol::Soltype)
  primalobj_ = Ref{Float64}()
  @MSK_getprimalobj(task.task,whichsol.value,primalobj_)
  primalobj_[]
end


function getprobtype(task::MSKtask)
  probtype_ = Ref{Int32}()
  @MSK_getprobtype(task.task,probtype_)
  probtype = Problemtype(probtype_[])
  probtype
end


function getqconk(task::MSKtask,k::Int32)
  __tmp_156 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_156)
  __tmp_155 = __tmp_156[]
  maxnumqcnz = Int64(__tmp_155)
  numqcnz_ = Ref{Int64}()
  __tmp_158 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_158)
  __tmp_157 = __tmp_158[]
  qcsubi_ = Vector{Int32}(undef,__tmp_157)
  __tmp_160 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_160)
  __tmp_159 = __tmp_160[]
  qcsubj_ = Vector{Int32}(undef,__tmp_159)
  __tmp_162 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_162)
  __tmp_161 = __tmp_162[]
  qcval_ = Vector{Float64}(undef,__tmp_161)
  @MSK_getqconk64(task.task,k-Int32(1),maxnumqcnz,numqcnz_,qcsubi_,qcsubj_,qcval_)
  qcsubi = qcsubi_;
  qcsubi .+= 1
  qcsubj = qcsubj_;
  qcsubj .+= 1
  qcval = qcval_;
  numqcnz_[],qcsubi,qcsubj,qcval
end
function getqconk(task::MSKtask,k::T0) where { T0<:Integer }
  getqconk(
    task,
    convert(Int32,k))
end


function getqobj(task::MSKtask)
  __tmp_169 = Ref{Int64}()
  @MSK_getnumqobjnz64(task.task,__tmp_169)
  __tmp_168 = __tmp_169[]
  maxnumqonz = Int64(__tmp_168)
  numqonz_ = Ref{Int64}()
  qosubi_ = Vector{Int32}(undef,maxnumqonz)
  qosubj_ = Vector{Int32}(undef,maxnumqonz)
  qoval_ = Vector{Float64}(undef,maxnumqonz)
  @MSK_getqobj64(task.task,maxnumqonz,numqonz_,qosubi_,qosubj_,qoval_)
  qosubi = qosubi_;
  qosubi .+= 1
  qosubj = qosubj_;
  qosubj .+= 1
  qoval = qoval_;
  numqonz_[],qosubi,qosubj,qoval
end


function getqobjij(task::MSKtask,i::Int32,j::Int32)
  qoij_ = Ref{Float64}()
  @MSK_getqobjij(task.task,i-Int32(1),j-Int32(1),qoij_)
  qoij_[]
end
function getqobjij(task::MSKtask,i::T0,j::T1) where { T0<:Integer,T1<:Integer }
  getqobjij(
    task,
    convert(Int32,i),
    convert(Int32,j))
end


function getsolution(task::MSKtask,whichsol::Soltype)
  problemsta_ = Ref{Int32}()
  solutionsta_ = Ref{Int32}()
  __tmp_173 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_173)
  __tmp_172 = __tmp_173[]
  __tmp_173 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_173)
  __tmp_172 = __tmp_173[]
  skc_ = Vector{Int32}(undef,__tmp_172)
  __tmp_175 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_175)
  __tmp_174 = __tmp_175[]
  __tmp_175 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_175)
  __tmp_174 = __tmp_175[]
  skx_ = Vector{Int32}(undef,__tmp_174)
  __tmp_177 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_177)
  __tmp_176 = __tmp_177[]
  __tmp_177 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_177)
  __tmp_176 = __tmp_177[]
  skn_ = Vector{Int32}(undef,__tmp_176)
  __tmp_179 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_179)
  __tmp_178 = __tmp_179[]
  xc_ = Vector{Float64}(undef,__tmp_178)
  __tmp_181 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_181)
  __tmp_180 = __tmp_181[]
  xx_ = Vector{Float64}(undef,__tmp_180)
  __tmp_183 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_183)
  __tmp_182 = __tmp_183[]
  y_ = Vector{Float64}(undef,__tmp_182)
  __tmp_185 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_185)
  __tmp_184 = __tmp_185[]
  slc_ = Vector{Float64}(undef,__tmp_184)
  __tmp_187 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_187)
  __tmp_186 = __tmp_187[]
  suc_ = Vector{Float64}(undef,__tmp_186)
  __tmp_189 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_189)
  __tmp_188 = __tmp_189[]
  slx_ = Vector{Float64}(undef,__tmp_188)
  __tmp_191 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_191)
  __tmp_190 = __tmp_191[]
  sux_ = Vector{Float64}(undef,__tmp_190)
  __tmp_193 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_193)
  __tmp_192 = __tmp_193[]
  snx_ = Vector{Float64}(undef,__tmp_192)
  @MSK_getsolution(task.task,whichsol.value,problemsta_,solutionsta_,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_)
  problemsta = Prosta(problemsta_[])
  solutionsta = Solsta(solutionsta_[])
  skc = Stakey[Stakey(item) for item in skc_]
  skx = Stakey[Stakey(item) for item in skx_]
  skn = Stakey[Stakey(item) for item in skn_]
  xc = xc_;
  xx = xx_;
  y = y_;
  slc = slc_;
  suc = suc_;
  slx = slx_;
  sux = sux_;
  snx = snx_;
  problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx
end


function getsolutionnew(task::MSKtask,whichsol::Soltype)
  problemsta_ = Ref{Int32}()
  solutionsta_ = Ref{Int32}()
  __tmp_196 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_196)
  __tmp_195 = __tmp_196[]
  __tmp_196 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_196)
  __tmp_195 = __tmp_196[]
  skc_ = Vector{Int32}(undef,__tmp_195)
  __tmp_198 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_198)
  __tmp_197 = __tmp_198[]
  __tmp_198 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_198)
  __tmp_197 = __tmp_198[]
  skx_ = Vector{Int32}(undef,__tmp_197)
  __tmp_200 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_200)
  __tmp_199 = __tmp_200[]
  __tmp_200 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_200)
  __tmp_199 = __tmp_200[]
  skn_ = Vector{Int32}(undef,__tmp_199)
  __tmp_202 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_202)
  __tmp_201 = __tmp_202[]
  xc_ = Vector{Float64}(undef,__tmp_201)
  __tmp_204 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_204)
  __tmp_203 = __tmp_204[]
  xx_ = Vector{Float64}(undef,__tmp_203)
  __tmp_206 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_206)
  __tmp_205 = __tmp_206[]
  y_ = Vector{Float64}(undef,__tmp_205)
  __tmp_208 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_208)
  __tmp_207 = __tmp_208[]
  slc_ = Vector{Float64}(undef,__tmp_207)
  __tmp_210 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_210)
  __tmp_209 = __tmp_210[]
  suc_ = Vector{Float64}(undef,__tmp_209)
  __tmp_212 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_212)
  __tmp_211 = __tmp_212[]
  slx_ = Vector{Float64}(undef,__tmp_211)
  __tmp_214 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_214)
  __tmp_213 = __tmp_214[]
  sux_ = Vector{Float64}(undef,__tmp_213)
  __tmp_216 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_216)
  __tmp_215 = __tmp_216[]
  snx_ = Vector{Float64}(undef,__tmp_215)
  __tmp_218 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_218)
  __tmp_217 = __tmp_218[]
  doty_ = Vector{Float64}(undef,__tmp_217)
  @MSK_getsolutionnew(task.task,whichsol.value,problemsta_,solutionsta_,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_,doty_)
  problemsta = Prosta(problemsta_[])
  solutionsta = Solsta(solutionsta_[])
  skc = Stakey[Stakey(item) for item in skc_]
  skx = Stakey[Stakey(item) for item in skx_]
  skn = Stakey[Stakey(item) for item in skn_]
  xc = xc_;
  xx = xx_;
  y = y_;
  slc = slc_;
  suc = suc_;
  slx = slx_;
  sux = sux_;
  snx = snx_;
  doty = doty_;
  problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty
end


function getsolsta(task::MSKtask,whichsol::Soltype)
  solutionsta_ = Ref{Int32}()
  @MSK_getsolsta(task.task,whichsol.value,solutionsta_)
  solutionsta = Solsta(solutionsta_[])
  solutionsta
end


function getprosta(task::MSKtask,whichsol::Soltype)
  problemsta_ = Ref{Int32}()
  @MSK_getprosta(task.task,whichsol.value,problemsta_)
  problemsta = Prosta(problemsta_[])
  problemsta
end


function getskc(task::MSKtask,whichsol::Soltype)
  __tmp_223 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_223)
  __tmp_222 = __tmp_223[]
  __tmp_223 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_223)
  __tmp_222 = __tmp_223[]
  skc_ = Vector{Int32}(undef,__tmp_222)
  @MSK_getskc(task.task,whichsol.value,skc_)
  skc = Stakey[Stakey(item) for item in skc_]
  skc
end


function getskx(task::MSKtask,whichsol::Soltype)
  __tmp_226 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_226)
  __tmp_225 = __tmp_226[]
  __tmp_226 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_226)
  __tmp_225 = __tmp_226[]
  skx_ = Vector{Int32}(undef,__tmp_225)
  @MSK_getskx(task.task,whichsol.value,skx_)
  skx = Stakey[Stakey(item) for item in skx_]
  skx
end


function getskn(task::MSKtask,whichsol::Soltype)
  __tmp_229 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_229)
  __tmp_228 = __tmp_229[]
  __tmp_229 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_229)
  __tmp_228 = __tmp_229[]
  skn_ = Vector{Int32}(undef,__tmp_228)
  @MSK_getskn(task.task,whichsol.value,skn_)
  skn = Stakey[Stakey(item) for item in skn_]
  skn
end


function getxc(task::MSKtask,whichsol::Soltype)
  __tmp_232 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_232)
  __tmp_231 = __tmp_232[]
  xc_ = Vector{Float64}(undef,__tmp_231)
  @MSK_getxc(task.task,whichsol.value,xc_)
  xc = xc_;
  xc
end


function getxx(task::MSKtask,whichsol::Soltype)
  __tmp_235 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_235)
  __tmp_234 = __tmp_235[]
  xx_ = Vector{Float64}(undef,__tmp_234)
  @MSK_getxx(task.task,whichsol.value,xx_)
  xx = xx_;
  xx
end


function gety(task::MSKtask,whichsol::Soltype)
  __tmp_238 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_238)
  __tmp_237 = __tmp_238[]
  y_ = Vector{Float64}(undef,__tmp_237)
  @MSK_gety(task.task,whichsol.value,y_)
  y = y_;
  y
end


function getslc(task::MSKtask,whichsol::Soltype)
  __tmp_241 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_241)
  __tmp_240 = __tmp_241[]
  slc_ = Vector{Float64}(undef,__tmp_240)
  @MSK_getslc(task.task,whichsol.value,slc_)
  slc = slc_;
  slc
end


function getaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64)
  __tmp_244 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_244)
  __tmp_243 = __tmp_244[]
  doty_ = Vector{Float64}(undef,__tmp_243)
  @MSK_getaccdoty(task.task,whichsol.value,accidx-Int64(1),doty_)
  doty = doty_;
  doty
end
function getaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where { T0<:Integer }
  getaccdoty(
    task,
    whichsol,
    convert(Int64,accidx))
end


function getaccdotys(task::MSKtask,whichsol::Soltype)
  __tmp_247 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_247)
  __tmp_246 = __tmp_247[]
  doty_ = Vector{Float64}(undef,__tmp_246)
  @MSK_getaccdotys(task.task,whichsol.value,doty_)
  doty = doty_;
  doty
end


function evaluateacc(task::MSKtask,whichsol::Soltype,accidx::Int64)
  __tmp_250 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_250)
  __tmp_249 = __tmp_250[]
  activity_ = Vector{Float64}(undef,__tmp_249)
  @MSK_evaluateacc(task.task,whichsol.value,accidx-Int64(1),activity_)
  activity = activity_;
  activity
end
function evaluateacc(task::MSKtask,whichsol::Soltype,accidx::T0) where { T0<:Integer }
  evaluateacc(
    task,
    whichsol,
    convert(Int64,accidx))
end


function evaluateaccs(task::MSKtask,whichsol::Soltype)
  __tmp_253 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_253)
  __tmp_252 = __tmp_253[]
  activity_ = Vector{Float64}(undef,__tmp_252)
  @MSK_evaluateaccs(task.task,whichsol.value,activity_)
  activity = activity_;
  activity
end


function getsuc(task::MSKtask,whichsol::Soltype)
  __tmp_256 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_256)
  __tmp_255 = __tmp_256[]
  suc_ = Vector{Float64}(undef,__tmp_255)
  @MSK_getsuc(task.task,whichsol.value,suc_)
  suc = suc_;
  suc
end


function getslx(task::MSKtask,whichsol::Soltype)
  __tmp_259 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_259)
  __tmp_258 = __tmp_259[]
  slx_ = Vector{Float64}(undef,__tmp_258)
  @MSK_getslx(task.task,whichsol.value,slx_)
  slx = slx_;
  slx
end


function getsux(task::MSKtask,whichsol::Soltype)
  __tmp_262 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_262)
  __tmp_261 = __tmp_262[]
  sux_ = Vector{Float64}(undef,__tmp_261)
  @MSK_getsux(task.task,whichsol.value,sux_)
  sux = sux_;
  sux
end


function getsnx(task::MSKtask,whichsol::Soltype)
  __tmp_265 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_265)
  __tmp_264 = __tmp_265[]
  snx_ = Vector{Float64}(undef,__tmp_264)
  @MSK_getsnx(task.task,whichsol.value,snx_)
  snx = snx_;
  snx
end


function getskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  skc_ = Vector{Int32}(undef,(last - first))
  @MSK_getskcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skc_)
  skc = Stakey[Stakey(item) for item in skc_]
  skc
end
function getskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getskcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  skx_ = Vector{Int32}(undef,(last - first))
  @MSK_getskxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skx_)
  skx = Stakey[Stakey(item) for item in skx_]
  skx
end
function getskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getskxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  xc_ = Vector{Float64}(undef,(last - first))
  @MSK_getxcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xc_)
  xc = xc_;
  xc
end
function getxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getxcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  xx_ = Vector{Float64}(undef,(last - first))
  @MSK_getxxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xx_)
  xx = xx_;
  xx
end
function getxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getxxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  y_ = Vector{Float64}(undef,(last - first))
  @MSK_getyslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),y_)
  y = y_;
  y
end
function getyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getyslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  slc_ = Vector{Float64}(undef,(last - first))
  @MSK_getslcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slc_)
  slc = slc_;
  slc
end
function getslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getslcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  suc_ = Vector{Float64}(undef,(last - first))
  @MSK_getsucslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),suc_)
  suc = suc_;
  suc
end
function getsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsucslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  slx_ = Vector{Float64}(undef,(last - first))
  @MSK_getslxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slx_)
  slx = slx_;
  slx
end
function getslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getslxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  sux_ = Vector{Float64}(undef,(last - first))
  @MSK_getsuxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),sux_)
  sux = sux_;
  sux
end
function getsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsuxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  snx_ = Vector{Float64}(undef,(last - first))
  @MSK_getsnxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),snx_)
  snx = snx_;
  snx
end
function getsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsnxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getbarxj(task::MSKtask,whichsol::Soltype,j::Int32)
  __tmp_278 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_278)
  __tmp_277 = __tmp_278[]
  barxj_ = Vector{Float64}(undef,__tmp_277)
  @MSK_getbarxj(task.task,whichsol.value,j-Int32(1),barxj_)
  barxj = barxj_;
  barxj
end
function getbarxj(task::MSKtask,whichsol::Soltype,j::T0) where { T0<:Integer }
  getbarxj(
    task,
    whichsol,
    convert(Int32,j))
end


function getbarxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64)
  barxslice_ = Vector{Float64}(undef,slicesize)
  @MSK_getbarxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slicesize,barxslice_)
  barxslice = barxslice_;
  barxslice
end
function getbarxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where { T0<:Integer,T1<:Integer,T2<:Integer }
  getbarxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Int64,slicesize))
end


function getbarsj(task::MSKtask,whichsol::Soltype,j::Int32)
  __tmp_282 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_282)
  __tmp_281 = __tmp_282[]
  barsj_ = Vector{Float64}(undef,__tmp_281)
  @MSK_getbarsj(task.task,whichsol.value,j-Int32(1),barsj_)
  barsj = barsj_;
  barsj
end
function getbarsj(task::MSKtask,whichsol::Soltype,j::T0) where { T0<:Integer }
  getbarsj(
    task,
    whichsol,
    convert(Int32,j))
end


function getbarsslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64)
  barsslice_ = Vector{Float64}(undef,slicesize)
  @MSK_getbarsslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slicesize,barsslice_)
  barsslice = barsslice_;
  barsslice
end
function getbarsslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where { T0<:Integer,T1<:Integer,T2<:Integer }
  getbarsslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Int64,slicesize))
end


function putskc(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey})
  __tmp_286 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_286)
  __tmp_285 = __tmp_286[]
  if length(skc) < __tmp_285
    throw(BoundsError())
  end
  skc_ = Int32[item.value for item in skc]
  @MSK_putskc(task.task,whichsol.value,skc_)
  nothing
end


function putskx(task::MSKtask,whichsol::Soltype,skx::Vector{Stakey})
  __tmp_289 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_289)
  __tmp_288 = __tmp_289[]
  if length(skx) < __tmp_288
    throw(BoundsError())
  end
  skx_ = Int32[item.value for item in skx]
  @MSK_putskx(task.task,whichsol.value,skx_)
  nothing
end


function putxc(task::MSKtask,whichsol::Soltype)
  __tmp_292 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_292)
  __tmp_291 = __tmp_292[]
  xc_ = Vector{Float64}(undef,__tmp_291)
  @MSK_putxc(task.task,whichsol.value,xc_)
  xc = xc_;
  xc
end


function putxx(task::MSKtask,whichsol::Soltype,xx::Vector{Float64})
  __tmp_295 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_295)
  __tmp_294 = __tmp_295[]
  if xx !== nothing && length(xx) < __tmp_294
    throw(BoundsError())
  end
  xx_ = xx
  @MSK_putxx(task.task,whichsol.value,xx_)
  nothing
end
function putxx(task::MSKtask,whichsol::Soltype,xx::T0) where { T0<:AbstractVector{<:Number} }
  putxx(
    task,
    whichsol,
    if xx === nothing; nothing; else convert(Vector{Float64},xx); end)
end


function puty(task::MSKtask,whichsol::Soltype,y::Vector{Float64})
  __tmp_298 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_298)
  __tmp_297 = __tmp_298[]
  if y !== nothing && length(y) < __tmp_297
    throw(BoundsError())
  end
  y_ = y
  @MSK_puty(task.task,whichsol.value,y_)
  nothing
end
function puty(task::MSKtask,whichsol::Soltype,y::T0) where { T0<:AbstractVector{<:Number} }
  puty(
    task,
    whichsol,
    if y === nothing; nothing; else convert(Vector{Float64},y); end)
end


function putslc(task::MSKtask,whichsol::Soltype,slc::Vector{Float64})
  __tmp_301 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_301)
  __tmp_300 = __tmp_301[]
  if slc !== nothing && length(slc) < __tmp_300
    throw(BoundsError())
  end
  slc_ = slc
  @MSK_putslc(task.task,whichsol.value,slc_)
  nothing
end
function putslc(task::MSKtask,whichsol::Soltype,slc::T0) where { T0<:AbstractVector{<:Number} }
  putslc(
    task,
    whichsol,
    if slc === nothing; nothing; else convert(Vector{Float64},slc); end)
end


function putsuc(task::MSKtask,whichsol::Soltype,suc::Vector{Float64})
  __tmp_304 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_304)
  __tmp_303 = __tmp_304[]
  if suc !== nothing && length(suc) < __tmp_303
    throw(BoundsError())
  end
  suc_ = suc
  @MSK_putsuc(task.task,whichsol.value,suc_)
  nothing
end
function putsuc(task::MSKtask,whichsol::Soltype,suc::T0) where { T0<:AbstractVector{<:Number} }
  putsuc(
    task,
    whichsol,
    if suc === nothing; nothing; else convert(Vector{Float64},suc); end)
end


function putslx(task::MSKtask,whichsol::Soltype,slx::Vector{Float64})
  __tmp_307 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_307)
  __tmp_306 = __tmp_307[]
  if slx !== nothing && length(slx) < __tmp_306
    throw(BoundsError())
  end
  slx_ = slx
  @MSK_putslx(task.task,whichsol.value,slx_)
  nothing
end
function putslx(task::MSKtask,whichsol::Soltype,slx::T0) where { T0<:AbstractVector{<:Number} }
  putslx(
    task,
    whichsol,
    if slx === nothing; nothing; else convert(Vector{Float64},slx); end)
end


function putsux(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
  __tmp_310 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_310)
  __tmp_309 = __tmp_310[]
  if sux !== nothing && length(sux) < __tmp_309
    throw(BoundsError())
  end
  sux_ = sux
  @MSK_putsux(task.task,whichsol.value,sux_)
  nothing
end
function putsux(task::MSKtask,whichsol::Soltype,sux::T0) where { T0<:AbstractVector{<:Number} }
  putsux(
    task,
    whichsol,
    if sux === nothing; nothing; else convert(Vector{Float64},sux); end)
end


function putsnx(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
  __tmp_313 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_313)
  __tmp_312 = __tmp_313[]
  if sux !== nothing && length(sux) < __tmp_312
    throw(BoundsError())
  end
  sux_ = sux
  @MSK_putsnx(task.task,whichsol.value,sux_)
  nothing
end
function putsnx(task::MSKtask,whichsol::Soltype,sux::T0) where { T0<:AbstractVector{<:Number} }
  putsnx(
    task,
    whichsol,
    if sux === nothing; nothing; else convert(Vector{Float64},sux); end)
end


function putaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64)
  __tmp_316 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_316)
  __tmp_315 = __tmp_316[]
  doty_ = Vector{Float64}(undef,__tmp_315)
  @MSK_putaccdoty(task.task,whichsol.value,accidx,doty_)
  doty = doty_;
  doty
end
function putaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where { T0<:Integer }
  putaccdoty(
    task,
    whichsol,
    convert(Int64,accidx))
end


function putskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skc::Vector{Stakey})
  if length(skc) < (last - first)
    throw(BoundsError())
  end
  skc_ = Int32[item.value for item in skc]
  @MSK_putskcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skc_)
  nothing
end
function putskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skc::Vector{Stakey}) where { T0<:Integer,T1<:Integer }
  putskcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    skc)
end


function putskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skx::Vector{Stakey})
  if length(skx) < (last - first)
    throw(BoundsError())
  end
  skx_ = Int32[item.value for item in skx]
  @MSK_putskxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skx_)
  nothing
end
function putskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skx::Vector{Stakey}) where { T0<:Integer,T1<:Integer }
  putskxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    skx)
end


function putxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xc::Vector{Float64})
  if xc !== nothing && length(xc) < (last - first)
    throw(BoundsError())
  end
  xc_ = xc
  @MSK_putxcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xc_)
  nothing
end
function putxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xc::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putxcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if xc === nothing; nothing; else convert(Vector{Float64},xc); end)
end


function putxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xx::Vector{Float64})
  if xx !== nothing && length(xx) < (last - first)
    throw(BoundsError())
  end
  xx_ = xx
  @MSK_putxxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xx_)
  nothing
end
function putxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xx::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putxxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if xx === nothing; nothing; else convert(Vector{Float64},xx); end)
end


function putyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,y::Vector{Float64})
  if y !== nothing && length(y) < (last - first)
    throw(BoundsError())
  end
  y_ = y
  @MSK_putyslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),y_)
  nothing
end
function putyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,y::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putyslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if y === nothing; nothing; else convert(Vector{Float64},y); end)
end


function putslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slc::Vector{Float64})
  if slc !== nothing && length(slc) < (last - first)
    throw(BoundsError())
  end
  slc_ = slc
  @MSK_putslcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slc_)
  nothing
end
function putslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slc::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putslcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if slc === nothing; nothing; else convert(Vector{Float64},slc); end)
end


function putsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,suc::Vector{Float64})
  if suc !== nothing && length(suc) < (last - first)
    throw(BoundsError())
  end
  suc_ = suc
  @MSK_putsucslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),suc_)
  nothing
end
function putsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,suc::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putsucslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if suc === nothing; nothing; else convert(Vector{Float64},suc); end)
end


function putslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slx::Vector{Float64})
  if slx !== nothing && length(slx) < (last - first)
    throw(BoundsError())
  end
  slx_ = slx
  @MSK_putslxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slx_)
  nothing
end
function putslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slx::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putslxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if slx === nothing; nothing; else convert(Vector{Float64},slx); end)
end


function putsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,sux::Vector{Float64})
  if sux !== nothing && length(sux) < (last - first)
    throw(BoundsError())
  end
  sux_ = sux
  @MSK_putsuxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),sux_)
  nothing
end
function putsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,sux::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putsuxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if sux === nothing; nothing; else convert(Vector{Float64},sux); end)
end


function putsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,snx::Vector{Float64})
  if snx !== nothing && length(snx) < (last - first)
    throw(BoundsError())
  end
  snx_ = snx
  @MSK_putsnxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),snx_)
  nothing
end
function putsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,snx::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putsnxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    if snx === nothing; nothing; else convert(Vector{Float64},snx); end)
end


function putbarxj(task::MSKtask,whichsol::Soltype,j::Int32,barxj::Vector{Float64})
  __tmp_329 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_329)
  __tmp_328 = __tmp_329[]
  if barxj !== nothing && length(barxj) < __tmp_328
    throw(BoundsError())
  end
  barxj_ = barxj
  @MSK_putbarxj(task.task,whichsol.value,j-Int32(1),barxj_)
  nothing
end
function putbarxj(task::MSKtask,whichsol::Soltype,j::T0,barxj::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  putbarxj(
    task,
    whichsol,
    convert(Int32,j),
    if barxj === nothing; nothing; else convert(Vector{Float64},barxj); end)
end


function putbarsj(task::MSKtask,whichsol::Soltype,j::Int32,barsj::Vector{Float64})
  __tmp_332 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_332)
  __tmp_331 = __tmp_332[]
  if barsj !== nothing && length(barsj) < __tmp_331
    throw(BoundsError())
  end
  barsj_ = barsj
  @MSK_putbarsj(task.task,whichsol.value,j-Int32(1),barsj_)
  nothing
end
function putbarsj(task::MSKtask,whichsol::Soltype,j::T0,barsj::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  putbarsj(
    task,
    whichsol,
    convert(Int32,j),
    if barsj === nothing; nothing; else convert(Vector{Float64},barsj); end)
end


function getpviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolcon(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolcon(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getpviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolvar(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolbarvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolbarvar(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getpviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolcones(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolcones(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64})
  numaccidx = Int64(length(accidxlist))
  accidxlist_ = accidxlist .- Int64(1)
  viol_ = Vector{Float64}(undef,numaccidx)
  @MSK_getpviolacc(task.task,whichsol.value,numaccidx,accidxlist_,viol_)
  viol = viol_;
  viol
end
function getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolacc(
    task,
    whichsol,
    if accidxlist === nothing; nothing; else convert(Vector{Int64},accidxlist); end)
end


function getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::Vector{Int64})
  numdjcidx = Int64(length(djcidxlist))
  djcidxlist_ = djcidxlist .- Int64(1)
  viol_ = Vector{Float64}(undef,numdjcidx)
  @MSK_getpvioldjc(task.task,whichsol.value,numdjcidx,djcidxlist_,viol_)
  viol = viol_;
  viol
end
function getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  getpvioldjc(
    task,
    whichsol,
    if djcidxlist === nothing; nothing; else convert(Vector{Int64},djcidxlist); end)
end


function getdviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolcon(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolcon(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getdviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolvar(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolbarvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolbarvar(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getdviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolcones(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolcones(
    task,
    whichsol,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end)
end


function getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64})
  numaccidx = Int64(length(accidxlist))
  accidxlist_ = accidxlist .- Int64(1)
  viol_ = Vector{Float64}(undef,numaccidx)
  @MSK_getdviolacc(task.task,whichsol.value,numaccidx,accidxlist_,viol_)
  viol = viol_;
  viol
end
function getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolacc(
    task,
    whichsol,
    if accidxlist === nothing; nothing; else convert(Vector{Int64},accidxlist); end)
end


function getsolutioninfo(task::MSKtask,whichsol::Soltype)
  pobj_ = Ref{Float64}()
  pviolcon_ = Ref{Float64}()
  pviolvar_ = Ref{Float64}()
  pviolbarvar_ = Ref{Float64}()
  pviolcone_ = Ref{Float64}()
  pviolitg_ = Ref{Float64}()
  dobj_ = Ref{Float64}()
  dviolcon_ = Ref{Float64}()
  dviolvar_ = Ref{Float64}()
  dviolbarvar_ = Ref{Float64}()
  dviolcone_ = Ref{Float64}()
  @MSK_getsolutioninfo(task.task,whichsol.value,pobj_,pviolcon_,pviolvar_,pviolbarvar_,pviolcone_,pviolitg_,dobj_,dviolcon_,dviolvar_,dviolbarvar_,dviolcone_)
  pobj_[],pviolcon_[],pviolvar_[],pviolbarvar_[],pviolcone_[],pviolitg_[],dobj_[],dviolcon_[],dviolvar_[],dviolbarvar_[],dviolcone_[]
end


function getsolutioninfonew(task::MSKtask,whichsol::Soltype)
  pobj_ = Ref{Float64}()
  pviolcon_ = Ref{Float64}()
  pviolvar_ = Ref{Float64}()
  pviolbarvar_ = Ref{Float64}()
  pviolcone_ = Ref{Float64}()
  pviolacc_ = Ref{Float64}()
  pvioldjc_ = Ref{Float64}()
  pviolitg_ = Ref{Float64}()
  dobj_ = Ref{Float64}()
  dviolcon_ = Ref{Float64}()
  dviolvar_ = Ref{Float64}()
  dviolbarvar_ = Ref{Float64}()
  dviolcone_ = Ref{Float64}()
  dviolacc_ = Ref{Float64}()
  @MSK_getsolutioninfonew(task.task,whichsol.value,pobj_,pviolcon_,pviolvar_,pviolbarvar_,pviolcone_,pviolacc_,pvioldjc_,pviolitg_,dobj_,dviolcon_,dviolvar_,dviolbarvar_,dviolcone_,dviolacc_)
  pobj_[],pviolcon_[],pviolvar_[],pviolbarvar_[],pviolcone_[],pviolacc_[],pvioldjc_[],pviolitg_[],dobj_[],dviolcon_[],dviolvar_[],dviolbarvar_[],dviolcone_[],dviolacc_[]
end


function getdualsolutionnorms(task::MSKtask,whichsol::Soltype)
  nrmy_ = Ref{Float64}()
  nrmslc_ = Ref{Float64}()
  nrmsuc_ = Ref{Float64}()
  nrmslx_ = Ref{Float64}()
  nrmsux_ = Ref{Float64}()
  nrmsnx_ = Ref{Float64}()
  nrmbars_ = Ref{Float64}()
  @MSK_getdualsolutionnorms(task.task,whichsol.value,nrmy_,nrmslc_,nrmsuc_,nrmslx_,nrmsux_,nrmsnx_,nrmbars_)
  nrmy_[],nrmslc_[],nrmsuc_[],nrmslx_[],nrmsux_[],nrmsnx_[],nrmbars_[]
end


function getprimalsolutionnorms(task::MSKtask,whichsol::Soltype)
  nrmxc_ = Ref{Float64}()
  nrmxx_ = Ref{Float64}()
  nrmbarx_ = Ref{Float64}()
  @MSK_getprimalsolutionnorms(task.task,whichsol.value,nrmxc_,nrmxx_,nrmbarx_)
  nrmxc_[],nrmxx_[],nrmbarx_[]
end


function getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::Int32,last::Int32)
  values_ = Vector{Float64}(undef,(last - first))
  @MSK_getsolutionslice(task.task,whichsol.value,solitem.value,first-Int32(1),last-Int32(1),values_)
  values = values_;
  values
end
function getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsolutionslice(
    task,
    whichsol,
    solitem,
    convert(Int32,first),
    convert(Int32,last))
end


function getreducedcosts(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  redcosts_ = Vector{Float64}(undef,(last - first))
  @MSK_getreducedcosts(task.task,whichsol.value,first-Int32(1),last-Int32(1),redcosts_)
  redcosts = redcosts_;
  redcosts
end
function getreducedcosts(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getreducedcosts(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


function getstrparam(task::MSKtask,param::Sparam)
  __tmp_352 = Ref{Int32}()
  @MSK_getstrparamlen(task.task,param,__tmp_352)
  __tmp_351 = __tmp_352[]
  maxlen = Int32((1 + __tmp_351))
  len_ = Ref{Int32}()
  parvalue_ = Array{UInt8}(undef,maxlen)
  @MSK_getstrparam(task.task,param.value,maxlen,len_,parvalue_)
  parvalue_len = findfirst(_c->_c==0,parvalue_)
  parvalue = if parvalue_len === nothing
    String(parvalue_)
  else
    String(parvalue_[1:parvalue_len-1])
  end
  len_[],parvalue
end


function getstrparamlen(task::MSKtask,param::Sparam)
  len_ = Ref{Int32}()
  @MSK_getstrparamlen(task.task,param.value,len_)
  len_[]
end


function gettasknamelen(task::MSKtask)
  len_ = Ref{Int32}()
  @MSK_gettasknamelen(task.task,len_)
  len_[]
end


function gettaskname(task::MSKtask)
  __tmp_357 = Ref{Int32}()
  @MSK_gettasknamelen(task.task,__tmp_357)
  __tmp_356 = __tmp_357[]
  sizetaskname = Int32((1 + __tmp_356))
  taskname_ = Array{UInt8}(undef,sizetaskname)
  @MSK_gettaskname(task.task,sizetaskname,taskname_)
  taskname_len = findfirst(_c->_c==0,taskname_)
  taskname = if taskname_len === nothing
    String(taskname_)
  else
    String(taskname_[1:taskname_len-1])
  end
  taskname
end


function getvartype(task::MSKtask,j::Int32)
  vartype_ = Ref{Int32}()
  @MSK_getvartype(task.task,j-Int32(1),vartype_)
  vartype = Variabletype(vartype_[])
  vartype
end
function getvartype(task::MSKtask,j::T0) where { T0<:Integer }
  getvartype(
    task,
    convert(Int32,j))
end


function getvartypelist(task::MSKtask,subj::Vector{Int32})
  num = Int32(length(subj))
  subj_ = subj .- Int32(1)
  vartype_ = Vector{Int32}(undef,num)
  @MSK_getvartypelist(task.task,num,subj_,vartype_)
  vartype = Variabletype[Variabletype(item) for item in vartype_]
  vartype
end
function getvartypelist(task::MSKtask,subj::T0) where { T0<:AbstractVector{<:Integer} }
  getvartypelist(
    task,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end)
end


function inputdata(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,c::Union{Nothing,Vector{Float64}},cfix::Float64,aptrb::Vector{Int64},aptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  numcon = Int32(min(length(buc),length(blc),length(bkc)))
  numvar = Int32(min(length(c),length(bux),length(blx),length(bkx),length(aptrb),length(aptre)))
  c_ = if c === nothing; C_NULL; else c end
  aptrb_ = aptrb .- Int64(1)
  aptre_ = aptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  bkc_ = Int32[item.value for item in bkc]
  blc_ = blc
  buc_ = buc
  bkx_ = Int32[item.value for item in bkx]
  blx_ = blx
  bux_ = bux
  @MSK_inputdata64(task.task,maxnumcon,maxnumvar,numcon,numvar,c_,cfix,aptrb_,aptre_,asub_,aval_,bkc_,blc_,buc_,bkx_,blx_,bux_)
  nothing
end
function inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,A:: SparseMatrixCSC{Float64},bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:Number,T8<:AbstractVector{<:Number},T9<:AbstractVector{<:Number},T10<:AbstractVector{<:Number},T11<:AbstractVector{<:Number}}
  aptrb = A.colptr[1:size(A,2)]
  aptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  inputdata(task,maxnumcon,maxnumvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
end
function inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,aptrb::T4,aptre::T5,asub::T6,aval::T7,bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:Number,T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number},T9<:AbstractVector{<:Number},T10<:AbstractVector{<:Number},T11<:AbstractVector{<:Number} }
  inputdata(
    task,
    convert(Int32,maxnumcon),
    convert(Int32,maxnumvar),
    if c === nothing; nothing; else convert(Vector{Float64},c); end,
    convert(Float64,cfix),
    if aptrb === nothing; nothing; else convert(Vector{Int64},aptrb); end,
    if aptre === nothing; nothing; else convert(Vector{Int64},aptre); end,
    if asub === nothing; nothing; else convert(Vector{Int32},asub); end,
    if aval === nothing; nothing; else convert(Vector{Float64},aval); end,
    bkc,
    if blc === nothing; nothing; else convert(Vector{Float64},blc); end,
    if buc === nothing; nothing; else convert(Vector{Float64},buc); end,
    bkx,
    if blx === nothing; nothing; else convert(Vector{Float64},blx); end,
    if bux === nothing; nothing; else convert(Vector{Float64},bux); end)
end


function isdouparname(task::MSKtask,parname::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  param_ = Ref{Int32}()
  @MSK_isdouparname(task.task,parname_,param_)
  param = Dparam(param_[])
  param
end


function isintparname(task::MSKtask,parname::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  param_ = Ref{Int32}()
  @MSK_isintparname(task.task,parname_,param_)
  param = Iparam(param_[])
  param
end


function isstrparname(task::MSKtask,parname::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  param_ = Ref{Int32}()
  @MSK_isstrparname(task.task,parname_,param_)
  param = Sparam(param_[])
  param
end


function linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::AbstractString,append::Int32)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_linkfiletotaskstream(task.task,whichstream.value,filename_,append)
  nothing
end
function linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::Union{Nothing,AbstractString},append::T0) where { T0<:Integer }
  linkfiletostream(
    task,
    whichstream,
    filename,
    convert(Int32,append))
end


function primalrepair(task::MSKtask,wlc::Union{Nothing,Vector{Float64}},wuc::Union{Nothing,Vector{Float64}},wlx::Union{Nothing,Vector{Float64}},wux::Union{Nothing,Vector{Float64}})
  __tmp_367 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_367)
  __tmp_366 = __tmp_367[]
  if wlc !== nothing && length(wlc) < __tmp_366
    throw(BoundsError())
  end
  wlc_ = if wlc === nothing; C_NULL; else wlc end
  __tmp_369 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_369)
  __tmp_368 = __tmp_369[]
  if wuc !== nothing && length(wuc) < __tmp_368
    throw(BoundsError())
  end
  wuc_ = if wuc === nothing; C_NULL; else wuc end
  __tmp_371 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_371)
  __tmp_370 = __tmp_371[]
  if wlx !== nothing && length(wlx) < __tmp_370
    throw(BoundsError())
  end
  wlx_ = if wlx === nothing; C_NULL; else wlx end
  __tmp_373 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_373)
  __tmp_372 = __tmp_373[]
  if wux !== nothing && length(wux) < __tmp_372
    throw(BoundsError())
  end
  wux_ = if wux === nothing; C_NULL; else wux end
  @MSK_primalrepair(task.task,wlc_,wuc_,wlx_,wux_)
  nothing
end
function primalrepair(task::MSKtask,wlc::T0,wuc::T1,wlx::T2,wux::T3) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number} }
  primalrepair(
    task,
    if wlc === nothing; nothing; else convert(Vector{Float64},wlc); end,
    if wuc === nothing; nothing; else convert(Vector{Float64},wuc); end,
    if wlx === nothing; nothing; else convert(Vector{Float64},wlx); end,
    if wux === nothing; nothing; else convert(Vector{Float64},wux); end)
end


function infeasibilityreport(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)
  @MSK_infeasibilityreport(task.task,whichstream.value,whichsol.value)
  nothing
end


function optimize(task::MSKtask)
  trmcode_ = Ref{Int32}()
  @MSK_optimizetrm(task.task,trmcode_)
  trmcode = Rescode(trmcode_[])
  trmcode
end


function printparam(task::MSKtask)
  @MSK_printparam(task.task)
  nothing
end


function probtypetostr(task::MSKtask,probtype::Problemtype)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_probtypetostr(task.task,probtype.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function prostatostr(task::MSKtask,problemsta::Prosta)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_prostatostr(task.task,problemsta.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function commitchanges(task::MSKtask)
  @MSK_commitchanges(task.task)
  nothing
end


function getatruncatetol(task::MSKtask)
  tolzero_ = Vector{Float64}(undef,1)
  @MSK_getatruncatetol(task.task,tolzero_)
  tolzero = tolzero_;
  tolzero
end


function putatruncatetol(task::MSKtask,tolzero::Float64)
  @MSK_putatruncatetol(task.task,tolzero)
  nothing
end
function putatruncatetol(task::MSKtask,tolzero::T0) where { T0<:Number }
  putatruncatetol(
    task,
    convert(Float64,tolzero))
end


function putaij(task::MSKtask,i::Int32,j::Int32,aij::Float64)
  @MSK_putaij(task.task,i-Int32(1),j-Int32(1),aij)
  nothing
end
function putaij(task::MSKtask,i::T0,j::T1,aij::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putaij(
    task,
    convert(Int32,i),
    convert(Int32,j),
    convert(Float64,aij))
end


function putaijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
  num = Int64(min(length(subi),length(subj),length(valij)))
  subi_ = subi .- Int32(1)
  subj_ = subj .- Int32(1)
  valij_ = valij
  @MSK_putaijlist64(task.task,num,subi_,subj_,valij_)
  nothing
end
function putaijlist(task::MSKtask,subi::T0,subj::T1,valij::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putaijlist(
    task,
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if valij === nothing; nothing; else convert(Vector{Float64},valij); end)
end


function putacol(task::MSKtask,j::Int32,subj::Vector{Int32},valj::Vector{Float64})
  nzj = Int32(min(length(subj),length(valj)))
  subj_ = subj .- Int32(1)
  valj_ = valj
  @MSK_putacol(task.task,j-Int32(1),nzj,subj_,valj_)
  nothing
end
function putacol(task::MSKtask,j::T0,subj::T1,valj::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putacol(
    task,
    convert(Int32,j),
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if valj === nothing; nothing; else convert(Vector{Float64},valj); end)
end


function putarow(task::MSKtask,i::Int32,subi::Vector{Int32},vali::Vector{Float64})
  nzi = Int32(min(length(subi),length(vali)))
  subi_ = subi .- Int32(1)
  vali_ = vali
  @MSK_putarow(task.task,i-Int32(1),nzi,subi_,vali_)
  nothing
end
function putarow(task::MSKtask,i::T0,subi::T1,vali::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putarow(
    task,
    convert(Int32,i),
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    if vali === nothing; nothing; else convert(Vector{Float64},vali); end)
end


function putarowslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  if ptrb !== nothing && length(ptrb) < (last - first)
    throw(BoundsError())
  end
  ptrb_ = ptrb .- Int64(1)
  if ptre !== nothing && length(ptre) < (last - first)
    throw(BoundsError())
  end
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putarowslice64(task.task,first-Int32(1),last-Int32(1),ptrb_,ptre_,asub_,aval_)
  nothing
end
function putarowslice(task::MSKtask,first::T0,last::T1,At:: SparseMatrixCSC{Float64}) where {T0<:Integer,T1<:Integer}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowslice(task,first,last,ptrb,ptre,asub,aval)
end
function putarowslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putarowslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    if ptrb === nothing; nothing; else convert(Vector{Int64},ptrb); end,
    if ptre === nothing; nothing; else convert(Vector{Int64},ptre); end,
    if asub === nothing; nothing; else convert(Vector{Int32},asub); end,
    if aval === nothing; nothing; else convert(Vector{Float64},aval); end)
end


function putarowlist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  num = Int32(min(length(sub),length(ptrb),length(ptre)))
  sub_ = sub .- Int32(1)
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putarowlist64(task.task,num,sub_,ptrb_,ptre_,asub_,aval_)
  nothing
end
function putarowlist(task::MSKtask,sub::T0,At:: SparseMatrixCSC{Float64}) where {T0<:AbstractVector{<:Integer}}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowlist(task,sub,ptrb,ptre,asub,aval)
end
function putarowlist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putarowlist(
    task,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end,
    if ptrb === nothing; nothing; else convert(Vector{Int64},ptrb); end,
    if ptre === nothing; nothing; else convert(Vector{Int64},ptre); end,
    if asub === nothing; nothing; else convert(Vector{Int32},asub); end,
    if aval === nothing; nothing; else convert(Vector{Float64},aval); end)
end


function putacolslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putacolslice64(task.task,first-Int32(1),last-Int32(1),ptrb_,ptre_,asub_,aval_)
  nothing
end
function putacolslice(task::MSKtask,first::T0,last::T1,A:: SparseMatrixCSC{Float64}) where {T0<:Integer,T1<:Integer}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacolslice(task,first,last,ptrb,ptre,asub,aval)
end
function putacolslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putacolslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    if ptrb === nothing; nothing; else convert(Vector{Int64},ptrb); end,
    if ptre === nothing; nothing; else convert(Vector{Int64},ptre); end,
    if asub === nothing; nothing; else convert(Vector{Int32},asub); end,
    if aval === nothing; nothing; else convert(Vector{Float64},aval); end)
end


function putacollist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  num = Int32(min(length(sub),length(ptrb),length(ptre)))
  sub_ = sub .- Int32(1)
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putacollist64(task.task,num,sub_,ptrb_,ptre_,asub_,aval_)
  nothing
end
function putacollist(task::MSKtask,sub::T0,A:: SparseMatrixCSC{Float64}) where {T0<:AbstractVector{<:Integer}}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacollist(task,sub,ptrb,ptre,asub,aval)
end
function putacollist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putacollist(
    task,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end,
    if ptrb === nothing; nothing; else convert(Vector{Int64},ptrb); end,
    if ptre === nothing; nothing; else convert(Vector{Int64},ptre); end,
    if asub === nothing; nothing; else convert(Vector{Int32},asub); end,
    if aval === nothing; nothing; else convert(Vector{Float64},aval); end)
end


function putbaraij(task::MSKtask,i::Int32,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
  num = Int64(min(length(sub),length(weights)))
  sub_ = sub .- Int64(1)
  weights_ = weights
  @MSK_putbaraij(task.task,i-Int32(1),j-Int32(1),num,sub_,weights_)
  nothing
end
function putbaraij(task::MSKtask,i::T0,j::T1,sub::T2,weights::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putbaraij(
    task,
    convert(Int32,i),
    convert(Int32,j),
    if sub === nothing; nothing; else convert(Vector{Int64},sub); end,
    if weights === nothing; nothing; else convert(Vector{Float64},weights); end)
end


function putbaraijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},alphaptrb::Vector{Int64},alphaptre::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
  num = Int32(min(length(subi),length(subj),length(alphaptrb),length(alphaptre)))
  subi_ = subi .- Int32(1)
  subj_ = subj .- Int32(1)
  alphaptrb_ = alphaptrb
  alphaptre_ = alphaptre
  matidx_ = matidx .- Int64(1)
  weights_ = weights
  @MSK_putbaraijlist(task.task,num,subi_,subj_,alphaptrb_,alphaptre_,matidx_,weights_)
  nothing
end
function putbaraijlist(task::MSKtask,subi::T0,subj::T1,A:: SparseMatrixCSC{Float64}) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer}}
  alphaptrb = A.colptr[1:size(A,2)]
  alphaptre = A.colptr[2:size(A,2)+1]
  matidx = A.rowval
  weights = A.nzval
  putbaraijlist(task,subi,subj,alphaptrb,alphaptre,matidx,weights)
end
function putbaraijlist(task::MSKtask,subi::T0,subj::T1,alphaptrb::T2,alphaptre::T3,matidx::T4,weights::T5) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putbaraijlist(
    task,
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if alphaptrb === nothing; nothing; else convert(Vector{Int64},alphaptrb); end,
    if alphaptre === nothing; nothing; else convert(Vector{Int64},alphaptre); end,
    if matidx === nothing; nothing; else convert(Vector{Int64},matidx); end,
    if weights === nothing; nothing; else convert(Vector{Float64},weights); end)
end


function putbararowlist(task::MSKtask,subi::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},subj::Vector{Int32},nummat::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
  num = Int32(min(length(subi),length(ptrb),length(ptre)))
  subi_ = subi .- Int32(1)
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  subj_ = subj .- Int32(1)
  if nummat !== nothing && length(nummat) < length(subj)
    throw(BoundsError())
  end
  nummat_ = nummat .- Int64(1)
  if matidx !== nothing && length(matidx) < sum(nummat)
    throw(BoundsError())
  end
  matidx_ = matidx .- Int64(1)
  if weights !== nothing && length(weights) < sum(nummat)
    throw(BoundsError())
  end
  weights_ = weights .- Float64(1)
  @MSK_putbararowlist(task.task,num,subi_,ptrb_,ptre_,subj_,nummat_,matidx_,weights_)
  nothing
end
function putbararowlist(task::MSKtask,subi::T0,A:: SparseMatrixCSC{Float64},matidx::T5,weights::T6) where {T0<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number}}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  subj = A.rowval
  nummat = A.nzval
  putbararowlist(task,subi,ptrb,ptre,subj,nummat,matidx,weights)
end
function putbararowlist(task::MSKtask,subi::T0,ptrb::T1,ptre::T2,subj::T3,nummat::T4,matidx::T5,weights::T6) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number} }
  putbararowlist(
    task,
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    if ptrb === nothing; nothing; else convert(Vector{Int64},ptrb); end,
    if ptre === nothing; nothing; else convert(Vector{Int64},ptre); end,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if nummat === nothing; nothing; else convert(Vector{Int64},nummat); end,
    if matidx === nothing; nothing; else convert(Vector{Int64},matidx); end,
    if weights === nothing; nothing; else convert(Vector{Float64},weights); end)
end


function getnumbarcnz(task::MSKtask)
  nz_ = Ref{Int64}()
  @MSK_getnumbarcnz(task.task,nz_)
  nz_[]
end


function getnumbaranz(task::MSKtask)
  nz_ = Ref{Int64}()
  @MSK_getnumbaranz(task.task,nz_)
  nz_[]
end


function getbarcsparsity(task::MSKtask)
  __tmp_397 = Ref{Int64}()
  @MSK_getnumbarcnz(task.task,__tmp_397)
  __tmp_396 = __tmp_397[]
  maxnumnz = Int64(__tmp_396)
  numnz_ = Ref{Int64}()
  idxj_ = Vector{Int64}(undef,maxnumnz)
  @MSK_getbarcsparsity(task.task,maxnumnz,numnz_,idxj_)
  idxj = idxj_;
  idxj .+= 1
  numnz_[],idxj
end


function getbarasparsity(task::MSKtask)
  __tmp_400 = Ref{Int64}()
  @MSK_getnumbaranz(task.task,__tmp_400)
  __tmp_399 = __tmp_400[]
  maxnumnz = Int64(__tmp_399)
  numnz_ = Ref{Int64}()
  idxij_ = Vector{Int64}(undef,maxnumnz)
  @MSK_getbarasparsity(task.task,maxnumnz,numnz_,idxij_)
  idxij = idxij_;
  idxij .+= 1
  numnz_[],idxij
end


function getbarcidxinfo(task::MSKtask,idx::Int64)
  num_ = Ref{Int64}()
  @MSK_getbarcidxinfo(task.task,idx-Int64(1),num_)
  num_[]
end
function getbarcidxinfo(task::MSKtask,idx::T0) where { T0<:Integer }
  getbarcidxinfo(
    task,
    convert(Int64,idx))
end


function getbarcidxj(task::MSKtask,idx::Int64)
  j_ = Ref{Int32}()
  @MSK_getbarcidxj(task.task,idx-Int64(1),j_)
  j_[]+Int32(1)
end
function getbarcidxj(task::MSKtask,idx::T0) where { T0<:Integer }
  getbarcidxj(
    task,
    convert(Int64,idx))
end


function getbarcidx(task::MSKtask,idx::Int64)
  __tmp_405 = Ref{Int64}()
  @MSK_getbarcidxinfo(task.task,idx-Int64(1),__tmp_405)
  __tmp_404 = __tmp_405[]
  maxnum = Int64(__tmp_404)
  j_ = Ref{Int32}()
  num_ = Ref{Int64}()
  sub_ = Vector{Int64}(undef,maxnum)
  weights_ = Vector{Float64}(undef,maxnum)
  @MSK_getbarcidx(task.task,idx-Int64(1),maxnum,j_,num_,sub_,weights_)
  sub = sub_;
  sub .+= 1
  weights = weights_;
  j_[]+Int32(1),num_[],sub,weights
end
function getbarcidx(task::MSKtask,idx::T0) where { T0<:Integer }
  getbarcidx(
    task,
    convert(Int64,idx))
end


function getbaraidxinfo(task::MSKtask,idx::Int64)
  num_ = Ref{Int64}()
  @MSK_getbaraidxinfo(task.task,idx-Int64(1),num_)
  num_[]
end
function getbaraidxinfo(task::MSKtask,idx::T0) where { T0<:Integer }
  getbaraidxinfo(
    task,
    convert(Int64,idx))
end


function getbaraidxij(task::MSKtask,idx::Int64)
  i_ = Ref{Int32}()
  j_ = Ref{Int32}()
  @MSK_getbaraidxij(task.task,idx-Int64(1),i_,j_)
  i_[]+Int32(1),j_[]+Int32(1)
end
function getbaraidxij(task::MSKtask,idx::T0) where { T0<:Integer }
  getbaraidxij(
    task,
    convert(Int64,idx))
end


function getbaraidx(task::MSKtask,idx::Int64)
  __tmp_410 = Ref{Int64}()
  @MSK_getbaraidxinfo(task.task,idx-Int64(1),__tmp_410)
  __tmp_409 = __tmp_410[]
  maxnum = Int64(__tmp_409)
  i_ = Ref{Int32}()
  j_ = Ref{Int32}()
  num_ = Ref{Int64}()
  sub_ = Vector{Int64}(undef,maxnum)
  weights_ = Vector{Float64}(undef,maxnum)
  @MSK_getbaraidx(task.task,idx-Int64(1),maxnum,i_,j_,num_,sub_,weights_)
  sub = sub_;
  sub .+= 1
  weights = weights_;
  i_[]+Int32(1),j_[]+Int32(1),num_[],sub,weights
end
function getbaraidx(task::MSKtask,idx::T0) where { T0<:Integer }
  getbaraidx(
    task,
    convert(Int64,idx))
end


function getnumbarcblocktriplets(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumbarcblocktriplets(task.task,num_)
  num_[]
end


function putbarcblocktriplet(task::MSKtask,subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valjkl::Vector{Float64})
  num = Int64(min(length(subj),length(subk),length(subl),length(valjkl)))
  if subj !== nothing && length(subj) < num
    throw(BoundsError())
  end
  subj_ = subj .- Int32(1)
  if subk !== nothing && length(subk) < num
    throw(BoundsError())
  end
  subk_ = subk .- Int32(1)
  if subl !== nothing && length(subl) < num
    throw(BoundsError())
  end
  subl_ = subl .- Int32(1)
  if valjkl !== nothing && length(valjkl) < num
    throw(BoundsError())
  end
  valjkl_ = valjkl
  @MSK_putbarcblocktriplet(task.task,num,subj_,subk_,subl_,valjkl_)
  nothing
end
function putbarcblocktriplet(task::MSKtask,subj::T0,subk::T1,subl::T2,valjkl::T3) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putbarcblocktriplet(
    task,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if subk === nothing; nothing; else convert(Vector{Int32},subk); end,
    if subl === nothing; nothing; else convert(Vector{Int32},subl); end,
    if valjkl === nothing; nothing; else convert(Vector{Float64},valjkl); end)
end


function getbarcblocktriplet(task::MSKtask)
  __tmp_415 = Ref{Int64}()
  @MSK_getnumbarcblocktriplets(task.task,__tmp_415)
  __tmp_414 = __tmp_415[]
  maxnum = Int64(__tmp_414)
  num_ = Ref{Int64}()
  subj_ = Vector{Int32}(undef,maxnum)
  subk_ = Vector{Int32}(undef,maxnum)
  subl_ = Vector{Int32}(undef,maxnum)
  valjkl_ = Vector{Float64}(undef,maxnum)
  @MSK_getbarcblocktriplet(task.task,maxnum,num_,subj_,subk_,subl_,valjkl_)
  subj = subj_;
  subj .+= 1
  subk = subk_;
  subk .+= 1
  subl = subl_;
  subl .+= 1
  valjkl = valjkl_;
  num_[],subj,subk,subl,valjkl
end


function putbarablocktriplet(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valijkl::Vector{Float64})
  num = Int64(min(length(subj),length(subk),length(subl),length(valijkl)))
  if subi !== nothing && length(subi) < num
    throw(BoundsError())
  end
  subi_ = subi .- Int32(1)
  if subj !== nothing && length(subj) < num
    throw(BoundsError())
  end
  subj_ = subj .- Int32(1)
  if subk !== nothing && length(subk) < num
    throw(BoundsError())
  end
  subk_ = subk .- Int32(1)
  if subl !== nothing && length(subl) < num
    throw(BoundsError())
  end
  subl_ = subl .- Int32(1)
  if valijkl !== nothing && length(valijkl) < num
    throw(BoundsError())
  end
  valijkl_ = valijkl
  @MSK_putbarablocktriplet(task.task,num,subi_,subj_,subk_,subl_,valijkl_)
  nothing
end
function putbarablocktriplet(task::MSKtask,subi::T0,subj::T1,subk::T2,subl::T3,valijkl::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putbarablocktriplet(
    task,
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if subk === nothing; nothing; else convert(Vector{Int32},subk); end,
    if subl === nothing; nothing; else convert(Vector{Int32},subl); end,
    if valijkl === nothing; nothing; else convert(Vector{Float64},valijkl); end)
end


function getnumbarablocktriplets(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumbarablocktriplets(task.task,num_)
  num_[]
end


function getbarablocktriplet(task::MSKtask)
  __tmp_420 = Ref{Int64}()
  @MSK_getnumbarablocktriplets(task.task,__tmp_420)
  __tmp_419 = __tmp_420[]
  maxnum = Int64(__tmp_419)
  num_ = Ref{Int64}()
  subi_ = Vector{Int32}(undef,maxnum)
  subj_ = Vector{Int32}(undef,maxnum)
  subk_ = Vector{Int32}(undef,maxnum)
  subl_ = Vector{Int32}(undef,maxnum)
  valijkl_ = Vector{Float64}(undef,maxnum)
  @MSK_getbarablocktriplet(task.task,maxnum,num_,subi_,subj_,subk_,subl_,valijkl_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  subk = subk_;
  subk .+= 1
  subl = subl_;
  subl .+= 1
  valijkl = valijkl_;
  num_[],subi,subj,subk,subl,valijkl
end


function putmaxnumafe(task::MSKtask,maxnumafe::Int64)
  @MSK_putmaxnumafe(task.task,maxnumafe)
  nothing
end
function putmaxnumafe(task::MSKtask,maxnumafe::T0) where { T0<:Integer }
  putmaxnumafe(
    task,
    convert(Int64,maxnumafe))
end


function getnumafe(task::MSKtask)
  numafe_ = Ref{Int64}()
  @MSK_getnumafe(task.task,numafe_)
  numafe_[]
end


function appendafes(task::MSKtask,num::Int64)
  @MSK_appendafes(task.task,num)
  nothing
end
function appendafes(task::MSKtask,num::T0) where { T0<:Integer }
  appendafes(
    task,
    convert(Int64,num))
end


function putafefentry(task::MSKtask,afeidx::Int64,varidx::Int32,value::Float64)
  @MSK_putafefentry(task.task,afeidx-Int64(1),varidx-Int32(1),value)
  nothing
end
function putafefentry(task::MSKtask,afeidx::T0,varidx::T1,value::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putafefentry(
    task,
    convert(Int64,afeidx),
    convert(Int32,varidx),
    convert(Float64,value))
end


function putafefentrylist(task::MSKtask,afeidx::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
  numentr = Int64(min(length(afeidx),length(varidx),length(val)))
  afeidx_ = afeidx .- Int64(1)
  varidx_ = varidx .- Int32(1)
  val_ = val
  @MSK_putafefentrylist(task.task,numentr,afeidx_,varidx_,val_)
  nothing
end
function putafefentrylist(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putafefentrylist(
    task,
    if afeidx === nothing; nothing; else convert(Vector{Int64},afeidx); end,
    if varidx === nothing; nothing; else convert(Vector{Int32},varidx); end,
    if val === nothing; nothing; else convert(Vector{Float64},val); end)
end


function emptyafefrow(task::MSKtask,afeidx::Int64)
  @MSK_emptyafefrow(task.task,afeidx-Int64(1))
  nothing
end
function emptyafefrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  emptyafefrow(
    task,
    convert(Int64,afeidx))
end


function emptyafefcol(task::MSKtask,varidx::Int32)
  @MSK_emptyafefcol(task.task,varidx-Int32(1))
  nothing
end
function emptyafefcol(task::MSKtask,varidx::T0) where { T0<:Integer }
  emptyafefcol(
    task,
    convert(Int32,varidx))
end


function emptyafefrowlist(task::MSKtask,afeidx::Vector{Int64})
  numafeidx = Int64(length(afeidx))
  afeidx_ = afeidx .- Int64(1)
  @MSK_emptyafefrowlist(task.task,numafeidx,afeidx_)
  nothing
end
function emptyafefrowlist(task::MSKtask,afeidx::T0) where { T0<:AbstractVector{<:Integer} }
  emptyafefrowlist(
    task,
    if afeidx === nothing; nothing; else convert(Vector{Int64},afeidx); end)
end


function emptyafefcollist(task::MSKtask,varidx::Vector{Int32})
  numvaridx = Int64(length(varidx))
  varidx_ = varidx .- Int32(1)
  @MSK_emptyafefcollist(task.task,numvaridx,varidx_)
  nothing
end
function emptyafefcollist(task::MSKtask,varidx::T0) where { T0<:AbstractVector{<:Integer} }
  emptyafefcollist(
    task,
    if varidx === nothing; nothing; else convert(Vector{Int32},varidx); end)
end


function putafefrow(task::MSKtask,afeidx::Int64,varidx::Vector{Int32},val::Vector{Float64})
  numnz = Int32(min(length(varidx),length(val)))
  varidx_ = varidx .- Int32(1)
  val_ = val
  @MSK_putafefrow(task.task,afeidx-Int64(1),numnz,varidx_,val_)
  nothing
end
function putafefrow(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putafefrow(
    task,
    convert(Int64,afeidx),
    if varidx === nothing; nothing; else convert(Vector{Int32},varidx); end,
    if val === nothing; nothing; else convert(Vector{Float64},val); end)
end


function putafefrowlist(task::MSKtask,afeidx::Vector{Int64},numnzrow::Vector{Int32},ptrrow::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
  numafeidx = Int64(min(length(afeidx),length(numnzrow),length(ptrrow)))
  afeidx_ = afeidx .- Int64(1)
  numnzrow_ = numnzrow
  ptrrow_ = ptrrow .- Int64(1)
  lenidxval = Int64(min(length(varidx),length(val)))
  varidx_ = varidx .- Int32(1)
  val_ = val
  @MSK_putafefrowlist(task.task,numafeidx,afeidx_,numnzrow_,ptrrow_,lenidxval,varidx_,val_)
  nothing
end
function putafefrowlist(task::MSKtask,afeidx::T0,numnzrow::T1,ptrrow::T2,varidx::T3,val::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putafefrowlist(
    task,
    if afeidx === nothing; nothing; else convert(Vector{Int64},afeidx); end,
    if numnzrow === nothing; nothing; else convert(Vector{Int32},numnzrow); end,
    if ptrrow === nothing; nothing; else convert(Vector{Int64},ptrrow); end,
    if varidx === nothing; nothing; else convert(Vector{Int32},varidx); end,
    if val === nothing; nothing; else convert(Vector{Float64},val); end)
end


function putafefcol(task::MSKtask,varidx::Int32,afeidx::Vector{Int64},val::Vector{Float64})
  numnz = Int64(min(length(afeidx),length(val)))
  afeidx_ = afeidx .- Int64(1)
  val_ = val
  @MSK_putafefcol(task.task,varidx-Int32(1),numnz,afeidx_,val_)
  nothing
end
function putafefcol(task::MSKtask,varidx::T0,afeidx::T1,val::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putafefcol(
    task,
    convert(Int32,varidx),
    if afeidx === nothing; nothing; else convert(Vector{Int64},afeidx); end,
    if val === nothing; nothing; else convert(Vector{Float64},val); end)
end


function getafefrownumnz(task::MSKtask,afeidx::Int64)
  numnz_ = Ref{Int32}()
  @MSK_getafefrownumnz(task.task,afeidx-Int64(1),numnz_)
  numnz_[]
end
function getafefrownumnz(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafefrownumnz(
    task,
    convert(Int64,afeidx))
end


function getafefnumnz(task::MSKtask)
  numnz_ = Ref{Int64}()
  @MSK_getafefnumnz(task.task,numnz_)
  numnz_[]
end


function getafefrow(task::MSKtask,afeidx::Int64)
  numnz_ = Ref{Int32}()
  __tmp_437 = Ref{Int32}()
  @MSK_getafefrownumnz(task.task,afeidx-Int64(1),__tmp_437)
  __tmp_436 = __tmp_437[]
  varidx_ = Vector{Int32}(undef,__tmp_436)
  __tmp_439 = Ref{Int32}()
  @MSK_getafefrownumnz(task.task,afeidx-Int64(1),__tmp_439)
  __tmp_438 = __tmp_439[]
  val_ = Vector{Float64}(undef,__tmp_438)
  @MSK_getafefrow(task.task,afeidx-Int64(1),numnz_,varidx_,val_)
  varidx = varidx_;
  varidx .+= 1
  val = val_;
  numnz_[],varidx,val
end
function getafefrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafefrow(
    task,
    convert(Int64,afeidx))
end


function getafeftrip(task::MSKtask)
  __tmp_442 = Ref{Int64}()
  @MSK_getafefnumnz(task.task,__tmp_442)
  __tmp_441 = __tmp_442[]
  afeidx_ = Vector{Int64}(undef,__tmp_441)
  __tmp_444 = Ref{Int64}()
  @MSK_getafefnumnz(task.task,__tmp_444)
  __tmp_443 = __tmp_444[]
  varidx_ = Vector{Int32}(undef,__tmp_443)
  __tmp_446 = Ref{Int64}()
  @MSK_getafefnumnz(task.task,__tmp_446)
  __tmp_445 = __tmp_446[]
  val_ = Vector{Float64}(undef,__tmp_445)
  @MSK_getafeftrip(task.task,afeidx_,varidx_,val_)
  afeidx = afeidx_;
  afeidx .+= 1
  varidx = varidx_;
  varidx .+= 1
  val = val_;
  afeidx,varidx,val
end


function putafebarfentry(task::MSKtask,afeidx::Int64,barvaridx::Int32,termidx::Vector{Int64},termweight::Vector{Float64})
  numterm = Int64(min(length(termidx),length(termweight)))
  termidx_ = termidx .- Int64(1)
  termweight_ = termweight
  @MSK_putafebarfentry(task.task,afeidx-Int64(1),barvaridx-Int32(1),numterm,termidx_,termweight_)
  nothing
end
function putafebarfentry(task::MSKtask,afeidx::T0,barvaridx::T1,termidx::T2,termweight::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putafebarfentry(
    task,
    convert(Int64,afeidx),
    convert(Int32,barvaridx),
    if termidx === nothing; nothing; else convert(Vector{Int64},termidx); end,
    if termweight === nothing; nothing; else convert(Vector{Float64},termweight); end)
end


function putafebarfentrylist(task::MSKtask,afeidx::Vector{Int64},barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
  numafeidx = Int64(min(length(afeidx),length(barvaridx),length(numterm),length(ptrterm)))
  afeidx_ = afeidx .- Int64(1)
  barvaridx_ = barvaridx .- Int32(1)
  numterm_ = numterm
  ptrterm_ = ptrterm .- Int64(1)
  lenterm = Int64(min(length(termidx),length(termweight)))
  termidx_ = termidx .- Int64(1)
  termweight_ = termweight
  @MSK_putafebarfentrylist(task.task,numafeidx,afeidx_,barvaridx_,numterm_,ptrterm_,lenterm,termidx_,termweight_)
  nothing
end
function putafebarfentrylist(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putafebarfentrylist(
    task,
    if afeidx === nothing; nothing; else convert(Vector{Int64},afeidx); end,
    if barvaridx === nothing; nothing; else convert(Vector{Int32},barvaridx); end,
    if numterm === nothing; nothing; else convert(Vector{Int64},numterm); end,
    if ptrterm === nothing; nothing; else convert(Vector{Int64},ptrterm); end,
    if termidx === nothing; nothing; else convert(Vector{Int64},termidx); end,
    if termweight === nothing; nothing; else convert(Vector{Float64},termweight); end)
end


function putafebarfrow(task::MSKtask,afeidx::Int64,barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
  numentr = Int32(min(length(barvaridx),length(numterm),length(ptrterm)))
  barvaridx_ = barvaridx .- Int32(1)
  numterm_ = numterm
  ptrterm_ = ptrterm .- Int64(1)
  lenterm = Int64(min(length(termidx),length(termweight)))
  termidx_ = termidx .- Int64(1)
  termweight_ = termweight
  @MSK_putafebarfrow(task.task,afeidx-Int64(1),numentr,barvaridx_,numterm_,ptrterm_,lenterm,termidx_,termweight_)
  nothing
end
function putafebarfrow(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putafebarfrow(
    task,
    convert(Int64,afeidx),
    if barvaridx === nothing; nothing; else convert(Vector{Int32},barvaridx); end,
    if numterm === nothing; nothing; else convert(Vector{Int64},numterm); end,
    if ptrterm === nothing; nothing; else convert(Vector{Int64},ptrterm); end,
    if termidx === nothing; nothing; else convert(Vector{Int64},termidx); end,
    if termweight === nothing; nothing; else convert(Vector{Float64},termweight); end)
end


function emptyafebarfrow(task::MSKtask,afeidx::Int64)
  @MSK_emptyafebarfrow(task.task,afeidx-Int64(1))
  nothing
end
function emptyafebarfrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  emptyafebarfrow(
    task,
    convert(Int64,afeidx))
end


function emptyafebarfrowlist(task::MSKtask,afeidxlist::Vector{Int64})
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  @MSK_emptyafebarfrowlist(task.task,numafeidx,afeidxlist_)
  nothing
end
function emptyafebarfrowlist(task::MSKtask,afeidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  emptyafebarfrowlist(
    task,
    if afeidxlist === nothing; nothing; else convert(Vector{Int64},afeidxlist); end)
end


function putafebarfblocktriplet(task::MSKtask,afeidx::Vector{Int64},barvaridx::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valkl::Vector{Float64})
  numtrip = Int64(min(length(afeidx),length(barvaridx),length(subk),length(subl),length(valkl)))
  if afeidx !== nothing && length(afeidx) < numtrip
    throw(BoundsError())
  end
  afeidx_ = afeidx .- Int64(1)
  if barvaridx !== nothing && length(barvaridx) < numtrip
    throw(BoundsError())
  end
  barvaridx_ = barvaridx .- Int32(1)
  if subk !== nothing && length(subk) < numtrip
    throw(BoundsError())
  end
  subk_ = subk .- Int32(1)
  if subl !== nothing && length(subl) < numtrip
    throw(BoundsError())
  end
  subl_ = subl .- Int32(1)
  if valkl !== nothing && length(valkl) < numtrip
    throw(BoundsError())
  end
  valkl_ = valkl
  @MSK_putafebarfblocktriplet(task.task,numtrip,afeidx_,barvaridx_,subk_,subl_,valkl_)
  nothing
end
function putafebarfblocktriplet(task::MSKtask,afeidx::T0,barvaridx::T1,subk::T2,subl::T3,valkl::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putafebarfblocktriplet(
    task,
    if afeidx === nothing; nothing; else convert(Vector{Int64},afeidx); end,
    if barvaridx === nothing; nothing; else convert(Vector{Int32},barvaridx); end,
    if subk === nothing; nothing; else convert(Vector{Int32},subk); end,
    if subl === nothing; nothing; else convert(Vector{Int32},subl); end,
    if valkl === nothing; nothing; else convert(Vector{Float64},valkl); end)
end


function getafebarfnumblocktriplets(task::MSKtask)
  numtrip_ = Ref{Int64}()
  @MSK_getafebarfnumblocktriplets(task.task,numtrip_)
  numtrip_[]
end


function getafebarfblocktriplet(task::MSKtask)
  __tmp_456 = Ref{Int64}()
  @MSK_getafebarfnumblocktriplets(task.task,__tmp_456)
  __tmp_455 = __tmp_456[]
  maxnumtrip = Int64(__tmp_455)
  numtrip_ = Ref{Int64}()
  afeidx_ = Vector{Int64}(undef,maxnumtrip)
  barvaridx_ = Vector{Int32}(undef,maxnumtrip)
  subk_ = Vector{Int32}(undef,maxnumtrip)
  subl_ = Vector{Int32}(undef,maxnumtrip)
  valkl_ = Vector{Float64}(undef,maxnumtrip)
  @MSK_getafebarfblocktriplet(task.task,maxnumtrip,numtrip_,afeidx_,barvaridx_,subk_,subl_,valkl_)
  afeidx = afeidx_;
  afeidx .+= 1
  barvaridx = barvaridx_;
  barvaridx .+= 1
  subk = subk_;
  subk .+= 1
  subl = subl_;
  subl .+= 1
  valkl = valkl_;
  numtrip_[],afeidx,barvaridx,subk,subl,valkl
end


function getafebarfnumrowentries(task::MSKtask,afeidx::Int64)
  numentr_ = Ref{Int32}()
  @MSK_getafebarfnumrowentries(task.task,afeidx-Int64(1),numentr_)
  numentr_[]
end
function getafebarfnumrowentries(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafebarfnumrowentries(
    task,
    convert(Int64,afeidx))
end


function getafebarfrowinfo(task::MSKtask,afeidx::Int64)
  numentr_ = Ref{Int32}()
  numterm_ = Ref{Int64}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),numentr_,numterm_)
  numentr_[],numterm_[]
end
function getafebarfrowinfo(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafebarfrowinfo(
    task,
    convert(Int64,afeidx))
end


function getafebarfrow(task::MSKtask,afeidx::Int64)
  __tmp_461 = Ref{Int32}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),__tmp_461,Ref{Int64}())
  __tmp_460 = __tmp_461[]
  barvaridx_ = Vector{Int32}(undef,__tmp_460)
  __tmp_463 = Ref{Int32}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),__tmp_463,Ref{Int64}())
  __tmp_462 = __tmp_463[]
  ptrterm_ = Vector{Int64}(undef,__tmp_462)
  __tmp_465 = Ref{Int32}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),__tmp_465,Ref{Int64}())
  __tmp_464 = __tmp_465[]
  numterm_ = Vector{Int64}(undef,__tmp_464)
  __tmp_467 = Ref{Int64}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),Ref{Int32}(),__tmp_467)
  __tmp_466 = __tmp_467[]
  termidx_ = Vector{Int64}(undef,__tmp_466)
  __tmp_469 = Ref{Int64}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),Ref{Int32}(),__tmp_469)
  __tmp_468 = __tmp_469[]
  termweight_ = Vector{Float64}(undef,__tmp_468)
  @MSK_getafebarfrow(task.task,afeidx-Int64(1),barvaridx_,ptrterm_,numterm_,termidx_,termweight_)
  barvaridx = barvaridx_;
  barvaridx .+= 1
  ptrterm = ptrterm_;
  ptrterm .+= 1
  numterm = numterm_;
  termidx = termidx_;
  termidx .+= 1
  termweight = termweight_;
  barvaridx,ptrterm,numterm,termidx,termweight
end
function getafebarfrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafebarfrow(
    task,
    convert(Int64,afeidx))
end


function putafeg(task::MSKtask,afeidx::Int64,g::Float64)
  @MSK_putafeg(task.task,afeidx-Int64(1),g)
  nothing
end
function putafeg(task::MSKtask,afeidx::T0,g::T1) where { T0<:Integer,T1<:Number }
  putafeg(
    task,
    convert(Int64,afeidx),
    convert(Float64,g))
end


function putafeglist(task::MSKtask,afeidx::Vector{Int64},g::Vector{Float64})
  numafeidx = Int64(min(length(afeidx),length(g)))
  afeidx_ = afeidx .- Int64(1)
  g_ = g
  @MSK_putafeglist(task.task,numafeidx,afeidx_,g_)
  nothing
end
function putafeglist(task::MSKtask,afeidx::T0,g::T1) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number} }
  putafeglist(
    task,
    if afeidx === nothing; nothing; else convert(Vector{Int64},afeidx); end,
    if g === nothing; nothing; else convert(Vector{Float64},g); end)
end


function getafeg(task::MSKtask,afeidx::Int64)
  g_ = Ref{Float64}()
  @MSK_getafeg(task.task,afeidx-Int64(1),g_)
  g_[]
end
function getafeg(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafeg(
    task,
    convert(Int64,afeidx))
end


function getafegslice(task::MSKtask,first::Int64,last::Int64)
  g_ = Vector{Float64}(undef,(last - first))
  @MSK_getafegslice(task.task,first-Int64(1),last-Int64(1),g_)
  g = g_;
  g
end
function getafegslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getafegslice(
    task,
    convert(Int64,first),
    convert(Int64,last))
end


function putafegslice(task::MSKtask,first::Int64,last::Int64,slice::Vector{Float64})
  if slice !== nothing && length(slice) < (last - first)
    throw(BoundsError())
  end
  slice_ = slice
  @MSK_putafegslice(task.task,first-Int64(1),last-Int64(1),slice_)
  nothing
end
function putafegslice(task::MSKtask,first::T0,last::T1,slice::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putafegslice(
    task,
    convert(Int64,first),
    convert(Int64,last),
    if slice === nothing; nothing; else convert(Vector{Float64},slice); end)
end


function putmaxnumdjc(task::MSKtask,maxnumdjc::Int64)
  @MSK_putmaxnumdjc(task.task,maxnumdjc)
  nothing
end
function putmaxnumdjc(task::MSKtask,maxnumdjc::T0) where { T0<:Integer }
  putmaxnumdjc(
    task,
    convert(Int64,maxnumdjc))
end


function getnumdjc(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumdjc(task.task,num_)
  num_[]
end


function getdjcnumdomain(task::MSKtask,djcidx::Int64)
  numdomain_ = Ref{Int64}()
  @MSK_getdjcnumdomain(task.task,djcidx-Int64(1),numdomain_)
  numdomain_[]
end
function getdjcnumdomain(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnumdomain(
    task,
    convert(Int64,djcidx))
end


function getdjcnumdomaintot(task::MSKtask)
  numdomaintot_ = Ref{Int64}()
  @MSK_getdjcnumdomaintot(task.task,numdomaintot_)
  numdomaintot_[]
end


function getdjcnumafe(task::MSKtask,djcidx::Int64)
  numafe_ = Ref{Int64}()
  @MSK_getdjcnumafe(task.task,djcidx-Int64(1),numafe_)
  numafe_[]
end
function getdjcnumafe(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnumafe(
    task,
    convert(Int64,djcidx))
end


function getdjcnumafetot(task::MSKtask)
  numafetot_ = Ref{Int64}()
  @MSK_getdjcnumafetot(task.task,numafetot_)
  numafetot_[]
end


function getdjcnumterm(task::MSKtask,djcidx::Int64)
  numterm_ = Ref{Int64}()
  @MSK_getdjcnumterm(task.task,djcidx-Int64(1),numterm_)
  numterm_[]
end
function getdjcnumterm(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnumterm(
    task,
    convert(Int64,djcidx))
end


function getdjcnumtermtot(task::MSKtask)
  numtermtot_ = Ref{Int64}()
  @MSK_getdjcnumtermtot(task.task,numtermtot_)
  numtermtot_[]
end


function putmaxnumacc(task::MSKtask,maxnumacc::Int64)
  @MSK_putmaxnumacc(task.task,maxnumacc)
  nothing
end
function putmaxnumacc(task::MSKtask,maxnumacc::T0) where { T0<:Integer }
  putmaxnumacc(
    task,
    convert(Int64,maxnumacc))
end


function getnumacc(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumacc(task.task,num_)
  num_[]
end


function appendacc(task::MSKtask,domidx::Int64,afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  @MSK_appendacc(task.task,domidx-Int64(1),numafeidx,afeidxlist_,b_)
  nothing
end
function appendacc(task::MSKtask,domidx::T0,afeidxlist::T1,b::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  appendacc(
    task,
    convert(Int64,domidx),
    if afeidxlist === nothing; nothing; else convert(Vector{Int64},afeidxlist); end,
    if b === nothing; nothing; else convert(Vector{Float64},b); end)
end


function appendaccs(task::MSKtask,domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
  numaccs = Int64(length(domidxs))
  domidxs_ = domidxs .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  @MSK_appendaccs(task.task,numaccs,domidxs_,numafeidx,afeidxlist_,b_)
  nothing
end
function appendaccs(task::MSKtask,domidxs::T0,afeidxlist::T1,b::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  appendaccs(
    task,
    if domidxs === nothing; nothing; else convert(Vector{Int64},domidxs); end,
    if afeidxlist === nothing; nothing; else convert(Vector{Int64},afeidxlist); end,
    if b === nothing; nothing; else convert(Vector{Float64},b); end)
end


function appendaccseq(task::MSKtask,domidx::Int64,afeidxfirst::Int64,b::Union{Nothing,Vector{Float64}})
  __tmp_489 = Ref{Int64}()
  @MSK_getdomainn(task.task,domidx-Int64(1),__tmp_489)
  __tmp_488 = __tmp_489[]
  numafeidx = Int64(__tmp_488)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  @MSK_appendaccseq(task.task,domidx-Int64(1),numafeidx,afeidxfirst-Int64(1),b_)
  nothing
end
function appendaccseq(task::MSKtask,domidx::T0,afeidxfirst::T1,b::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  appendaccseq(
    task,
    convert(Int64,domidx),
    convert(Int64,afeidxfirst),
    if b === nothing; nothing; else convert(Vector{Float64},b); end)
end


function appendaccsseq(task::MSKtask,domidxs::Vector{Int64},numafeidx::Int64,afeidxfirst::Int64,b::Union{Nothing,Vector{Float64}})
  numaccs = Int64(length(domidxs))
  domidxs_ = domidxs .- Int64(1)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  @MSK_appendaccsseq(task.task,numaccs,domidxs_,numafeidx,afeidxfirst-Int64(1),b_)
  nothing
end
function appendaccsseq(task::MSKtask,domidxs::T0,numafeidx::T1,afeidxfirst::T2,b::T3) where { T0<:AbstractVector{<:Integer},T1<:Integer,T2<:Integer,T3<:AbstractVector{<:Number} }
  appendaccsseq(
    task,
    if domidxs === nothing; nothing; else convert(Vector{Int64},domidxs); end,
    convert(Int64,numafeidx),
    convert(Int64,afeidxfirst),
    if b === nothing; nothing; else convert(Vector{Float64},b); end)
end


function putacc(task::MSKtask,accidx::Int64,domidx::Int64,afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  @MSK_putacc(task.task,accidx-Int64(1),domidx-Int64(1),numafeidx,afeidxlist_,b_)
  nothing
end
function putacc(task::MSKtask,accidx::T0,domidx::T1,afeidxlist::T2,b::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putacc(
    task,
    convert(Int64,accidx),
    convert(Int64,domidx),
    if afeidxlist === nothing; nothing; else convert(Vector{Int64},afeidxlist); end,
    if b === nothing; nothing; else convert(Vector{Float64},b); end)
end


function putacclist(task::MSKtask,accidxs::Vector{Int64},domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}})
  numaccs = Int64(min(length(domidxs),length(accidxs)))
  accidxs_ = accidxs .- Int64(1)
  domidxs_ = domidxs .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  @MSK_putacclist(task.task,numaccs,accidxs_,domidxs_,numafeidx,afeidxlist_,b_)
  nothing
end
function putacclist(task::MSKtask,accidxs::T0,domidxs::T1,afeidxlist::T2,b::T3) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putacclist(
    task,
    if accidxs === nothing; nothing; else convert(Vector{Int64},accidxs); end,
    if domidxs === nothing; nothing; else convert(Vector{Int64},domidxs); end,
    if afeidxlist === nothing; nothing; else convert(Vector{Int64},afeidxlist); end,
    if b === nothing; nothing; else convert(Vector{Float64},b); end)
end


function putaccb(task::MSKtask,accidx::Int64,b::Union{Nothing,Vector{Float64}})
  lengthb = Int64(length(b))
  b_ = if b === nothing; C_NULL; else b end
  @MSK_putaccb(task.task,accidx-Int64(1),lengthb,b_)
  nothing
end
function putaccb(task::MSKtask,accidx::T0,b::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  putaccb(
    task,
    convert(Int64,accidx),
    if b === nothing; nothing; else convert(Vector{Float64},b); end)
end


function putaccbj(task::MSKtask,accidx::Int64,j::Int64,bj::Float64)
  @MSK_putaccbj(task.task,accidx-Int64(1),j-Int64(1),bj)
  nothing
end
function putaccbj(task::MSKtask,accidx::T0,j::T1,bj::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putaccbj(
    task,
    convert(Int64,accidx),
    convert(Int64,j),
    convert(Float64,bj))
end


function getaccdomain(task::MSKtask,accidx::Int64)
  domidx_ = Ref{Int64}()
  @MSK_getaccdomain(task.task,accidx-Int64(1),domidx_)
  domidx_[]+Int64(1)
end
function getaccdomain(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccdomain(
    task,
    convert(Int64,accidx))
end


function getaccn(task::MSKtask,accidx::Int64)
  n_ = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),n_)
  n_[]
end
function getaccn(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccn(
    task,
    convert(Int64,accidx))
end


function getaccntot(task::MSKtask)
  n_ = Ref{Int64}()
  @MSK_getaccntot(task.task,n_)
  n_[]
end


function getaccafeidxlist(task::MSKtask,accidx::Int64)
  __tmp_500 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_500)
  __tmp_499 = __tmp_500[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_499)
  @MSK_getaccafeidxlist(task.task,accidx-Int64(1),afeidxlist_)
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  afeidxlist
end
function getaccafeidxlist(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccafeidxlist(
    task,
    convert(Int64,accidx))
end


function getaccb(task::MSKtask,accidx::Int64)
  __tmp_503 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_503)
  __tmp_502 = __tmp_503[]
  b_ = Vector{Float64}(undef,__tmp_502)
  @MSK_getaccb(task.task,accidx-Int64(1),b_)
  b = b_;
  b
end
function getaccb(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccb(
    task,
    convert(Int64,accidx))
end


function getaccs(task::MSKtask)
  __tmp_506 = Ref{Int64}()
  @MSK_getnumacc(task.task,__tmp_506)
  __tmp_505 = __tmp_506[]
  domidxlist_ = Vector{Int64}(undef,__tmp_505)
  __tmp_508 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_508)
  __tmp_507 = __tmp_508[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_507)
  __tmp_510 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_510)
  __tmp_509 = __tmp_510[]
  b_ = Vector{Float64}(undef,__tmp_509)
  @MSK_getaccs(task.task,domidxlist_,afeidxlist_,b_)
  domidxlist = domidxlist_;
  domidxlist .+= 1
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  b = b_;
  domidxlist,afeidxlist,b
end


function getaccfnumnz(task::MSKtask)
  accfnnz_ = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,accfnnz_)
  accfnnz_[]
end


function getaccftrip(task::MSKtask)
  __tmp_514 = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,__tmp_514)
  __tmp_513 = __tmp_514[]
  frow_ = Vector{Int64}(undef,__tmp_513)
  __tmp_516 = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,__tmp_516)
  __tmp_515 = __tmp_516[]
  fcol_ = Vector{Int32}(undef,__tmp_515)
  __tmp_518 = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,__tmp_518)
  __tmp_517 = __tmp_518[]
  fval_ = Vector{Float64}(undef,__tmp_517)
  @MSK_getaccftrip(task.task,frow_,fcol_,fval_)
  frow = frow_;
  frow .+= 1
  fcol = fcol_;
  fcol .+= 1
  fval = fval_;
  frow,fcol,fval
end


function getaccgvector(task::MSKtask)
  __tmp_521 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_521)
  __tmp_520 = __tmp_521[]
  g_ = Vector{Float64}(undef,__tmp_520)
  @MSK_getaccgvector(task.task,g_)
  g = g_;
  g
end


function getaccbarfnumblocktriplets(task::MSKtask)
  numtrip_ = Ref{Int64}()
  @MSK_getaccbarfnumblocktriplets(task.task,numtrip_)
  numtrip_[]
end


function getaccbarfblocktriplet(task::MSKtask)
  __tmp_525 = Ref{Int64}()
  @MSK_getaccbarfnumblocktriplets(task.task,__tmp_525)
  __tmp_524 = __tmp_525[]
  maxnumtrip = Int64(__tmp_524)
  numtrip_ = Ref{Int64}()
  acc_afe_ = Vector{Int64}(undef,maxnumtrip)
  bar_var_ = Vector{Int32}(undef,maxnumtrip)
  blk_row_ = Vector{Int32}(undef,maxnumtrip)
  blk_col_ = Vector{Int32}(undef,maxnumtrip)
  blk_val_ = Vector{Float64}(undef,maxnumtrip)
  @MSK_getaccbarfblocktriplet(task.task,maxnumtrip,numtrip_,acc_afe_,bar_var_,blk_row_,blk_col_,blk_val_)
  acc_afe = acc_afe_;
  acc_afe .+= 1
  bar_var = bar_var_;
  bar_var .+= 1
  blk_row = blk_row_;
  blk_row .+= 1
  blk_col = blk_col_;
  blk_col .+= 1
  blk_val = blk_val_;
  numtrip_[],acc_afe,bar_var,blk_row,blk_col,blk_val
end


function appenddjcs(task::MSKtask,num::Int64)
  @MSK_appenddjcs(task.task,num)
  nothing
end
function appenddjcs(task::MSKtask,num::T0) where { T0<:Integer }
  appenddjcs(
    task,
    convert(Int64,num))
end


function putdjc(task::MSKtask,djcidx::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}},termsizelist::Vector{Int64})
  numdomidx = Int64(length(domidxlist))
  domidxlist_ = domidxlist .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  numterms = Int64(length(termsizelist))
  termsizelist_ = termsizelist
  @MSK_putdjc(task.task,djcidx-Int64(1),numdomidx,domidxlist_,numafeidx,afeidxlist_,b_,numterms,termsizelist_)
  nothing
end
function putdjc(task::MSKtask,djcidx::T0,domidxlist::T1,afeidxlist::T2,b::T3,termsizelist::T4) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Integer} }
  putdjc(
    task,
    convert(Int64,djcidx),
    if domidxlist === nothing; nothing; else convert(Vector{Int64},domidxlist); end,
    if afeidxlist === nothing; nothing; else convert(Vector{Int64},afeidxlist); end,
    if b === nothing; nothing; else convert(Vector{Float64},b); end,
    if termsizelist === nothing; nothing; else convert(Vector{Int64},termsizelist); end)
end


function putdjcslice(task::MSKtask,idxfirst::Int64,idxlast::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Union{Nothing,Vector{Float64}},termsizelist::Vector{Int64},termsindjc::Vector{Int64})
  numdomidx = Int64(length(domidxlist))
  domidxlist_ = domidxlist .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if b !== nothing && length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = if b === nothing; C_NULL; else b end
  numterms = Int64(length(termsizelist))
  termsizelist_ = termsizelist
  if termsindjc !== nothing && length(termsindjc) < (idxlast - idxfirst)
    throw(BoundsError())
  end
  termsindjc_ = termsindjc
  @MSK_putdjcslice(task.task,idxfirst-Int64(1),idxlast-Int64(1),numdomidx,domidxlist_,numafeidx,afeidxlist_,b_,numterms,termsizelist_,termsindjc_)
  nothing
end
function putdjcslice(task::MSKtask,idxfirst::T0,idxlast::T1,domidxlist::T2,afeidxlist::T3,b::T4,termsizelist::T5,termsindjc::T6) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer} }
  putdjcslice(
    task,
    convert(Int64,idxfirst),
    convert(Int64,idxlast),
    if domidxlist === nothing; nothing; else convert(Vector{Int64},domidxlist); end,
    if afeidxlist === nothing; nothing; else convert(Vector{Int64},afeidxlist); end,
    if b === nothing; nothing; else convert(Vector{Float64},b); end,
    if termsizelist === nothing; nothing; else convert(Vector{Int64},termsizelist); end,
    if termsindjc === nothing; nothing; else convert(Vector{Int64},termsindjc); end)
end


function getdjcdomainidxlist(task::MSKtask,djcidx::Int64)
  __tmp_531 = Ref{Int64}()
  @MSK_getdjcnumdomain(task.task,djcidx-Int64(1),__tmp_531)
  __tmp_530 = __tmp_531[]
  domidxlist_ = Vector{Int64}(undef,__tmp_530)
  @MSK_getdjcdomainidxlist(task.task,djcidx-Int64(1),domidxlist_)
  domidxlist = domidxlist_;
  domidxlist .+= 1
  domidxlist
end
function getdjcdomainidxlist(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcdomainidxlist(
    task,
    convert(Int64,djcidx))
end


function getdjcafeidxlist(task::MSKtask,djcidx::Int64)
  __tmp_534 = Ref{Int64}()
  @MSK_getdjcnumafe(task.task,djcidx-Int64(1),__tmp_534)
  __tmp_533 = __tmp_534[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_533)
  @MSK_getdjcafeidxlist(task.task,djcidx-Int64(1),afeidxlist_)
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  afeidxlist
end
function getdjcafeidxlist(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcafeidxlist(
    task,
    convert(Int64,djcidx))
end


function getdjcb(task::MSKtask,djcidx::Int64)
  __tmp_537 = Ref{Int64}()
  @MSK_getdjcnumafe(task.task,djcidx-Int64(1),__tmp_537)
  __tmp_536 = __tmp_537[]
  b_ = Vector{Float64}(undef,__tmp_536)
  @MSK_getdjcb(task.task,djcidx-Int64(1),b_)
  b = b_;
  b
end
function getdjcb(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcb(
    task,
    convert(Int64,djcidx))
end


function getdjctermsizelist(task::MSKtask,djcidx::Int64)
  __tmp_540 = Ref{Int64}()
  @MSK_getdjcnumterm(task.task,djcidx-Int64(1),__tmp_540)
  __tmp_539 = __tmp_540[]
  termsizelist_ = Vector{Int64}(undef,__tmp_539)
  @MSK_getdjctermsizelist(task.task,djcidx-Int64(1),termsizelist_)
  termsizelist = termsizelist_;
  termsizelist
end
function getdjctermsizelist(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjctermsizelist(
    task,
    convert(Int64,djcidx))
end


function getdjcs(task::MSKtask)
  __tmp_543 = Ref{Int64}()
  @MSK_getdjcnumdomaintot(task.task,__tmp_543)
  __tmp_542 = __tmp_543[]
  domidxlist_ = Vector{Int64}(undef,__tmp_542)
  __tmp_545 = Ref{Int64}()
  @MSK_getdjcnumafetot(task.task,__tmp_545)
  __tmp_544 = __tmp_545[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_544)
  __tmp_547 = Ref{Int64}()
  @MSK_getdjcnumafetot(task.task,__tmp_547)
  __tmp_546 = __tmp_547[]
  b_ = Vector{Float64}(undef,__tmp_546)
  __tmp_549 = Ref{Int64}()
  @MSK_getdjcnumtermtot(task.task,__tmp_549)
  __tmp_548 = __tmp_549[]
  termsizelist_ = Vector{Int64}(undef,__tmp_548)
  __tmp_551 = Ref{Int64}()
  @MSK_getnumdjc(task.task,__tmp_551)
  __tmp_550 = __tmp_551[]
  numterms_ = Vector{Int64}(undef,__tmp_550)
  @MSK_getdjcs(task.task,domidxlist_,afeidxlist_,b_,termsizelist_,numterms_)
  domidxlist = domidxlist_;
  domidxlist .+= 1
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  b = b_;
  termsizelist = termsizelist_;
  numterms = numterms_;
  domidxlist,afeidxlist,b,termsizelist,numterms
end


function putconbound(task::MSKtask,i::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
  @MSK_putconbound(task.task,i-Int32(1),bkc.value,blc,buc)
  nothing
end
function putconbound(task::MSKtask,i::T0,bkc::Boundkey,blc::T1,buc::T2) where { T0<:Integer,T1<:Number,T2<:Number }
  putconbound(
    task,
    convert(Int32,i),
    bkc,
    convert(Float64,blc),
    convert(Float64,buc))
end


function putconboundlist(task::MSKtask,sub::Vector{Int32},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
  num = Int32(min(length(sub),length(bkc),length(blc),length(buc)))
  sub_ = sub .- Int32(1)
  bkc_ = Int32[item.value for item in bkc]
  blc_ = blc
  buc_ = buc
  @MSK_putconboundlist(task.task,num,sub_,bkc_,blc_,buc_)
  nothing
end
function putconboundlist(task::MSKtask,sub::T0,bkc::Vector{Boundkey},blc::T1,buc::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number} }
  putconboundlist(
    task,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end,
    bkc,
    if blc === nothing; nothing; else convert(Vector{Float64},blc); end,
    if buc === nothing; nothing; else convert(Vector{Float64},buc); end)
end


function putconboundlistconst(task::MSKtask,sub::Vector{Int32},bkc::Boundkey,blc::Float64,buc::Float64)
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  @MSK_putconboundlistconst(task.task,num,sub_,bkc.value,blc,buc)
  nothing
end
function putconboundlistconst(task::MSKtask,sub::T0,bkc::Boundkey,blc::T1,buc::T2) where { T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number }
  putconboundlistconst(
    task,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end,
    bkc,
    convert(Float64,blc),
    convert(Float64,buc))
end


function putconboundslice(task::MSKtask,first::Int32,last::Int32,bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
  if length(bkc) < (last - first)
    throw(BoundsError())
  end
  bkc_ = Int32[item.value for item in bkc]
  if blc !== nothing && length(blc) < (last - first)
    throw(BoundsError())
  end
  blc_ = blc
  if buc !== nothing && length(buc) < (last - first)
    throw(BoundsError())
  end
  buc_ = buc
  @MSK_putconboundslice(task.task,first-Int32(1),last-Int32(1),bkc_,blc_,buc_)
  nothing
end
function putconboundslice(task::MSKtask,first::T0,last::T1,bkc::Vector{Boundkey},blc::T2,buc::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number} }
  putconboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkc,
    if blc === nothing; nothing; else convert(Vector{Float64},blc); end,
    if buc === nothing; nothing; else convert(Vector{Float64},buc); end)
end


function putconboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
  @MSK_putconboundsliceconst(task.task,first-Int32(1),last-Int32(1),bkc.value,blc,buc)
  nothing
end
function putconboundsliceconst(task::MSKtask,first::T0,last::T1,bkc::Boundkey,blc::T2,buc::T3) where { T0<:Integer,T1<:Integer,T2<:Number,T3<:Number }
  putconboundsliceconst(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkc,
    convert(Float64,blc),
    convert(Float64,buc))
end


function putvarbound(task::MSKtask,j::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
  @MSK_putvarbound(task.task,j-Int32(1),bkx.value,blx,bux)
  nothing
end
function putvarbound(task::MSKtask,j::T0,bkx::Boundkey,blx::T1,bux::T2) where { T0<:Integer,T1<:Number,T2<:Number }
  putvarbound(
    task,
    convert(Int32,j),
    bkx,
    convert(Float64,blx),
    convert(Float64,bux))
end


function putvarboundlist(task::MSKtask,sub::Vector{Int32},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  num = Int32(min(length(sub),length(bkx),length(blx),length(bux)))
  sub_ = sub .- Int32(1)
  bkx_ = Int32[item.value for item in bkx]
  blx_ = blx
  bux_ = bux
  @MSK_putvarboundlist(task.task,num,sub_,bkx_,blx_,bux_)
  nothing
end
function putvarboundlist(task::MSKtask,sub::T0,bkx::Vector{Boundkey},blx::T1,bux::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number} }
  putvarboundlist(
    task,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end,
    bkx,
    if blx === nothing; nothing; else convert(Vector{Float64},blx); end,
    if bux === nothing; nothing; else convert(Vector{Float64},bux); end)
end


function putvarboundlistconst(task::MSKtask,sub::Vector{Int32},bkx::Boundkey,blx::Float64,bux::Float64)
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  @MSK_putvarboundlistconst(task.task,num,sub_,bkx.value,blx,bux)
  nothing
end
function putvarboundlistconst(task::MSKtask,sub::T0,bkx::Boundkey,blx::T1,bux::T2) where { T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number }
  putvarboundlistconst(
    task,
    if sub === nothing; nothing; else convert(Vector{Int32},sub); end,
    bkx,
    convert(Float64,blx),
    convert(Float64,bux))
end


function putvarboundslice(task::MSKtask,first::Int32,last::Int32,bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  if length(bkx) < (last - first)
    throw(BoundsError())
  end
  bkx_ = Int32[item.value for item in bkx]
  if blx !== nothing && length(blx) < (last - first)
    throw(BoundsError())
  end
  blx_ = blx
  if bux !== nothing && length(bux) < (last - first)
    throw(BoundsError())
  end
  bux_ = bux
  @MSK_putvarboundslice(task.task,first-Int32(1),last-Int32(1),bkx_,blx_,bux_)
  nothing
end
function putvarboundslice(task::MSKtask,first::T0,last::T1,bkx::Vector{Boundkey},blx::T2,bux::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number} }
  putvarboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkx,
    if blx === nothing; nothing; else convert(Vector{Float64},blx); end,
    if bux === nothing; nothing; else convert(Vector{Float64},bux); end)
end


function putvarboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
  @MSK_putvarboundsliceconst(task.task,first-Int32(1),last-Int32(1),bkx.value,blx,bux)
  nothing
end
function putvarboundsliceconst(task::MSKtask,first::T0,last::T1,bkx::Boundkey,blx::T2,bux::T3) where { T0<:Integer,T1<:Integer,T2<:Number,T3<:Number }
  putvarboundsliceconst(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkx,
    convert(Float64,blx),
    convert(Float64,bux))
end


function putcfix(task::MSKtask,cfix::Float64)
  @MSK_putcfix(task.task,cfix)
  nothing
end
function putcfix(task::MSKtask,cfix::T0) where { T0<:Number }
  putcfix(
    task,
    convert(Float64,cfix))
end


function putcj(task::MSKtask,j::Int32,cj::Float64)
  @MSK_putcj(task.task,j-Int32(1),cj)
  nothing
end
function putcj(task::MSKtask,j::T0,cj::T1) where { T0<:Integer,T1<:Number }
  putcj(
    task,
    convert(Int32,j),
    convert(Float64,cj))
end


function putobjsense(task::MSKtask,sense::Objsense)
  @MSK_putobjsense(task.task,sense.value)
  nothing
end


function getobjsense(task::MSKtask)
  sense_ = Ref{Int32}()
  @MSK_getobjsense(task.task,sense_)
  sense = Objsense(sense_[])
  sense
end


function putclist(task::MSKtask,subj::Vector{Int32},val::Vector{Float64})
  num = Int32(min(length(subj),length(val)))
  subj_ = subj .- Int32(1)
  val_ = val
  @MSK_putclist(task.task,num,subj_,val_)
  nothing
end
function putclist(task::MSKtask,subj::T0,val::T1) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number} }
  putclist(
    task,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if val === nothing; nothing; else convert(Vector{Float64},val); end)
end


function putcslice(task::MSKtask,first::Int32,last::Int32,slice::Vector{Float64})
  if slice !== nothing && length(slice) < (last - first)
    throw(BoundsError())
  end
  slice_ = slice
  @MSK_putcslice(task.task,first-Int32(1),last-Int32(1),slice_)
  nothing
end
function putcslice(task::MSKtask,first::T0,last::T1,slice::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putcslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    if slice === nothing; nothing; else convert(Vector{Float64},slice); end)
end


function putbarcj(task::MSKtask,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
  num = Int64(min(length(sub),length(weights)))
  sub_ = sub .- Int64(1)
  weights_ = weights
  @MSK_putbarcj(task.task,j-Int32(1),num,sub_,weights_)
  nothing
end
function putbarcj(task::MSKtask,j::T0,sub::T1,weights::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putbarcj(
    task,
    convert(Int32,j),
    if sub === nothing; nothing; else convert(Vector{Int64},sub); end,
    if weights === nothing; nothing; else convert(Vector{Float64},weights); end)
end


function putcone(task::MSKtask,k::Int32,ct::Conetype,conepar::Float64,submem::Vector{Int32})
  nummem = Int32(length(submem))
  submem_ = submem .- Int32(1)
  @MSK_putcone(task.task,k-Int32(1),ct.value,conepar,nummem,submem_)
  nothing
end
function putcone(task::MSKtask,k::T0,ct::Conetype,conepar::T1,submem::T2) where { T0<:Integer,T1<:Number,T2<:AbstractVector{<:Integer} }
  putcone(
    task,
    convert(Int32,k),
    ct,
    convert(Float64,conepar),
    if submem === nothing; nothing; else convert(Vector{Int32},submem); end)
end


function putmaxnumdomain(task::MSKtask,maxnumdomain::Int64)
  @MSK_putmaxnumdomain(task.task,maxnumdomain)
  nothing
end
function putmaxnumdomain(task::MSKtask,maxnumdomain::T0) where { T0<:Integer }
  putmaxnumdomain(
    task,
    convert(Int64,maxnumdomain))
end


function getnumdomain(task::MSKtask)
  numdomain_ = Ref{Int64}()
  @MSK_getnumdomain(task.task,numdomain_)
  numdomain_[]
end


function appendrplusdomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrplusdomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrplusdomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrplusdomain(
    task,
    convert(Int64,n))
end


function appendrminusdomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrminusdomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrminusdomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrminusdomain(
    task,
    convert(Int64,n))
end


function appendrdomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrdomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrdomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrdomain(
    task,
    convert(Int64,n))
end


function appendrzerodomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrzerodomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrzerodomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrzerodomain(
    task,
    convert(Int64,n))
end


function appendquadraticconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendquadraticconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendquadraticconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendquadraticconedomain(
    task,
    convert(Int64,n))
end


function appendrquadraticconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrquadraticconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrquadraticconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrquadraticconedomain(
    task,
    convert(Int64,n))
end


function appendprimalexpconedomain(task::MSKtask)
  domidx_ = Ref{Int64}()
  @MSK_appendprimalexpconedomain(task.task,domidx_)
  domidx_[]+Int64(1)
end


function appenddualexpconedomain(task::MSKtask)
  domidx_ = Ref{Int64}()
  @MSK_appenddualexpconedomain(task.task,domidx_)
  domidx_[]+Int64(1)
end


function appendprimalgeomeanconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendprimalgeomeanconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendprimalgeomeanconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendprimalgeomeanconedomain(
    task,
    convert(Int64,n))
end


function appenddualgeomeanconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appenddualgeomeanconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appenddualgeomeanconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appenddualgeomeanconedomain(
    task,
    convert(Int64,n))
end


function appendprimalpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64})
  nleft = Int64(length(alpha))
  alpha_ = alpha
  domidx_ = Ref{Int64}()
  @MSK_appendprimalpowerconedomain(task.task,n,nleft,alpha_,domidx_)
  domidx_[]+Int64(1)
end
function appendprimalpowerconedomain(task::MSKtask,n::T0,alpha::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  appendprimalpowerconedomain(
    task,
    convert(Int64,n),
    if alpha === nothing; nothing; else convert(Vector{Float64},alpha); end)
end


function appenddualpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64})
  nleft = Int64(length(alpha))
  alpha_ = alpha
  domidx_ = Ref{Int64}()
  @MSK_appenddualpowerconedomain(task.task,n,nleft,alpha_,domidx_)
  domidx_[]+Int64(1)
end
function appenddualpowerconedomain(task::MSKtask,n::T0,alpha::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  appenddualpowerconedomain(
    task,
    convert(Int64,n),
    if alpha === nothing; nothing; else convert(Vector{Float64},alpha); end)
end


function appendsvecpsdconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendsvecpsdconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendsvecpsdconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendsvecpsdconedomain(
    task,
    convert(Int64,n))
end


function getdomaintype(task::MSKtask,domidx::Int64)
  domtype_ = Ref{Int32}()
  @MSK_getdomaintype(task.task,domidx-Int64(1),domtype_)
  domtype = Domaintype(domtype_[])
  domtype
end
function getdomaintype(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomaintype(
    task,
    convert(Int64,domidx))
end


function getdomainn(task::MSKtask,domidx::Int64)
  n_ = Ref{Int64}()
  @MSK_getdomainn(task.task,domidx-Int64(1),n_)
  n_[]
end
function getdomainn(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomainn(
    task,
    convert(Int64,domidx))
end


function getpowerdomaininfo(task::MSKtask,domidx::Int64)
  n_ = Ref{Int64}()
  nleft_ = Ref{Int64}()
  @MSK_getpowerdomaininfo(task.task,domidx-Int64(1),n_,nleft_)
  n_[],nleft_[]
end
function getpowerdomaininfo(task::MSKtask,domidx::T0) where { T0<:Integer }
  getpowerdomaininfo(
    task,
    convert(Int64,domidx))
end


function getpowerdomainalpha(task::MSKtask,domidx::Int64)
  __tmp_590 = Ref{Int64}()
  @MSK_getpowerdomaininfo(task.task,domidx-Int64(1),Ref{Int64}(),__tmp_590)
  __tmp_589 = __tmp_590[]
  alpha_ = Vector{Float64}(undef,__tmp_589)
  @MSK_getpowerdomainalpha(task.task,domidx-Int64(1),alpha_)
  alpha = alpha_;
  alpha
end
function getpowerdomainalpha(task::MSKtask,domidx::T0) where { T0<:Integer }
  getpowerdomainalpha(
    task,
    convert(Int64,domidx))
end


function appendsparsesymmat(task::MSKtask,dim::Int32,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
  nz = Int64(min(length(subi),length(subj),length(valij)))
  subi_ = subi .- Int32(1)
  subj_ = subj .- Int32(1)
  valij_ = valij
  idx_ = Ref{Int64}()
  @MSK_appendsparsesymmat(task.task,dim,nz,subi_,subj_,valij_,idx_)
  idx_[]+Int64(1)
end
function appendsparsesymmat(task::MSKtask,dim::T0,data:: SparseMatrixCSC{Float64}) where {T0<:Integer}
  subi,subj,valij = tril(data)
  appendsparsesymmat(task,dim,subi,subj,valij)
end
function appendsparsesymmat(task::MSKtask,dim::T0,subi::T1,subj::T2,valij::T3) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  appendsparsesymmat(
    task,
    convert(Int32,dim),
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if valij === nothing; nothing; else convert(Vector{Float64},valij); end)
end


function appendsparsesymmatlist(task::MSKtask,dims::Vector{Int32},nz::Vector{Int64},subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
  num = Int32(min(length(dims),length(nz)))
  dims_ = dims
  nz_ = nz
  if subi !== nothing && length(subi) < sum(nz)
    throw(BoundsError())
  end
  subi_ = subi .- Int32(1)
  if subj !== nothing && length(subj) < sum(nz)
    throw(BoundsError())
  end
  subj_ = subj .- Int32(1)
  if valij !== nothing && length(valij) < sum(nz)
    throw(BoundsError())
  end
  valij_ = valij
  idx_ = Vector{Int64}(undef,num)
  @MSK_appendsparsesymmatlist(task.task,num,dims_,nz_,subi_,subj_,valij_,idx_)
  idx = idx_;
  idx .+= 1
  idx
end
function appendsparsesymmatlist(task::MSKtask,dims::T0,nz::T1,subi::T2,subj::T3,valij::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  appendsparsesymmatlist(
    task,
    if dims === nothing; nothing; else convert(Vector{Int32},dims); end,
    if nz === nothing; nothing; else convert(Vector{Int64},nz); end,
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    if valij === nothing; nothing; else convert(Vector{Float64},valij); end)
end


function getsymmatinfo(task::MSKtask,idx::Int64)
  dim_ = Ref{Int32}()
  nz_ = Ref{Int64}()
  mattype_ = Ref{Int32}()
  @MSK_getsymmatinfo(task.task,idx-Int64(1),dim_,nz_,mattype_)
  mattype = Symmattype(mattype_[])
  dim_[],nz_[],mattype
end
function getsymmatinfo(task::MSKtask,idx::T0) where { T0<:Integer }
  getsymmatinfo(
    task,
    convert(Int64,idx))
end


function getnumsymmat(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumsymmat(task.task,num_)
  num_[]
end


function getsparsesymmat(task::MSKtask,idx::Int64)
  __tmp_597 = Ref{Int64}()
  @MSK_getsymmatinfo(task.task,idx-Int64(1),Ref{Int32}(),__tmp_597,Ref{Int32}())
  __tmp_596 = __tmp_597[]
  maxlen = Int64(__tmp_596)
  subi_ = Vector{Int32}(undef,maxlen)
  subj_ = Vector{Int32}(undef,maxlen)
  valij_ = Vector{Float64}(undef,maxlen)
  @MSK_getsparsesymmat(task.task,idx-Int64(1),maxlen,subi_,subj_,valij_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  valij = valij_;
  subi,subj,valij
end
function getsparsesymmat(task::MSKtask,idx::T0) where { T0<:Integer }
  getsparsesymmat(
    task,
    convert(Int64,idx))
end


function putdouparam(task::MSKtask,param::Dparam,parvalue::Float64)
  @MSK_putdouparam(task.task,param.value,parvalue)
  nothing
end
function putdouparam(task::MSKtask,param::Dparam,parvalue::T0) where { T0<:Number }
  putdouparam(
    task,
    param,
    convert(Float64,parvalue))
end


function putintparam(task::MSKtask,param::Iparam,parvalue::Int32)
  @MSK_putintparam(task.task,param.value,parvalue)
  nothing
end
function putintparam(task::MSKtask,param::Iparam,parvalue::T0) where { T0<:Integer }
  putintparam(
    task,
    param,
    convert(Int32,parvalue))
end


function putmaxnumcon(task::MSKtask,maxnumcon::Int32)
  @MSK_putmaxnumcon(task.task,maxnumcon)
  nothing
end
function putmaxnumcon(task::MSKtask,maxnumcon::T0) where { T0<:Integer }
  putmaxnumcon(
    task,
    convert(Int32,maxnumcon))
end


function putmaxnumcone(task::MSKtask,maxnumcone::Int32)
  @MSK_putmaxnumcone(task.task,maxnumcone)
  nothing
end
function putmaxnumcone(task::MSKtask,maxnumcone::T0) where { T0<:Integer }
  putmaxnumcone(
    task,
    convert(Int32,maxnumcone))
end


function getmaxnumcone(task::MSKtask)
  maxnumcone_ = Ref{Int32}()
  @MSK_getmaxnumcone(task.task,maxnumcone_)
  maxnumcone_[]
end


function putmaxnumvar(task::MSKtask,maxnumvar::Int32)
  @MSK_putmaxnumvar(task.task,maxnumvar)
  nothing
end
function putmaxnumvar(task::MSKtask,maxnumvar::T0) where { T0<:Integer }
  putmaxnumvar(
    task,
    convert(Int32,maxnumvar))
end


function putmaxnumbarvar(task::MSKtask,maxnumbarvar::Int32)
  @MSK_putmaxnumbarvar(task.task,maxnumbarvar)
  nothing
end
function putmaxnumbarvar(task::MSKtask,maxnumbarvar::T0) where { T0<:Integer }
  putmaxnumbarvar(
    task,
    convert(Int32,maxnumbarvar))
end


function putmaxnumanz(task::MSKtask,maxnumanz::Int64)
  @MSK_putmaxnumanz(task.task,maxnumanz)
  nothing
end
function putmaxnumanz(task::MSKtask,maxnumanz::T0) where { T0<:Integer }
  putmaxnumanz(
    task,
    convert(Int64,maxnumanz))
end


function putmaxnumqnz(task::MSKtask,maxnumqnz::Int64)
  @MSK_putmaxnumqnz(task.task,maxnumqnz)
  nothing
end
function putmaxnumqnz(task::MSKtask,maxnumqnz::T0) where { T0<:Integer }
  putmaxnumqnz(
    task,
    convert(Int64,maxnumqnz))
end


function getmaxnumqnz(task::MSKtask)
  maxnumqnz_ = Ref{Int64}()
  @MSK_getmaxnumqnz64(task.task,maxnumqnz_)
  maxnumqnz_[]
end


function putnadouparam(task::MSKtask,paramname::AbstractString,parvalue::Float64)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  @MSK_putnadouparam(task.task,paramname_,parvalue)
  nothing
end
function putnadouparam(task::MSKtask,paramname::Union{Nothing,AbstractString},parvalue::T0) where { T0<:Number }
  putnadouparam(
    task,
    paramname,
    convert(Float64,parvalue))
end


function putnaintparam(task::MSKtask,paramname::AbstractString,parvalue::Int32)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  @MSK_putnaintparam(task.task,paramname_,parvalue)
  nothing
end
function putnaintparam(task::MSKtask,paramname::Union{Nothing,AbstractString},parvalue::T0) where { T0<:Integer }
  putnaintparam(
    task,
    paramname,
    convert(Int32,parvalue))
end


function putnastrparam(task::MSKtask,paramname::AbstractString,parvalue::AbstractString)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  parvalue_ = Vector{UInt8}(parvalue); push!(parvalue_,UInt8(0))
  @MSK_putnastrparam(task.task,paramname_,parvalue_)
  nothing
end


function putobjname(task::MSKtask,objname::AbstractString)
  objname_ = Vector{UInt8}(objname); push!(objname_,UInt8(0))
  @MSK_putobjname(task.task,objname_)
  nothing
end


function putparam(task::MSKtask,parname::AbstractString,parvalue::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  parvalue_ = Vector{UInt8}(parvalue); push!(parvalue_,UInt8(0))
  @MSK_putparam(task.task,parname_,parvalue_)
  nothing
end


function putqcon(task::MSKtask,qcsubk::Vector{Int32},qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
  numqcnz = Int32(min(length(qcsubi),length(qcsubj),length(qcval)))
  qcsubk_ = qcsubk .- Int32(1)
  qcsubi_ = qcsubi .- Int32(1)
  qcsubj_ = qcsubj .- Int32(1)
  qcval_ = qcval
  @MSK_putqcon(task.task,numqcnz,qcsubk_,qcsubi_,qcsubj_,qcval_)
  nothing
end
function putqcon(task::MSKtask,qcsubk::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putqcon(
    task,
    if qcsubk === nothing; nothing; else convert(Vector{Int32},qcsubk); end,
    if qcsubi === nothing; nothing; else convert(Vector{Int32},qcsubi); end,
    if qcsubj === nothing; nothing; else convert(Vector{Int32},qcsubj); end,
    if qcval === nothing; nothing; else convert(Vector{Float64},qcval); end)
end


function putqconk(task::MSKtask,k::Int32,qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
  numqcnz = Int32(min(length(qcsubi),length(qcsubj),length(qcval)))
  qcsubi_ = qcsubi .- Int32(1)
  qcsubj_ = qcsubj .- Int32(1)
  qcval_ = qcval
  @MSK_putqconk(task.task,k-Int32(1),numqcnz,qcsubi_,qcsubj_,qcval_)
  nothing
end
function putqconk(task::MSKtask,k::T0,Qk:: SparseMatrixCSC{Float64}) where {T0<:Integer}
  qcsubi,qcsubj,qcval = tril(Qk)
  putqconk(task,k,qcsubi,qcsubj,qcval)
end
function putqconk(task::MSKtask,k::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putqconk(
    task,
    convert(Int32,k),
    if qcsubi === nothing; nothing; else convert(Vector{Int32},qcsubi); end,
    if qcsubj === nothing; nothing; else convert(Vector{Int32},qcsubj); end,
    if qcval === nothing; nothing; else convert(Vector{Float64},qcval); end)
end


function putqobj(task::MSKtask,qosubi::Vector{Int32},qosubj::Vector{Int32},qoval::Vector{Float64})
  numqonz = Int32(min(length(qosubi),length(qosubj),length(qoval)))
  qosubi_ = qosubi .- Int32(1)
  qosubj_ = qosubj .- Int32(1)
  qoval_ = qoval
  @MSK_putqobj(task.task,numqonz,qosubi_,qosubj_,qoval_)
  nothing
end
function putqobj(task::MSKtask,Qk:: SparseMatrixCSC{Float64})
  qosubi,qosubj,qoval = tril(Qk)
  putqobj(task,qosubi,qosubj,qoval)
end
function putqobj(task::MSKtask,qosubi::T0,qosubj::T1,qoval::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putqobj(
    task,
    if qosubi === nothing; nothing; else convert(Vector{Int32},qosubi); end,
    if qosubj === nothing; nothing; else convert(Vector{Int32},qosubj); end,
    if qoval === nothing; nothing; else convert(Vector{Float64},qoval); end)
end


function putqobjij(task::MSKtask,i::Int32,j::Int32,qoij::Float64)
  @MSK_putqobjij(task.task,i-Int32(1),j-Int32(1),qoij)
  nothing
end
function putqobjij(task::MSKtask,i::T0,j::T1,qoij::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putqobjij(
    task,
    convert(Int32,i),
    convert(Int32,j),
    convert(Float64,qoij))
end


function putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Union{Nothing,Vector{Float64}},xx::Union{Nothing,Vector{Float64}},y::Union{Nothing,Vector{Float64}},slc::Union{Nothing,Vector{Float64}},suc::Union{Nothing,Vector{Float64}},slx::Union{Nothing,Vector{Float64}},sux::Union{Nothing,Vector{Float64}},snx::Union{Nothing,Vector{Float64}})
  skc_ = Int32[item.value for item in skc]
  skx_ = Int32[item.value for item in skx]
  skn_ = Int32[item.value for item in skn]
  xc_ = if xc === nothing; C_NULL; else xc end
  xx_ = if xx === nothing; C_NULL; else xx end
  y_ = if y === nothing; C_NULL; else y end
  slc_ = if slc === nothing; C_NULL; else slc end
  suc_ = if suc === nothing; C_NULL; else suc end
  slx_ = if slx === nothing; C_NULL; else slx end
  sux_ = if sux === nothing; C_NULL; else sux end
  snx_ = if snx === nothing; C_NULL; else snx end
  @MSK_putsolution(task.task,whichsol.value,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_)
  nothing
end
function putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number} }
  putsolution(
    task,
    whichsol,
    skc,
    skx,
    skn,
    if xc === nothing; nothing; else convert(Vector{Float64},xc); end,
    if xx === nothing; nothing; else convert(Vector{Float64},xx); end,
    if y === nothing; nothing; else convert(Vector{Float64},y); end,
    if slc === nothing; nothing; else convert(Vector{Float64},slc); end,
    if suc === nothing; nothing; else convert(Vector{Float64},suc); end,
    if slx === nothing; nothing; else convert(Vector{Float64},slx); end,
    if sux === nothing; nothing; else convert(Vector{Float64},sux); end,
    if snx === nothing; nothing; else convert(Vector{Float64},snx); end)
end


function putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Union{Nothing,Vector{Float64}},xx::Union{Nothing,Vector{Float64}},y::Union{Nothing,Vector{Float64}},slc::Union{Nothing,Vector{Float64}},suc::Union{Nothing,Vector{Float64}},slx::Union{Nothing,Vector{Float64}},sux::Union{Nothing,Vector{Float64}},snx::Union{Nothing,Vector{Float64}},doty::Union{Nothing,Vector{Float64}})
  skc_ = Int32[item.value for item in skc]
  skx_ = Int32[item.value for item in skx]
  skn_ = Int32[item.value for item in skn]
  xc_ = if xc === nothing; C_NULL; else xc end
  xx_ = if xx === nothing; C_NULL; else xx end
  y_ = if y === nothing; C_NULL; else y end
  slc_ = if slc === nothing; C_NULL; else slc end
  suc_ = if suc === nothing; C_NULL; else suc end
  slx_ = if slx === nothing; C_NULL; else slx end
  sux_ = if sux === nothing; C_NULL; else sux end
  snx_ = if snx === nothing; C_NULL; else snx end
  doty_ = if doty === nothing; C_NULL; else doty end
  @MSK_putsolutionnew(task.task,whichsol.value,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_,doty_)
  nothing
end
function putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7,doty::T8) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number} }
  putsolutionnew(
    task,
    whichsol,
    skc,
    skx,
    skn,
    if xc === nothing; nothing; else convert(Vector{Float64},xc); end,
    if xx === nothing; nothing; else convert(Vector{Float64},xx); end,
    if y === nothing; nothing; else convert(Vector{Float64},y); end,
    if slc === nothing; nothing; else convert(Vector{Float64},slc); end,
    if suc === nothing; nothing; else convert(Vector{Float64},suc); end,
    if slx === nothing; nothing; else convert(Vector{Float64},slx); end,
    if sux === nothing; nothing; else convert(Vector{Float64},sux); end,
    if snx === nothing; nothing; else convert(Vector{Float64},snx); end,
    if doty === nothing; nothing; else convert(Vector{Float64},doty); end)
end


function putconsolutioni(task::MSKtask,i::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64)
  @MSK_putconsolutioni(task.task,i-Int32(1),whichsol.value,sk.value,x,sl,su)
  nothing
end
function putconsolutioni(task::MSKtask,i::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3) where { T0<:Integer,T1<:Number,T2<:Number,T3<:Number }
  putconsolutioni(
    task,
    convert(Int32,i),
    whichsol,
    sk,
    convert(Float64,x),
    convert(Float64,sl),
    convert(Float64,su))
end


function putvarsolutionj(task::MSKtask,j::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64,sn::Float64)
  @MSK_putvarsolutionj(task.task,j-Int32(1),whichsol.value,sk.value,x,sl,su,sn)
  nothing
end
function putvarsolutionj(task::MSKtask,j::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3,sn::T4) where { T0<:Integer,T1<:Number,T2<:Number,T3<:Number,T4<:Number }
  putvarsolutionj(
    task,
    convert(Int32,j),
    whichsol,
    sk,
    convert(Float64,x),
    convert(Float64,sl),
    convert(Float64,su),
    convert(Float64,sn))
end


function putsolutionyi(task::MSKtask,i::Int32,whichsol::Soltype,y::Float64)
  @MSK_putsolutionyi(task.task,i-Int32(1),whichsol.value,y)
  nothing
end
function putsolutionyi(task::MSKtask,i::T0,whichsol::Soltype,y::T1) where { T0<:Integer,T1<:Number }
  putsolutionyi(
    task,
    convert(Int32,i),
    whichsol,
    convert(Float64,y))
end


function putstrparam(task::MSKtask,param::Sparam,parvalue::AbstractString)
  parvalue_ = Vector{UInt8}(parvalue); push!(parvalue_,UInt8(0))
  @MSK_putstrparam(task.task,param.value,parvalue_)
  nothing
end


function puttaskname(task::MSKtask,taskname::AbstractString)
  taskname_ = Vector{UInt8}(taskname); push!(taskname_,UInt8(0))
  @MSK_puttaskname(task.task,taskname_)
  nothing
end


function putvartype(task::MSKtask,j::Int32,vartype::Variabletype)
  @MSK_putvartype(task.task,j-Int32(1),vartype.value)
  nothing
end
function putvartype(task::MSKtask,j::T0,vartype::Variabletype) where { T0<:Integer }
  putvartype(
    task,
    convert(Int32,j),
    vartype)
end


function putvartypelist(task::MSKtask,subj::Vector{Int32},vartype::Vector{Variabletype})
  num = Int32(min(length(subj),length(vartype)))
  subj_ = subj .- Int32(1)
  vartype_ = Int32[item.value for item in vartype]
  @MSK_putvartypelist(task.task,num,subj_,vartype_)
  nothing
end
function putvartypelist(task::MSKtask,subj::T0,vartype::Vector{Variabletype}) where { T0<:AbstractVector{<:Integer} }
  putvartypelist(
    task,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    vartype)
end


function readdataformat(task::MSKtask,filename::AbstractString,format::Dataformat,compress::Compresstype)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readdataformat(task.task,filename_,format.value,compress.value)
  nothing
end


function readdata(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readdataautoformat(task.task,filename_)
  nothing
end


function readparamfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readparamfile(task.task,filename_)
  nothing
end


function readsolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readsolution(task.task,whichsol.value,filename_)
  nothing
end


function readjsonsol(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readjsonsol(task.task,filename_)
  nothing
end


function readsummary(task::MSKtask,whichstream::Streamtype)
  @MSK_readsummary(task.task,whichstream.value)
  nothing
end


function resizetask(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,maxnumcone::Int32,maxnumanz::Int64,maxnumqnz::Int64)
  @MSK_resizetask(task.task,maxnumcon,maxnumvar,maxnumcone,maxnumanz,maxnumqnz)
  nothing
end
function resizetask(task::MSKtask,maxnumcon::T0,maxnumvar::T1,maxnumcone::T2,maxnumanz::T3,maxnumqnz::T4) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer,T4<:Integer }
  resizetask(
    task,
    convert(Int32,maxnumcon),
    convert(Int32,maxnumvar),
    convert(Int32,maxnumcone),
    convert(Int64,maxnumanz),
    convert(Int64,maxnumqnz))
end


function checkmem(task::MSKtask,file::AbstractString,line::Int32)
  file_ = Vector{UInt8}(file); push!(file_,UInt8(0))
  @MSK_checkmemtask(task.task,file_,line)
  nothing
end
function checkmem(task::MSKtask,file::Union{Nothing,AbstractString},line::T0) where { T0<:Integer }
  checkmem(
    task,
    file,
    convert(Int32,line))
end


function getmemusage(task::MSKtask)
  meminuse_ = Ref{Int64}()
  maxmemuse_ = Ref{Int64}()
  @MSK_getmemusagetask(task.task,meminuse_,maxmemuse_)
  meminuse_[],maxmemuse_[]
end


function setdefaults(task::MSKtask)
  @MSK_setdefaults(task.task)
  nothing
end


function solutiondef(task::MSKtask,whichsol::Soltype)
  isdef_ = Ref{Int32}()
  @MSK_solutiondef(task.task,whichsol.value,isdef_)
  isdef_[] != 0
end


function deletesolution(task::MSKtask,whichsol::Soltype)
  @MSK_deletesolution(task.task,whichsol.value)
  nothing
end


function onesolutionsummary(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)
  @MSK_onesolutionsummary(task.task,whichstream.value,whichsol.value)
  nothing
end


function solutionsummary(task::MSKtask,whichstream::Streamtype)
  @MSK_solutionsummary(task.task,whichstream.value)
  nothing
end


function updatesolutioninfo(task::MSKtask,whichsol::Soltype)
  @MSK_updatesolutioninfo(task.task,whichsol.value)
  nothing
end


function optimizersummary(task::MSKtask,whichstream::Streamtype)
  @MSK_optimizersummary(task.task,whichstream.value)
  nothing
end


function strtoconetype(task::MSKtask,str::AbstractString)
  str_ = Vector{UInt8}(str); push!(str_,UInt8(0))
  conetype_ = Ref{Int32}()
  @MSK_strtoconetype(task.task,str_,conetype_)
  conetype = Conetype(conetype_[])
  conetype
end


function strtosk(task::MSKtask,str::AbstractString)
  str_ = Vector{UInt8}(str); push!(str_,UInt8(0))
  sk_ = Ref{Int32}()
  @MSK_strtosk(task.task,str_,sk_)
  sk = Stakey(sk_[])
  sk
end


function writedata(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writedata(task.task,filename_)
  nothing
end


function writetask(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writetask(task.task,filename_)
  nothing
end


function writebsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writebsolution(task.task,filename_,compress.value)
  nothing
end


function readbsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readbsolution(task.task,filename_,compress.value)
  nothing
end


function writesolutionfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writesolutionfile(task.task,filename_)
  nothing
end


function readsolutionfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readsolutionfile(task.task,filename_)
  nothing
end


function readtask(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readtask(task.task,filename_)
  nothing
end


function readopfstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readopfstring(task.task,data_)
  nothing
end


function readlpstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readlpstring(task.task,data_)
  nothing
end


function readjsonstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readjsonstring(task.task,data_)
  nothing
end


function readptfstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readptfstring(task.task,data_)
  nothing
end


function writeparamfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writeparamfile(task.task,filename_)
  nothing
end


function getinfeasiblesubproblem(task::MSKtask,whichsol::Soltype)
  inftask_ = Ref{Ptr{Nothing}}()
  @MSK_getinfeasiblesubproblem(task.task,whichsol.value,inftask_)
  inftask = Task(inftask_[],False)
  inftask
end


function writesolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writesolution(task.task,whichsol.value,filename_)
  nothing
end


function writejsonsol(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writejsonsol(task.task,filename_)
  nothing
end


function primalsensitivity(task::MSKtask,subi::Vector{Int32},marki::Vector{Mark},subj::Vector{Int32},markj::Vector{Mark})
  numi = Int32(min(length(subi),length(marki)))
  subi_ = subi .- Int32(1)
  marki_ = Int32[item.value for item in marki]
  numj = Int32(min(length(subj),length(markj)))
  subj_ = subj .- Int32(1)
  markj_ = Int32[item.value for item in markj]
  leftpricei_ = Vector{Float64}(undef,numi)
  rightpricei_ = Vector{Float64}(undef,numi)
  leftrangei_ = Vector{Float64}(undef,numi)
  rightrangei_ = Vector{Float64}(undef,numi)
  leftpricej_ = Vector{Float64}(undef,numj)
  rightpricej_ = Vector{Float64}(undef,numj)
  leftrangej_ = Vector{Float64}(undef,numj)
  rightrangej_ = Vector{Float64}(undef,numj)
  @MSK_primalsensitivity(task.task,numi,subi_,marki_,numj,subj_,markj_,leftpricei_,rightpricei_,leftrangei_,rightrangei_,leftpricej_,rightpricej_,leftrangej_,rightrangej_)
  leftpricei = leftpricei_;
  rightpricei = rightpricei_;
  leftrangei = leftrangei_;
  rightrangei = rightrangei_;
  leftpricej = leftpricej_;
  rightpricej = rightpricej_;
  leftrangej = leftrangej_;
  rightrangej = rightrangej_;
  leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej
end
function primalsensitivity(task::MSKtask,subi::T0,marki::Vector{Mark},subj::T1,markj::Vector{Mark}) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer} }
  primalsensitivity(
    task,
    if subi === nothing; nothing; else convert(Vector{Int32},subi); end,
    marki,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end,
    markj)
end


function sensitivityreport(task::MSKtask,whichstream::Streamtype)
  @MSK_sensitivityreport(task.task,whichstream.value)
  nothing
end


function dualsensitivity(task::MSKtask,subj::Vector{Int32})
  numj = Int32(length(subj))
  subj_ = subj .- Int32(1)
  leftpricej_ = Vector{Float64}(undef,numj)
  rightpricej_ = Vector{Float64}(undef,numj)
  leftrangej_ = Vector{Float64}(undef,numj)
  rightrangej_ = Vector{Float64}(undef,numj)
  @MSK_dualsensitivity(task.task,numj,subj_,leftpricej_,rightpricej_,leftrangej_,rightrangej_)
  leftpricej = leftpricej_;
  rightpricej = rightpricej_;
  leftrangej = leftrangej_;
  rightrangej = rightrangej_;
  leftpricej,rightpricej,leftrangej,rightrangej
end
function dualsensitivity(task::MSKtask,subj::T0) where { T0<:AbstractVector{<:Integer} }
  dualsensitivity(
    task,
    if subj === nothing; nothing; else convert(Vector{Int32},subj); end)
end


function getlasterror(task::MSKtask)
  lastrescode_ = Ref{Int32}()
  __tmp_664 = Ref{Int64}()
  @MSK_getlasterror64(task.task,Ref{Int32}(),0,__tmp_664,C_NULL)
  __tmp_663 = __tmp_664[]
  sizelastmsg = Int64((__tmp_663 + Int64(1)))
  lastmsglen_ = Ref{Int64}()
  lastmsg_ = Array{UInt8}(undef,sizelastmsg)
  @MSK_getlasterror64(task.task,lastrescode_,sizelastmsg,lastmsglen_,lastmsg_)
  lastrescode = Rescode(lastrescode_[])
  lastmsg_len = findfirst(_c->_c==0,lastmsg_)
  lastmsg = if lastmsg_len === nothing
    String(lastmsg_)
  else
    String(lastmsg_[1:lastmsg_len-1])
  end
  lastrescode,lastmsglen_[],lastmsg
end


function optimizermt(task::MSKtask,address::AbstractString,accesstoken::AbstractString)
  address_ = Vector{UInt8}(address); push!(address_,UInt8(0))
  accesstoken_ = Vector{UInt8}(accesstoken); push!(accesstoken_,UInt8(0))
  trmcode_ = Ref{Int32}()
  @MSK_optimizermt(task.task,address_,accesstoken_,trmcode_)
  trmcode = Rescode(trmcode_[])
  trmcode
end


function asyncoptimize(task::MSKtask,address::AbstractString,accesstoken::AbstractString)
  address_ = Vector{UInt8}(address); push!(address_,UInt8(0))
  accesstoken_ = Vector{UInt8}(accesstoken); push!(accesstoken_,UInt8(0))
  token_ = Array{UInt8}(undef,65)
  @MSK_asyncoptimize(task.task,address_,accesstoken_,token_)
  token_len = findfirst(_c->_c==0,token_)
  token = if token_len === nothing
    String(token_)
  else
    String(token_[1:token_len-1])
  end
  token
end


function asyncstop(task::MSKtask,address::AbstractString,accesstoken::AbstractString,token::AbstractString)
  address_ = Vector{UInt8}(address); push!(address_,UInt8(0))
  accesstoken_ = Vector{UInt8}(accesstoken); push!(accesstoken_,UInt8(0))
  token_ = Vector{UInt8}(token); push!(token_,UInt8(0))
  @MSK_asyncstop(task.task,address_,accesstoken_,token_)
  nothing
end


function asyncpoll(task::MSKtask,address::AbstractString,accesstoken::AbstractString,token::AbstractString)
  address_ = Vector{UInt8}(address); push!(address_,UInt8(0))
  accesstoken_ = Vector{UInt8}(accesstoken); push!(accesstoken_,UInt8(0))
  token_ = Vector{UInt8}(token); push!(token_,UInt8(0))
  respavailable_ = Ref{Int32}()
  resp_ = Ref{Int32}()
  trm_ = Ref{Int32}()
  @MSK_asyncpoll(task.task,address_,accesstoken_,token_,respavailable_,resp_,trm_)
  resp = Rescode(resp_[])
  trm = Rescode(trm_[])
  respavailable_[] != 0,resp,trm
end


function asyncgetresult(task::MSKtask,address::AbstractString,accesstoken::AbstractString,token::AbstractString)
  address_ = Vector{UInt8}(address); push!(address_,UInt8(0))
  accesstoken_ = Vector{UInt8}(accesstoken); push!(accesstoken_,UInt8(0))
  token_ = Vector{UInt8}(token); push!(token_,UInt8(0))
  respavailable_ = Ref{Int32}()
  resp_ = Ref{Int32}()
  trm_ = Ref{Int32}()
  @MSK_asyncgetresult(task.task,address_,accesstoken_,token_,respavailable_,resp_,trm_)
  resp = Rescode(resp_[])
  trm = Rescode(trm_[])
  respavailable_[] != 0,resp,trm
end


function putoptserverhost(task::MSKtask,host::Union{Nothing,AbstractString})
  if host === nothing
      host_ = C_NULL
  else
      host_ = Vector{UInt8}(host); push!(host_,UInt8(0))
  end
  @MSK_putoptserverhost(task.task,host_)
  nothing
end


function optimizebatch(env::MSKenv,israce::Bool,maxtime::Float64,numthreads::Int32,task::Vector{MSKtask})
  numtask = Int64(length(task))
  if length(task) < numtask
    throw(BoundsError())
  end
  task_ = Ptr{Nothing}[item.task for item in task]
  trmcode_ = Vector{Int32}(undef,numtask)
  rcode_ = Vector{Int32}(undef,numtask)
  @MSK_optimizebatch(env.env,israce,maxtime,numthreads,numtask,task_,trmcode_,rcode_)
  trmcode = Rescode[Rescode(item) for item in trmcode_]
  rcode = Rescode[Rescode(item) for item in rcode_]
  trmcode,rcode
end
function optimizebatch(env::MSKenv,israce::Bool,maxtime::T0,numthreads::T1,task::Vector{MSKtask}) where { T0<:Number,T1<:Integer }
  optimizebatch(
    env,
    israce,
    convert(Float64,maxtime),
    convert(Int32,numthreads),
    task)
end


function optimizebatch(israce::Bool,maxtime::Float64,numthreads::Int32,task::Vector{MSKtask})
  numtask = Int64(length(task))
  if length(task) < numtask
    throw(BoundsError())
  end
  task_ = Ptr{Nothing}[item.task for item in task]
  trmcode_ = Vector{Int32}(undef,numtask)
  rcode_ = Vector{Int32}(undef,numtask)
  @MSK_optimizebatch(C_NULL,israce,maxtime,numthreads,numtask,task_,trmcode_,rcode_)
  trmcode = Rescode[Rescode(item) for item in trmcode_]
  rcode = Rescode[Rescode(item) for item in rcode_]
  trmcode,rcode
end
function optimizebatch(israce::Bool,maxtime::T0,numthreads::T1,task::Vector{MSKtask}) where { T0<:Number,T1<:Integer }
  optimizebatch(
    israce,
    convert(Float64,maxtime),
    convert(Int32,numthreads),
    task)
end


function callbackcodetostr(code::Callbackcode)
  callbackcodestr_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_callbackcodetostr(code.value,callbackcodestr_)
  callbackcodestr_len = findfirst(_c->_c==0,callbackcodestr_)
  callbackcodestr = if callbackcodestr_len === nothing
    String(callbackcodestr_)
  else
    String(callbackcodestr_[1:callbackcodestr_len-1])
  end
  callbackcodestr
end


function checkoutlicense(env::MSKenv,feature::Feature)
  @MSK_checkoutlicense(env.env,feature.value)
  nothing
end


function checkoutlicense(feature::Feature)
  @MSK_checkoutlicense(C_NULL,feature.value)
  nothing
end


function checkinlicense(env::MSKenv,feature::Feature)
  @MSK_checkinlicense(env.env,feature.value)
  nothing
end


function checkinlicense(feature::Feature)
  @MSK_checkinlicense(C_NULL,feature.value)
  nothing
end


function checkinall(env::MSKenv)
  @MSK_checkinall(env.env)
  nothing
end


function checkinall()
  @MSK_checkinall(C_NULL)
  nothing
end


function expirylicenses(env::MSKenv)
  expiry_ = Ref{Int64}()
  @MSK_expirylicenses(env.env,expiry_)
  expiry_[]
end


function expirylicenses()
  expiry_ = Ref{Int64}()
  @MSK_expirylicenses(C_NULL,expiry_)
  expiry_[]
end


function resetexpirylicenses(env::MSKenv)
  @MSK_resetexpirylicenses(env.env)
  nothing
end


function resetexpirylicenses()
  @MSK_resetexpirylicenses(C_NULL)
  nothing
end


function echointro(env::MSKenv,longver::Int32)
  @MSK_echointro(env.env,longver)
  nothing
end
function echointro(env::MSKenv,longver::T0) where { T0<:Integer }
  echointro(
    env,
    convert(Int32,longver))
end


function echointro(longver::Int32)
  @MSK_echointro(C_NULL,longver)
  nothing
end
function echointro(longver::T0) where { T0<:Integer }
  echointro(convert(Int32,longver))
end


function getcodedesc(code::Rescode)
  symname_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_getcodedesc(code.value,symname_,str_)
  symname_len = findfirst(_c->_c==0,symname_)
  symname = if symname_len === nothing
    String(symname_)
  else
    String(symname_[1:symname_len-1])
  end
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  symname,str
end


function rescodetostr(res::Rescode)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_rescodetostr(res.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function iinfitemtostr(item::Iinfitem)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_iinfitemtostr(item.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function dinfitemtostr(item::Dinfitem)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_dinfitemtostr(item.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function liinfitemtostr(item::Liinfitem)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_liinfitemtostr(item.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


function getversion()
  major_ = Ref{Int32}()
  minor_ = Ref{Int32}()
  revision_ = Ref{Int32}()
  @MSK_getversion(major_,minor_,revision_)
  major_[],minor_[],revision_[]
end


function linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::AbstractString,append::Int32)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_linkfiletoenvstream(env.env,whichstream.value,filename_,append)
  nothing
end
function linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::Union{Nothing,AbstractString},append::T0) where { T0<:Integer }
  linkfiletostream(
    env,
    whichstream,
    filename,
    convert(Int32,append))
end


function linkfiletostream(whichstream::Streamtype,filename::AbstractString,append::Int32)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_linkfiletoenvstream(C_NULL,whichstream.value,filename_,append)
  nothing
end
function linkfiletostream(whichstream::Streamtype,filename::Union{Nothing,AbstractString},append::T0) where { T0<:Integer }
  linkfiletostream(
    whichstream,
    filename,
    convert(Int32,append))
end


function putlicensedebug(env::MSKenv,licdebug::Int32)
  @MSK_putlicensedebug(env.env,licdebug)
  nothing
end
function putlicensedebug(env::MSKenv,licdebug::T0) where { T0<:Integer }
  putlicensedebug(
    env,
    convert(Int32,licdebug))
end


function putlicensedebug(licdebug::Int32)
  @MSK_putlicensedebug(C_NULL,licdebug)
  nothing
end
function putlicensedebug(licdebug::T0) where { T0<:Integer }
  putlicensedebug(convert(Int32,licdebug))
end


function putlicensecode(env::MSKenv,code::Union{Nothing,Vector{Int32}})
  if code !== nothing && length(code) < MSK_LICENSE_BUFFER_LENGTH
    throw(BoundsError())
  end
  code_ = if code === nothing; C_NULL; else code end
  @MSK_putlicensecode(env.env,code_)
  nothing
end
function putlicensecode(env::MSKenv,code::T0) where { T0<:AbstractVector{<:Integer} }
  putlicensecode(
    env,
    if code === nothing; nothing; else convert(Vector{Int32},code); end)
end


function putlicensecode(code::Union{Nothing,Vector{Int32}})
  if code !== nothing && length(code) < MSK_LICENSE_BUFFER_LENGTH
    throw(BoundsError())
  end
  code_ = if code === nothing; C_NULL; else code end
  @MSK_putlicensecode(C_NULL,code_)
  nothing
end
function putlicensecode(code::T0) where { T0<:AbstractVector{<:Integer} }
  putlicensecode(if code === nothing; nothing; else convert(Vector{Int32},code); end)
end


function putlicensewait(env::MSKenv,licwait::Int32)
  @MSK_putlicensewait(env.env,licwait)
  nothing
end
function putlicensewait(env::MSKenv,licwait::T0) where { T0<:Integer }
  putlicensewait(
    env,
    convert(Int32,licwait))
end


function putlicensewait(licwait::Int32)
  @MSK_putlicensewait(C_NULL,licwait)
  nothing
end
function putlicensewait(licwait::T0) where { T0<:Integer }
  putlicensewait(convert(Int32,licwait))
end


function putlicensepath(env::MSKenv,licensepath::Union{Nothing,AbstractString})
  if licensepath === nothing
      licensepath_ = C_NULL
  else
      licensepath_ = Vector{UInt8}(licensepath); push!(licensepath_,UInt8(0))
  end
  @MSK_putlicensepath(env.env,licensepath_)
  nothing
end


function putlicensepath(licensepath::Union{Nothing,AbstractString})
  if licensepath === nothing
      licensepath_ = C_NULL
  else
      licensepath_ = Vector{UInt8}(licensepath); push!(licensepath_,UInt8(0))
  end
  @MSK_putlicensepath(C_NULL,licensepath_)
  nothing
end


function computesparsecholesky(env::MSKenv,numthreads::Int32,ordermethod::Int32,tolsingular::Float64,anzc::Vector{Int32},aptrc::Vector{Int64},asubc::Vector{Int32},avalc::Vector{Float64})
  n = Int32(min(length(anzc),length(aptrc)))
  anzc_ = anzc
  aptrc_ = aptrc .- Int64(1)
  asubc_ = asubc .- Int32(1)
  avalc_ = avalc
  perm_ = Ref{Ptr{Int32}}()
  diag_ = Ref{Ptr{Float64}}()
  lnzc_ = Ref{Ptr{Int32}}()
  lptrc_ = Ref{Ptr{Int64}}()
  lensubnval_ = Ref{Int64}()
  lsubc_ = Ref{Ptr{Int32}}()
  lvalc_ = Ref{Ptr{Float64}}()
  @MSK_computesparsecholesky(env.env,numthreads,ordermethod,tolsingular,n,anzc_,aptrc_,asubc_,avalc_,perm_,diag_,lnzc_,lptrc_,lensubnval_,lsubc_,lvalc_)
  __tmp_715 = n
  perm = copy(unsafe_wrap(Array,perm_[],__tmp_715))
  @MSK_freeenv(env.env,perm_[])
  perm .+= 1
  __tmp_716 = n
  diag = copy(unsafe_wrap(Array,diag_[],__tmp_716))
  @MSK_freeenv(env.env,diag_[])
  __tmp_717 = n
  lnzc = copy(unsafe_wrap(Array,lnzc_[],__tmp_717))
  @MSK_freeenv(env.env,lnzc_[])
  __tmp_718 = n
  lptrc = copy(unsafe_wrap(Array,lptrc_[],__tmp_718))
  @MSK_freeenv(env.env,lptrc_[])
  lptrc .+= 1
  __tmp_719 = lensubnval_[]
  lsubc = copy(unsafe_wrap(Array,lsubc_[],__tmp_719))
  @MSK_freeenv(env.env,lsubc_[])
  lsubc .+= 1
  __tmp_720 = lensubnval_[]
  lvalc = copy(unsafe_wrap(Array,lvalc_[],__tmp_720))
  @MSK_freeenv(env.env,lvalc_[])
  perm,diag,lnzc,lptrc,lensubnval_[],lsubc,lvalc
end
function computesparsecholesky(env::MSKenv,numthreads::T0,ordermethod::T1,tolsingular::T2,anzc::T3,aptrc::T4,asubc::T5,avalc::T6) where { T0<:Integer,T1<:Integer,T2<:Number,T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number} }
  computesparsecholesky(
    env,
    convert(Int32,numthreads),
    convert(Int32,ordermethod),
    convert(Float64,tolsingular),
    if anzc === nothing; nothing; else convert(Vector{Int32},anzc); end,
    if aptrc === nothing; nothing; else convert(Vector{Int64},aptrc); end,
    if asubc === nothing; nothing; else convert(Vector{Int32},asubc); end,
    if avalc === nothing; nothing; else convert(Vector{Float64},avalc); end)
end


function computesparsecholesky(numthreads::Int32,ordermethod::Int32,tolsingular::Float64,anzc::Vector{Int32},aptrc::Vector{Int64},asubc::Vector{Int32},avalc::Vector{Float64})
  n = Int32(min(length(anzc),length(aptrc)))
  anzc_ = anzc
  aptrc_ = aptrc .- Int64(1)
  asubc_ = asubc .- Int32(1)
  avalc_ = avalc
  perm_ = Ref{Ptr{Int32}}()
  diag_ = Ref{Ptr{Float64}}()
  lnzc_ = Ref{Ptr{Int32}}()
  lptrc_ = Ref{Ptr{Int64}}()
  lensubnval_ = Ref{Int64}()
  lsubc_ = Ref{Ptr{Int32}}()
  lvalc_ = Ref{Ptr{Float64}}()
  @MSK_computesparsecholesky(C_NULL,numthreads,ordermethod,tolsingular,n,anzc_,aptrc_,asubc_,avalc_,perm_,diag_,lnzc_,lptrc_,lensubnval_,lsubc_,lvalc_)
  __tmp_722 = n
  perm = copy(unsafe_wrap(Array,perm_[],__tmp_722))
  @MSK_freeenv(Ptr{Nothing}(),perm_[])
  perm .+= 1
  __tmp_723 = n
  diag = copy(unsafe_wrap(Array,diag_[],__tmp_723))
  @MSK_freeenv(Ptr{Nothing}(),diag_[])
  __tmp_724 = n
  lnzc = copy(unsafe_wrap(Array,lnzc_[],__tmp_724))
  @MSK_freeenv(Ptr{Nothing}(),lnzc_[])
  __tmp_725 = n
  lptrc = copy(unsafe_wrap(Array,lptrc_[],__tmp_725))
  @MSK_freeenv(Ptr{Nothing}(),lptrc_[])
  lptrc .+= 1
  __tmp_726 = lensubnval_[]
  lsubc = copy(unsafe_wrap(Array,lsubc_[],__tmp_726))
  @MSK_freeenv(Ptr{Nothing}(),lsubc_[])
  lsubc .+= 1
  __tmp_727 = lensubnval_[]
  lvalc = copy(unsafe_wrap(Array,lvalc_[],__tmp_727))
  @MSK_freeenv(Ptr{Nothing}(),lvalc_[])
  perm,diag,lnzc,lptrc,lensubnval_[],lsubc,lvalc
end
function computesparsecholesky(numthreads::T0,ordermethod::T1,tolsingular::T2,anzc::T3,aptrc::T4,asubc::T5,avalc::T6) where { T0<:Integer,T1<:Integer,T2<:Number,T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number} }
  computesparsecholesky(
    convert(Int32,numthreads),
    convert(Int32,ordermethod),
    convert(Float64,tolsingular),
    if anzc === nothing; nothing; else convert(Vector{Int32},anzc); end,
    if aptrc === nothing; nothing; else convert(Vector{Int64},aptrc); end,
    if asubc === nothing; nothing; else convert(Vector{Int32},asubc); end,
    if avalc === nothing; nothing; else convert(Vector{Float64},avalc); end)
end


function sparsetriangularsolvedense(env::MSKenv,transposed::Transpose,lnzc::Vector{Int32},lptrc::Vector{Int64},lsubc::Vector{Int32},lvalc::Vector{Float64},b::Vector{Float64})
  n = Int32(min(length(b),length(lnzc),length(lptrc)))
  if lnzc !== nothing && length(lnzc) < n
    throw(BoundsError())
  end
  lnzc_ = lnzc
  if lptrc !== nothing && length(lptrc) < n
    throw(BoundsError())
  end
  lptrc_ = lptrc .- Int64(1)
  lensubnval = Int64(min(length(lsubc),length(lvalc)))
  if lsubc !== nothing && length(lsubc) < lensubnval
    throw(BoundsError())
  end
  lsubc_ = lsubc .- Int32(1)
  if lvalc !== nothing && length(lvalc) < lensubnval
    throw(BoundsError())
  end
  lvalc_ = lvalc
  if b !== nothing && length(b) < n
    throw(BoundsError())
  end
  b_ = b
  @MSK_sparsetriangularsolvedense(env.env,transposed.value,n,lnzc_,lptrc_,lensubnval,lsubc_,lvalc_,b_)
  if b !== nothing; b[:] = b_; end
  nothing
end
function sparsetriangularsolvedense(env::MSKenv,transposed::Transpose,lnzc::T0,lptrc::T1,lsubc::T2,lvalc::T3,b::Vector{Float64}) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  sparsetriangularsolvedense(
    env,
    transposed,
    if lnzc === nothing; nothing; else convert(Vector{Int32},lnzc); end,
    if lptrc === nothing; nothing; else convert(Vector{Int64},lptrc); end,
    if lsubc === nothing; nothing; else convert(Vector{Int32},lsubc); end,
    if lvalc === nothing; nothing; else convert(Vector{Float64},lvalc); end,
    b)
end


function sparsetriangularsolvedense(transposed::Transpose,lnzc::Vector{Int32},lptrc::Vector{Int64},lsubc::Vector{Int32},lvalc::Vector{Float64},b::Vector{Float64})
  n = Int32(min(length(b),length(lnzc),length(lptrc)))
  if lnzc !== nothing && length(lnzc) < n
    throw(BoundsError())
  end
  lnzc_ = lnzc
  if lptrc !== nothing && length(lptrc) < n
    throw(BoundsError())
  end
  lptrc_ = lptrc .- Int64(1)
  lensubnval = Int64(min(length(lsubc),length(lvalc)))
  if lsubc !== nothing && length(lsubc) < lensubnval
    throw(BoundsError())
  end
  lsubc_ = lsubc .- Int32(1)
  if lvalc !== nothing && length(lvalc) < lensubnval
    throw(BoundsError())
  end
  lvalc_ = lvalc
  if b !== nothing && length(b) < n
    throw(BoundsError())
  end
  b_ = b
  @MSK_sparsetriangularsolvedense(C_NULL,transposed.value,n,lnzc_,lptrc_,lensubnval,lsubc_,lvalc_,b_)
  if b !== nothing; b[:] = b_; end
  nothing
end
function sparsetriangularsolvedense(transposed::Transpose,lnzc::T0,lptrc::T1,lsubc::T2,lvalc::T3,b::Vector{Float64}) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  sparsetriangularsolvedense(
    transposed,
    if lnzc === nothing; nothing; else convert(Vector{Int32},lnzc); end,
    if lptrc === nothing; nothing; else convert(Vector{Int64},lptrc); end,
    if lsubc === nothing; nothing; else convert(Vector{Int32},lsubc); end,
    if lvalc === nothing; nothing; else convert(Vector{Float64},lvalc); end,
    b)
end


function licensecleanup()
  @MSK_licensecleanup()
  nothing
end


