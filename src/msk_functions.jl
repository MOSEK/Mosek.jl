# Contents of this file is generated. Do not edit by hand
# Target: Mosek 10.0.16
export
  analyzeproblem,
  analyzenames,
  analyzesolution,
  initbasissolve,
  solvewithbasis,
  basiscond,
  appendcons,
  appendvars,
  removecons,
  removevars,
  removebarvars,
  removecones,
  appendbarvars,
  appendcone,
  appendconeseq,
  appendconesseq,
  bktostr,
  callbackcodetostr,
  chgconbound,
  chgvarbound,
  conetypetostr,
  getaij,
  getapiecenumnz,
  getacolnumnz,
  getacol,
  getacolslice,
  getarownumnz,
  getarow,
  getacolslicenumnz,
  getarowslicenumnz,
  getarowslice,
  getatrip,
  getarowslicetrip,
  getacolslicetrip,
  getconbound,
  getvarbound,
  getconboundslice,
  getvarboundslice,
  getcj,
  getc,
  getcfix,
  getcone,
  getconeinfo,
  getclist,
  getcslice,
  getdouinf,
  getdouparam,
  getdualobj,
  getinfname,
  getintinf,
  getlintinf,
  getintparam,
  getmaxnumanz,
  getmaxnumcon,
  getmaxnumvar,
  getnadouinf,
  getnadouparam,
  getnaintinf,
  getnaintparam,
  getbarvarnamelen,
  getbarvarname,
  getbarvarnameindex,
  putconname,
  putvarname,
  putconename,
  putbarvarname,
  putdomainname,
  putdjcname,
  putaccname,
  getvarnamelen,
  getvarname,
  getconnamelen,
  getconname,
  getconnameindex,
  getvarnameindex,
  getconenamelen,
  getconename,
  getconenameindex,
  getdomainnamelen,
  getdomainname,
  getdjcnamelen,
  getdjcname,
  getaccnamelen,
  getaccname,
  getnastrparam,
  getnumanz,
  getnumanz64,
  getnumcon,
  getnumcone,
  getnumconemem,
  getnumintvar,
  getnumparam,
  getnumqconknz,
  getnumqobjnz,
  getnumvar,
  getnumbarvar,
  getmaxnumbarvar,
  getdimbarvarj,
  getlenbarvarj,
  getobjname,
  getobjnamelen,
  getparamname,
  getprimalobj,
  getprobtype,
  getqconk,
  getqobj,
  getqobjij,
  getsolution,
  getsolutionnew,
  getsolsta,
  getprosta,
  getskc,
  getskx,
  getskn,
  getxc,
  getxx,
  gety,
  getslc,
  getaccdoty,
  getaccdotys,
  evaluateacc,
  evaluateaccs,
  getsuc,
  getslx,
  getsux,
  getsnx,
  getskcslice,
  getskxslice,
  getxcslice,
  getxxslice,
  getyslice,
  getslcslice,
  getsucslice,
  getslxslice,
  getsuxslice,
  getsnxslice,
  getbarxj,
  getbarxslice,
  getbarsj,
  getbarsslice,
  putskc,
  putskx,
  putxc,
  putxx,
  puty,
  putslc,
  putsuc,
  putslx,
  putsux,
  putsnx,
  putaccdoty,
  putskcslice,
  putskxslice,
  putxcslice,
  putxxslice,
  putyslice,
  putslcslice,
  putsucslice,
  putslxslice,
  putsuxslice,
  putsnxslice,
  putbarxj,
  putbarsj,
  getpviolcon,
  getpviolvar,
  getpviolbarvar,
  getpviolcones,
  getpviolacc,
  getpvioldjc,
  getdviolcon,
  getdviolvar,
  getdviolbarvar,
  getdviolcones,
  getdviolacc,
  getsolutioninfo,
  getsolutioninfonew,
  getdualsolutionnorms,
  getprimalsolutionnorms,
  getsolutionslice,
  getreducedcosts,
  getstrparam,
  getstrparamlen,
  gettasknamelen,
  gettaskname,
  getvartype,
  getvartypelist,
  inputdata,
  isdouparname,
  isintparname,
  isstrparname,
  linkfiletostream,
  primalrepair,
  infeasibilityreport,
  optimize,
  printparam,
  commitchanges,
  getatruncatetol,
  putatruncatetol,
  putaij,
  putaijlist,
  putacol,
  putarow,
  putarowslice,
  putarowlist,
  putacolslice,
  putacollist,
  putbaraij,
  putbaraijlist,
  putbararowlist,
  getnumbarcnz,
  getnumbaranz,
  getbarcsparsity,
  getbarasparsity,
  getbarcidxinfo,
  getbarcidxj,
  getbarcidx,
  getbaraidxinfo,
  getbaraidxij,
  getbaraidx,
  getnumbarcblocktriplets,
  putbarcblocktriplet,
  getbarcblocktriplet,
  putbarablocktriplet,
  getnumbarablocktriplets,
  getbarablocktriplet,
  putmaxnumafe,
  getnumafe,
  appendafes,
  putafefentry,
  putafefentrylist,
  emptyafefrow,
  emptyafefcol,
  emptyafefrowlist,
  emptyafefcollist,
  putafefrow,
  putafefrowlist,
  putafefcol,
  getafefrownumnz,
  getafefnumnz,
  getafefrow,
  getafeftrip,
  putafebarfentry,
  putafebarfentrylist,
  putafebarfrow,
  emptyafebarfrow,
  emptyafebarfrowlist,
  putafebarfblocktriplet,
  getafebarfnumblocktriplets,
  getafebarfblocktriplet,
  getafebarfnumrowentries,
  getafebarfrowinfo,
  getafebarfrow,
  putafeg,
  putafeglist,
  getafeg,
  getafegslice,
  putafegslice,
  putmaxnumdjc,
  getnumdjc,
  getdjcnumdomain,
  getdjcnumdomaintot,
  getdjcnumafe,
  getdjcnumafetot,
  getdjcnumterm,
  getdjcnumtermtot,
  putmaxnumacc,
  getnumacc,
  appendacc,
  appendaccs,
  appendaccseq,
  appendaccsseq,
  putacc,
  putacclist,
  putaccb,
  putaccbj,
  getaccdomain,
  getaccn,
  getaccntot,
  getaccafeidxlist,
  getaccb,
  getaccs,
  getaccfnumnz,
  getaccftrip,
  getaccgvector,
  getaccbarfnumblocktriplets,
  getaccbarfblocktriplet,
  appenddjcs,
  putdjc,
  putdjcslice,
  getdjcdomainidxlist,
  getdjcafeidxlist,
  getdjcb,
  getdjctermsizelist,
  getdjcs,
  putconbound,
  putconboundlist,
  putconboundlistconst,
  putconboundslice,
  putconboundsliceconst,
  putvarbound,
  putvarboundlist,
  putvarboundlistconst,
  putvarboundslice,
  putvarboundsliceconst,
  putcfix,
  putcj,
  putobjsense,
  getobjsense,
  putclist,
  putcslice,
  putbarcj,
  putcone,
  putmaxnumdomain,
  getnumdomain,
  appendrplusdomain,
  appendrminusdomain,
  appendrdomain,
  appendrzerodomain,
  appendquadraticconedomain,
  appendrquadraticconedomain,
  appendprimalexpconedomain,
  appenddualexpconedomain,
  appendprimalgeomeanconedomain,
  appenddualgeomeanconedomain,
  appendprimalpowerconedomain,
  appenddualpowerconedomain,
  appendsvecpsdconedomain,
  getdomaintype,
  getdomainn,
  getpowerdomaininfo,
  getpowerdomainalpha,
  appendsparsesymmat,
  appendsparsesymmatlist,
  getsymmatinfo,
  getnumsymmat,
  getsparsesymmat,
  putdouparam,
  putintparam,
  putmaxnumcon,
  putmaxnumcone,
  getmaxnumcone,
  putmaxnumvar,
  putmaxnumbarvar,
  putmaxnumanz,
  putmaxnumqnz,
  getmaxnumqnz,
  putnadouparam,
  putnaintparam,
  putnastrparam,
  putobjname,
  putparam,
  putqcon,
  putqconk,
  putqobj,
  putqobjij,
  putsolution,
  putsolutionnew,
  putconsolutioni,
  putvarsolutionj,
  putsolutionyi,
  putstrparam,
  puttaskname,
  putvartype,
  putvartypelist,
  readdataformat,
  readdata,
  readparamfile,
  readsolution,
  readsummary,
  resizetask,
  checkmem,
  getmemusage,
  setdefaults,
  solutiondef,
  deletesolution,
  onesolutionsummary,
  solutionsummary,
  updatesolutioninfo,
  optimizersummary,
  strtoconetype,
  strtosk,
  writedata,
  writetask,
  writebsolution,
  readbsolution,
  writesolutionfile,
  readsolutionfile,
  readtask,
  readopfstring,
  readlpstring,
  readjsonstring,
  readptfstring,
  writeparamfile,
  getinfeasiblesubproblem,
  writesolution,
  writejsonsol,
  primalsensitivity,
  sensitivityreport,
  dualsensitivity,
  getlasterror,
  optimizermt,
  putoptserverhost,
  optimizebatch,
  checkoutlicense,
  checkinlicense,
  checkinall,
  expirylicenses,
  resetexpirylicenses,
  echointro,
  getcodedesc,
  getversion,
  linkfiletostream,
  putlicensedebug,
  putlicensecode,
  putlicensewait,
  putlicensepath,
  computesparsecholesky,
  licensecleanup

macro MSK_analyzeproblem(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_analyzeproblem,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_analyzenames(task,whichstream,nametype)
  quote
     local res = disable_sigint(()->ccall((:MSK_analyzenames,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(nametype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_analyzesolution(task,whichstream,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_analyzesolution,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_initbasissolve(task,basis)
  quote
     local res = disable_sigint(()->ccall((:MSK_initbasissolve,libmosek),Int32,(Ptr{Nothing},Ptr{Int32},),$(esc(task)),$(esc(basis))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solvewithbasis(task,transp,numnz,sub,val,numnzout)
  quote
     local res = disable_sigint(()->ccall((:MSK_solvewithbasis,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ref{Int32},),$(esc(task)),$(esc(transp)),$(esc(numnz)),$(esc(sub)),$(esc(val)),$(esc(numnzout))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_basiscond(task,nrmbasis,nrminvbasis)
  quote
     local res = disable_sigint(()->ccall((:MSK_basiscond,libmosek),Int32,(Ptr{Nothing},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(nrmbasis)),$(esc(nrminvbasis))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendcons(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendcons,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendvars(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendvars,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removecons(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removecons,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removevars(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removevars,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removebarvars(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removebarvars,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_removecones(task,num,subset)
  quote
     local res = disable_sigint(()->ccall((:MSK_removecones,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subset))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendbarvars(task,num,dim)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendbarvars,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(dim))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendcone(task,ct,conepar,nummem,submem)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendcone,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Int32,Ptr{Int32},),$(esc(task)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(submem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendconeseq(task,ct,conepar,nummem,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendconeseq,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Int32,Int32,),$(esc(task)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendconesseq(task,num,ct,conepar,nummem,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendconesseq,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Int32},Int32,),$(esc(task)),$(esc(num)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_bktostr(task,bk,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_bktostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(bk)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_callbackcodetostr(code,callbackcodestr)
  quote
     local res = disable_sigint(()->ccall((:MSK_callbackcodetostr,libmosek),Int32,(Int32,Ptr{UInt8},),$(esc(code)),$(esc(callbackcodestr))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_chgconbound(task,i,lower,finite,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_chgconbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(lower)),$(esc(finite)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_chgvarbound(task,j,lower,finite,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_chgvarbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,),$(esc(task)),$(esc(j)),$(esc(lower)),$(esc(finite)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_conetypetostr(task,ct,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_conetypetostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(ct)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_deletetask(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_deletetask,libmosek),Int32,(Ref{Ptr{Nothing}},),$(esc(task))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_freetask(task,buffer)
  quote
     disable_sigint(()->ccall((:MSK_freetask,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},),$(esc(task)),$(esc(buffer))))
  end
end
macro MSK_freedbgtask(task,buffer,file,line)
  quote
     disable_sigint(()->ccall((:MSK_freedbgtask,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},Ptr{UInt8},UInt32,),$(esc(task)),$(esc(buffer)),$(esc(file)),$(esc(line))))
  end
end
macro MSK_getaij(task,i,j,aij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(aij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getapiecenumnz(task,firsti,lasti,firstj,lastj,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getapiecenumnz,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ref{Int32},),$(esc(task)),$(esc(firsti)),$(esc(lasti)),$(esc(firstj)),$(esc(lastj)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolnumnz(task,i,nzj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolnumnz,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(nzj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacol(task,j,nzj,subj,valj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacol,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(j)),$(esc(nzj)),$(esc(subj)),$(esc(valj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslice(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslice64(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarownumnz(task,i,nzi)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarownumnz,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(nzi))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarow(task,i,nzi,subi,vali)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarow,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(i)),$(esc(nzi)),$(esc(subi)),$(esc(vali))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslicenumnz(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslicenumnz,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslicenumnz64(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslicenumnz64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslicenumnz(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslicenumnz,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslicenumnz64(task,first,last,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslicenumnz64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslice(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslice64(task,first,last,maxnumnz,ptrb,ptre,sub,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(ptrb)),$(esc(ptre)),$(esc(sub)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getatrip(task,maxnumnz,subi,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getatrip,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumnz)),$(esc(subi)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getarowslicetrip(task,first,last,maxnumnz,subi,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getarowslicetrip,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(subi)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getacolslicetrip(task,first,last,maxnumnz,subi,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getacolslicetrip,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(maxnumnz)),$(esc(subi)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconbound(task,i,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconbound,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarbound(task,i,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarbound,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconboundslice(task,first,last,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarboundslice(task,first,last,bk,bl,bu)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bk)),$(esc(bl)),$(esc(bu))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcj(task,j,cj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(j)),$(esc(cj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getc(task,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_getc,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},),$(esc(task)),$(esc(c))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcallbackfunc(task,func,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcallbackfunc,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Cvoid}},Ref{Any},),$(esc(task)),$(esc(func)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcfix(task,cfix)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcfix,libmosek),Int32,(Ptr{Nothing},Ref{Float64},),$(esc(task)),$(esc(cfix))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcone(task,k,ct,conepar,nummem,submem)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcone,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Int32},Ptr{Int32},),$(esc(task)),$(esc(k)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(submem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconeinfo(task,k,ct,conepar,nummem)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconeinfo,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Int32},),$(esc(task)),$(esc(k)),$(esc(ct)),$(esc(conepar)),$(esc(nummem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getclist(task,num,subj,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_getclist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(c))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getcslice(task,first,last,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(c))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdouinf(task,whichdinf,dvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdouinf,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(whichdinf)),$(esc(dvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdouparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdouparam,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdualobj(task,whichsol,dualobj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdualobj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(dualobj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getenv(task,env)
  quote
     local res = disable_sigint(()->ccall((:MSK_getenv,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Nothing}},),$(esc(task)),$(esc(env))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfindex(task,inftype,infname,infindex)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfindex,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(inftype)),$(esc(infname)),$(esc(infindex))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfmax(task,inftype,infmax)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfmax,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(inftype)),$(esc(infmax))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfname(task,inftype,whichinf,infname)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(inftype)),$(esc(whichinf)),$(esc(infname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getintinf(task,whichiinf,ivalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getintinf,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichiinf)),$(esc(ivalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getlintinf(task,whichliinf,ivalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getlintinf,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int64},),$(esc(task)),$(esc(whichliinf)),$(esc(ivalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getintparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getintparam,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnamelen(task,maxlen)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnamelen,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxlen))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumanz(task,maxnumanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumanz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumanz64(task,maxnumanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumanz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(maxnumanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumcon(task,maxnumcon)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumcon,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumcon))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumvar(task,maxnumvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnadouinf(task,infitemname,dvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnadouinf,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Float64},),$(esc(task)),$(esc(infitemname)),$(esc(dvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnadouparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnadouparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Float64},),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnaintinf(task,infitemname,ivalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnaintinf,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(infitemname)),$(esc(ivalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnaintparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnaintparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarvarnamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarvarnamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarvarname(task,i,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarvarname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarvarnameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarvarnameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconname(task,i,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarname(task,j,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconename(task,j,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconename,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarvarname(task,j,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarvarname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdomainname(task,domidx,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdomainname,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{UInt8},),$(esc(task)),$(esc(domidx)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdjcname(task,djcidx,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdjcname,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{UInt8},),$(esc(task)),$(esc(djcidx)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccname(task,accidx,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccname,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{UInt8},),$(esc(task)),$(esc(accidx)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarnamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarnamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarname(task,j,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(j)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconnamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconnamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconname(task,i,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconnameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconnameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvarnameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvarnameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconenamelen(task,i,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconenamelen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconename(task,i,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconename,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(i)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getconenameindex(task,somename,asgn,index)
  quote
     local res = disable_sigint(()->ccall((:MSK_getconenameindex,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(somename)),$(esc(asgn)),$(esc(index))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomainnamelen(task,domidx,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomainnamelen,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(domidx)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomainname(task,domidx,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomainname,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{UInt8},),$(esc(task)),$(esc(domidx)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnamelen(task,djcidx,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnamelen,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(djcidx)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcname(task,djcidx,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcname,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{UInt8},),$(esc(task)),$(esc(djcidx)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccnamelen(task,accidx,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccnamelen,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(accidx)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccname(task,accidx,sizename,name)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccname,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{UInt8},),$(esc(task)),$(esc(accidx)),$(esc(sizename)),$(esc(name))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnastrparam(task,paramname,sizeparamname,len,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnastrparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,Ref{Int32},Ptr{UInt8},),$(esc(task)),$(esc(paramname)),$(esc(sizeparamname)),$(esc(len)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumanz(task,numanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumanz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumanz64(task,numanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumanz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumcon(task,numcon)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumcon,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numcon))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumcone(task,numcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumcone,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumconemem(task,k,nummem)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumconemem,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(k)),$(esc(nummem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumintvar(task,numintvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumintvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numintvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumparam(task,partype,numparam)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumparam,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(partype)),$(esc(numparam))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqconknz(task,k,numqcnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqconknz,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(k)),$(esc(numqcnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqconknz64(task,k,numqcnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqconknz64,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int64},),$(esc(task)),$(esc(k)),$(esc(numqcnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqobjnz(task,numqonz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqobjnz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numqonz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumqobjnz64(task,numqonz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumqobjnz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numqonz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumvar(task,numvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarvar(task,numbarvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(numbarvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumbarvar(task,maxnumbarvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumbarvar,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumbarvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdimbarvarj(task,j,dimbarvarj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdimbarvarj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(j)),$(esc(dimbarvarj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getlenbarvarj(task,j,lenbarvarj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getlenbarvarj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int64},),$(esc(task)),$(esc(j)),$(esc(lenbarvarj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getobjname(task,sizeobjname,objname)
  quote
     local res = disable_sigint(()->ccall((:MSK_getobjname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(sizeobjname)),$(esc(objname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getobjnamelen(task,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getobjnamelen,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getparamname(task,partype,param,parname)
  quote
     local res = disable_sigint(()->ccall((:MSK_getparamname,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(partype)),$(esc(param)),$(esc(parname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getparammax(task,partype,parammax)
  quote
     local res = disable_sigint(()->ccall((:MSK_getparammax,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(partype)),$(esc(parammax))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprimalobj(task,whichsol,primalobj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprimalobj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(primalobj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprobtype(task,probtype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprobtype,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(probtype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqconk64(task,k,maxnumqcnz,numqcnz,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqconk64,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(k)),$(esc(maxnumqcnz)),$(esc(numqcnz)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqconk(task,k,maxnumqcnz,numqcnz,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqconk,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(k)),$(esc(maxnumqcnz)),$(esc(numqcnz)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqobj(task,maxnumqonz,numqonz,qosubi,qosubj,qoval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqobj,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumqonz)),$(esc(numqonz)),$(esc(qosubi)),$(esc(qosubj)),$(esc(qoval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqobj64(task,maxnumqonz,numqonz,qosubi,qosubj,qoval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqobj64,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumqonz)),$(esc(numqonz)),$(esc(qosubi)),$(esc(qosubj)),$(esc(qoval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getqobjij(task,i,j,qoij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getqobjij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Float64},),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(qoij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolution(task,whichsol,problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolution,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(problemsta)),$(esc(solutionsta)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutionnew(task,whichsol,problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutionnew,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(problemsta)),$(esc(solutionsta)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolsta(task,whichsol,solutionsta)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolsta,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(solutionsta))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprosta(task,whichsol,problemsta)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprosta,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(problemsta))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskc(task,whichsol,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskx(task,whichsol,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskn(task,whichsol,skn)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskn,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skn))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxc(task,whichsol,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxx(task,whichsol,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_gety(task,whichsol,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_gety,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslc(task,whichsol,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccdoty(task,whichsol,accidx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccdoty,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(accidx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccdotys(task,whichsol,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccdotys,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_evaluateacc(task,whichsol,accidx,activity)
  quote
     local res = disable_sigint(()->ccall((:MSK_evaluateacc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(accidx)),$(esc(activity))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_evaluateaccs(task,whichsol,activity)
  quote
     local res = disable_sigint(()->ccall((:MSK_evaluateaccs,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(activity))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsuc(task,whichsol,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsuc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslx(task,whichsol,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsux(task,whichsol,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsux,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsnx(task,whichsol,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsnx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskcslice(task,whichsol,first,last,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getskxslice(task,whichsol,first,last,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getskxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxcslice(task,whichsol,first,last,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getxxslice(task,whichsol,first,last,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getxxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getyslice(task,whichsol,first,last,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_getyslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslcslice(task,whichsol,first,last,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsucslice(task,whichsol,first,last,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsucslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getslxslice(task,whichsol,first,last,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getslxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsuxslice(task,whichsol,first,last,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsuxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsnxslice(task,whichsol,first,last,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsnxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarxj(task,whichsol,j,barxj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarxj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barxj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarxslice(task,whichsol,first,last,slicesize,barxslice)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slicesize)),$(esc(barxslice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarsj(task,whichsol,j,barsj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarsj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barsj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarsslice(task,whichsol,first,last,slicesize,barsslice)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarsslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slicesize)),$(esc(barsslice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskc(task,whichsol,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskx(task,whichsol,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxc(task,whichsol,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxx(task,whichsol,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_puty(task,whichsol,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_puty,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslc(task,whichsol,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsuc(task,whichsol,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsuc,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslx(task,whichsol,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsux(task,whichsol,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsux,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsnx(task,whichsol,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsnx,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccdoty(task,whichsol,accidx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccdoty,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(accidx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskcslice(task,whichsol,first,last,skc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putskxslice(task,whichsol,first,last,skx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putskxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(skx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxcslice(task,whichsol,first,last,xc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putxxslice(task,whichsol,first,last,xx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putxxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(xx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putyslice(task,whichsol,first,last,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_putyslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslcslice(task,whichsol,first,last,slc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsucslice(task,whichsol,first,last,suc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsucslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(suc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putslxslice(task,whichsol,first,last,slx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putslxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(slx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsuxslice(task,whichsol,first,last,sux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsuxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(sux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsnxslice(task,whichsol,first,last,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsnxslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarxj(task,whichsol,j,barxj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarxj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barxj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarsj(task,whichsol,j,barsj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarsj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(j)),$(esc(barsj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolcon(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolcon,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolbarvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolbarvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolcones(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolcones,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpviolacc(task,whichsol,numaccidx,accidxlist,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpviolacc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(numaccidx)),$(esc(accidxlist)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpvioldjc(task,whichsol,numdjcidx,djcidxlist,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpvioldjc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(numdjcidx)),$(esc(djcidxlist)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolcon(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolcon,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolbarvar(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolbarvar,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolcones(task,whichsol,num,sub,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolcones,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(num)),$(esc(sub)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdviolacc(task,whichsol,numaccidx,accidxlist,viol)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdviolacc,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(numaccidx)),$(esc(accidxlist)),$(esc(viol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutioninfo(task,whichsol,pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutioninfo,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(pobj)),$(esc(pviolcon)),$(esc(pviolvar)),$(esc(pviolbarvar)),$(esc(pviolcone)),$(esc(pviolitg)),$(esc(dobj)),$(esc(dviolcon)),$(esc(dviolvar)),$(esc(dviolbarvar)),$(esc(dviolcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutioninfonew(task,whichsol,pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolacc,pvioldjc,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone,dviolacc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutioninfonew,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(pobj)),$(esc(pviolcon)),$(esc(pviolvar)),$(esc(pviolbarvar)),$(esc(pviolcone)),$(esc(pviolacc)),$(esc(pvioldjc)),$(esc(pviolitg)),$(esc(dobj)),$(esc(dviolcon)),$(esc(dviolvar)),$(esc(dviolbarvar)),$(esc(dviolcone)),$(esc(dviolacc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdualsolutionnorms(task,whichsol,nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdualsolutionnorms,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(nrmy)),$(esc(nrmslc)),$(esc(nrmsuc)),$(esc(nrmslx)),$(esc(nrmsux)),$(esc(nrmsnx)),$(esc(nrmbars))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getprimalsolutionnorms(task,whichsol,nrmxc,nrmxx,nrmbarx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getprimalsolutionnorms,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(nrmxc)),$(esc(nrmxx)),$(esc(nrmbarx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsolutionslice(task,whichsol,solitem,first,last,values)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsolutionslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(solitem)),$(esc(first)),$(esc(last)),$(esc(values))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getreducedcosts(task,whichsol,first,last,redcosts)
  quote
     local res = disable_sigint(()->ccall((:MSK_getreducedcosts,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(first)),$(esc(last)),$(esc(redcosts))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getstrparam(task,param,maxlen,len,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_getstrparam,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Int32},Ptr{UInt8},),$(esc(task)),$(esc(param)),$(esc(maxlen)),$(esc(len)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getstrparamlen(task,param,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_getstrparamlen,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(param)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsymbcon(task,i,sizevalue,name,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsymbcon,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(i)),$(esc(sizevalue)),$(esc(name)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_gettasknamelen(task,len)
  quote
     local res = disable_sigint(()->ccall((:MSK_gettasknamelen,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(len))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_gettaskname(task,sizetaskname,taskname)
  quote
     local res = disable_sigint(()->ccall((:MSK_gettaskname,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(sizetaskname)),$(esc(taskname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvartype(task,j,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvartype,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(j)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getvartypelist(task,num,subj,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getvartypelist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_inputdata(task,maxnumcon,maxnumvar,numcon,numvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_inputdata,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},Float64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(numcon)),$(esc(numvar)),$(esc(c)),$(esc(cfix)),$(esc(aptrb)),$(esc(aptre)),$(esc(asub)),$(esc(aval)),$(esc(bkc)),$(esc(blc)),$(esc(buc)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_inputdata64(task,maxnumcon,maxnumvar,numcon,numvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_inputdata64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},Float64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(numcon)),$(esc(numvar)),$(esc(c)),$(esc(cfix)),$(esc(aptrb)),$(esc(aptre)),$(esc(asub)),$(esc(aval)),$(esc(bkc)),$(esc(blc)),$(esc(buc)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_isdouparname(task,parname,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_isdouparname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_isintparname(task,parname,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_isintparname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_isstrparname(task,parname,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_isstrparname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_linkfiletotaskstream(task,whichstream,filename,append)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfiletotaskstream,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Int32,),$(esc(task)),$(esc(whichstream)),$(esc(filename)),$(esc(append))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_linkfunctotaskstream(task,whichstream,handle,func)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfunctotaskstream,libmosek),Int32,(Ptr{Nothing},Int32,Any,Ptr{Cvoid},),$(esc(task)),$(esc(whichstream)),$(esc(handle)),$(esc(func))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_unlinkfuncfromtaskstream(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_unlinkfuncfromtaskstream,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_clonetask(task,clonedtask)
  quote
     local res = disable_sigint(()->ccall((:MSK_clonetask,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Nothing}},),$(esc(task)),$(esc(clonedtask))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_primalrepair(task,wlc,wuc,wlx,wux)
  quote
     local res = disable_sigint(()->ccall((:MSK_primalrepair,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(wlc)),$(esc(wuc)),$(esc(wlx)),$(esc(wux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_infeasibilityreport(task,whichstream,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_infeasibilityreport,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_toconic(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_toconic,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimize(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimize,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizetrm(task,trmcode)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizetrm,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(trmcode))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_printparam(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_printparam,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_probtypetostr(task,probtype,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_probtypetostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(probtype)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_prostatostr(task,problemsta,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_prostatostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(problemsta)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putresponsefunc(task,responsefunc,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_putresponsefunc,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,),$(esc(task)),$(esc(responsefunc)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_commitchanges(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_commitchanges,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getatruncatetol(task,tolzero)
  quote
     local res = disable_sigint(()->ccall((:MSK_getatruncatetol,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},),$(esc(task)),$(esc(tolzero))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putatruncatetol(task,tolzero)
  quote
     local res = disable_sigint(()->ccall((:MSK_putatruncatetol,libmosek),Int32,(Ptr{Nothing},Float64,),$(esc(task)),$(esc(tolzero))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaij(task,i,j,aij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(aij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaijlist(task,num,subi,subj,valij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaijlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(valij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaijlist64(task,num,subi,subj,valij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaijlist64,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(valij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacol(task,j,nzj,subj,valj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacol,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(j)),$(esc(nzj)),$(esc(subj)),$(esc(valj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarow(task,i,nzi,subi,vali)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarow,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(i)),$(esc(nzi)),$(esc(subi)),$(esc(vali))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowslice(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowslice64(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowlist(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putarowlist64(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putarowlist64,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacolslice(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacolslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacolslice64(task,first,last,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacolslice64,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacollist(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacollist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacollist64(task,num,sub,ptrb,ptre,asub,aval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacollist64,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(ptrb)),$(esc(ptre)),$(esc(asub)),$(esc(aval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbaraij(task,i,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbaraij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbaraijlist(task,num,subi,subj,alphaptrb,alphaptre,matidx,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbaraijlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(alphaptrb)),$(esc(alphaptre)),$(esc(matidx)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbararowlist(task,num,subi,ptrb,ptre,subj,nummat,matidx,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbararowlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(ptrb)),$(esc(ptre)),$(esc(subj)),$(esc(nummat)),$(esc(matidx)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarcnz(task,nz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarcnz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(nz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbaranz(task,nz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbaranz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(nz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcsparsity(task,maxnumnz,numnz,idxj)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcsparsity,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},),$(esc(task)),$(esc(maxnumnz)),$(esc(numnz)),$(esc(idxj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarasparsity(task,maxnumnz,numnz,idxij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarasparsity,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},),$(esc(task)),$(esc(maxnumnz)),$(esc(numnz)),$(esc(idxij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcidxinfo(task,idx,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcidxinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(idx)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcidxj(task,idx,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcidxj,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(idx)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcidx(task,idx,maxnum,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcidx,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ref{Int32},Ref{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(idx)),$(esc(maxnum)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbaraidxinfo(task,idx,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbaraidxinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(idx)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbaraidxij(task,idx,i,j)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbaraidxij,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(idx)),$(esc(i)),$(esc(j))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbaraidx(task,idx,maxnum,i,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbaraidx,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ref{Int32},Ref{Int32},Ref{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(idx)),$(esc(maxnum)),$(esc(i)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarcblocktriplets(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarcblocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarcblocktriplet(task,num,subj,subk,subl,valjkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarcblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valjkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarcblocktriplet(task,maxnum,num,subj,subk,subl,valjkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarcblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnum)),$(esc(num)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valjkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarablocktriplet(task,num,subi,subj,subk,subl,valijkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarablocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valijkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumbarablocktriplets(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumbarablocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getbarablocktriplet(task,maxnum,num,subi,subj,subk,subl,valijkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbarablocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnum)),$(esc(num)),$(esc(subi)),$(esc(subj)),$(esc(subk)),$(esc(subl)),$(esc(valijkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumafe(task,maxnumafe)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumafe,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumafe))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumafe(task,numafe)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumafe,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numafe))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendafes(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendafes,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefentry(task,afeidx,varidx,value)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefentry,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Float64,),$(esc(task)),$(esc(afeidx)),$(esc(varidx)),$(esc(value))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefentrylist(task,numentr,afeidx,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefentrylist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numentr)),$(esc(afeidx)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefrow(task,afeidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefrow,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(afeidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefcol(task,varidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefcol,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(varidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefrowlist(task,numafeidx,afeidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefrowlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafefcollist(task,numvaridx,varidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafefcollist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},),$(esc(task)),$(esc(numvaridx)),$(esc(varidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefrow(task,afeidx,numnz,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefrow,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(numnz)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefrowlist(task,numafeidx,afeidx,numnzrow,ptrrow,lenidxval,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefrowlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int64},Int64,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx)),$(esc(numnzrow)),$(esc(ptrrow)),$(esc(lenidxval)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafefcol(task,varidx,numnz,afeidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafefcol,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(varidx)),$(esc(numnz)),$(esc(afeidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafefrownumnz(task,afeidx,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafefrownumnz,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(afeidx)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafefnumnz(task,numnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafefnumnz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafefrow(task,afeidx,numnz,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafefrow,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(numnz)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafeftrip(task,afeidx,varidx,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafeftrip,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(varidx)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfentry(task,afeidx,barvaridx,numterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfentry,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(numterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfentrylist(task,numafeidx,afeidx,barvaridx,numterm,ptrterm,lenterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfentrylist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(numterm)),$(esc(ptrterm)),$(esc(lenterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfrow(task,afeidx,numentr,barvaridx,numterm,ptrterm,lenterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfrow,libmosek),Int32,(Ptr{Nothing},Int64,Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(numentr)),$(esc(barvaridx)),$(esc(numterm)),$(esc(ptrterm)),$(esc(lenterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafebarfrow(task,afeidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafebarfrow,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(afeidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_emptyafebarfrowlist(task,numafeidx,afeidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_emptyafebarfrowlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafebarfblocktriplet(task,numtrip,afeidx,barvaridx,subk,subl,valkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafebarfblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numtrip)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(subk)),$(esc(subl)),$(esc(valkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfnumblocktriplets(task,numtrip)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfnumblocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numtrip))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfblocktriplet(task,maxnumtrip,numtrip,afeidx,barvaridx,subk,subl,valkl)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumtrip)),$(esc(numtrip)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(subk)),$(esc(subl)),$(esc(valkl))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfnumrowentries(task,afeidx,numentr)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfnumrowentries,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(afeidx)),$(esc(numentr))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfrowinfo(task,afeidx,numentr,numterm)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfrowinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ref{Int64},),$(esc(task)),$(esc(afeidx)),$(esc(numentr)),$(esc(numterm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafebarfrow(task,afeidx,barvaridx,ptrterm,numterm,termidx,termweight)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafebarfrow,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(barvaridx)),$(esc(ptrterm)),$(esc(numterm)),$(esc(termidx)),$(esc(termweight))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafeg(task,afeidx,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafeg,libmosek),Int32,(Ptr{Nothing},Int64,Float64,),$(esc(task)),$(esc(afeidx)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafeglist(task,numafeidx,afeidx,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafeglist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numafeidx)),$(esc(afeidx)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafeg(task,afeidx,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafeg,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Float64},),$(esc(task)),$(esc(afeidx)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getafegslice(task,first,last,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_getafegslice,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putafegslice(task,first,last,slice)
  quote
     local res = disable_sigint(()->ccall((:MSK_putafegslice,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(slice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumdjc(task,maxnumdjc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumdjc,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumdjc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumdjc(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumdjc,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumdomain(task,djcidx,numdomain)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numdomain))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumdomaintot(task,numdomaintot)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumdomaintot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numdomaintot))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumafe(task,djcidx,numafe)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumafe,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numafe))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumafetot(task,numafetot)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumafetot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numafetot))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumterm(task,djcidx,numterm)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumterm,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numterm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcnumtermtot(task,numtermtot)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcnumtermtot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numtermtot))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumacc(task,maxnumacc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumacc,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumacc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumacc(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumacc,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendacc(task,domidx,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendacc,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(domidx)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendaccs(task,numaccs,domidxs,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendaccs,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numaccs)),$(esc(domidxs)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendaccseq(task,domidx,numafeidx,afeidxfirst,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendaccseq,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(domidx)),$(esc(numafeidx)),$(esc(afeidxfirst)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendaccsseq(task,numaccs,domidxs,numafeidx,afeidxfirst,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendaccsseq,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(numaccs)),$(esc(domidxs)),$(esc(numafeidx)),$(esc(afeidxfirst)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacc(task,accidx,domidx,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacc,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(accidx)),$(esc(domidx)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putacclist(task,numaccs,accidxs,domidxs,numafeidx,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_putacclist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(numaccs)),$(esc(accidxs)),$(esc(domidxs)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccb(task,accidx,lengthb,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccb,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},),$(esc(task)),$(esc(accidx)),$(esc(lengthb)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putaccbj(task,accidx,j,bj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putaccbj,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Float64,),$(esc(task)),$(esc(accidx)),$(esc(j)),$(esc(bj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccdomain(task,accidx,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(accidx)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccn(task,accidx,n)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccn,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(accidx)),$(esc(n))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccntot(task,n)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccntot,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(n))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccafeidxlist(task,accidx,afeidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccafeidxlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(accidx)),$(esc(afeidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccb(task,accidx,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccb,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Float64},),$(esc(task)),$(esc(accidx)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccs(task,domidxlist,afeidxlist,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccs,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(domidxlist)),$(esc(afeidxlist)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccfnumnz(task,accfnnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccfnumnz,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(accfnnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccftrip(task,frow,fcol,fval)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccftrip,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(frow)),$(esc(fcol)),$(esc(fval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccgvector(task,g)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccgvector,libmosek),Int32,(Ptr{Nothing},Ptr{Float64},),$(esc(task)),$(esc(g))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccbarfnumblocktriplets(task,numtrip)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccbarfnumblocktriplets,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numtrip))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getaccbarfblocktriplet(task,maxnumtrip,numtrip,acc_afe,bar_var,blk_row,blk_col,blk_val)
  quote
     local res = disable_sigint(()->ccall((:MSK_getaccbarfblocktriplet,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(maxnumtrip)),$(esc(numtrip)),$(esc(acc_afe)),$(esc(bar_var)),$(esc(blk_row)),$(esc(blk_col)),$(esc(blk_val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddjcs(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddjcs,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdjc(task,djcidx,numdomidx,domidxlist,numafeidx,afeidxlist,b,numterms,termsizelist)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdjc,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(numdomidx)),$(esc(domidxlist)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b)),$(esc(numterms)),$(esc(termsizelist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdjcslice(task,idxfirst,idxlast,numdomidx,domidxlist,numafeidx,afeidxlist,b,numterms,termsizelist,termsindjc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdjcslice,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},Int64,Ptr{Int64},Ptr{Int64},),$(esc(task)),$(esc(idxfirst)),$(esc(idxlast)),$(esc(numdomidx)),$(esc(domidxlist)),$(esc(numafeidx)),$(esc(afeidxlist)),$(esc(b)),$(esc(numterms)),$(esc(termsizelist)),$(esc(termsindjc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcdomainidxlist(task,djcidx,domidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcdomainidxlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(domidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcafeidxlist(task,djcidx,afeidxlist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcafeidxlist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(afeidxlist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcb(task,djcidx,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcb,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Float64},),$(esc(task)),$(esc(djcidx)),$(esc(b))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjctermsizelist(task,djcidx,termsizelist)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjctermsizelist,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Int64},),$(esc(task)),$(esc(djcidx)),$(esc(termsizelist))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdjcs(task,domidxlist,afeidxlist,b,termsizelist,numterms)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdjcs,libmosek),Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int64},Ptr{Float64},Ptr{Int64},Ptr{Int64},),$(esc(task)),$(esc(domidxlist)),$(esc(afeidxlist)),$(esc(b)),$(esc(termsizelist)),$(esc(numterms))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconbound(task,i,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(i)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundlist(task,num,sub,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundlistconst(task,num,sub,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundlistconst,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Int32,Float64,Float64,),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundslice(task,first,last,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconboundsliceconst(task,first,last,bkc,blc,buc)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconboundsliceconst,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkc)),$(esc(blc)),$(esc(buc))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarbound(task,j,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarbound,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(j)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundlist(task,num,sub,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundlistconst(task,num,sub,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundlistconst,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Int32,Float64,Float64,),$(esc(task)),$(esc(num)),$(esc(sub)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundslice(task,first,last,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarboundsliceconst(task,first,last,bkx,blx,bux)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarboundsliceconst,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(bkx)),$(esc(blx)),$(esc(bux))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcallbackfunc(task,func,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcallbackfunc,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,),$(esc(task)),$(esc(func)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcfix(task,cfix)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcfix,libmosek),Int32,(Ptr{Nothing},Float64,),$(esc(task)),$(esc(cfix))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcj(task,j,cj)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcj,libmosek),Int32,(Ptr{Nothing},Int32,Float64,),$(esc(task)),$(esc(j)),$(esc(cj))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putobjsense(task,sense)
  quote
     local res = disable_sigint(()->ccall((:MSK_putobjsense,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(sense))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getobjsense(task,sense)
  quote
     local res = disable_sigint(()->ccall((:MSK_getobjsense,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(sense))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putclist(task,num,subj,val)
  quote
     local res = disable_sigint(()->ccall((:MSK_putclist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(val))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcslice(task,first,last,slice)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcslice,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(task)),$(esc(first)),$(esc(last)),$(esc(slice))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putbarcj(task,j,num,sub,weights)
  quote
     local res = disable_sigint(()->ccall((:MSK_putbarcj,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),$(esc(task)),$(esc(j)),$(esc(num)),$(esc(sub)),$(esc(weights))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putcone(task,k,ct,conepar,nummem,submem)
  quote
     local res = disable_sigint(()->ccall((:MSK_putcone,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Int32,Ptr{Int32},),$(esc(task)),$(esc(k)),$(esc(ct)),$(esc(conepar)),$(esc(nummem)),$(esc(submem))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumdomain(task,maxnumdomain)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumdomain,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumdomain))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumdomain(task,numdomain)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumdomain,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(numdomain))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrplusdomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrplusdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrminusdomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrminusdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrdomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrdomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrzerodomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrzerodomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendquadraticconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendquadraticconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendrquadraticconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendrquadraticconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendprimalexpconedomain(task,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendprimalexpconedomain,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddualexpconedomain(task,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddualexpconedomain,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendprimalgeomeanconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendprimalgeomeanconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddualgeomeanconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddualgeomeanconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendprimalpowerconedomain(task,n,nleft,alpha,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendprimalpowerconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(nleft)),$(esc(alpha)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appenddualpowerconedomain(task,n,nleft,alpha,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appenddualpowerconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Float64},Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(nleft)),$(esc(alpha)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendsvecpsdconedomain(task,n,domidx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendsvecpsdconedomain,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(n)),$(esc(domidx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomaintype(task,domidx,domtype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomaintype,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},),$(esc(task)),$(esc(domidx)),$(esc(domtype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getdomainn(task,domidx,n)
  quote
     local res = disable_sigint(()->ccall((:MSK_getdomainn,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},),$(esc(task)),$(esc(domidx)),$(esc(n))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpowerdomaininfo(task,domidx,n,nleft)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpowerdomaininfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int64},Ref{Int64},),$(esc(task)),$(esc(domidx)),$(esc(n)),$(esc(nleft))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getpowerdomainalpha(task,domidx,alpha)
  quote
     local res = disable_sigint(()->ccall((:MSK_getpowerdomainalpha,libmosek),Int32,(Ptr{Nothing},Int64,Ptr{Float64},),$(esc(task)),$(esc(domidx)),$(esc(alpha))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendsparsesymmat(task,dim,nz,subi,subj,valij,idx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendsparsesymmat,libmosek),Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ref{Int64},),$(esc(task)),$(esc(dim)),$(esc(nz)),$(esc(subi)),$(esc(subj)),$(esc(valij)),$(esc(idx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_appendsparsesymmatlist(task,num,dims,nz,subi,subj,valij,idx)
  quote
     local res = disable_sigint(()->ccall((:MSK_appendsparsesymmatlist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Int64},),$(esc(task)),$(esc(num)),$(esc(dims)),$(esc(nz)),$(esc(subi)),$(esc(subj)),$(esc(valij)),$(esc(idx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsymmatinfo(task,idx,dim,nz,mattype)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsymmatinfo,libmosek),Int32,(Ptr{Nothing},Int64,Ref{Int32},Ref{Int64},Ref{Int32},),$(esc(task)),$(esc(idx)),$(esc(dim)),$(esc(nz)),$(esc(mattype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getnumsymmat(task,num)
  quote
     local res = disable_sigint(()->ccall((:MSK_getnumsymmat,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(num))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getsparsesymmat(task,idx,maxlen,subi,subj,valij)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsparsesymmat,libmosek),Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(idx)),$(esc(maxlen)),$(esc(subi)),$(esc(subj)),$(esc(valij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putdouparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putdouparam,libmosek),Int32,(Ptr{Nothing},Int32,Float64,),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putintparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putintparam,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumcon(task,maxnumcon)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumcon,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumcon))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumcone(task,maxnumcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumcone,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumcone(task,maxnumcone)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumcone,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumcone))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumvar(task,maxnumvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumvar,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumbarvar(task,maxnumbarvar)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumbarvar,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(maxnumbarvar))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumanz(task,maxnumanz)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumanz,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumanz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putmaxnumqnz(task,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_putmaxnumqnz,libmosek),Int32,(Ptr{Nothing},Int64,),$(esc(task)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumqnz(task,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumqnz,libmosek),Int32,(Ptr{Nothing},Ref{Int32},),$(esc(task)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmaxnumqnz64(task,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmaxnumqnz64,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(task)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putnadouparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putnadouparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Float64,),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putnaintparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putnaintparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putnastrparam(task,paramname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putnastrparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(paramname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putobjname(task,objname)
  quote
     local res = disable_sigint(()->ccall((:MSK_putobjname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(objname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putparam(task,parname,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(parname)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqcon(task,numqcnz,qcsubk,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqcon,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numqcnz)),$(esc(qcsubk)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqconk(task,k,numqcnz,qcsubi,qcsubj,qcval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqconk,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(k)),$(esc(numqcnz)),$(esc(qcsubi)),$(esc(qcsubj)),$(esc(qcval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqobj(task,numqonz,qosubi,qosubj,qoval)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqobj,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),$(esc(task)),$(esc(numqonz)),$(esc(qosubi)),$(esc(qosubj)),$(esc(qoval))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putqobjij(task,i,j,qoij)
  quote
     local res = disable_sigint(()->ccall((:MSK_putqobjij,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(j)),$(esc(qoij))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsolution(task,whichsol,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsolution,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsolutionnew(task,whichsol,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsolutionnew,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(whichsol)),$(esc(skc)),$(esc(skx)),$(esc(skn)),$(esc(xc)),$(esc(xx)),$(esc(y)),$(esc(slc)),$(esc(suc)),$(esc(slx)),$(esc(sux)),$(esc(snx)),$(esc(doty))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putconsolutioni(task,i,whichsol,sk,x,sl,su)
  quote
     local res = disable_sigint(()->ccall((:MSK_putconsolutioni,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,Float64,),$(esc(task)),$(esc(i)),$(esc(whichsol)),$(esc(sk)),$(esc(x)),$(esc(sl)),$(esc(su))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvarsolutionj(task,j,whichsol,sk,x,sl,su,sn)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvarsolutionj,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,Float64,Float64,),$(esc(task)),$(esc(j)),$(esc(whichsol)),$(esc(sk)),$(esc(x)),$(esc(sl)),$(esc(su)),$(esc(sn))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putsolutionyi(task,i,whichsol,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_putsolutionyi,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,),$(esc(task)),$(esc(i)),$(esc(whichsol)),$(esc(y))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putstrparam(task,param,parvalue)
  quote
     local res = disable_sigint(()->ccall((:MSK_putstrparam,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(param)),$(esc(parvalue))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_puttaskname(task,taskname)
  quote
     local res = disable_sigint(()->ccall((:MSK_puttaskname,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(taskname))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvartype(task,j,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvartype,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(j)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putvartypelist(task,num,subj,vartype)
  quote
     local res = disable_sigint(()->ccall((:MSK_putvartypelist,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},),$(esc(task)),$(esc(num)),$(esc(subj)),$(esc(vartype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdata(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdata,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdatacb(task,hread,h,format,compress,path)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdatacb,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,Int32,Int32,Ptr{UInt8},),$(esc(task)),$(esc(hread)),$(esc(h)),$(esc(format)),$(esc(compress)),$(esc(path))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writedatahandle(task,func,handle,format,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_writedatahandle,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,Int32,Int32,),$(esc(task)),$(esc(func)),$(esc(handle)),$(esc(format)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdataformat(task,filename,format,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdataformat,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,Int32,),$(esc(task)),$(esc(filename)),$(esc(format)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readdataautoformat(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readdataautoformat,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readparamfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readparamfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readsolution(task,whichsol,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readsolution,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(whichsol)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readsummary(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_readsummary,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_resizetask(task,maxnumcon,maxnumvar,maxnumcone,maxnumanz,maxnumqnz)
  quote
     local res = disable_sigint(()->ccall((:MSK_resizetask,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Int64,),$(esc(task)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(maxnumcone)),$(esc(maxnumanz)),$(esc(maxnumqnz))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_checkmemtask(task,file,line)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkmemtask,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(file)),$(esc(line))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getmemusagetask(task,meminuse,maxmemuse)
  quote
     local res = disable_sigint(()->ccall((:MSK_getmemusagetask,libmosek),Int32,(Ptr{Nothing},Ref{Int64},Ref{Int64},),$(esc(task)),$(esc(meminuse)),$(esc(maxmemuse))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_setdefaults(task)
  quote
     local res = disable_sigint(()->ccall((:MSK_setdefaults,libmosek),Int32,(Ptr{Nothing},),$(esc(task))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_sktostr(task,sk,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_sktostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(sk)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solstatostr(task,solutionsta,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_solstatostr,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(solutionsta)),$(esc(str))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solutiondef(task,whichsol,isdef)
  quote
     local res = disable_sigint(()->ccall((:MSK_solutiondef,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Int32},),$(esc(task)),$(esc(whichsol)),$(esc(isdef))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_deletesolution(task,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_deletesolution,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_onesolutionsummary(task,whichstream,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_onesolutionsummary,libmosek),Int32,(Ptr{Nothing},Int32,Int32,),$(esc(task)),$(esc(whichstream)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_solutionsummary(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_solutionsummary,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_updatesolutioninfo(task,whichsol)
  quote
     local res = disable_sigint(()->ccall((:MSK_updatesolutioninfo,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichsol))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizersummary(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizersummary,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_strtoconetype(task,str,conetype)
  quote
     local res = disable_sigint(()->ccall((:MSK_strtoconetype,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(str)),$(esc(conetype))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_strtosk(task,str,sk)
  quote
     local res = disable_sigint(()->ccall((:MSK_strtosk,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(str)),$(esc(sk))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_whichparam(task,parname,partype,param)
  quote
     local res = disable_sigint(()->ccall((:MSK_whichparam,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(parname)),$(esc(partype)),$(esc(param))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writedata(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writedata,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writetask(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writetask,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writebsolution(task,filename,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_writebsolution,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(filename)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readbsolution(task,filename,compress)
  quote
     local res = disable_sigint(()->ccall((:MSK_readbsolution,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(task)),$(esc(filename)),$(esc(compress))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writesolutionfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writesolutionfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readsolutionfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readsolutionfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readtask(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_readtask,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readopfstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readopfstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readlpstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readlpstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readjsonstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readjsonstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_readptfstring(task,data)
  quote
     local res = disable_sigint(()->ccall((:MSK_readptfstring,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(data))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writeparamfile(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writeparamfile,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getinfeasiblesubproblem(task,whichsol,inftask)
  quote
     local res = disable_sigint(()->ccall((:MSK_getinfeasiblesubproblem,libmosek),Int32,(Ptr{Nothing},Int32,Ref{Ptr{Nothing}},),$(esc(task)),$(esc(whichsol)),$(esc(inftask))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writesolution(task,whichsol,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writesolution,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),$(esc(task)),$(esc(whichsol)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_writejsonsol(task,filename)
  quote
     local res = disable_sigint(()->ccall((:MSK_writejsonsol,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(filename))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_primalsensitivity(task,numi,subi,marki,numj,subj,markj,leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej)
  quote
     local res = disable_sigint(()->ccall((:MSK_primalsensitivity,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(numi)),$(esc(subi)),$(esc(marki)),$(esc(numj)),$(esc(subj)),$(esc(markj)),$(esc(leftpricei)),$(esc(rightpricei)),$(esc(leftrangei)),$(esc(rightrangei)),$(esc(leftpricej)),$(esc(rightpricej)),$(esc(leftrangej)),$(esc(rightrangej))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_sensitivityreport(task,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_sensitivityreport,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(task)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_dualsensitivity(task,numj,subj,leftpricej,rightpricej,leftrangej,rightrangej)
  quote
     local res = disable_sigint(()->ccall((:MSK_dualsensitivity,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),$(esc(task)),$(esc(numj)),$(esc(subj)),$(esc(leftpricej)),$(esc(rightpricej)),$(esc(leftrangej)),$(esc(rightrangej))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_getlasterror64(task,lastrescode,sizelastmsg,lastmsglen,lastmsg)
  quote
     local res = disable_sigint(()->ccall((:MSK_getlasterror64,libmosek),Int32,(Ptr{Nothing},Ref{Int32},Int64,Ref{Int64},Ptr{UInt8},),$(esc(task)),$(esc(lastrescode)),$(esc(sizelastmsg)),$(esc(lastmsglen)),$(esc(lastmsg))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizermt(task,address,accesstoken,trmcode)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizermt,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ref{Int32},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(trmcode))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncoptimize(task,address,accesstoken,token)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncoptimize,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncstop(task,address,accesstoken,token)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncstop,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncpoll(task,address,accesstoken,token,respavailable,resp,trm)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncpoll,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ref{Int32},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token)),$(esc(respavailable)),$(esc(resp)),$(esc(trm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_asyncgetresult(task,address,accesstoken,token,respavailable,resp,trm)
  quote
     local res = disable_sigint(()->ccall((:MSK_asyncgetresult,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ref{Int32},Ref{Int32},Ref{Int32},),$(esc(task)),$(esc(address)),$(esc(accesstoken)),$(esc(token)),$(esc(respavailable)),$(esc(resp)),$(esc(trm))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_putoptserverhost(task,host)
  quote
     local res = disable_sigint(()->ccall((:MSK_putoptserverhost,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(task)),$(esc(host))))
     if res != 0
       throw(MosekError(res,getlasterrormsg($(esc(task)))))
     end
     nothing
  end
end
macro MSK_optimizebatch(env,israce,maxtime,numthreads,numtask,task,trmcode,rcode)
  quote
     local res = disable_sigint(()->ccall((:MSK_optimizebatch,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Int32,Int64,Ptr{Ptr{Nothing}},Ptr{Int32},Ptr{Int32},),$(esc(env)),$(esc(israce)),$(esc(maxtime)),$(esc(numthreads)),$(esc(numtask)),$(esc(task)),$(esc(trmcode)),$(esc(rcode))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkoutlicense(env,feature)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkoutlicense,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(feature))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkinlicense(env,feature)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkinlicense,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(feature))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkinall(env)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkinall,libmosek),Int32,(Ptr{Nothing},),$(esc(env))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_expirylicenses(env,expiry)
  quote
     local res = disable_sigint(()->ccall((:MSK_expirylicenses,libmosek),Int32,(Ptr{Nothing},Ref{Int64},),$(esc(env)),$(esc(expiry))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_resetexpirylicenses(env)
  quote
     local res = disable_sigint(()->ccall((:MSK_resetexpirylicenses,libmosek),Int32,(Ptr{Nothing},),$(esc(env))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getbuildinfo(buildstate,builddate)
  quote
     local res = disable_sigint(()->ccall((:MSK_getbuildinfo,libmosek),Int32,(Ptr{UInt8},Ptr{UInt8},),$(esc(buildstate)),$(esc(builddate))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getresponseclass(r,rc)
  quote
     local res = disable_sigint(()->ccall((:MSK_getresponseclass,libmosek),Int32,(Int32,Ref{Int32},),$(esc(r)),$(esc(rc))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_deleteenv(env)
  quote
     local res = disable_sigint(()->ccall((:MSK_deleteenv,libmosek),Int32,(Ref{Ptr{Nothing}},),$(esc(env))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_echointro(env,longver)
  quote
     local res = disable_sigint(()->ccall((:MSK_echointro,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(longver))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_freeenv(env,buffer)
  quote
     disable_sigint(()->ccall((:MSK_freeenv,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},),$(esc(env)),$(esc(buffer))))
  end
end
macro MSK_freedbgenv(env,buffer,file,line)
  quote
     disable_sigint(()->ccall((:MSK_freedbgenv,libmosek),Cvoid,(Ptr{Nothing},Ptr{Cvoid},Ptr{UInt8},UInt32,),$(esc(env)),$(esc(buffer)),$(esc(file)),$(esc(line))))
  end
end
macro MSK_getcodedesc(code,symname,str)
  quote
     local res = disable_sigint(()->ccall((:MSK_getcodedesc,libmosek),Int32,(Int32,Ptr{UInt8},Ptr{UInt8},),$(esc(code)),$(esc(symname)),$(esc(str))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getsymbcondim(env,num,maxlen)
  quote
     local res = disable_sigint(()->ccall((:MSK_getsymbcondim,libmosek),Int32,(Ptr{Nothing},Ref{Int32},Ref{CSize},),$(esc(env)),$(esc(num)),$(esc(maxlen))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_getversion(major,minor,revision)
  quote
     local res = disable_sigint(()->ccall((:MSK_getversion,libmosek),Int32,(Ref{Int32},Ref{Int32},Ref{Int32},),$(esc(major)),$(esc(minor)),$(esc(revision))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkversion(env,major,minor,revision)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkversion,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,),$(esc(env)),$(esc(major)),$(esc(minor)),$(esc(revision))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_linkfiletoenvstream(env,whichstream,filename,append)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfiletoenvstream,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Int32,),$(esc(env)),$(esc(whichstream)),$(esc(filename)),$(esc(append))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_linkfunctoenvstream(env,whichstream,handle,func)
  quote
     local res = disable_sigint(()->ccall((:MSK_linkfunctoenvstream,libmosek),Int32,(Ptr{Nothing},Int32,Any,Ptr{Cvoid},),$(esc(env)),$(esc(whichstream)),$(esc(handle)),$(esc(func))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_unlinkfuncfromenvstream(env,whichstream)
  quote
     local res = disable_sigint(()->ccall((:MSK_unlinkfuncfromenvstream,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(whichstream))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_makeenv(env,dbgfile)
  quote
     local res = disable_sigint(()->ccall((:MSK_makeenv,libmosek),Int32,(Ref{Ptr{Nothing}},Ptr{UInt8},),$(esc(env)),$(esc(dbgfile))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensedebug(env,licdebug)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensedebug,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(licdebug))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensecode(env,code)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensecode,libmosek),Int32,(Ptr{Nothing},Ptr{Int32},),$(esc(env)),$(esc(code))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensewait(env,licwait)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensewait,libmosek),Int32,(Ptr{Nothing},Int32,),$(esc(env)),$(esc(licwait))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putlicensepath(env,licensepath)
  quote
     local res = disable_sigint(()->ccall((:MSK_putlicensepath,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},),$(esc(env)),$(esc(licensepath))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_maketask(env,maxnumcon,maxnumvar,task)
  quote
     local res = disable_sigint(()->ccall((:MSK_maketask,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ref{Ptr{Nothing}},),$(esc(env)),$(esc(maxnumcon)),$(esc(maxnumvar)),$(esc(task))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_makeemptytask(env,task)
  quote
     local res = disable_sigint(()->ccall((:MSK_makeemptytask,libmosek),Int32,(Ptr{Nothing},Ref{Ptr{Nothing}},),$(esc(env)),$(esc(task))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_putexitfunc(env,exitfunc,handle)
  quote
     local res = disable_sigint(()->ccall((:MSK_putexitfunc,libmosek),Int32,(Ptr{Nothing},Ptr{Cvoid},Any,),$(esc(env)),$(esc(exitfunc)),$(esc(handle))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_checkmemenv(env,file,line)
  quote
     local res = disable_sigint(()->ccall((:MSK_checkmemenv,libmosek),Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),$(esc(env)),$(esc(file)),$(esc(line))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_axpy(env,n,alpha,x,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_axpy,libmosek),Int32,(Ptr{Nothing},Int32,Float64,Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(n)),$(esc(alpha)),$(esc(x)),$(esc(y))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_dot(env,n,x,y,xty)
  quote
     local res = disable_sigint(()->ccall((:MSK_dot,libmosek),Int32,(Ptr{Nothing},Int32,Ptr{Float64},Ptr{Float64},Ref{Float64},),$(esc(env)),$(esc(n)),$(esc(x)),$(esc(y)),$(esc(xty))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_gemv(env,transa,m,n,alpha,a,x,beta,y)
  quote
     local res = disable_sigint(()->ccall((:MSK_gemv,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Ptr{Float64},Ptr{Float64},Float64,Ptr{Float64},),$(esc(env)),$(esc(transa)),$(esc(m)),$(esc(n)),$(esc(alpha)),$(esc(a)),$(esc(x)),$(esc(beta)),$(esc(y))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_gemm(env,transa,transb,m,n,k,alpha,a,b,beta,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_gemm,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Int32,Float64,Ptr{Float64},Ptr{Float64},Float64,Ptr{Float64},),$(esc(env)),$(esc(transa)),$(esc(transb)),$(esc(m)),$(esc(n)),$(esc(k)),$(esc(alpha)),$(esc(a)),$(esc(b)),$(esc(beta)),$(esc(c))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_syrk(env,uplo,trans,n,k,alpha,a,beta,c)
  quote
     local res = disable_sigint(()->ccall((:MSK_syrk,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Float64,Ptr{Float64},Float64,Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(trans)),$(esc(n)),$(esc(k)),$(esc(alpha)),$(esc(a)),$(esc(beta)),$(esc(c))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_computesparsecholesky(env,numthreads,ordermethod,tolsingular,n,anzc,aptrc,asubc,avalc,perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)
  quote
     local res = disable_sigint(()->ccall((:MSK_computesparsecholesky,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Float64,Int32,Ptr{Int32},Ptr{Int64},Ptr{Int32},Ptr{Float64},Ref{Ptr{Int32}},Ref{Ptr{Float64}},Ref{Ptr{Int32}},Ref{Ptr{Int64}},Ref{Int64},Ref{Ptr{Int32}},Ref{Ptr{Float64}},),$(esc(env)),$(esc(numthreads)),$(esc(ordermethod)),$(esc(tolsingular)),$(esc(n)),$(esc(anzc)),$(esc(aptrc)),$(esc(asubc)),$(esc(avalc)),$(esc(perm)),$(esc(diag)),$(esc(lnzc)),$(esc(lptrc)),$(esc(lensubnval)),$(esc(lsubc)),$(esc(lvalc))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_sparsetriangularsolvedense(env,transposed,n,lnzc,lptrc,lensubnval,lsubc,lvalc,b)
  quote
     local res = disable_sigint(()->ccall((:MSK_sparsetriangularsolvedense,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int64},Int64,Ptr{Int32},Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(transposed)),$(esc(n)),$(esc(lnzc)),$(esc(lptrc)),$(esc(lensubnval)),$(esc(lsubc)),$(esc(lvalc)),$(esc(b))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_potrf(env,uplo,n,a)
  quote
     local res = disable_sigint(()->ccall((:MSK_potrf,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(n)),$(esc(a))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_syeig(env,uplo,n,a,w)
  quote
     local res = disable_sigint(()->ccall((:MSK_syeig,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(n)),$(esc(a)),$(esc(w))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_syevd(env,uplo,n,a,w)
  quote
     local res = disable_sigint(()->ccall((:MSK_syevd,libmosek),Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},Ptr{Float64},),$(esc(env)),$(esc(uplo)),$(esc(n)),$(esc(a)),$(esc(w))))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end
macro MSK_licensecleanup()
  quote
     local res = disable_sigint(()->ccall((:MSK_licensecleanup,libmosek),Int32,()))
     if res != 0
       throw(MosekError(res,""))
     end
     nothing
  end
end

"""
  analyzeproblem(task::MSKtask,whichstream::Streamtype)

  Analyze the data of a task.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function analyzeproblem end
function analyzeproblem(task::MSKtask,whichstream::Streamtype)
  @MSK_analyzeproblem(task.task,whichstream.value)
  nothing
end


"""
  analyzenames(task::MSKtask,whichstream::Streamtype,nametype::Nametype)

  Analyze the names and issue an error for the first invalid name.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
    nametype::Nametype The type of names e.g. valid in MPS or LP files.
"""
function analyzenames end
function analyzenames(task::MSKtask,whichstream::Streamtype,nametype::Nametype)
  @MSK_analyzenames(task.task,whichstream.value,nametype.value)
  nothing
end


"""
  analyzesolution(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)

  Print information related to the quality of the solution.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
    whichsol::Soltype Selects a solution.
"""
function analyzesolution end
function analyzesolution(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)
  @MSK_analyzesolution(task.task,whichstream.value,whichsol.value)
  nothing
end


"""
  initbasissolve(task::MSKtask) :: basis

  Prepare a task for basis solver.

  Arguments
    task::MSKtask An optimization task.
  Returns
    basis::Vector{Int32} The array of basis indexes to use.
"""
function initbasissolve end
function initbasissolve(task::MSKtask)
  __tmp_4 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_4)
  __tmp_3 = __tmp_4[]
  basis_ = Vector{Int32}(undef,__tmp_3)
  @MSK_initbasissolve(task.task,basis_)
  basis = basis_;
  basis
end


"""
  solvewithbasis(task::MSKtask,transp::Int32,numnz::Int32,sub::Vector{Int32},val::Vector{Float64}) :: numnzout
  solvewithbasis(task::MSKtask,transp::T0,numnz::T1,sub::Vector{Int32},val::Vector{Float64}) where {T0<:Integer,T1<:Integer}  :: numnzout

  Solve a linear equation system involving a basis matrix.

  Arguments
    task::MSKtask An optimization task.
    transp::Int32 Controls which problem formulation is solved.
    numnz::Int32 Input (number of non-zeros in right-hand side).
    sub::Vector{Int32} Input (indexes of non-zeros in right-hand side) and output (indexes of non-zeros in solution vector).
    val::Vector{Float64} Input (right-hand side values) and output (solution vector values).
  Returns
    numnzout::Int32 Output (number of non-zeros in solution vector).
"""
function solvewithbasis end
function solvewithbasis(task::MSKtask,transp::Int32,numnz::Int32,sub::Vector{Int32},val::Vector{Float64})
  __tmp_7 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_7)
  __tmp_6 = __tmp_7[]
  if length(sub) < __tmp_6
    throw(BoundsError())
  end
  sub_ = sub .- Int32(1)
  __tmp_10 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_10)
  __tmp_9 = __tmp_10[]
  if length(val) < __tmp_9
    throw(BoundsError())
  end
  val_ = val
  numnzout_ = Ref{Int32}()
  @MSK_solvewithbasis(task.task,transp,numnz,sub_,val_,numnzout_)
  sub = sub_ .+ Int32(1)
  val = val_
  numnzout_[]
end
function solvewithbasis(task::MSKtask,transp::T0,numnz::T1,sub::Vector{Int32},val::Vector{Float64}) where { T0<:Integer,T1<:Integer }
  solvewithbasis(
    task,
    convert(Int32,transp),
    convert(Int32,numnz),
    sub,
    val)
end


"""
  basiscond(task::MSKtask) :: (nrmbasis,nrminvbasis)

  Computes conditioning information for the basis matrix.

  Arguments
    task::MSKtask An optimization task.
  Returns
    nrmbasis::Float64 An estimate for the 1-norm of the basis.
    nrminvbasis::Float64 An estimate for the 1-norm of the inverse of the basis.
"""
function basiscond end
function basiscond(task::MSKtask)
  nrmbasis_ = Ref{Float64}()
  nrminvbasis_ = Ref{Float64}()
  @MSK_basiscond(task.task,nrmbasis_,nrminvbasis_)
  nrmbasis_[],nrminvbasis_[]
end


"""
  appendcons(task::MSKtask,num::Int32)
  appendcons(task::MSKtask,num::T0) where {T0<:Integer} 

  Appends a number of constraints to the optimization task.

  Arguments
    task::MSKtask An optimization task.
    num::Int32 Number of constraints which should be appended.
"""
function appendcons end
function appendcons(task::MSKtask,num::Int32)
  @MSK_appendcons(task.task,num)
  nothing
end
function appendcons(task::MSKtask,num::T0) where { T0<:Integer }
  appendcons(
    task,
    convert(Int32,num))
end


"""
  appendvars(task::MSKtask,num::Int32)
  appendvars(task::MSKtask,num::T0) where {T0<:Integer} 

  Appends a number of variables to the optimization task.

  Arguments
    task::MSKtask An optimization task.
    num::Int32 Number of variables which should be appended.
"""
function appendvars end
function appendvars(task::MSKtask,num::Int32)
  @MSK_appendvars(task.task,num)
  nothing
end
function appendvars(task::MSKtask,num::T0) where { T0<:Integer }
  appendvars(
    task,
    convert(Int32,num))
end


"""
  removecons(task::MSKtask,subset::Vector{Int32})
  removecons(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

  Removes a number of constraints.

  Arguments
    task::MSKtask An optimization task.
    subset::Vector{Int32} Indexes of constraints which should be removed.
"""
function removecons end
function removecons(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset
  @MSK_removecons(task.task,num,subset_)
  nothing
end
function removecons(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removecons(
    task,
    convert(Vector{Int32},subset))
end


"""
  removevars(task::MSKtask,subset::Vector{Int32})
  removevars(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

  Removes a number of variables.

  Arguments
    task::MSKtask An optimization task.
    subset::Vector{Int32} Indexes of variables which should be removed.
"""
function removevars end
function removevars(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset
  @MSK_removevars(task.task,num,subset_)
  nothing
end
function removevars(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removevars(
    task,
    convert(Vector{Int32},subset))
end


"""
  removebarvars(task::MSKtask,subset::Vector{Int32})
  removebarvars(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

  Removes a number of symmetric matrices.

  Arguments
    task::MSKtask An optimization task.
    subset::Vector{Int32} Indexes of symmetric matrices which should be removed.
"""
function removebarvars end
function removebarvars(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset
  @MSK_removebarvars(task.task,num,subset_)
  nothing
end
function removebarvars(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removebarvars(
    task,
    convert(Vector{Int32},subset))
end


"""
  removecones(task::MSKtask,subset::Vector{Int32})
  removecones(task::MSKtask,subset::T0) where {T0<:AbstractVector{<:Integer}} 

  Removes a number of conic constraints from the problem.

  Arguments
    task::MSKtask An optimization task.
    subset::Vector{Int32} Indexes of cones which should be removed.
"""
function removecones end
function removecones(task::MSKtask,subset::Vector{Int32})
  num = Int32(length(subset))
  subset_ = subset .- Int32(1)
  @MSK_removecones(task.task,num,subset_)
  nothing
end
function removecones(task::MSKtask,subset::T0) where { T0<:AbstractVector{<:Integer} }
  removecones(
    task,
    convert(Vector{Int32},subset))
end


"""
  appendbarvars(task::MSKtask,dim::Vector{Int32})
  appendbarvars(task::MSKtask,dim::T0) where {T0<:AbstractVector{<:Integer}} 

  Appends semidefinite variables to the problem.

  Arguments
    task::MSKtask An optimization task.
    dim::Vector{Int32} Dimensions of symmetric matrix variables to be added.
"""
function appendbarvars end
function appendbarvars(task::MSKtask,dim::Vector{Int32})
  num = Int32(length(dim))
  dim_ = dim
  @MSK_appendbarvars(task.task,num,dim_)
  nothing
end
function appendbarvars(task::MSKtask,dim::T0) where { T0<:AbstractVector{<:Integer} }
  appendbarvars(
    task,
    convert(Vector{Int32},dim))
end


"""
  appendcone(task::MSKtask,ct::Conetype,conepar::Float64,submem::Vector{Int32})
  appendcone(task::MSKtask,ct::Conetype,conepar::T0,submem::T1) where {T0<:Number,T1<:AbstractVector{<:Integer}} 

  Appends a new conic constraint to the problem.

  Arguments
    task::MSKtask An optimization task.
    ct::Conetype Specifies the type of the cone.
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    submem::Vector{Int32} Variable subscripts of the members in the cone.
"""
function appendcone end
function appendcone(task::MSKtask,ct::Conetype,conepar::Float64,submem::Vector{Int32})
  nummem = Int32(length(submem))
  submem_ = submem .- Int32(1)
  @MSK_appendcone(task.task,ct.value,conepar,nummem,submem_)
  nothing
end
function appendcone(task::MSKtask,ct::Conetype,conepar::T0,submem::T1) where { T0<:Number,T1<:AbstractVector{<:Integer} }
  appendcone(
    task,
    ct,
    convert(Float64,conepar),
    convert(Vector{Int32},submem))
end


"""
  appendconeseq(task::MSKtask,ct::Conetype,conepar::Float64,nummem::Int32,j::Int32)
  appendconeseq(task::MSKtask,ct::Conetype,conepar::T0,nummem::T1,j::T2) where {T0<:Number,T1<:Integer,T2<:Integer} 

  Appends a new conic constraint to the problem.

  Arguments
    task::MSKtask An optimization task.
    ct::Conetype Specifies the type of the cone.
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    nummem::Int32 Number of member variables in the cone.
    j::Int32 Index of the first variable in the conic constraint.
"""
function appendconeseq end
function appendconeseq(task::MSKtask,ct::Conetype,conepar::Float64,nummem::Int32,j::Int32)
  @MSK_appendconeseq(task.task,ct.value,conepar,nummem,j-Int32(1))
  nothing
end
function appendconeseq(task::MSKtask,ct::Conetype,conepar::T0,nummem::T1,j::T2) where { T0<:Number,T1<:Integer,T2<:Integer }
  appendconeseq(
    task,
    ct,
    convert(Float64,conepar),
    convert(Int32,nummem),
    convert(Int32,j))
end


"""
  appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::Vector{Float64},nummem::Vector{Int32},j::Int32)
  appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::T0,nummem::T1,j::T2) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Integer},T2<:Integer} 

  Appends multiple conic constraints to the problem.

  Arguments
    task::MSKtask An optimization task.
    ct::Vector{Conetype} Specifies the type of the cone.
    conepar::Vector{Float64} For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    nummem::Vector{Int32} Numbers of member variables in the cones.
    j::Int32 Index of the first variable in the first cone to be appended.
"""
function appendconesseq end
function appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::Vector{Float64},nummem::Vector{Int32},j::Int32)
  num = Int32(min(length(ct),length(conepar),length(nummem)))
  ct_ = Int32[item.value for item in ct]
  conepar_ = conepar
  nummem_ = nummem
  @MSK_appendconesseq(task.task,num,ct_,conepar_,nummem_,j-Int32(1))
  nothing
end
function appendconesseq(task::MSKtask,ct::Vector{Conetype},conepar::T0,nummem::T1,j::T2) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Integer},T2<:Integer }
  appendconesseq(
    task,
    ct,
    convert(Vector{Float64},conepar),
    convert(Vector{Int32},nummem),
    convert(Int32,j))
end


"""
  bktostr(task::MSKtask,bk::Boundkey) :: str

  Obtains a bound key string identifier.

  Arguments
    task::MSKtask An optimization task.
    bk::Boundkey Bound key.
  Returns
    str::String String corresponding to the bound key.
"""
function bktostr end
function bktostr(task::MSKtask,bk::Boundkey)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_bktostr(task.task,bk.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


"""
  callbackcodetostr(code::Callbackcode) :: callbackcodestr

  Obtains a callback code string identifier.

  Arguments
    code::Callbackcode A callback code.
  Returns
    callbackcodestr::String String corresponding to the callback code.
"""
function callbackcodetostr end
function callbackcodetostr(code::Callbackcode)
  callbackcodestr_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_callbackcodetostr(code.value,callbackcodestr_)
  callbackcodestr_len = findfirst(_c->_c==0,callbackcodestr_)
  callbackcodestr = if callbackcodestr_len === nothing
    String(callbackcodestr_)
  else
    String(callbackcodestr_[1:callbackcodestr_len-1])
  end
  callbackcodestr
end


"""
  chgconbound(task::MSKtask,i::Int32,lower::Int32,finite::Int32,value::Float64)
  chgconbound(task::MSKtask,i::T0,lower::T1,finite::T2,value::T3) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number} 

  Changes the bounds for one constraint.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the constraint for which the bounds should be changed.
    lower::Int32 If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
    finite::Int32 If non-zero, then the given value is assumed to be finite.
    value::Float64 New value for the bound.
"""
function chgconbound end
function chgconbound(task::MSKtask,i::Int32,lower::Int32,finite::Int32,value::Float64)
  @MSK_chgconbound(task.task,i-Int32(1),lower,finite,value)
  nothing
end
function chgconbound(task::MSKtask,i::T0,lower::T1,finite::T2,value::T3) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number }
  chgconbound(
    task,
    convert(Int32,i),
    convert(Int32,lower),
    convert(Int32,finite),
    convert(Float64,value))
end


"""
  chgvarbound(task::MSKtask,j::Int32,lower::Int32,finite::Int32,value::Float64)
  chgvarbound(task::MSKtask,j::T0,lower::T1,finite::T2,value::T3) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number} 

  Changes the bounds for one variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable for which the bounds should be changed.
    lower::Int32 If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
    finite::Int32 If non-zero, then the given value is assumed to be finite.
    value::Float64 New value for the bound.
"""
function chgvarbound end
function chgvarbound(task::MSKtask,j::Int32,lower::Int32,finite::Int32,value::Float64)
  @MSK_chgvarbound(task.task,j-Int32(1),lower,finite,value)
  nothing
end
function chgvarbound(task::MSKtask,j::T0,lower::T1,finite::T2,value::T3) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Number }
  chgvarbound(
    task,
    convert(Int32,j),
    convert(Int32,lower),
    convert(Int32,finite),
    convert(Float64,value))
end


"""
  conetypetostr(task::MSKtask,ct::Conetype) :: str

  Obtains a cone type string identifier.

  Arguments
    task::MSKtask An optimization task.
    ct::Conetype Specifies the type of the cone.
  Returns
    str::String String corresponding to the cone type.
"""
function conetypetostr end
function conetypetostr(task::MSKtask,ct::Conetype)
  str_ = Array{UInt8}(undef,1024)
  @MSK_conetypetostr(task.task,ct.value,str_)
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  str
end


"""
  getaij(task::MSKtask,i::Int32,j::Int32) :: aij
  getaij(task::MSKtask,i::T0,j::T1) where {T0<:Integer,T1<:Integer}  :: aij

  Obtains a single coefficient in linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Row index of the coefficient to be returned.
    j::Int32 Column index of the coefficient to be returned.
  Returns
    aij::Float64 Returns the requested coefficient.
"""
function getaij end
function getaij(task::MSKtask,i::Int32,j::Int32)
  aij_ = Ref{Float64}()
  @MSK_getaij(task.task,i-Int32(1),j-Int32(1),aij_)
  aij_[]
end
function getaij(task::MSKtask,i::T0,j::T1) where { T0<:Integer,T1<:Integer }
  getaij(
    task,
    convert(Int32,i),
    convert(Int32,j))
end


"""
  getapiecenumnz(task::MSKtask,firsti::Int32,lasti::Int32,firstj::Int32,lastj::Int32) :: numnz
  getapiecenumnz(task::MSKtask,firsti::T0,lasti::T1,firstj::T2,lastj::T3) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer}  :: numnz

  Obtains the number non-zeros in a rectangular piece of the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    firsti::Int32 Index of the first row in the rectangular piece.
    lasti::Int32 Index of the last row plus one in the rectangular piece.
    firstj::Int32 Index of the first column in the rectangular piece.
    lastj::Int32 Index of the last column plus one in the rectangular piece.
  Returns
    numnz::Int32 Number of non-zero elements in the rectangular piece of the linear constraint matrix.
"""
function getapiecenumnz end
function getapiecenumnz(task::MSKtask,firsti::Int32,lasti::Int32,firstj::Int32,lastj::Int32)
  numnz_ = Ref{Int32}()
  @MSK_getapiecenumnz(task.task,firsti-Int32(1),lasti-Int32(1),firstj-Int32(1),lastj-Int32(1),numnz_)
  numnz_[]
end
function getapiecenumnz(task::MSKtask,firsti::T0,lasti::T1,firstj::T2,lastj::T3) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer }
  getapiecenumnz(
    task,
    convert(Int32,firsti),
    convert(Int32,lasti),
    convert(Int32,firstj),
    convert(Int32,lastj))
end


"""
  getacolnumnz(task::MSKtask,i::Int32) :: nzj
  getacolnumnz(task::MSKtask,i::T0) where {T0<:Integer}  :: nzj

  Obtains the number of non-zero elements in one column of the linear constraint matrix

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the column.
  Returns
    nzj::Int32 Number of non-zeros in the j'th column of (A).
"""
function getacolnumnz end
function getacolnumnz(task::MSKtask,i::Int32)
  nzj_ = Ref{Int32}()
  @MSK_getacolnumnz(task.task,i-Int32(1),nzj_)
  nzj_[]
end
function getacolnumnz(task::MSKtask,i::T0) where { T0<:Integer }
  getacolnumnz(
    task,
    convert(Int32,i))
end


"""
  getacol(task::MSKtask,j::Int32) :: (nzj,subj,valj)
  getacol(task::MSKtask,j::T0) where {T0<:Integer}  :: (nzj,subj,valj)

  Obtains one column of the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the column.
  Returns
    nzj::Int32 Number of non-zeros in the column obtained.
    subj::Vector{Int32} Row indices of the non-zeros in the column obtained.
    valj::Vector{Float64} Numerical values in the column obtained.
"""
function getacol end
function getacol(task::MSKtask,j::Int32)
  nzj_ = Ref{Int32}()
  __tmp_35 = Ref{Int32}()
  @MSK_getacolnumnz(task.task,j-Int32(1),__tmp_35)
  __tmp_34 = __tmp_35[]
  subj_ = Vector{Int32}(undef,__tmp_34)
  __tmp_37 = Ref{Int32}()
  @MSK_getacolnumnz(task.task,j-Int32(1),__tmp_37)
  __tmp_36 = __tmp_37[]
  valj_ = Vector{Float64}(undef,__tmp_36)
  @MSK_getacol(task.task,j-Int32(1),nzj_,subj_,valj_)
  subj = subj_;
  subj .+= 1
  valj = valj_;
  nzj_[],subj,valj
end
function getacol(task::MSKtask,j::T0) where { T0<:Integer }
  getacol(
    task,
    convert(Int32,j))
end


"""
  getacolslice(task::MSKtask,first::Int32,last::Int32) :: (ptrb,ptre,sub,val)
  getacolslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (ptrb,ptre,sub,val)

  Obtains a sequence of columns from the coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 Index of the first column in the sequence.
    last::Int32 Index of the last column in the sequence plus one.
  Returns
    ptrb::Vector{Int64} Column start pointers.
    ptre::Vector{Int64} Column end pointers.
    sub::Vector{Int32} Contains the row subscripts.
    val::Vector{Float64} Contains the coefficient values.
"""
function getacolslice end
function getacolslice(task::MSKtask,first::Int32,last::Int32)
  __tmp_42 = Ref{Int64}()
  @MSK_getacolslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_42)
  __tmp_41 = __tmp_42[]
  maxnumnz = Int64(__tmp_41)
  ptrb_ = Vector{Int64}(undef,(last - first))
  ptre_ = Vector{Int64}(undef,(last - first))
  sub_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getacolslice64(task.task,first-Int32(1),last-Int32(1),maxnumnz,ptrb_,ptre_,sub_,val_)
  ptrb = ptrb_;
  ptrb .+= 1
  ptre = ptre_;
  ptre .+= 1
  sub = sub_;
  sub .+= 1
  val = val_;
  ptrb,ptre,sub,val
end
function getacolslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getacolslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getarownumnz(task::MSKtask,i::Int32) :: nzi
  getarownumnz(task::MSKtask,i::T0) where {T0<:Integer}  :: nzi

  Obtains the number of non-zero elements in one row of the linear constraint matrix

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the row.
  Returns
    nzi::Int32 Number of non-zeros in the i'th row of `A`.
"""
function getarownumnz end
function getarownumnz(task::MSKtask,i::Int32)
  nzi_ = Ref{Int32}()
  @MSK_getarownumnz(task.task,i-Int32(1),nzi_)
  nzi_[]
end
function getarownumnz(task::MSKtask,i::T0) where { T0<:Integer }
  getarownumnz(
    task,
    convert(Int32,i))
end


"""
  getarow(task::MSKtask,i::Int32) :: (nzi,subi,vali)
  getarow(task::MSKtask,i::T0) where {T0<:Integer}  :: (nzi,subi,vali)

  Obtains one row of the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the row.
  Returns
    nzi::Int32 Number of non-zeros in the row obtained.
    subi::Vector{Int32} Column indices of the non-zeros in the row obtained.
    vali::Vector{Float64} Numerical values of the row obtained.
"""
function getarow end
function getarow(task::MSKtask,i::Int32)
  nzi_ = Ref{Int32}()
  __tmp_46 = Ref{Int32}()
  @MSK_getarownumnz(task.task,i-Int32(1),__tmp_46)
  __tmp_45 = __tmp_46[]
  subi_ = Vector{Int32}(undef,__tmp_45)
  __tmp_48 = Ref{Int32}()
  @MSK_getarownumnz(task.task,i-Int32(1),__tmp_48)
  __tmp_47 = __tmp_48[]
  vali_ = Vector{Float64}(undef,__tmp_47)
  @MSK_getarow(task.task,i-Int32(1),nzi_,subi_,vali_)
  subi = subi_;
  subi .+= 1
  vali = vali_;
  nzi_[],subi,vali
end
function getarow(task::MSKtask,i::T0) where { T0<:Integer }
  getarow(
    task,
    convert(Int32,i))
end


"""
  getacolslicenumnz(task::MSKtask,first::Int32,last::Int32) :: numnz
  getacolslicenumnz(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: numnz

  Obtains the number of non-zeros in a slice of columns of the coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 Index of the first column in the sequence.
    last::Int32 Index of the last column plus one in the sequence.
  Returns
    numnz::Int64 Number of non-zeros in the slice.
"""
function getacolslicenumnz end
function getacolslicenumnz(task::MSKtask,first::Int32,last::Int32)
  numnz_ = Ref{Int64}()
  @MSK_getacolslicenumnz64(task.task,first-Int32(1),last-Int32(1),numnz_)
  numnz_[]
end
function getacolslicenumnz(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getacolslicenumnz(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getarowslicenumnz(task::MSKtask,first::Int32,last::Int32) :: numnz
  getarowslicenumnz(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: numnz

  Obtains the number of non-zeros in a slice of rows of the coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 Index of the first row in the sequence.
    last::Int32 Index of the last row plus one in the sequence.
  Returns
    numnz::Int64 Number of non-zeros in the slice.
"""
function getarowslicenumnz end
function getarowslicenumnz(task::MSKtask,first::Int32,last::Int32)
  numnz_ = Ref{Int64}()
  @MSK_getarowslicenumnz64(task.task,first-Int32(1),last-Int32(1),numnz_)
  numnz_[]
end
function getarowslicenumnz(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getarowslicenumnz(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getarowslice(task::MSKtask,first::Int32,last::Int32) :: (ptrb,ptre,sub,val)
  getarowslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (ptrb,ptre,sub,val)

  Obtains a sequence of rows from the coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 Index of the first row in the sequence.
    last::Int32 Index of the last row in the sequence plus one.
  Returns
    ptrb::Vector{Int64} Row start pointers.
    ptre::Vector{Int64} Row end pointers.
    sub::Vector{Int32} Contains the column subscripts.
    val::Vector{Float64} Contains the coefficient values.
"""
function getarowslice end
function getarowslice(task::MSKtask,first::Int32,last::Int32)
  __tmp_55 = Ref{Int64}()
  @MSK_getarowslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_55)
  __tmp_54 = __tmp_55[]
  maxnumnz = Int64(__tmp_54)
  ptrb_ = Vector{Int64}(undef,(last - first))
  ptre_ = Vector{Int64}(undef,(last - first))
  sub_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getarowslice64(task.task,first-Int32(1),last-Int32(1),maxnumnz,ptrb_,ptre_,sub_,val_)
  ptrb = ptrb_;
  ptrb .+= 1
  ptre = ptre_;
  ptre .+= 1
  sub = sub_;
  sub .+= 1
  val = val_;
  ptrb,ptre,sub,val
end
function getarowslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getarowslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getatrip(task::MSKtask) :: (subi,subj,val)

  Obtains the A matrix in sparse triplet format.

  Arguments
    task::MSKtask An optimization task.
  Returns
    subi::Vector{Int32} Constraint subscripts.
    subj::Vector{Int32} Column subscripts.
    val::Vector{Float64} Values.
"""
function getatrip end
function getatrip(task::MSKtask)
  __tmp_58 = Ref{Int64}()
  @MSK_getnumanz64(task.task,__tmp_58)
  __tmp_57 = __tmp_58[]
  maxnumnz = Int64(__tmp_57)
  subi_ = Vector{Int32}(undef,maxnumnz)
  subj_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getatrip(task.task,maxnumnz,subi_,subj_,val_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  val = val_;
  subi,subj,val
end


"""
  getarowslicetrip(task::MSKtask,first::Int32,last::Int32) :: (subi,subj,val)
  getarowslicetrip(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (subi,subj,val)

  Obtains a sequence of rows from the coefficient matrix in sparse triplet format.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 Index of the first row in the sequence.
    last::Int32 Index of the last row in the sequence plus one.
  Returns
    subi::Vector{Int32} Constraint subscripts.
    subj::Vector{Int32} Column subscripts.
    val::Vector{Float64} Values.
"""
function getarowslicetrip end
function getarowslicetrip(task::MSKtask,first::Int32,last::Int32)
  __tmp_61 = Ref{Int64}()
  @MSK_getarowslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_61)
  __tmp_60 = __tmp_61[]
  maxnumnz = Int64(__tmp_60)
  subi_ = Vector{Int32}(undef,maxnumnz)
  subj_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getarowslicetrip(task.task,first-Int32(1),last-Int32(1),maxnumnz,subi_,subj_,val_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  val = val_;
  subi,subj,val
end
function getarowslicetrip(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getarowslicetrip(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getacolslicetrip(task::MSKtask,first::Int32,last::Int32) :: (subi,subj,val)
  getacolslicetrip(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (subi,subj,val)

  Obtains a sequence of columns from the coefficient matrix in triplet format.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 Index of the first column in the sequence.
    last::Int32 Index of the last column in the sequence plus one.
  Returns
    subi::Vector{Int32} Constraint subscripts.
    subj::Vector{Int32} Column subscripts.
    val::Vector{Float64} Values.
"""
function getacolslicetrip end
function getacolslicetrip(task::MSKtask,first::Int32,last::Int32)
  __tmp_64 = Ref{Int64}()
  @MSK_getacolslicenumnz64(task.task,first-Int32(1),last-Int32(1),__tmp_64)
  __tmp_63 = __tmp_64[]
  maxnumnz = Int64(__tmp_63)
  subi_ = Vector{Int32}(undef,maxnumnz)
  subj_ = Vector{Int32}(undef,maxnumnz)
  val_ = Vector{Float64}(undef,maxnumnz)
  @MSK_getacolslicetrip(task.task,first-Int32(1),last-Int32(1),maxnumnz,subi_,subj_,val_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  val = val_;
  subi,subj,val
end
function getacolslicetrip(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getacolslicetrip(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getconbound(task::MSKtask,i::Int32) :: (bk,bl,bu)
  getconbound(task::MSKtask,i::T0) where {T0<:Integer}  :: (bk,bl,bu)

  Obtains bound information for one constraint.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the constraint for which the bound information should be obtained.
  Returns
    bk::Boundkey Bound keys.
    bl::Float64 Values for lower bounds.
    bu::Float64 Values for upper bounds.
"""
function getconbound end
function getconbound(task::MSKtask,i::Int32)
  bk_ = Ref{Int32}()
  bl_ = Ref{Float64}()
  bu_ = Ref{Float64}()
  @MSK_getconbound(task.task,i-Int32(1),bk_,bl_,bu_)
  bk = Boundkey(bk_[])
  bk,bl_[],bu_[]
end
function getconbound(task::MSKtask,i::T0) where { T0<:Integer }
  getconbound(
    task,
    convert(Int32,i))
end


"""
  getvarbound(task::MSKtask,i::Int32) :: (bk,bl,bu)
  getvarbound(task::MSKtask,i::T0) where {T0<:Integer}  :: (bk,bl,bu)

  Obtains bound information for one variable.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the variable for which the bound information should be obtained.
  Returns
    bk::Boundkey Bound keys.
    bl::Float64 Values for lower bounds.
    bu::Float64 Values for upper bounds.
"""
function getvarbound end
function getvarbound(task::MSKtask,i::Int32)
  bk_ = Ref{Int32}()
  bl_ = Ref{Float64}()
  bu_ = Ref{Float64}()
  @MSK_getvarbound(task.task,i-Int32(1),bk_,bl_,bu_)
  bk = Boundkey(bk_[])
  bk,bl_[],bu_[]
end
function getvarbound(task::MSKtask,i::T0) where { T0<:Integer }
  getvarbound(
    task,
    convert(Int32,i))
end


"""
  getconboundslice(task::MSKtask,first::Int32,last::Int32) :: (bk,bl,bu)
  getconboundslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (bk,bl,bu)

  Obtains bounds information for a slice of the constraints.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    bk::Vector{Boundkey} Bound keys.
    bl::Vector{Float64} Values for lower bounds.
    bu::Vector{Float64} Values for upper bounds.
"""
function getconboundslice end
function getconboundslice(task::MSKtask,first::Int32,last::Int32)
  bk_ = Vector{Int32}(undef,(last - first))
  bl_ = Vector{Float64}(undef,(last - first))
  bu_ = Vector{Float64}(undef,(last - first))
  @MSK_getconboundslice(task.task,first-Int32(1),last-Int32(1),bk_,bl_,bu_)
  bk = Boundkey[Boundkey(item) for item in bk_]
  bl = bl_;
  bu = bu_;
  bk,bl,bu
end
function getconboundslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getconboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getvarboundslice(task::MSKtask,first::Int32,last::Int32) :: (bk,bl,bu)
  getvarboundslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: (bk,bl,bu)

  Obtains bounds information for a slice of the variables.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    bk::Vector{Boundkey} Bound keys.
    bl::Vector{Float64} Values for lower bounds.
    bu::Vector{Float64} Values for upper bounds.
"""
function getvarboundslice end
function getvarboundslice(task::MSKtask,first::Int32,last::Int32)
  bk_ = Vector{Int32}(undef,(last - first))
  bl_ = Vector{Float64}(undef,(last - first))
  bu_ = Vector{Float64}(undef,(last - first))
  @MSK_getvarboundslice(task.task,first-Int32(1),last-Int32(1),bk_,bl_,bu_)
  bk = Boundkey[Boundkey(item) for item in bk_]
  bl = bl_;
  bu = bu_;
  bk,bl,bu
end
function getvarboundslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getvarboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getcj(task::MSKtask,j::Int32) :: cj
  getcj(task::MSKtask,j::T0) where {T0<:Integer}  :: cj

  Obtains one objective coefficient.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable for which the c coefficient should be obtained.
  Returns
    cj::Float64 The c coefficient value.
"""
function getcj end
function getcj(task::MSKtask,j::Int32)
  cj_ = Ref{Float64}()
  @MSK_getcj(task.task,j-Int32(1),cj_)
  cj_[]
end
function getcj(task::MSKtask,j::T0) where { T0<:Integer }
  getcj(
    task,
    convert(Int32,j))
end


"""
  getc(task::MSKtask) :: c

  Obtains all objective coefficients.

  Arguments
    task::MSKtask An optimization task.
  Returns
    c::Vector{Float64} Linear terms of the objective as a dense vector. The length is the number of variables.
"""
function getc end
function getc(task::MSKtask)
  __tmp_72 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_72)
  __tmp_71 = __tmp_72[]
  c_ = Vector{Float64}(undef,__tmp_71)
  @MSK_getc(task.task,c_)
  c = c_;
  c
end


"""
  getcfix(task::MSKtask) :: cfix

  Obtains the fixed term in the objective.

  Arguments
    task::MSKtask An optimization task.
  Returns
    cfix::Float64 Fixed term in the objective.
"""
function getcfix end
function getcfix(task::MSKtask)
  cfix_ = Ref{Float64}()
  @MSK_getcfix(task.task,cfix_)
  cfix_[]
end


"""
  getcone(task::MSKtask,k::Int32) :: (ct,conepar,nummem,submem)
  getcone(task::MSKtask,k::T0) where {T0<:Integer}  :: (ct,conepar,nummem,submem)

  Obtains a cone.

  Arguments
    task::MSKtask An optimization task.
    k::Int32 Index of the cone.
  Returns
    ct::Conetype Specifies the type of the cone.
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    nummem::Int32 Number of member variables in the cone.
    submem::Vector{Int32} Variable subscripts of the members in the cone.
"""
function getcone end
function getcone(task::MSKtask,k::Int32)
  ct_ = Ref{Int32}()
  conepar_ = Ref{Float64}()
  nummem_ = Ref{Int32}()
  __tmp_76 = Ref{Int32}()
  @MSK_getconeinfo(task.task,k-Int32(1),Ref{Int32}(),Ref{Float64}(),__tmp_76)
  __tmp_75 = __tmp_76[]
  submem_ = Vector{Int32}(undef,__tmp_75)
  @MSK_getcone(task.task,k-Int32(1),ct_,conepar_,nummem_,submem_)
  ct = Conetype(ct_[])
  submem = submem_;
  submem .+= 1
  ct,conepar_[],nummem_[],submem
end
function getcone(task::MSKtask,k::T0) where { T0<:Integer }
  getcone(
    task,
    convert(Int32,k))
end


"""
  getconeinfo(task::MSKtask,k::Int32) :: (ct,conepar,nummem)
  getconeinfo(task::MSKtask,k::T0) where {T0<:Integer}  :: (ct,conepar,nummem)

  Obtains information about a cone.

  Arguments
    task::MSKtask An optimization task.
    k::Int32 Index of the cone.
  Returns
    ct::Conetype Specifies the type of the cone.
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    nummem::Int32 Number of member variables in the cone.
"""
function getconeinfo end
function getconeinfo(task::MSKtask,k::Int32)
  ct_ = Ref{Int32}()
  conepar_ = Ref{Float64}()
  nummem_ = Ref{Int32}()
  @MSK_getconeinfo(task.task,k-Int32(1),ct_,conepar_,nummem_)
  ct = Conetype(ct_[])
  ct,conepar_[],nummem_[]
end
function getconeinfo(task::MSKtask,k::T0) where { T0<:Integer }
  getconeinfo(
    task,
    convert(Int32,k))
end


"""
  getclist(task::MSKtask,subj::Vector{Int32}) :: c
  getclist(task::MSKtask,subj::T0) where {T0<:AbstractVector{<:Integer}}  :: c

  Obtains a sequence of coefficients from the objective.

  Arguments
    task::MSKtask An optimization task.
    subj::Vector{Int32} A list of variable indexes.
  Returns
    c::Vector{Float64} Linear terms of the requested list of the objective as a dense vector.
"""
function getclist end
function getclist(task::MSKtask,subj::Vector{Int32})
  num = Int32(length(subj))
  subj_ = subj .- Int32(1)
  c_ = Vector{Float64}(undef,num)
  @MSK_getclist(task.task,num,subj_,c_)
  c = c_;
  c
end
function getclist(task::MSKtask,subj::T0) where { T0<:AbstractVector{<:Integer} }
  getclist(
    task,
    convert(Vector{Int32},subj))
end


"""
  getcslice(task::MSKtask,first::Int32,last::Int32) :: c
  getcslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: c

  Obtains a sequence of coefficients from the objective.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    c::Vector{Float64} Linear terms of the requested slice of the objective as a dense vector.
"""
function getcslice end
function getcslice(task::MSKtask,first::Int32,last::Int32)
  c_ = Vector{Float64}(undef,(last - first))
  @MSK_getcslice(task.task,first-Int32(1),last-Int32(1),c_)
  c = c_;
  c
end
function getcslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getcslice(
    task,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getdouinf(task::MSKtask,whichdinf::Dinfitem) :: dvalue

  Obtains a double information item.

  Arguments
    task::MSKtask An optimization task.
    whichdinf::Dinfitem Specifies a double information item.
  Returns
    dvalue::Float64 The value of the required double information item.
"""
function getdouinf end
function getdouinf(task::MSKtask,whichdinf::Dinfitem)
  dvalue_ = Ref{Float64}()
  @MSK_getdouinf(task.task,whichdinf.value,dvalue_)
  dvalue_[]
end


"""
  getdouparam(task::MSKtask,param::Dparam) :: parvalue

  Obtains a double parameter.

  Arguments
    task::MSKtask An optimization task.
    param::Dparam Which parameter.
  Returns
    parvalue::Float64 Parameter value.
"""
function getdouparam end
function getdouparam(task::MSKtask,param::Dparam)
  parvalue_ = Ref{Float64}()
  @MSK_getdouparam(task.task,param.value,parvalue_)
  parvalue_[]
end


"""
  getdualobj(task::MSKtask,whichsol::Soltype) :: dualobj

  Computes the dual objective value associated with the solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    dualobj::Float64 Objective value corresponding to the dual solution.
"""
function getdualobj end
function getdualobj(task::MSKtask,whichsol::Soltype)
  dualobj_ = Ref{Float64}()
  @MSK_getdualobj(task.task,whichsol.value,dualobj_)
  dualobj_[]
end


"""
  getinfname(task::MSKtask,inftype::Inftype,whichinf::Int32) :: infname
  getinfname(task::MSKtask,inftype::Inftype,whichinf::T0) where {T0<:Integer}  :: infname

  Obtains the name of an information item.

  Arguments
    task::MSKtask An optimization task.
    inftype::Inftype Type of the information item.
    whichinf::Int32 An information item.
  Returns
    infname::String Name of the information item.
"""
function getinfname end
function getinfname(task::MSKtask,inftype::Inftype,whichinf::Int32)
  infname_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_getinfname(task.task,inftype.value,whichinf,infname_)
  infname_len = findfirst(_c->_c==0,infname_)
  infname = if infname_len === nothing
    String(infname_)
  else
    String(infname_[1:infname_len-1])
  end
  infname
end
function getinfname(task::MSKtask,inftype::Inftype,whichinf::T0) where { T0<:Integer }
  getinfname(
    task,
    inftype,
    convert(Int32,whichinf))
end


"""
  getintinf(task::MSKtask,whichiinf::Iinfitem) :: ivalue

  Obtains an integer information item.

  Arguments
    task::MSKtask An optimization task.
    whichiinf::Iinfitem Specifies an integer information item.
  Returns
    ivalue::Int32 The value of the required integer information item.
"""
function getintinf end
function getintinf(task::MSKtask,whichiinf::Iinfitem)
  ivalue_ = Ref{Int32}()
  @MSK_getintinf(task.task,whichiinf.value,ivalue_)
  ivalue_[]
end


"""
  getlintinf(task::MSKtask,whichliinf::Liinfitem) :: ivalue

  Obtains a long integer information item.

  Arguments
    task::MSKtask An optimization task.
    whichliinf::Liinfitem Specifies a long information item.
  Returns
    ivalue::Int64 The value of the required long integer information item.
"""
function getlintinf end
function getlintinf(task::MSKtask,whichliinf::Liinfitem)
  ivalue_ = Ref{Int64}()
  @MSK_getlintinf(task.task,whichliinf.value,ivalue_)
  ivalue_[]
end


"""
  getintparam(task::MSKtask,param::Iparam) :: parvalue

  Obtains an integer parameter.

  Arguments
    task::MSKtask An optimization task.
    param::Iparam Which parameter.
  Returns
    parvalue::Int32 Parameter value.
"""
function getintparam end
function getintparam(task::MSKtask,param::Iparam)
  parvalue_ = Ref{Int32}()
  @MSK_getintparam(task.task,param.value,parvalue_)
  parvalue_[]
end


"""
  getmaxnumanz(task::MSKtask) :: maxnumanz

  Obtains number of preallocated non-zeros in the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
  Returns
    maxnumanz::Int64 Number of preallocated non-zero linear matrix elements.
"""
function getmaxnumanz end
function getmaxnumanz(task::MSKtask)
  maxnumanz_ = Ref{Int64}()
  @MSK_getmaxnumanz64(task.task,maxnumanz_)
  maxnumanz_[]
end


"""
  getmaxnumcon(task::MSKtask) :: maxnumcon

  Obtains the number of preallocated constraints in the optimization task.

  Arguments
    task::MSKtask An optimization task.
  Returns
    maxnumcon::Int32 Number of preallocated constraints in the optimization task.
"""
function getmaxnumcon end
function getmaxnumcon(task::MSKtask)
  maxnumcon_ = Ref{Int32}()
  @MSK_getmaxnumcon(task.task,maxnumcon_)
  maxnumcon_[]
end


"""
  getmaxnumvar(task::MSKtask) :: maxnumvar

  Obtains the maximum number variables allowed.

  Arguments
    task::MSKtask An optimization task.
  Returns
    maxnumvar::Int32 Number of preallocated variables in the optimization task.
"""
function getmaxnumvar end
function getmaxnumvar(task::MSKtask)
  maxnumvar_ = Ref{Int32}()
  @MSK_getmaxnumvar(task.task,maxnumvar_)
  maxnumvar_[]
end


"""
  getnadouinf(task::MSKtask,infitemname::AbstractString) :: dvalue

  Obtains a named double information item.

  Arguments
    task::MSKtask An optimization task.
    infitemname::AbstractString The name of a double information item.
  Returns
    dvalue::Float64 The value of the required double information item.
"""
function getnadouinf end
function getnadouinf(task::MSKtask,infitemname::AbstractString)
  infitemname_ = Vector{UInt8}(infitemname); push!(infitemname_,UInt8(0))
  dvalue_ = Ref{Float64}()
  @MSK_getnadouinf(task.task,infitemname_,dvalue_)
  dvalue_[]
end


"""
  getnadouparam(task::MSKtask,paramname::AbstractString) :: parvalue

  Obtains a double parameter.

  Arguments
    task::MSKtask An optimization task.
    paramname::AbstractString Name of a parameter.
  Returns
    parvalue::Float64 Parameter value.
"""
function getnadouparam end
function getnadouparam(task::MSKtask,paramname::AbstractString)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  parvalue_ = Ref{Float64}()
  @MSK_getnadouparam(task.task,paramname_,parvalue_)
  parvalue_[]
end


"""
  getnaintinf(task::MSKtask,infitemname::AbstractString) :: ivalue

  Obtains a named integer information item.

  Arguments
    task::MSKtask An optimization task.
    infitemname::AbstractString The name of an integer information item.
  Returns
    ivalue::Int32 The value of the required integer information item.
"""
function getnaintinf end
function getnaintinf(task::MSKtask,infitemname::AbstractString)
  infitemname_ = Vector{UInt8}(infitemname); push!(infitemname_,UInt8(0))
  ivalue_ = Ref{Int32}()
  @MSK_getnaintinf(task.task,infitemname_,ivalue_)
  ivalue_[]
end


"""
  getnaintparam(task::MSKtask,paramname::AbstractString) :: parvalue

  Obtains an integer parameter.

  Arguments
    task::MSKtask An optimization task.
    paramname::AbstractString Name of a parameter.
  Returns
    parvalue::Int32 Parameter value.
"""
function getnaintparam end
function getnaintparam(task::MSKtask,paramname::AbstractString)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  parvalue_ = Ref{Int32}()
  @MSK_getnaintparam(task.task,paramname_,parvalue_)
  parvalue_[]
end


"""
  getbarvarnamelen(task::MSKtask,i::Int32) :: len
  getbarvarnamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

  Obtains the length of the name of a semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the variable.
  Returns
    len::Int32 Returns the length of the indicated name.
"""
function getbarvarnamelen end
function getbarvarnamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getbarvarnamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getbarvarnamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getbarvarnamelen(
    task,
    convert(Int32,i))
end


"""
  getbarvarname(task::MSKtask,i::Int32) :: name
  getbarvarname(task::MSKtask,i::T0) where {T0<:Integer}  :: name

  Obtains the name of a semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the variable.
  Returns
    name::String The requested name is copied to this buffer.
"""
function getbarvarname end
function getbarvarname(task::MSKtask,i::Int32)
  __tmp_97 = Ref{Int32}()
  @MSK_getbarvarnamelen(task.task,i-Int32(1),__tmp_97)
  __tmp_96 = __tmp_97[]
  sizename = Int32((1 + __tmp_96))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getbarvarname(task.task,i-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getbarvarname(task::MSKtask,i::T0) where { T0<:Integer }
  getbarvarname(
    task,
    convert(Int32,i))
end


"""
  getbarvarnameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

  Obtains the index of semidefinite variable from its name.

  Arguments
    task::MSKtask An optimization task.
    somename::AbstractString The name of the variable.
  Returns
    asgn::Int32 Non-zero if the name somename is assigned to some semidefinite variable.
    index::Int32 The index of a semidefinite variable with the name somename (if one exists).
"""
function getbarvarnameindex end
function getbarvarnameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getbarvarnameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]
end


"""
  putconname(task::MSKtask,i::Int32,name::AbstractString)
  putconname(task::MSKtask,i::T0,name::AbstractString) where {T0<:Integer} 

  Sets the name of a constraint.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the constraint.
    name::AbstractString The name of the constraint.
"""
function putconname end
function putconname(task::MSKtask,i::Int32,name::AbstractString)
  name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  @MSK_putconname(task.task,i-Int32(1),name_)
  nothing
end
function putconname(task::MSKtask,i::T0,name::AbstractString) where { T0<:Integer }
  putconname(
    task,
    convert(Int32,i),
    name)
end


"""
  putvarname(task::MSKtask,j::Int32,name::AbstractString)
  putvarname(task::MSKtask,j::T0,name::AbstractString) where {T0<:Integer} 

  Sets the name of a variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable.
    name::AbstractString The variable name.
"""
function putvarname end
function putvarname(task::MSKtask,j::Int32,name::AbstractString)
  name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  @MSK_putvarname(task.task,j-Int32(1),name_)
  nothing
end
function putvarname(task::MSKtask,j::T0,name::AbstractString) where { T0<:Integer }
  putvarname(
    task,
    convert(Int32,j),
    name)
end


"""
  putconename(task::MSKtask,j::Int32,name::AbstractString)
  putconename(task::MSKtask,j::T0,name::AbstractString) where {T0<:Integer} 

  Sets the name of a cone.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the cone.
    name::AbstractString The name of the cone.
"""
function putconename end
function putconename(task::MSKtask,j::Int32,name::AbstractString)
  name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  @MSK_putconename(task.task,j-Int32(1),name_)
  nothing
end
function putconename(task::MSKtask,j::T0,name::AbstractString) where { T0<:Integer }
  putconename(
    task,
    convert(Int32,j),
    name)
end


"""
  putbarvarname(task::MSKtask,j::Int32,name::AbstractString)
  putbarvarname(task::MSKtask,j::T0,name::AbstractString) where {T0<:Integer} 

  Sets the name of a semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable.
    name::AbstractString The variable name.
"""
function putbarvarname end
function putbarvarname(task::MSKtask,j::Int32,name::AbstractString)
  name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  @MSK_putbarvarname(task.task,j-Int32(1),name_)
  nothing
end
function putbarvarname(task::MSKtask,j::T0,name::AbstractString) where { T0<:Integer }
  putbarvarname(
    task,
    convert(Int32,j),
    name)
end


"""
  putdomainname(task::MSKtask,domidx::Int64,name::AbstractString)
  putdomainname(task::MSKtask,domidx::T0,name::AbstractString) where {T0<:Integer} 

  Sets the name of a domain.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Index of the domain.
    name::AbstractString The name of the domain.
"""
function putdomainname end
function putdomainname(task::MSKtask,domidx::Int64,name::AbstractString)
  name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  @MSK_putdomainname(task.task,domidx-Int64(1),name_)
  nothing
end
function putdomainname(task::MSKtask,domidx::T0,name::AbstractString) where { T0<:Integer }
  putdomainname(
    task,
    convert(Int64,domidx),
    name)
end


"""
  putdjcname(task::MSKtask,djcidx::Int64,name::AbstractString)
  putdjcname(task::MSKtask,djcidx::T0,name::AbstractString) where {T0<:Integer} 

  Sets the name of a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
    name::AbstractString The name of the disjunctive constraint.
"""
function putdjcname end
function putdjcname(task::MSKtask,djcidx::Int64,name::AbstractString)
  name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  @MSK_putdjcname(task.task,djcidx-Int64(1),name_)
  nothing
end
function putdjcname(task::MSKtask,djcidx::T0,name::AbstractString) where { T0<:Integer }
  putdjcname(
    task,
    convert(Int64,djcidx),
    name)
end


"""
  putaccname(task::MSKtask,accidx::Int64,name::AbstractString)
  putaccname(task::MSKtask,accidx::T0,name::AbstractString) where {T0<:Integer} 

  Sets the name of an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Index of the affine conic constraint.
    name::AbstractString The name of the affine conic constraint.
"""
function putaccname end
function putaccname(task::MSKtask,accidx::Int64,name::AbstractString)
  name_ = Vector{UInt8}(name); push!(name_,UInt8(0))
  @MSK_putaccname(task.task,accidx-Int64(1),name_)
  nothing
end
function putaccname(task::MSKtask,accidx::T0,name::AbstractString) where { T0<:Integer }
  putaccname(
    task,
    convert(Int64,accidx),
    name)
end


"""
  getvarnamelen(task::MSKtask,i::Int32) :: len
  getvarnamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

  Obtains the length of the name of a variable.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of a variable.
  Returns
    len::Int32 Returns the length of the indicated name.
"""
function getvarnamelen end
function getvarnamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getvarnamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getvarnamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getvarnamelen(
    task,
    convert(Int32,i))
end


"""
  getvarname(task::MSKtask,j::Int32) :: name
  getvarname(task::MSKtask,j::T0) where {T0<:Integer}  :: name

  Obtains the name of a variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of a variable.
  Returns
    name::String Returns the required name.
"""
function getvarname end
function getvarname(task::MSKtask,j::Int32)
  __tmp_109 = Ref{Int32}()
  @MSK_getvarnamelen(task.task,j-Int32(1),__tmp_109)
  __tmp_108 = __tmp_109[]
  sizename = Int32((1 + __tmp_108))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getvarname(task.task,j-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getvarname(task::MSKtask,j::T0) where { T0<:Integer }
  getvarname(
    task,
    convert(Int32,j))
end


"""
  getconnamelen(task::MSKtask,i::Int32) :: len
  getconnamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

  Obtains the length of the name of a constraint.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the constraint.
  Returns
    len::Int32 Returns the length of the indicated name.
"""
function getconnamelen end
function getconnamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getconnamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getconnamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getconnamelen(
    task,
    convert(Int32,i))
end


"""
  getconname(task::MSKtask,i::Int32) :: name
  getconname(task::MSKtask,i::T0) where {T0<:Integer}  :: name

  Obtains the name of a constraint.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the constraint.
  Returns
    name::String The required name.
"""
function getconname end
function getconname(task::MSKtask,i::Int32)
  __tmp_113 = Ref{Int32}()
  @MSK_getconnamelen(task.task,i-Int32(1),__tmp_113)
  __tmp_112 = __tmp_113[]
  sizename = Int32((1 + __tmp_112))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getconname(task.task,i-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getconname(task::MSKtask,i::T0) where { T0<:Integer }
  getconname(
    task,
    convert(Int32,i))
end


"""
  getconnameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

  Checks whether the name has been assigned to any constraint.

  Arguments
    task::MSKtask An optimization task.
    somename::AbstractString The name which should be checked.
  Returns
    asgn::Int32 Is non-zero if the name somename is assigned to some constraint.
    index::Int32 If the name somename is assigned to a constraint, then return the index of the constraint.
"""
function getconnameindex end
function getconnameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getconnameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]+Int32(1)
end


"""
  getvarnameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

  Checks whether the name has been assigned to any variable.

  Arguments
    task::MSKtask An optimization task.
    somename::AbstractString The name which should be checked.
  Returns
    asgn::Int32 Is non-zero if the name somename is assigned to a variable.
    index::Int32 If the name somename is assigned to a variable, then return the index of the variable.
"""
function getvarnameindex end
function getvarnameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getvarnameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]+Int32(1)
end


"""
  getconenamelen(task::MSKtask,i::Int32) :: len
  getconenamelen(task::MSKtask,i::T0) where {T0<:Integer}  :: len

  Obtains the length of the name of a cone.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the cone.
  Returns
    len::Int32 Returns the length of the indicated name.
"""
function getconenamelen end
function getconenamelen(task::MSKtask,i::Int32)
  len_ = Ref{Int32}()
  @MSK_getconenamelen(task.task,i-Int32(1),len_)
  len_[]
end
function getconenamelen(task::MSKtask,i::T0) where { T0<:Integer }
  getconenamelen(
    task,
    convert(Int32,i))
end


"""
  getconename(task::MSKtask,i::Int32) :: name
  getconename(task::MSKtask,i::T0) where {T0<:Integer}  :: name

  Obtains the name of a cone.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the cone.
  Returns
    name::String The required name.
"""
function getconename end
function getconename(task::MSKtask,i::Int32)
  __tmp_119 = Ref{Int32}()
  @MSK_getconenamelen(task.task,i-Int32(1),__tmp_119)
  __tmp_118 = __tmp_119[]
  sizename = Int32((1 + __tmp_118))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getconename(task.task,i-Int32(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getconename(task::MSKtask,i::T0) where { T0<:Integer }
  getconename(
    task,
    convert(Int32,i))
end


"""
  getconenameindex(task::MSKtask,somename::AbstractString) :: (asgn,index)

  Checks whether the name has been assigned to any cone.

  Arguments
    task::MSKtask An optimization task.
    somename::AbstractString The name which should be checked.
  Returns
    asgn::Int32 Is non-zero if the name somename is assigned to some cone.
    index::Int32 If the name somename is assigned to some cone, this is the index of the cone.
"""
function getconenameindex end
function getconenameindex(task::MSKtask,somename::AbstractString)
  somename_ = Vector{UInt8}(somename); push!(somename_,UInt8(0))
  asgn_ = Ref{Int32}()
  index_ = Ref{Int32}()
  @MSK_getconenameindex(task.task,somename_,asgn_,index_)
  asgn_[],index_[]
end


"""
  getdomainnamelen(task::MSKtask,domidx::Int64) :: len
  getdomainnamelen(task::MSKtask,domidx::T0) where {T0<:Integer}  :: len

  Obtains the length of the name of a domain.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Index of a domain.
  Returns
    len::Int32 Returns the length of the indicated name.
"""
function getdomainnamelen end
function getdomainnamelen(task::MSKtask,domidx::Int64)
  len_ = Ref{Int32}()
  @MSK_getdomainnamelen(task.task,domidx-Int64(1),len_)
  len_[]
end
function getdomainnamelen(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomainnamelen(
    task,
    convert(Int64,domidx))
end


"""
  getdomainname(task::MSKtask,domidx::Int64) :: name
  getdomainname(task::MSKtask,domidx::T0) where {T0<:Integer}  :: name

  Obtains the name of a domain.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Index of a domain.
  Returns
    name::String Returns the required name.
"""
function getdomainname end
function getdomainname(task::MSKtask,domidx::Int64)
  __tmp_124 = Ref{Int32}()
  @MSK_getdomainnamelen(task.task,domidx-Int64(1),__tmp_124)
  __tmp_123 = __tmp_124[]
  sizename = Int32((1 + __tmp_123))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getdomainname(task.task,domidx-Int64(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getdomainname(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomainname(
    task,
    convert(Int64,domidx))
end


"""
  getdjcnamelen(task::MSKtask,djcidx::Int64) :: len
  getdjcnamelen(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: len

  Obtains the length of the name of a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of a disjunctive constraint.
  Returns
    len::Int32 Returns the length of the indicated name.
"""
function getdjcnamelen end
function getdjcnamelen(task::MSKtask,djcidx::Int64)
  len_ = Ref{Int32}()
  @MSK_getdjcnamelen(task.task,djcidx-Int64(1),len_)
  len_[]
end
function getdjcnamelen(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnamelen(
    task,
    convert(Int64,djcidx))
end


"""
  getdjcname(task::MSKtask,djcidx::Int64) :: name
  getdjcname(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: name

  Obtains the name of a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of a disjunctive constraint.
  Returns
    name::String Returns the required name.
"""
function getdjcname end
function getdjcname(task::MSKtask,djcidx::Int64)
  __tmp_128 = Ref{Int32}()
  @MSK_getdjcnamelen(task.task,djcidx-Int64(1),__tmp_128)
  __tmp_127 = __tmp_128[]
  sizename = Int32((1 + __tmp_127))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getdjcname(task.task,djcidx-Int64(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getdjcname(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcname(
    task,
    convert(Int64,djcidx))
end


"""
  getaccnamelen(task::MSKtask,accidx::Int64) :: len
  getaccnamelen(task::MSKtask,accidx::T0) where {T0<:Integer}  :: len

  Obtains the length of the name of an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Index of an affine conic constraint.
  Returns
    len::Int32 Returns the length of the indicated name.
"""
function getaccnamelen end
function getaccnamelen(task::MSKtask,accidx::Int64)
  len_ = Ref{Int32}()
  @MSK_getaccnamelen(task.task,accidx-Int64(1),len_)
  len_[]
end
function getaccnamelen(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccnamelen(
    task,
    convert(Int64,accidx))
end


"""
  getaccname(task::MSKtask,accidx::Int64) :: name
  getaccname(task::MSKtask,accidx::T0) where {T0<:Integer}  :: name

  Obtains the name of an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Index of an affine conic constraint.
  Returns
    name::String Returns the required name.
"""
function getaccname end
function getaccname(task::MSKtask,accidx::Int64)
  __tmp_132 = Ref{Int32}()
  @MSK_getaccnamelen(task.task,accidx-Int64(1),__tmp_132)
  __tmp_131 = __tmp_132[]
  sizename = Int32((1 + __tmp_131))
  name_ = Array{UInt8}(undef,sizename)
  @MSK_getaccname(task.task,accidx-Int64(1),sizename,name_)
  name_len = findfirst(_c->_c==0,name_)
  name = if name_len === nothing
    String(name_)
  else
    String(name_[1:name_len-1])
  end
  name
end
function getaccname(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccname(
    task,
    convert(Int64,accidx))
end


"""
  getnastrparam(task::MSKtask,paramname::AbstractString,sizeparamname::Int32) :: (len,parvalue)
  getnastrparam(task::MSKtask,paramname::AbstractString,sizeparamname::T0) where {T0<:Integer}  :: (len,parvalue)

  Obtains a string parameter.

  Arguments
    task::MSKtask An optimization task.
    paramname::AbstractString Name of a parameter.
    sizeparamname::Int32 Size of the name buffer.
  Returns
    len::Int32 Returns the length of the parameter value.
    parvalue::String Parameter value.
"""
function getnastrparam end
function getnastrparam(task::MSKtask,paramname::AbstractString,sizeparamname::Int32)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  len_ = Ref{Int32}()
  parvalue_ = Array{UInt8}(undef,sizeparamname)
  @MSK_getnastrparam(task.task,paramname_,sizeparamname,len_,parvalue_)
  parvalue_len = findfirst(_c->_c==0,parvalue_)
  parvalue = if parvalue_len === nothing
    String(parvalue_)
  else
    String(parvalue_[1:parvalue_len-1])
  end
  len_[],parvalue
end
function getnastrparam(task::MSKtask,paramname::AbstractString,sizeparamname::T0) where { T0<:Integer }
  getnastrparam(
    task,
    paramname,
    convert(Int32,sizeparamname))
end


"""
  getnumanz(task::MSKtask) :: numanz

  Obtains the number of non-zeros in the coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numanz::Int32 Number of non-zero elements in the linear constraint matrix.
"""
function getnumanz end
function getnumanz(task::MSKtask)
  numanz_ = Ref{Int32}()
  @MSK_getnumanz(task.task,numanz_)
  numanz_[]
end


"""
  getnumanz64(task::MSKtask) :: numanz

  Obtains the number of non-zeros in the coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numanz::Int64 Number of non-zero elements in the linear constraint matrix.
"""
function getnumanz64 end
function getnumanz64(task::MSKtask)
  numanz_ = Ref{Int64}()
  @MSK_getnumanz64(task.task,numanz_)
  numanz_[]
end


"""
  getnumcon(task::MSKtask) :: numcon

  Obtains the number of constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numcon::Int32 Number of constraints.
"""
function getnumcon end
function getnumcon(task::MSKtask)
  numcon_ = Ref{Int32}()
  @MSK_getnumcon(task.task,numcon_)
  numcon_[]
end


"""
  getnumcone(task::MSKtask) :: numcone

  Obtains the number of cones.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numcone::Int32 Number of conic constraints.
"""
function getnumcone end
function getnumcone(task::MSKtask)
  numcone_ = Ref{Int32}()
  @MSK_getnumcone(task.task,numcone_)
  numcone_[]
end


"""
  getnumconemem(task::MSKtask,k::Int32) :: nummem
  getnumconemem(task::MSKtask,k::T0) where {T0<:Integer}  :: nummem

  Obtains the number of members in a cone.

  Arguments
    task::MSKtask An optimization task.
    k::Int32 Index of the cone.
  Returns
    nummem::Int32 Number of member variables in the cone.
"""
function getnumconemem end
function getnumconemem(task::MSKtask,k::Int32)
  nummem_ = Ref{Int32}()
  @MSK_getnumconemem(task.task,k-Int32(1),nummem_)
  nummem_[]
end
function getnumconemem(task::MSKtask,k::T0) where { T0<:Integer }
  getnumconemem(
    task,
    convert(Int32,k))
end


"""
  getnumintvar(task::MSKtask) :: numintvar

  Obtains the number of integer-constrained variables.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numintvar::Int32 Number of integer variables.
"""
function getnumintvar end
function getnumintvar(task::MSKtask)
  numintvar_ = Ref{Int32}()
  @MSK_getnumintvar(task.task,numintvar_)
  numintvar_[]
end


"""
  getnumparam(task::MSKtask,partype::Parametertype) :: numparam

  Obtains the number of parameters of a given type.

  Arguments
    task::MSKtask An optimization task.
    partype::Parametertype Parameter type.
  Returns
    numparam::Int32 Returns the number of parameters of the requested type.
"""
function getnumparam end
function getnumparam(task::MSKtask,partype::Parametertype)
  numparam_ = Ref{Int32}()
  @MSK_getnumparam(task.task,partype.value,numparam_)
  numparam_[]
end


"""
  getnumqconknz(task::MSKtask,k::Int32) :: numqcnz
  getnumqconknz(task::MSKtask,k::T0) where {T0<:Integer}  :: numqcnz

  Obtains the number of non-zero quadratic terms in a constraint.

  Arguments
    task::MSKtask An optimization task.
    k::Int32 Index of the constraint for which the number quadratic terms should be obtained.
  Returns
    numqcnz::Int64 Number of quadratic terms.
"""
function getnumqconknz end
function getnumqconknz(task::MSKtask,k::Int32)
  numqcnz_ = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),numqcnz_)
  numqcnz_[]
end
function getnumqconknz(task::MSKtask,k::T0) where { T0<:Integer }
  getnumqconknz(
    task,
    convert(Int32,k))
end


"""
  getnumqobjnz(task::MSKtask) :: numqonz

  Obtains the number of non-zero quadratic terms in the objective.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numqonz::Int64 Number of non-zero elements in the quadratic objective terms.
"""
function getnumqobjnz end
function getnumqobjnz(task::MSKtask)
  numqonz_ = Ref{Int64}()
  @MSK_getnumqobjnz64(task.task,numqonz_)
  numqonz_[]
end


"""
  getnumvar(task::MSKtask) :: numvar

  Obtains the number of variables.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numvar::Int32 Number of variables.
"""
function getnumvar end
function getnumvar(task::MSKtask)
  numvar_ = Ref{Int32}()
  @MSK_getnumvar(task.task,numvar_)
  numvar_[]
end


"""
  getnumbarvar(task::MSKtask) :: numbarvar

  Obtains the number of semidefinite variables.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numbarvar::Int32 Number of semidefinite variables in the problem.
"""
function getnumbarvar end
function getnumbarvar(task::MSKtask)
  numbarvar_ = Ref{Int32}()
  @MSK_getnumbarvar(task.task,numbarvar_)
  numbarvar_[]
end


"""
  getmaxnumbarvar(task::MSKtask) :: maxnumbarvar

  Obtains maximum number of symmetric matrix variables for which space is currently preallocated.

  Arguments
    task::MSKtask An optimization task.
  Returns
    maxnumbarvar::Int32 Maximum number of symmetric matrix variables for which space is currently preallocated.
"""
function getmaxnumbarvar end
function getmaxnumbarvar(task::MSKtask)
  maxnumbarvar_ = Ref{Int32}()
  @MSK_getmaxnumbarvar(task.task,maxnumbarvar_)
  maxnumbarvar_[]
end


"""
  getdimbarvarj(task::MSKtask,j::Int32) :: dimbarvarj
  getdimbarvarj(task::MSKtask,j::T0) where {T0<:Integer}  :: dimbarvarj

  Obtains the dimension of a symmetric matrix variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the semidefinite variable whose dimension is requested.
  Returns
    dimbarvarj::Int32 The dimension of the j'th semidefinite variable.
"""
function getdimbarvarj end
function getdimbarvarj(task::MSKtask,j::Int32)
  dimbarvarj_ = Ref{Int32}()
  @MSK_getdimbarvarj(task.task,j-Int32(1),dimbarvarj_)
  dimbarvarj_[]
end
function getdimbarvarj(task::MSKtask,j::T0) where { T0<:Integer }
  getdimbarvarj(
    task,
    convert(Int32,j))
end


"""
  getlenbarvarj(task::MSKtask,j::Int32) :: lenbarvarj
  getlenbarvarj(task::MSKtask,j::T0) where {T0<:Integer}  :: lenbarvarj

  Obtains the length of one semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the semidefinite variable whose length if requested.
  Returns
    lenbarvarj::Int64 Number of scalar elements in the lower triangular part of the semidefinite variable.
"""
function getlenbarvarj end
function getlenbarvarj(task::MSKtask,j::Int32)
  lenbarvarj_ = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),lenbarvarj_)
  lenbarvarj_[]
end
function getlenbarvarj(task::MSKtask,j::T0) where { T0<:Integer }
  getlenbarvarj(
    task,
    convert(Int32,j))
end


"""
  getobjname(task::MSKtask) :: objname

  Obtains the name assigned to the objective function.

  Arguments
    task::MSKtask An optimization task.
  Returns
    objname::String Assigned the objective name.
"""
function getobjname end
function getobjname(task::MSKtask)
  __tmp_150 = Ref{Int32}()
  @MSK_getobjnamelen(task.task,__tmp_150)
  __tmp_149 = __tmp_150[]
  sizeobjname = Int32((1 + __tmp_149))
  objname_ = Array{UInt8}(undef,sizeobjname)
  @MSK_getobjname(task.task,sizeobjname,objname_)
  objname_len = findfirst(_c->_c==0,objname_)
  objname = if objname_len === nothing
    String(objname_)
  else
    String(objname_[1:objname_len-1])
  end
  objname
end


"""
  getobjnamelen(task::MSKtask) :: len

  Obtains the length of the name assigned to the objective function.

  Arguments
    task::MSKtask An optimization task.
  Returns
    len::Int32 Assigned the length of the objective name.
"""
function getobjnamelen end
function getobjnamelen(task::MSKtask)
  len_ = Ref{Int32}()
  @MSK_getobjnamelen(task.task,len_)
  len_[]
end


"""
  getparamname(task::MSKtask,partype::Parametertype,param::Int32) :: parname
  getparamname(task::MSKtask,partype::Parametertype,param::T0) where {T0<:Integer}  :: parname

  Obtains the name of a parameter.

  Arguments
    task::MSKtask An optimization task.
    partype::Parametertype Parameter type.
    param::Int32 Which parameter.
  Returns
    parname::String Parameter name.
"""
function getparamname end
function getparamname(task::MSKtask,partype::Parametertype,param::Int32)
  parname_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_getparamname(task.task,partype.value,param,parname_)
  parname_len = findfirst(_c->_c==0,parname_)
  parname = if parname_len === nothing
    String(parname_)
  else
    String(parname_[1:parname_len-1])
  end
  parname
end
function getparamname(task::MSKtask,partype::Parametertype,param::T0) where { T0<:Integer }
  getparamname(
    task,
    partype,
    convert(Int32,param))
end


"""
  getprimalobj(task::MSKtask,whichsol::Soltype) :: primalobj

  Computes the primal objective value for the desired solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    primalobj::Float64 Objective value corresponding to the primal solution.
"""
function getprimalobj end
function getprimalobj(task::MSKtask,whichsol::Soltype)
  primalobj_ = Ref{Float64}()
  @MSK_getprimalobj(task.task,whichsol.value,primalobj_)
  primalobj_[]
end


"""
  getprobtype(task::MSKtask) :: probtype

  Obtains the problem type.

  Arguments
    task::MSKtask An optimization task.
  Returns
    probtype::Problemtype The problem type.
"""
function getprobtype end
function getprobtype(task::MSKtask)
  probtype_ = Ref{Int32}()
  @MSK_getprobtype(task.task,probtype_)
  probtype = Problemtype(probtype_[])
  probtype
end


"""
  getqconk(task::MSKtask,k::Int32) :: (numqcnz,qcsubi,qcsubj,qcval)
  getqconk(task::MSKtask,k::T0) where {T0<:Integer}  :: (numqcnz,qcsubi,qcsubj,qcval)

  Obtains all the quadratic terms in a constraint.

  Arguments
    task::MSKtask An optimization task.
    k::Int32 Which constraint.
  Returns
    numqcnz::Int64 Number of quadratic terms.
    qcsubi::Vector{Int32} Row subscripts for quadratic constraint matrix.
    qcsubj::Vector{Int32} Column subscripts for quadratic constraint matrix.
    qcval::Vector{Float64} Quadratic constraint coefficient values.
"""
function getqconk end
function getqconk(task::MSKtask,k::Int32)
  __tmp_157 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_157)
  __tmp_156 = __tmp_157[]
  maxnumqcnz = Int64(__tmp_156)
  numqcnz_ = Ref{Int64}()
  __tmp_159 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_159)
  __tmp_158 = __tmp_159[]
  qcsubi_ = Vector{Int32}(undef,__tmp_158)
  __tmp_161 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_161)
  __tmp_160 = __tmp_161[]
  qcsubj_ = Vector{Int32}(undef,__tmp_160)
  __tmp_163 = Ref{Int64}()
  @MSK_getnumqconknz64(task.task,k-Int32(1),__tmp_163)
  __tmp_162 = __tmp_163[]
  qcval_ = Vector{Float64}(undef,__tmp_162)
  @MSK_getqconk64(task.task,k-Int32(1),maxnumqcnz,numqcnz_,qcsubi_,qcsubj_,qcval_)
  qcsubi = qcsubi_;
  qcsubi .+= 1
  qcsubj = qcsubj_;
  qcsubj .+= 1
  qcval = qcval_;
  numqcnz_[],qcsubi,qcsubj,qcval
end
function getqconk(task::MSKtask,k::T0) where { T0<:Integer }
  getqconk(
    task,
    convert(Int32,k))
end


"""
  getqobj(task::MSKtask) :: (numqonz,qosubi,qosubj,qoval)

  Obtains all the quadratic terms in the objective.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numqonz::Int64 Number of non-zero elements in the quadratic objective terms.
    qosubi::Vector{Int32} Row subscripts for quadratic objective coefficients.
    qosubj::Vector{Int32} Column subscripts for quadratic objective coefficients.
    qoval::Vector{Float64} Quadratic objective coefficient values.
"""
function getqobj end
function getqobj(task::MSKtask)
  __tmp_170 = Ref{Int64}()
  @MSK_getnumqobjnz64(task.task,__tmp_170)
  __tmp_169 = __tmp_170[]
  maxnumqonz = Int64(__tmp_169)
  numqonz_ = Ref{Int64}()
  qosubi_ = Vector{Int32}(undef,maxnumqonz)
  qosubj_ = Vector{Int32}(undef,maxnumqonz)
  qoval_ = Vector{Float64}(undef,maxnumqonz)
  @MSK_getqobj64(task.task,maxnumqonz,numqonz_,qosubi_,qosubj_,qoval_)
  qosubi = qosubi_;
  qosubi .+= 1
  qosubj = qosubj_;
  qosubj .+= 1
  qoval = qoval_;
  numqonz_[],qosubi,qosubj,qoval
end


"""
  getqobjij(task::MSKtask,i::Int32,j::Int32) :: qoij
  getqobjij(task::MSKtask,i::T0,j::T1) where {T0<:Integer,T1<:Integer}  :: qoij

  Obtains one coefficient from the quadratic term of the objective

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Row index of the coefficient.
    j::Int32 Column index of coefficient.
  Returns
    qoij::Float64 The required coefficient.
"""
function getqobjij end
function getqobjij(task::MSKtask,i::Int32,j::Int32)
  qoij_ = Ref{Float64}()
  @MSK_getqobjij(task.task,i-Int32(1),j-Int32(1),qoij_)
  qoij_[]
end
function getqobjij(task::MSKtask,i::T0,j::T1) where { T0<:Integer,T1<:Integer }
  getqobjij(
    task,
    convert(Int32,i),
    convert(Int32,j))
end


"""
  getsolution(task::MSKtask,whichsol::Soltype) :: (problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)

  Obtains the complete solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    problemsta::Prosta Problem status.
    solutionsta::Solsta Solution status.
    skc::Vector{Stakey} Status keys for the constraints.
    skx::Vector{Stakey} Status keys for the variables.
    skn::Vector{Stakey} Status keys for the conic constraints.
    xc::Vector{Float64} Primal constraint solution.
    xx::Vector{Float64} Primal variable solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
"""
function getsolution end
function getsolution(task::MSKtask,whichsol::Soltype)
  problemsta_ = Ref{Int32}()
  solutionsta_ = Ref{Int32}()
  __tmp_174 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_174)
  __tmp_173 = __tmp_174[]
  __tmp_174 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_174)
  __tmp_173 = __tmp_174[]
  skc_ = Vector{Int32}(undef,__tmp_173)
  __tmp_176 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_176)
  __tmp_175 = __tmp_176[]
  __tmp_176 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_176)
  __tmp_175 = __tmp_176[]
  skx_ = Vector{Int32}(undef,__tmp_175)
  __tmp_178 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_178)
  __tmp_177 = __tmp_178[]
  __tmp_178 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_178)
  __tmp_177 = __tmp_178[]
  skn_ = Vector{Int32}(undef,__tmp_177)
  __tmp_180 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_180)
  __tmp_179 = __tmp_180[]
  xc_ = Vector{Float64}(undef,__tmp_179)
  __tmp_182 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_182)
  __tmp_181 = __tmp_182[]
  xx_ = Vector{Float64}(undef,__tmp_181)
  __tmp_184 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_184)
  __tmp_183 = __tmp_184[]
  y_ = Vector{Float64}(undef,__tmp_183)
  __tmp_186 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_186)
  __tmp_185 = __tmp_186[]
  slc_ = Vector{Float64}(undef,__tmp_185)
  __tmp_188 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_188)
  __tmp_187 = __tmp_188[]
  suc_ = Vector{Float64}(undef,__tmp_187)
  __tmp_190 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_190)
  __tmp_189 = __tmp_190[]
  slx_ = Vector{Float64}(undef,__tmp_189)
  __tmp_192 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_192)
  __tmp_191 = __tmp_192[]
  sux_ = Vector{Float64}(undef,__tmp_191)
  __tmp_194 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_194)
  __tmp_193 = __tmp_194[]
  snx_ = Vector{Float64}(undef,__tmp_193)
  @MSK_getsolution(task.task,whichsol.value,problemsta_,solutionsta_,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_)
  problemsta = Prosta(problemsta_[])
  solutionsta = Solsta(solutionsta_[])
  skc = Stakey[Stakey(item) for item in skc_]
  skx = Stakey[Stakey(item) for item in skx_]
  skn = Stakey[Stakey(item) for item in skn_]
  xc = xc_;
  xx = xx_;
  y = y_;
  slc = slc_;
  suc = suc_;
  slx = slx_;
  sux = sux_;
  snx = snx_;
  problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx
end


"""
  getsolutionnew(task::MSKtask,whichsol::Soltype) :: (problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)

  Obtains the complete solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    problemsta::Prosta Problem status.
    solutionsta::Solsta Solution status.
    skc::Vector{Stakey} Status keys for the constraints.
    skx::Vector{Stakey} Status keys for the variables.
    skn::Vector{Stakey} Status keys for the conic constraints.
    xc::Vector{Float64} Primal constraint solution.
    xx::Vector{Float64} Primal variable solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
    doty::Vector{Float64} Dual variables corresponding to affine conic constraints.
"""
function getsolutionnew end
function getsolutionnew(task::MSKtask,whichsol::Soltype)
  problemsta_ = Ref{Int32}()
  solutionsta_ = Ref{Int32}()
  __tmp_197 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_197)
  __tmp_196 = __tmp_197[]
  __tmp_197 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_197)
  __tmp_196 = __tmp_197[]
  skc_ = Vector{Int32}(undef,__tmp_196)
  __tmp_199 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_199)
  __tmp_198 = __tmp_199[]
  __tmp_199 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_199)
  __tmp_198 = __tmp_199[]
  skx_ = Vector{Int32}(undef,__tmp_198)
  __tmp_201 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_201)
  __tmp_200 = __tmp_201[]
  __tmp_201 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_201)
  __tmp_200 = __tmp_201[]
  skn_ = Vector{Int32}(undef,__tmp_200)
  __tmp_203 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_203)
  __tmp_202 = __tmp_203[]
  xc_ = Vector{Float64}(undef,__tmp_202)
  __tmp_205 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_205)
  __tmp_204 = __tmp_205[]
  xx_ = Vector{Float64}(undef,__tmp_204)
  __tmp_207 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_207)
  __tmp_206 = __tmp_207[]
  y_ = Vector{Float64}(undef,__tmp_206)
  __tmp_209 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_209)
  __tmp_208 = __tmp_209[]
  slc_ = Vector{Float64}(undef,__tmp_208)
  __tmp_211 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_211)
  __tmp_210 = __tmp_211[]
  suc_ = Vector{Float64}(undef,__tmp_210)
  __tmp_213 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_213)
  __tmp_212 = __tmp_213[]
  slx_ = Vector{Float64}(undef,__tmp_212)
  __tmp_215 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_215)
  __tmp_214 = __tmp_215[]
  sux_ = Vector{Float64}(undef,__tmp_214)
  __tmp_217 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_217)
  __tmp_216 = __tmp_217[]
  snx_ = Vector{Float64}(undef,__tmp_216)
  __tmp_219 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_219)
  __tmp_218 = __tmp_219[]
  doty_ = Vector{Float64}(undef,__tmp_218)
  @MSK_getsolutionnew(task.task,whichsol.value,problemsta_,solutionsta_,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_,doty_)
  problemsta = Prosta(problemsta_[])
  solutionsta = Solsta(solutionsta_[])
  skc = Stakey[Stakey(item) for item in skc_]
  skx = Stakey[Stakey(item) for item in skx_]
  skn = Stakey[Stakey(item) for item in skn_]
  xc = xc_;
  xx = xx_;
  y = y_;
  slc = slc_;
  suc = suc_;
  slx = slx_;
  sux = sux_;
  snx = snx_;
  doty = doty_;
  problemsta,solutionsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty
end


"""
  getsolsta(task::MSKtask,whichsol::Soltype) :: solutionsta

  Obtains the solution status.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    solutionsta::Solsta Solution status.
"""
function getsolsta end
function getsolsta(task::MSKtask,whichsol::Soltype)
  solutionsta_ = Ref{Int32}()
  @MSK_getsolsta(task.task,whichsol.value,solutionsta_)
  solutionsta = Solsta(solutionsta_[])
  solutionsta
end


"""
  getprosta(task::MSKtask,whichsol::Soltype) :: problemsta

  Obtains the problem status.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    problemsta::Prosta Problem status.
"""
function getprosta end
function getprosta(task::MSKtask,whichsol::Soltype)
  problemsta_ = Ref{Int32}()
  @MSK_getprosta(task.task,whichsol.value,problemsta_)
  problemsta = Prosta(problemsta_[])
  problemsta
end


"""
  getskc(task::MSKtask,whichsol::Soltype) :: skc

  Obtains the status keys for the constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    skc::Vector{Stakey} Status keys for the constraints.
"""
function getskc end
function getskc(task::MSKtask,whichsol::Soltype)
  __tmp_224 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_224)
  __tmp_223 = __tmp_224[]
  __tmp_224 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_224)
  __tmp_223 = __tmp_224[]
  skc_ = Vector{Int32}(undef,__tmp_223)
  @MSK_getskc(task.task,whichsol.value,skc_)
  skc = Stakey[Stakey(item) for item in skc_]
  skc
end


"""
  getskx(task::MSKtask,whichsol::Soltype) :: skx

  Obtains the status keys for the scalar variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    skx::Vector{Stakey} Status keys for the variables.
"""
function getskx end
function getskx(task::MSKtask,whichsol::Soltype)
  __tmp_227 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_227)
  __tmp_226 = __tmp_227[]
  __tmp_227 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_227)
  __tmp_226 = __tmp_227[]
  skx_ = Vector{Int32}(undef,__tmp_226)
  @MSK_getskx(task.task,whichsol.value,skx_)
  skx = Stakey[Stakey(item) for item in skx_]
  skx
end


"""
  getskn(task::MSKtask,whichsol::Soltype) :: skn

  Obtains the status keys for the conic constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    skn::Vector{Stakey} Status keys for the conic constraints.
"""
function getskn end
function getskn(task::MSKtask,whichsol::Soltype)
  __tmp_230 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_230)
  __tmp_229 = __tmp_230[]
  __tmp_230 = Ref{Int32}()
  @MSK_getnumcone(task.task,__tmp_230)
  __tmp_229 = __tmp_230[]
  skn_ = Vector{Int32}(undef,__tmp_229)
  @MSK_getskn(task.task,whichsol.value,skn_)
  skn = Stakey[Stakey(item) for item in skn_]
  skn
end


"""
  getxc(task::MSKtask,whichsol::Soltype) :: xc

  Obtains the xc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    xc::Vector{Float64} Primal constraint solution.
"""
function getxc end
function getxc(task::MSKtask,whichsol::Soltype)
  __tmp_233 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_233)
  __tmp_232 = __tmp_233[]
  xc_ = Vector{Float64}(undef,__tmp_232)
  @MSK_getxc(task.task,whichsol.value,xc_)
  xc = xc_;
  xc
end


"""
  getxx(task::MSKtask,whichsol::Soltype) :: xx

  Obtains the xx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    xx::Vector{Float64} Primal variable solution.
"""
function getxx end
function getxx(task::MSKtask,whichsol::Soltype)
  __tmp_236 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_236)
  __tmp_235 = __tmp_236[]
  xx_ = Vector{Float64}(undef,__tmp_235)
  @MSK_getxx(task.task,whichsol.value,xx_)
  xx = xx_;
  xx
end


"""
  gety(task::MSKtask,whichsol::Soltype) :: y

  Obtains the y vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function gety end
function gety(task::MSKtask,whichsol::Soltype)
  __tmp_239 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_239)
  __tmp_238 = __tmp_239[]
  y_ = Vector{Float64}(undef,__tmp_238)
  @MSK_gety(task.task,whichsol.value,y_)
  y = y_;
  y
end


"""
  getslc(task::MSKtask,whichsol::Soltype) :: slc

  Obtains the slc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
"""
function getslc end
function getslc(task::MSKtask,whichsol::Soltype)
  __tmp_242 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_242)
  __tmp_241 = __tmp_242[]
  slc_ = Vector{Float64}(undef,__tmp_241)
  @MSK_getslc(task.task,whichsol.value,slc_)
  slc = slc_;
  slc
end


"""
  getaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64) :: doty
  getaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where {T0<:Integer}  :: doty

  Obtains the doty vector for an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    accidx::Int64 The index of the affine conic constraint.
  Returns
    doty::Vector{Float64} The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.
"""
function getaccdoty end
function getaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64)
  __tmp_245 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_245)
  __tmp_244 = __tmp_245[]
  doty_ = Vector{Float64}(undef,__tmp_244)
  @MSK_getaccdoty(task.task,whichsol.value,accidx-Int64(1),doty_)
  doty = doty_;
  doty
end
function getaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where { T0<:Integer }
  getaccdoty(
    task,
    whichsol,
    convert(Int64,accidx))
end


"""
  getaccdotys(task::MSKtask,whichsol::Soltype) :: doty

  Obtains the doty vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    doty::Vector{Float64} The dual values of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.
"""
function getaccdotys end
function getaccdotys(task::MSKtask,whichsol::Soltype)
  __tmp_248 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_248)
  __tmp_247 = __tmp_248[]
  doty_ = Vector{Float64}(undef,__tmp_247)
  @MSK_getaccdotys(task.task,whichsol.value,doty_)
  doty = doty_;
  doty
end


"""
  evaluateacc(task::MSKtask,whichsol::Soltype,accidx::Int64) :: activity
  evaluateacc(task::MSKtask,whichsol::Soltype,accidx::T0) where {T0<:Integer}  :: activity

  Evaluates the activity of an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    accidx::Int64 The index of the affine conic constraint.
  Returns
    activity::Vector{Float64} The activity of the affine conic constraint. The array should have length equal to the dimension of the constraint.
"""
function evaluateacc end
function evaluateacc(task::MSKtask,whichsol::Soltype,accidx::Int64)
  __tmp_251 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_251)
  __tmp_250 = __tmp_251[]
  activity_ = Vector{Float64}(undef,__tmp_250)
  @MSK_evaluateacc(task.task,whichsol.value,accidx-Int64(1),activity_)
  activity = activity_;
  activity
end
function evaluateacc(task::MSKtask,whichsol::Soltype,accidx::T0) where { T0<:Integer }
  evaluateacc(
    task,
    whichsol,
    convert(Int64,accidx))
end


"""
  evaluateaccs(task::MSKtask,whichsol::Soltype) :: activity

  Evaluates the activities of all affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    activity::Vector{Float64} The activity of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.
"""
function evaluateaccs end
function evaluateaccs(task::MSKtask,whichsol::Soltype)
  __tmp_254 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_254)
  __tmp_253 = __tmp_254[]
  activity_ = Vector{Float64}(undef,__tmp_253)
  @MSK_evaluateaccs(task.task,whichsol.value,activity_)
  activity = activity_;
  activity
end


"""
  getsuc(task::MSKtask,whichsol::Soltype) :: suc

  Obtains the suc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
"""
function getsuc end
function getsuc(task::MSKtask,whichsol::Soltype)
  __tmp_257 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_257)
  __tmp_256 = __tmp_257[]
  suc_ = Vector{Float64}(undef,__tmp_256)
  @MSK_getsuc(task.task,whichsol.value,suc_)
  suc = suc_;
  suc
end


"""
  getslx(task::MSKtask,whichsol::Soltype) :: slx

  Obtains the slx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
"""
function getslx end
function getslx(task::MSKtask,whichsol::Soltype)
  __tmp_260 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_260)
  __tmp_259 = __tmp_260[]
  slx_ = Vector{Float64}(undef,__tmp_259)
  @MSK_getslx(task.task,whichsol.value,slx_)
  slx = slx_;
  slx
end


"""
  getsux(task::MSKtask,whichsol::Soltype) :: sux

  Obtains the sux vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
"""
function getsux end
function getsux(task::MSKtask,whichsol::Soltype)
  __tmp_263 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_263)
  __tmp_262 = __tmp_263[]
  sux_ = Vector{Float64}(undef,__tmp_262)
  @MSK_getsux(task.task,whichsol.value,sux_)
  sux = sux_;
  sux
end


"""
  getsnx(task::MSKtask,whichsol::Soltype) :: snx

  Obtains the snx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
"""
function getsnx end
function getsnx(task::MSKtask,whichsol::Soltype)
  __tmp_266 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_266)
  __tmp_265 = __tmp_266[]
  snx_ = Vector{Float64}(undef,__tmp_265)
  @MSK_getsnx(task.task,whichsol.value,snx_)
  snx = snx_;
  snx
end


"""
  getskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: skc
  getskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: skc

  Obtains the status keys for a slice of the constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    skc::Vector{Stakey} Status keys for the constraints.
"""
function getskcslice end
function getskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  skc_ = Vector{Int32}(undef,(last - first))
  @MSK_getskcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skc_)
  skc = Stakey[Stakey(item) for item in skc_]
  skc
end
function getskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getskcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: skx
  getskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: skx

  Obtains the status keys for a slice of the scalar variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    skx::Vector{Stakey} Status keys for the variables.
"""
function getskxslice end
function getskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  skx_ = Vector{Int32}(undef,(last - first))
  @MSK_getskxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skx_)
  skx = Stakey[Stakey(item) for item in skx_]
  skx
end
function getskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getskxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: xc
  getxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: xc

  Obtains a slice of the xc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    xc::Vector{Float64} Primal constraint solution.
"""
function getxcslice end
function getxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  xc_ = Vector{Float64}(undef,(last - first))
  @MSK_getxcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xc_)
  xc = xc_;
  xc
end
function getxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getxcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: xx
  getxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: xx

  Obtains a slice of the xx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    xx::Vector{Float64} Primal variable solution.
"""
function getxxslice end
function getxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  xx_ = Vector{Float64}(undef,(last - first))
  @MSK_getxxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xx_)
  xx = xx_;
  xx
end
function getxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getxxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: y
  getyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: y

  Obtains a slice of the y vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function getyslice end
function getyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  y_ = Vector{Float64}(undef,(last - first))
  @MSK_getyslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),y_)
  y = y_;
  y
end
function getyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getyslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: slc
  getslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: slc

  Obtains a slice of the slc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
"""
function getslcslice end
function getslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  slc_ = Vector{Float64}(undef,(last - first))
  @MSK_getslcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slc_)
  slc = slc_;
  slc
end
function getslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getslcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: suc
  getsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: suc

  Obtains a slice of the suc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
"""
function getsucslice end
function getsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  suc_ = Vector{Float64}(undef,(last - first))
  @MSK_getsucslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),suc_)
  suc = suc_;
  suc
end
function getsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsucslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: slx
  getslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: slx

  Obtains a slice of the slx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
"""
function getslxslice end
function getslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  slx_ = Vector{Float64}(undef,(last - first))
  @MSK_getslxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slx_)
  slx = slx_;
  slx
end
function getslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getslxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: sux
  getsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: sux

  Obtains a slice of the sux vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
"""
function getsuxslice end
function getsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  sux_ = Vector{Float64}(undef,(last - first))
  @MSK_getsuxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),sux_)
  sux = sux_;
  sux
end
function getsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsuxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: snx
  getsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: snx

  Obtains a slice of the snx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
"""
function getsnxslice end
function getsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  snx_ = Vector{Float64}(undef,(last - first))
  @MSK_getsnxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),snx_)
  snx = snx_;
  snx
end
function getsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsnxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getbarxj(task::MSKtask,whichsol::Soltype,j::Int32) :: barxj
  getbarxj(task::MSKtask,whichsol::Soltype,j::T0) where {T0<:Integer}  :: barxj

  Obtains the primal solution for a semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    j::Int32 Index of the semidefinite variable.
  Returns
    barxj::Vector{Float64} Value of the j'th variable of barx.
"""
function getbarxj end
function getbarxj(task::MSKtask,whichsol::Soltype,j::Int32)
  __tmp_279 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_279)
  __tmp_278 = __tmp_279[]
  barxj_ = Vector{Float64}(undef,__tmp_278)
  @MSK_getbarxj(task.task,whichsol.value,j-Int32(1),barxj_)
  barxj = barxj_;
  barxj
end
function getbarxj(task::MSKtask,whichsol::Soltype,j::T0) where { T0<:Integer }
  getbarxj(
    task,
    whichsol,
    convert(Int32,j))
end


"""
  getbarxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64) :: barxslice
  getbarxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where {T0<:Integer,T1<:Integer,T2<:Integer}  :: barxslice

  Obtains the primal solution for a sequence of semidefinite variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 Index of the first semidefinite variable in the slice.
    last::Int32 Index of the last semidefinite variable in the slice plus one.
    slicesize::Int64 Denotes the length of the array barxslice.
  Returns
    barxslice::Vector{Float64} Solution values of symmetric matrix variables in the slice, stored sequentially.
"""
function getbarxslice end
function getbarxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64)
  barxslice_ = Vector{Float64}(undef,slicesize)
  @MSK_getbarxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slicesize,barxslice_)
  barxslice = barxslice_;
  barxslice
end
function getbarxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where { T0<:Integer,T1<:Integer,T2<:Integer }
  getbarxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Int64,slicesize))
end


"""
  getbarsj(task::MSKtask,whichsol::Soltype,j::Int32) :: barsj
  getbarsj(task::MSKtask,whichsol::Soltype,j::T0) where {T0<:Integer}  :: barsj

  Obtains the dual solution for a semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    j::Int32 Index of the semidefinite variable.
  Returns
    barsj::Vector{Float64} Value of the j'th dual variable of barx.
"""
function getbarsj end
function getbarsj(task::MSKtask,whichsol::Soltype,j::Int32)
  __tmp_283 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_283)
  __tmp_282 = __tmp_283[]
  barsj_ = Vector{Float64}(undef,__tmp_282)
  @MSK_getbarsj(task.task,whichsol.value,j-Int32(1),barsj_)
  barsj = barsj_;
  barsj
end
function getbarsj(task::MSKtask,whichsol::Soltype,j::T0) where { T0<:Integer }
  getbarsj(
    task,
    whichsol,
    convert(Int32,j))
end


"""
  getbarsslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64) :: barsslice
  getbarsslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where {T0<:Integer,T1<:Integer,T2<:Integer}  :: barsslice

  Obtains the dual solution for a sequence of semidefinite variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 Index of the first semidefinite variable in the slice.
    last::Int32 Index of the last semidefinite variable in the slice plus one.
    slicesize::Int64 Denotes the length of the array barsslice.
  Returns
    barsslice::Vector{Float64} Dual solution values of symmetric matrix variables in the slice, stored sequentially.
"""
function getbarsslice end
function getbarsslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slicesize::Int64)
  barsslice_ = Vector{Float64}(undef,slicesize)
  @MSK_getbarsslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slicesize,barsslice_)
  barsslice = barsslice_;
  barsslice
end
function getbarsslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slicesize::T2) where { T0<:Integer,T1<:Integer,T2<:Integer }
  getbarsslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Int64,slicesize))
end


"""
  putskc(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey})

  Sets the status keys for the constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    skc::Vector{Stakey} Status keys for the constraints.
"""
function putskc end
function putskc(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey})
  __tmp_287 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_287)
  __tmp_286 = __tmp_287[]
  if length(skc) < __tmp_286
    throw(BoundsError())
  end
  skc_ = Int32[item.value for item in skc]
  @MSK_putskc(task.task,whichsol.value,skc_)
  nothing
end


"""
  putskx(task::MSKtask,whichsol::Soltype,skx::Vector{Stakey})

  Sets the status keys for the scalar variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    skx::Vector{Stakey} Status keys for the variables.
"""
function putskx end
function putskx(task::MSKtask,whichsol::Soltype,skx::Vector{Stakey})
  __tmp_290 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_290)
  __tmp_289 = __tmp_290[]
  if length(skx) < __tmp_289
    throw(BoundsError())
  end
  skx_ = Int32[item.value for item in skx]
  @MSK_putskx(task.task,whichsol.value,skx_)
  nothing
end


"""
  putxc(task::MSKtask,whichsol::Soltype) :: xc

  Sets the xc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    xc::Vector{Float64} Primal constraint solution.
"""
function putxc end
function putxc(task::MSKtask,whichsol::Soltype)
  __tmp_293 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_293)
  __tmp_292 = __tmp_293[]
  xc_ = Vector{Float64}(undef,__tmp_292)
  @MSK_putxc(task.task,whichsol.value,xc_)
  xc = xc_;
  xc
end


"""
  putxx(task::MSKtask,whichsol::Soltype,xx::Vector{Float64})
  putxx(task::MSKtask,whichsol::Soltype,xx::T0) where {T0<:AbstractVector{<:Number}} 

  Sets the xx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    xx::Vector{Float64} Primal variable solution.
"""
function putxx end
function putxx(task::MSKtask,whichsol::Soltype,xx::Vector{Float64})
  __tmp_296 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_296)
  __tmp_295 = __tmp_296[]
  if length(xx) < __tmp_295
    throw(BoundsError())
  end
  xx_ = xx
  @MSK_putxx(task.task,whichsol.value,xx_)
  nothing
end
function putxx(task::MSKtask,whichsol::Soltype,xx::T0) where { T0<:AbstractVector{<:Number} }
  putxx(
    task,
    whichsol,
    convert(Vector{Float64},xx))
end


"""
  puty(task::MSKtask,whichsol::Soltype,y::Vector{Float64})
  puty(task::MSKtask,whichsol::Soltype,y::T0) where {T0<:AbstractVector{<:Number}} 

  Sets the y vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function puty end
function puty(task::MSKtask,whichsol::Soltype,y::Vector{Float64})
  __tmp_299 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_299)
  __tmp_298 = __tmp_299[]
  if length(y) < __tmp_298
    throw(BoundsError())
  end
  y_ = y
  @MSK_puty(task.task,whichsol.value,y_)
  nothing
end
function puty(task::MSKtask,whichsol::Soltype,y::T0) where { T0<:AbstractVector{<:Number} }
  puty(
    task,
    whichsol,
    convert(Vector{Float64},y))
end


"""
  putslc(task::MSKtask,whichsol::Soltype,slc::Vector{Float64})
  putslc(task::MSKtask,whichsol::Soltype,slc::T0) where {T0<:AbstractVector{<:Number}} 

  Sets the slc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
"""
function putslc end
function putslc(task::MSKtask,whichsol::Soltype,slc::Vector{Float64})
  __tmp_302 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_302)
  __tmp_301 = __tmp_302[]
  if length(slc) < __tmp_301
    throw(BoundsError())
  end
  slc_ = slc
  @MSK_putslc(task.task,whichsol.value,slc_)
  nothing
end
function putslc(task::MSKtask,whichsol::Soltype,slc::T0) where { T0<:AbstractVector{<:Number} }
  putslc(
    task,
    whichsol,
    convert(Vector{Float64},slc))
end


"""
  putsuc(task::MSKtask,whichsol::Soltype,suc::Vector{Float64})
  putsuc(task::MSKtask,whichsol::Soltype,suc::T0) where {T0<:AbstractVector{<:Number}} 

  Sets the suc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
"""
function putsuc end
function putsuc(task::MSKtask,whichsol::Soltype,suc::Vector{Float64})
  __tmp_305 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_305)
  __tmp_304 = __tmp_305[]
  if length(suc) < __tmp_304
    throw(BoundsError())
  end
  suc_ = suc
  @MSK_putsuc(task.task,whichsol.value,suc_)
  nothing
end
function putsuc(task::MSKtask,whichsol::Soltype,suc::T0) where { T0<:AbstractVector{<:Number} }
  putsuc(
    task,
    whichsol,
    convert(Vector{Float64},suc))
end


"""
  putslx(task::MSKtask,whichsol::Soltype,slx::Vector{Float64})
  putslx(task::MSKtask,whichsol::Soltype,slx::T0) where {T0<:AbstractVector{<:Number}} 

  Sets the slx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
"""
function putslx end
function putslx(task::MSKtask,whichsol::Soltype,slx::Vector{Float64})
  __tmp_308 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_308)
  __tmp_307 = __tmp_308[]
  if length(slx) < __tmp_307
    throw(BoundsError())
  end
  slx_ = slx
  @MSK_putslx(task.task,whichsol.value,slx_)
  nothing
end
function putslx(task::MSKtask,whichsol::Soltype,slx::T0) where { T0<:AbstractVector{<:Number} }
  putslx(
    task,
    whichsol,
    convert(Vector{Float64},slx))
end


"""
  putsux(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
  putsux(task::MSKtask,whichsol::Soltype,sux::T0) where {T0<:AbstractVector{<:Number}} 

  Sets the sux vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
"""
function putsux end
function putsux(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
  __tmp_311 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_311)
  __tmp_310 = __tmp_311[]
  if length(sux) < __tmp_310
    throw(BoundsError())
  end
  sux_ = sux
  @MSK_putsux(task.task,whichsol.value,sux_)
  nothing
end
function putsux(task::MSKtask,whichsol::Soltype,sux::T0) where { T0<:AbstractVector{<:Number} }
  putsux(
    task,
    whichsol,
    convert(Vector{Float64},sux))
end


"""
  putsnx(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
  putsnx(task::MSKtask,whichsol::Soltype,sux::T0) where {T0<:AbstractVector{<:Number}} 

  Sets the snx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
"""
function putsnx end
function putsnx(task::MSKtask,whichsol::Soltype,sux::Vector{Float64})
  __tmp_314 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_314)
  __tmp_313 = __tmp_314[]
  if length(sux) < __tmp_313
    throw(BoundsError())
  end
  sux_ = sux
  @MSK_putsnx(task.task,whichsol.value,sux_)
  nothing
end
function putsnx(task::MSKtask,whichsol::Soltype,sux::T0) where { T0<:AbstractVector{<:Number} }
  putsnx(
    task,
    whichsol,
    convert(Vector{Float64},sux))
end


"""
  putaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64) :: doty
  putaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where {T0<:Integer}  :: doty

  Puts the doty vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    accidx::Int64 The index of the affine conic constraint.
  Returns
    doty::Vector{Float64} The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.
"""
function putaccdoty end
function putaccdoty(task::MSKtask,whichsol::Soltype,accidx::Int64)
  __tmp_317 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_317)
  __tmp_316 = __tmp_317[]
  doty_ = Vector{Float64}(undef,__tmp_316)
  @MSK_putaccdoty(task.task,whichsol.value,accidx,doty_)
  doty = doty_;
  doty
end
function putaccdoty(task::MSKtask,whichsol::Soltype,accidx::T0) where { T0<:Integer }
  putaccdoty(
    task,
    whichsol,
    convert(Int64,accidx))
end


"""
  putskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skc::Vector{Stakey})
  putskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skc::Vector{Stakey}) where {T0<:Integer,T1<:Integer} 

  Sets the status keys for a slice of the constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    skc::Vector{Stakey} Status keys for the constraints.
"""
function putskcslice end
function putskcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skc::Vector{Stakey})
  if length(skc) < (last - first)
    throw(BoundsError())
  end
  skc_ = Int32[item.value for item in skc]
  @MSK_putskcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skc_)
  nothing
end
function putskcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skc::Vector{Stakey}) where { T0<:Integer,T1<:Integer }
  putskcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    skc)
end


"""
  putskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skx::Vector{Stakey})
  putskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skx::Vector{Stakey}) where {T0<:Integer,T1<:Integer} 

  Sets the status keys for a slice of the variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    skx::Vector{Stakey} Status keys for the variables.
"""
function putskxslice end
function putskxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,skx::Vector{Stakey})
  if length(skx) < (last - first)
    throw(BoundsError())
  end
  skx_ = Int32[item.value for item in skx]
  @MSK_putskxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),skx_)
  nothing
end
function putskxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,skx::Vector{Stakey}) where { T0<:Integer,T1<:Integer }
  putskxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    skx)
end


"""
  putxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xc::Vector{Float64})
  putxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xc::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the xc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    xc::Vector{Float64} Primal constraint solution.
"""
function putxcslice end
function putxcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xc::Vector{Float64})
  if length(xc) < (last - first)
    throw(BoundsError())
  end
  xc_ = xc
  @MSK_putxcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xc_)
  nothing
end
function putxcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xc::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putxcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},xc))
end


"""
  putxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xx::Vector{Float64})
  putxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xx::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the xx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    xx::Vector{Float64} Primal variable solution.
"""
function putxxslice end
function putxxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,xx::Vector{Float64})
  if length(xx) < (last - first)
    throw(BoundsError())
  end
  xx_ = xx
  @MSK_putxxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),xx_)
  nothing
end
function putxxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,xx::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putxxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},xx))
end


"""
  putyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,y::Vector{Float64})
  putyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,y::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the y vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
"""
function putyslice end
function putyslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,y::Vector{Float64})
  if length(y) < (last - first)
    throw(BoundsError())
  end
  y_ = y
  @MSK_putyslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),y_)
  nothing
end
function putyslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,y::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putyslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},y))
end


"""
  putslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slc::Vector{Float64})
  putslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slc::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the slc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
"""
function putslcslice end
function putslcslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slc::Vector{Float64})
  if length(slc) < (last - first)
    throw(BoundsError())
  end
  slc_ = slc
  @MSK_putslcslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slc_)
  nothing
end
function putslcslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slc::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putslcslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},slc))
end


"""
  putsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,suc::Vector{Float64})
  putsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,suc::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the suc vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
"""
function putsucslice end
function putsucslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,suc::Vector{Float64})
  if length(suc) < (last - first)
    throw(BoundsError())
  end
  suc_ = suc
  @MSK_putsucslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),suc_)
  nothing
end
function putsucslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,suc::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putsucslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},suc))
end


"""
  putslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slx::Vector{Float64})
  putslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slx::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the slx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
"""
function putslxslice end
function putslxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,slx::Vector{Float64})
  if length(slx) < (last - first)
    throw(BoundsError())
  end
  slx_ = slx
  @MSK_putslxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),slx_)
  nothing
end
function putslxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,slx::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putslxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},slx))
end


"""
  putsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,sux::Vector{Float64})
  putsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,sux::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the sux vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
"""
function putsuxslice end
function putsuxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,sux::Vector{Float64})
  if length(sux) < (last - first)
    throw(BoundsError())
  end
  sux_ = sux
  @MSK_putsuxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),sux_)
  nothing
end
function putsuxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,sux::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putsuxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},sux))
end


"""
  putsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,snx::Vector{Float64})
  putsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,snx::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Sets a slice of the snx vector for a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
"""
function putsnxslice end
function putsnxslice(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32,snx::Vector{Float64})
  if length(snx) < (last - first)
    throw(BoundsError())
  end
  snx_ = snx
  @MSK_putsnxslice(task.task,whichsol.value,first-Int32(1),last-Int32(1),snx_)
  nothing
end
function putsnxslice(task::MSKtask,whichsol::Soltype,first::T0,last::T1,snx::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putsnxslice(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},snx))
end


"""
  putbarxj(task::MSKtask,whichsol::Soltype,j::Int32,barxj::Vector{Float64})
  putbarxj(task::MSKtask,whichsol::Soltype,j::T0,barxj::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}} 

  Sets the primal solution for a semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    j::Int32 Index of the semidefinite variable.
    barxj::Vector{Float64} Value of the j'th variable of barx.
"""
function putbarxj end
function putbarxj(task::MSKtask,whichsol::Soltype,j::Int32,barxj::Vector{Float64})
  __tmp_330 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_330)
  __tmp_329 = __tmp_330[]
  if length(barxj) < __tmp_329
    throw(BoundsError())
  end
  barxj_ = barxj
  @MSK_putbarxj(task.task,whichsol.value,j-Int32(1),barxj_)
  nothing
end
function putbarxj(task::MSKtask,whichsol::Soltype,j::T0,barxj::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  putbarxj(
    task,
    whichsol,
    convert(Int32,j),
    convert(Vector{Float64},barxj))
end


"""
  putbarsj(task::MSKtask,whichsol::Soltype,j::Int32,barsj::Vector{Float64})
  putbarsj(task::MSKtask,whichsol::Soltype,j::T0,barsj::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}} 

  Sets the dual solution for a semidefinite variable.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    j::Int32 Index of the semidefinite variable.
    barsj::Vector{Float64} Value of the j'th variable of barx.
"""
function putbarsj end
function putbarsj(task::MSKtask,whichsol::Soltype,j::Int32,barsj::Vector{Float64})
  __tmp_333 = Ref{Int64}()
  @MSK_getlenbarvarj(task.task,j-Int32(1),__tmp_333)
  __tmp_332 = __tmp_333[]
  if length(barsj) < __tmp_332
    throw(BoundsError())
  end
  barsj_ = barsj
  @MSK_putbarsj(task.task,whichsol.value,j-Int32(1),barsj_)
  nothing
end
function putbarsj(task::MSKtask,whichsol::Soltype,j::T0,barsj::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  putbarsj(
    task,
    whichsol,
    convert(Int32,j),
    convert(Vector{Float64},barsj))
end


"""
  getpviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getpviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a primal solution associated to a constraint.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of constraints.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolcon end
function getpviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolcon(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolcon(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getpviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getpviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a primal solution for a list of scalar variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of x variables.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolvar end
function getpviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolvar(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a primal solution for a list of semidefinite variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of barX variables.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolbarvar end
function getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolbarvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolbarvar(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getpviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getpviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a solution for set of conic constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of conic constraints.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolcones end
function getpviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getpviolcones(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getpviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolcones(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64}) :: viol
  getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a solution for set of affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    accidxlist::Vector{Int64} An array of indexes of conic constraints.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpviolacc end
function getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64})
  numaccidx = Int64(length(accidxlist))
  accidxlist_ = accidxlist .- Int64(1)
  viol_ = Vector{Float64}(undef,numaccidx)
  @MSK_getpviolacc(task.task,whichsol.value,numaccidx,accidxlist_,viol_)
  viol = viol_;
  viol
end
function getpviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  getpviolacc(
    task,
    whichsol,
    convert(Vector{Int64},accidxlist))
end


"""
  getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::Vector{Int64}) :: viol
  getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a solution for set of disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    djcidxlist::Vector{Int64} An array of indexes of disjunctive constraints.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getpvioldjc end
function getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::Vector{Int64})
  numdjcidx = Int64(length(djcidxlist))
  djcidxlist_ = djcidxlist .- Int64(1)
  viol_ = Vector{Float64}(undef,numdjcidx)
  @MSK_getpvioldjc(task.task,whichsol.value,numdjcidx,djcidxlist_,viol_)
  viol = viol_;
  viol
end
function getpvioldjc(task::MSKtask,whichsol::Soltype,djcidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  getpvioldjc(
    task,
    whichsol,
    convert(Vector{Int64},djcidxlist))
end


"""
  getdviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getdviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a dual solution associated with a set of constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of constraints.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolcon end
function getdviolcon(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolcon(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolcon(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolcon(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getdviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getdviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a dual solution associated with a set of scalar variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of x variables.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolvar end
function getdviolvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolvar(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of dual solution for a set of semidefinite variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of barx variables.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolbarvar end
function getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolbarvar(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolbarvar(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolbarvar(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getdviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32}) :: viol
  getdviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of a solution for set of dual conic constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    sub::Vector{Int32} An array of indexes of conic constraints.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolcones end
function getdviolcones(task::MSKtask,whichsol::Soltype,sub::Vector{Int32})
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  viol_ = Vector{Float64}(undef,num)
  @MSK_getdviolcones(task.task,whichsol.value,num,sub_,viol_)
  viol = viol_;
  viol
end
function getdviolcones(task::MSKtask,whichsol::Soltype,sub::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolcones(
    task,
    whichsol,
    convert(Vector{Int32},sub))
end


"""
  getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64}) :: viol
  getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where {T0<:AbstractVector{<:Integer}}  :: viol

  Computes the violation of the dual solution for set of affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    accidxlist::Vector{Int64} An array of indexes of conic constraints.
  Returns
    viol::Vector{Float64} List of violations corresponding to sub.
"""
function getdviolacc end
function getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::Vector{Int64})
  numaccidx = Int64(length(accidxlist))
  accidxlist_ = accidxlist .- Int64(1)
  viol_ = Vector{Float64}(undef,numaccidx)
  @MSK_getdviolacc(task.task,whichsol.value,numaccidx,accidxlist_,viol_)
  viol = viol_;
  viol
end
function getdviolacc(task::MSKtask,whichsol::Soltype,accidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  getdviolacc(
    task,
    whichsol,
    convert(Vector{Int64},accidxlist))
end


"""
  getsolutioninfo(task::MSKtask,whichsol::Soltype) :: (pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone)

  Obtains information about of a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    pobj::Float64 The primal objective value.
    pviolcon::Float64 Maximal primal bound violation for a xc variable.
    pviolvar::Float64 Maximal primal bound violation for a xx variable.
    pviolbarvar::Float64 Maximal primal bound violation for a barx variable.
    pviolcone::Float64 Maximal primal violation of the solution with respect to the conic constraints.
    pviolitg::Float64 Maximal violation in the integer constraints.
    dobj::Float64 Dual objective value.
    dviolcon::Float64 Maximal dual bound violation for a xc variable.
    dviolvar::Float64 Maximal dual bound violation for a xx variable.
    dviolbarvar::Float64 Maximal dual bound violation for a bars variable.
    dviolcone::Float64 Maximum violation of the dual solution in the dual conic constraints.
"""
function getsolutioninfo end
function getsolutioninfo(task::MSKtask,whichsol::Soltype)
  pobj_ = Ref{Float64}()
  pviolcon_ = Ref{Float64}()
  pviolvar_ = Ref{Float64}()
  pviolbarvar_ = Ref{Float64}()
  pviolcone_ = Ref{Float64}()
  pviolitg_ = Ref{Float64}()
  dobj_ = Ref{Float64}()
  dviolcon_ = Ref{Float64}()
  dviolvar_ = Ref{Float64}()
  dviolbarvar_ = Ref{Float64}()
  dviolcone_ = Ref{Float64}()
  @MSK_getsolutioninfo(task.task,whichsol.value,pobj_,pviolcon_,pviolvar_,pviolbarvar_,pviolcone_,pviolitg_,dobj_,dviolcon_,dviolvar_,dviolbarvar_,dviolcone_)
  pobj_[],pviolcon_[],pviolvar_[],pviolbarvar_[],pviolcone_[],pviolitg_[],dobj_[],dviolcon_[],dviolvar_[],dviolbarvar_[],dviolcone_[]
end


"""
  getsolutioninfonew(task::MSKtask,whichsol::Soltype) :: (pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolacc,pvioldjc,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone,dviolacc)

  Obtains information about of a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    pobj::Float64 The primal objective value.
    pviolcon::Float64 Maximal primal bound violation for a xc variable.
    pviolvar::Float64 Maximal primal bound violation for a xx variable.
    pviolbarvar::Float64 Maximal primal bound violation for a barx variable.
    pviolcone::Float64 Maximal primal violation of the solution with respect to the conic constraints.
    pviolacc::Float64 Maximal primal violation of the solution with respect to the affine conic constraints.
    pvioldjc::Float64 Maximal primal violation of the solution with respect to the disjunctive constraints.
    pviolitg::Float64 Maximal violation in the integer constraints.
    dobj::Float64 Dual objective value.
    dviolcon::Float64 Maximal dual bound violation for a xc variable.
    dviolvar::Float64 Maximal dual bound violation for a xx variable.
    dviolbarvar::Float64 Maximal dual bound violation for a bars variable.
    dviolcone::Float64 Maximum violation of the dual solution in the dual conic constraints.
    dviolacc::Float64 Maximum violation of the dual solution in the dual affine conic constraints.
"""
function getsolutioninfonew end
function getsolutioninfonew(task::MSKtask,whichsol::Soltype)
  pobj_ = Ref{Float64}()
  pviolcon_ = Ref{Float64}()
  pviolvar_ = Ref{Float64}()
  pviolbarvar_ = Ref{Float64}()
  pviolcone_ = Ref{Float64}()
  pviolacc_ = Ref{Float64}()
  pvioldjc_ = Ref{Float64}()
  pviolitg_ = Ref{Float64}()
  dobj_ = Ref{Float64}()
  dviolcon_ = Ref{Float64}()
  dviolvar_ = Ref{Float64}()
  dviolbarvar_ = Ref{Float64}()
  dviolcone_ = Ref{Float64}()
  dviolacc_ = Ref{Float64}()
  @MSK_getsolutioninfonew(task.task,whichsol.value,pobj_,pviolcon_,pviolvar_,pviolbarvar_,pviolcone_,pviolacc_,pvioldjc_,pviolitg_,dobj_,dviolcon_,dviolvar_,dviolbarvar_,dviolcone_,dviolacc_)
  pobj_[],pviolcon_[],pviolvar_[],pviolbarvar_[],pviolcone_[],pviolacc_[],pvioldjc_[],pviolitg_[],dobj_[],dviolcon_[],dviolvar_[],dviolbarvar_[],dviolcone_[],dviolacc_[]
end


"""
  getdualsolutionnorms(task::MSKtask,whichsol::Soltype) :: (nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars)

  Compute norms of the dual solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    nrmy::Float64 The norm of the y vector.
    nrmslc::Float64 The norm of the slc vector.
    nrmsuc::Float64 The norm of the suc vector.
    nrmslx::Float64 The norm of the slx vector.
    nrmsux::Float64 The norm of the sux vector.
    nrmsnx::Float64 The norm of the snx vector.
    nrmbars::Float64 The norm of the bars vector.
"""
function getdualsolutionnorms end
function getdualsolutionnorms(task::MSKtask,whichsol::Soltype)
  nrmy_ = Ref{Float64}()
  nrmslc_ = Ref{Float64}()
  nrmsuc_ = Ref{Float64}()
  nrmslx_ = Ref{Float64}()
  nrmsux_ = Ref{Float64}()
  nrmsnx_ = Ref{Float64}()
  nrmbars_ = Ref{Float64}()
  @MSK_getdualsolutionnorms(task.task,whichsol.value,nrmy_,nrmslc_,nrmsuc_,nrmslx_,nrmsux_,nrmsnx_,nrmbars_)
  nrmy_[],nrmslc_[],nrmsuc_[],nrmslx_[],nrmsux_[],nrmsnx_[],nrmbars_[]
end


"""
  getprimalsolutionnorms(task::MSKtask,whichsol::Soltype) :: (nrmxc,nrmxx,nrmbarx)

  Compute norms of the primal solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    nrmxc::Float64 The norm of the xc vector.
    nrmxx::Float64 The norm of the xx vector.
    nrmbarx::Float64 The norm of the barX vector.
"""
function getprimalsolutionnorms end
function getprimalsolutionnorms(task::MSKtask,whichsol::Soltype)
  nrmxc_ = Ref{Float64}()
  nrmxx_ = Ref{Float64}()
  nrmbarx_ = Ref{Float64}()
  @MSK_getprimalsolutionnorms(task.task,whichsol.value,nrmxc_,nrmxx_,nrmbarx_)
  nrmxc_[],nrmxx_[],nrmbarx_[]
end


"""
  getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::Int32,last::Int32) :: values
  getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: values

  Obtains a slice of the solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    solitem::Solitem Which part of the solution is required.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
  Returns
    values::Vector{Float64} The values of the requested solution elements.
"""
function getsolutionslice end
function getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::Int32,last::Int32)
  values_ = Vector{Float64}(undef,(last - first))
  @MSK_getsolutionslice(task.task,whichsol.value,solitem.value,first-Int32(1),last-Int32(1),values_)
  values = values_;
  values
end
function getsolutionslice(task::MSKtask,whichsol::Soltype,solitem::Solitem,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getsolutionslice(
    task,
    whichsol,
    solitem,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getreducedcosts(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32) :: redcosts
  getreducedcosts(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: redcosts

  Obtains the reduced costs for a sequence of variables.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    first::Int32 The index of the first variable in the sequence.
    last::Int32 The index of the last variable in the sequence plus 1.
  Returns
    redcosts::Vector{Float64} Returns the requested reduced costs.
"""
function getreducedcosts end
function getreducedcosts(task::MSKtask,whichsol::Soltype,first::Int32,last::Int32)
  redcosts_ = Vector{Float64}(undef,(last - first))
  @MSK_getreducedcosts(task.task,whichsol.value,first-Int32(1),last-Int32(1),redcosts_)
  redcosts = redcosts_;
  redcosts
end
function getreducedcosts(task::MSKtask,whichsol::Soltype,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getreducedcosts(
    task,
    whichsol,
    convert(Int32,first),
    convert(Int32,last))
end


"""
  getstrparam(task::MSKtask,param::Sparam) :: (len,parvalue)

  Obtains the value of a string parameter.

  Arguments
    task::MSKtask An optimization task.
    param::Sparam Which parameter.
  Returns
    len::Int32 The length of the parameter value.
    parvalue::String If this is not a null pointer, the parameter value is stored here.
"""
function getstrparam end
function getstrparam(task::MSKtask,param::Sparam)
  __tmp_353 = Ref{Int32}()
  @MSK_getstrparamlen(task.task,param,__tmp_353)
  __tmp_352 = __tmp_353[]
  maxlen = Int32((1 + __tmp_352))
  len_ = Ref{Int32}()
  parvalue_ = Array{UInt8}(undef,maxlen)
  @MSK_getstrparam(task.task,param.value,maxlen,len_,parvalue_)
  parvalue_len = findfirst(_c->_c==0,parvalue_)
  parvalue = if parvalue_len === nothing
    String(parvalue_)
  else
    String(parvalue_[1:parvalue_len-1])
  end
  len_[],parvalue
end


"""
  getstrparamlen(task::MSKtask,param::Sparam) :: len

  Obtains the length of a string parameter.

  Arguments
    task::MSKtask An optimization task.
    param::Sparam Which parameter.
  Returns
    len::Int32 The length of the parameter value.
"""
function getstrparamlen end
function getstrparamlen(task::MSKtask,param::Sparam)
  len_ = Ref{Int32}()
  @MSK_getstrparamlen(task.task,param.value,len_)
  len_[]
end


"""
  gettasknamelen(task::MSKtask) :: len

  Obtains the length the task name.

  Arguments
    task::MSKtask An optimization task.
  Returns
    len::Int32 Returns the length of the task name.
"""
function gettasknamelen end
function gettasknamelen(task::MSKtask)
  len_ = Ref{Int32}()
  @MSK_gettasknamelen(task.task,len_)
  len_[]
end


"""
  gettaskname(task::MSKtask) :: taskname

  Obtains the task name.

  Arguments
    task::MSKtask An optimization task.
  Returns
    taskname::String Returns the task name.
"""
function gettaskname end
function gettaskname(task::MSKtask)
  __tmp_358 = Ref{Int32}()
  @MSK_gettasknamelen(task.task,__tmp_358)
  __tmp_357 = __tmp_358[]
  sizetaskname = Int32((1 + __tmp_357))
  taskname_ = Array{UInt8}(undef,sizetaskname)
  @MSK_gettaskname(task.task,sizetaskname,taskname_)
  taskname_len = findfirst(_c->_c==0,taskname_)
  taskname = if taskname_len === nothing
    String(taskname_)
  else
    String(taskname_[1:taskname_len-1])
  end
  taskname
end


"""
  getvartype(task::MSKtask,j::Int32) :: vartype
  getvartype(task::MSKtask,j::T0) where {T0<:Integer}  :: vartype

  Gets the variable type of one variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable.
  Returns
    vartype::Variabletype Variable type of variable index j.
"""
function getvartype end
function getvartype(task::MSKtask,j::Int32)
  vartype_ = Ref{Int32}()
  @MSK_getvartype(task.task,j-Int32(1),vartype_)
  vartype = Variabletype(vartype_[])
  vartype
end
function getvartype(task::MSKtask,j::T0) where { T0<:Integer }
  getvartype(
    task,
    convert(Int32,j))
end


"""
  getvartypelist(task::MSKtask,subj::Vector{Int32}) :: vartype
  getvartypelist(task::MSKtask,subj::T0) where {T0<:AbstractVector{<:Integer}}  :: vartype

  Obtains the variable type for one or more variables.

  Arguments
    task::MSKtask An optimization task.
    subj::Vector{Int32} A list of variable indexes.
  Returns
    vartype::Vector{Variabletype} Returns the variables types corresponding the variable indexes requested.
"""
function getvartypelist end
function getvartypelist(task::MSKtask,subj::Vector{Int32})
  num = Int32(length(subj))
  subj_ = subj .- Int32(1)
  vartype_ = Vector{Int32}(undef,num)
  @MSK_getvartypelist(task.task,num,subj_,vartype_)
  vartype = Variabletype[Variabletype(item) for item in vartype_]
  vartype
end
function getvartypelist(task::MSKtask,subj::T0) where { T0<:AbstractVector{<:Integer} }
  getvartypelist(
    task,
    convert(Vector{Int32},subj))
end


"""
  inputdata(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,c::Vector{Float64},cfix::Float64,aptrb::Vector{Int64},aptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,aptrb::T4,aptre::T5,asub::T6,aval::T7,bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:Number,T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number},T9<:AbstractVector{<:Number},T10<:AbstractVector{<:Number},T11<:AbstractVector{<:Number}} 
  inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,A:: SparseMatrixCSC{Float64},bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11)

  Input the linear part of an optimization task in one function call.

  Arguments
    task::MSKtask An optimization task.
    maxnumcon::Int32 Number of preallocated constraints in the optimization task.
    maxnumvar::Int32 Number of preallocated variables in the optimization task.
    c::Vector{Float64} Linear terms of the objective as a dense vector. The length is the number of variables.
    cfix::Float64 Fixed term in the objective.
    aptrb::Vector{Int64} Row or column start pointers.
    aptre::Vector{Int64} Row or column end pointers.
    asub::Vector{Int32} Coefficient subscripts.
    aval::Vector{Float64} Coefficient values.
    bkc::Vector{Boundkey} Bound keys for the constraints.
    blc::Vector{Float64} Lower bounds for the constraints.
    buc::Vector{Float64} Upper bounds for the constraints.
    bkx::Vector{Boundkey} Bound keys for the variables.
    blx::Vector{Float64} Lower bounds for the variables.
    bux::Vector{Float64} Upper bounds for the variables.
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
"""
function inputdata end
function inputdata(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,c::Vector{Float64},cfix::Float64,aptrb::Vector{Int64},aptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  numcon = Int32(min(length(buc),length(blc),length(bkc)))
  numvar = Int32(min(length(c),length(bux),length(blx),length(bkx),length(aptrb),length(aptre)))
  c_ = c
  aptrb_ = aptrb .- Int64(1)
  aptre_ = aptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  bkc_ = Int32[item.value for item in bkc]
  blc_ = blc
  buc_ = buc
  bkx_ = Int32[item.value for item in bkx]
  blx_ = blx
  bux_ = bux
  @MSK_inputdata64(task.task,maxnumcon,maxnumvar,numcon,numvar,c_,cfix,aptrb_,aptre_,asub_,aval_,bkc_,blc_,buc_,bkx_,blx_,bux_)
  nothing
end
function inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,A:: SparseMatrixCSC{Float64},bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:Number,T8<:AbstractVector{<:Number},T9<:AbstractVector{<:Number},T10<:AbstractVector{<:Number},T11<:AbstractVector{<:Number}}
  aptrb = A.colptr[1:size(A,2)]
  aptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  inputdata(task,maxnumcon,maxnumvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
end
function inputdata(task::MSKtask,maxnumcon::T0,maxnumvar::T1,c::T2,cfix::T3,aptrb::T4,aptre::T5,asub::T6,aval::T7,bkc::Vector{Boundkey},blc::T8,buc::T9,bkx::Vector{Boundkey},blx::T10,bux::T11) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:Number,T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number},T9<:AbstractVector{<:Number},T10<:AbstractVector{<:Number},T11<:AbstractVector{<:Number} }
  inputdata(
    task,
    convert(Int32,maxnumcon),
    convert(Int32,maxnumvar),
    convert(Vector{Float64},c),
    convert(Float64,cfix),
    convert(Vector{Int64},aptrb),
    convert(Vector{Int64},aptre),
    convert(Vector{Int32},asub),
    convert(Vector{Float64},aval),
    bkc,
    convert(Vector{Float64},blc),
    convert(Vector{Float64},buc),
    bkx,
    convert(Vector{Float64},blx),
    convert(Vector{Float64},bux))
end


"""
  isdouparname(task::MSKtask,parname::AbstractString) :: param

  Checks a double parameter name.

  Arguments
    task::MSKtask An optimization task.
    parname::AbstractString Parameter name.
  Returns
    param::Dparam Returns the parameter corresponding to the name, if one exists.
"""
function isdouparname end
function isdouparname(task::MSKtask,parname::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  param_ = Ref{Int32}()
  @MSK_isdouparname(task.task,parname_,param_)
  param = Dparam(param_[])
  param
end


"""
  isintparname(task::MSKtask,parname::AbstractString) :: param

  Checks an integer parameter name.

  Arguments
    task::MSKtask An optimization task.
    parname::AbstractString Parameter name.
  Returns
    param::Iparam Returns the parameter corresponding to the name, if one exists.
"""
function isintparname end
function isintparname(task::MSKtask,parname::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  param_ = Ref{Int32}()
  @MSK_isintparname(task.task,parname_,param_)
  param = Iparam(param_[])
  param
end


"""
  isstrparname(task::MSKtask,parname::AbstractString) :: param

  Checks a string parameter name.

  Arguments
    task::MSKtask An optimization task.
    parname::AbstractString Parameter name.
  Returns
    param::Sparam Returns the parameter corresponding to the name, if one exists.
"""
function isstrparname end
function isstrparname(task::MSKtask,parname::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  param_ = Ref{Int32}()
  @MSK_isstrparname(task.task,parname_,param_)
  param = Sparam(param_[])
  param
end


"""
  linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::AbstractString,append::Int32)
  linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::AbstractString,append::T0) where {T0<:Integer} 

  Directs all output from a task stream to a file.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
    filename::AbstractString A valid file name.
    append::Int32 If this argument is 0 the output file will be overwritten, otherwise it will be appended to.
"""
function linkfiletostream end
function linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::AbstractString,append::Int32)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_linkfiletotaskstream(task.task,whichstream.value,filename_,append)
  nothing
end
function linkfiletostream(task::MSKtask,whichstream::Streamtype,filename::AbstractString,append::T0) where { T0<:Integer }
  linkfiletostream(
    task,
    whichstream,
    filename,
    convert(Int32,append))
end


"""
  primalrepair(task::MSKtask,wlc::Vector{Float64},wuc::Vector{Float64},wlx::Vector{Float64},wux::Vector{Float64})
  primalrepair(task::MSKtask,wlc::T0,wuc::T1,wlx::T2,wux::T3) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number}} 

  Repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables.

  Arguments
    task::MSKtask An optimization task.
    wlc::Vector{Float64} Weights associated with relaxing lower bounds on the constraints.
    wuc::Vector{Float64} Weights associated with relaxing the upper bound on the constraints.
    wlx::Vector{Float64} Weights associated with relaxing the lower bounds of the variables.
    wux::Vector{Float64} Weights associated with relaxing the upper bounds of variables.
"""
function primalrepair end
function primalrepair(task::MSKtask,wlc::Vector{Float64},wuc::Vector{Float64},wlx::Vector{Float64},wux::Vector{Float64})
  __tmp_368 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_368)
  __tmp_367 = __tmp_368[]
  if length(wlc) < __tmp_367
    throw(BoundsError())
  end
  wlc_ = wlc
  __tmp_370 = Ref{Int32}()
  @MSK_getnumcon(task.task,__tmp_370)
  __tmp_369 = __tmp_370[]
  if length(wuc) < __tmp_369
    throw(BoundsError())
  end
  wuc_ = wuc
  __tmp_372 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_372)
  __tmp_371 = __tmp_372[]
  if length(wlx) < __tmp_371
    throw(BoundsError())
  end
  wlx_ = wlx
  __tmp_374 = Ref{Int32}()
  @MSK_getnumvar(task.task,__tmp_374)
  __tmp_373 = __tmp_374[]
  if length(wux) < __tmp_373
    throw(BoundsError())
  end
  wux_ = wux
  @MSK_primalrepair(task.task,wlc_,wuc_,wlx_,wux_)
  nothing
end
function primalrepair(task::MSKtask,wlc::T0,wuc::T1,wlx::T2,wux::T3) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number} }
  primalrepair(
    task,
    convert(Vector{Float64},wlc),
    convert(Vector{Float64},wuc),
    convert(Vector{Float64},wlx),
    convert(Vector{Float64},wux))
end


"""
  infeasibilityreport(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)

  TBD

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
    whichsol::Soltype Selects a solution.
"""
function infeasibilityreport end
function infeasibilityreport(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)
  @MSK_infeasibilityreport(task.task,whichstream.value,whichsol.value)
  nothing
end


"""
  optimize(task::MSKtask) :: trmcode

  Optimizes the problem.

  Arguments
    task::MSKtask An optimization task.
  Returns
    trmcode::Rescode Is either OK or a termination response code.
"""
function optimize end
function optimize(task::MSKtask)
  trmcode_ = Ref{Int32}()
  @MSK_optimizetrm(task.task,trmcode_)
  trmcode = Rescode(trmcode_[])
  trmcode
end


"""
  printparam(task::MSKtask)

  Prints the current parameter settings.

  Arguments
    task::MSKtask An optimization task.
"""
function printparam end
function printparam(task::MSKtask)
  @MSK_printparam(task.task)
  nothing
end


"""
  commitchanges(task::MSKtask)

  Commits all cached problem changes.

  Arguments
    task::MSKtask An optimization task.
"""
function commitchanges end
function commitchanges(task::MSKtask)
  @MSK_commitchanges(task.task)
  nothing
end


"""
  getatruncatetol(task::MSKtask) :: tolzero

  Gets the current A matrix truncation threshold.

  Arguments
    task::MSKtask An optimization task.
  Returns
    tolzero::Vector{Float64} Truncation tolerance.
"""
function getatruncatetol end
function getatruncatetol(task::MSKtask)
  tolzero_ = Vector{Float64}(undef,1)
  @MSK_getatruncatetol(task.task,tolzero_)
  tolzero = tolzero_;
  tolzero
end


"""
  putatruncatetol(task::MSKtask,tolzero::Float64)
  putatruncatetol(task::MSKtask,tolzero::T0) where {T0<:Number} 

  Truncates all elements in A below a certain tolerance to zero.

  Arguments
    task::MSKtask An optimization task.
    tolzero::Float64 Truncation tolerance.
"""
function putatruncatetol end
function putatruncatetol(task::MSKtask,tolzero::Float64)
  @MSK_putatruncatetol(task.task,tolzero)
  nothing
end
function putatruncatetol(task::MSKtask,tolzero::T0) where { T0<:Number }
  putatruncatetol(
    task,
    convert(Float64,tolzero))
end


"""
  putaij(task::MSKtask,i::Int32,j::Int32,aij::Float64)
  putaij(task::MSKtask,i::T0,j::T1,aij::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

  Changes a single value in the linear coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Constraint (row) index.
    j::Int32 Variable (column) index.
    aij::Float64 New coefficient.
"""
function putaij end
function putaij(task::MSKtask,i::Int32,j::Int32,aij::Float64)
  @MSK_putaij(task.task,i-Int32(1),j-Int32(1),aij)
  nothing
end
function putaij(task::MSKtask,i::T0,j::T1,aij::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putaij(
    task,
    convert(Int32,i),
    convert(Int32,j),
    convert(Float64,aij))
end


"""
  putaijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
  putaijlist(task::MSKtask,subi::T0,subj::T1,valij::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Changes one or more coefficients in the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    subi::Vector{Int32} Constraint (row) indices.
    subj::Vector{Int32} Variable (column) indices.
    valij::Vector{Float64} New coefficient values.
"""
function putaijlist end
function putaijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
  num = Int64(min(length(subi),length(subj),length(valij)))
  subi_ = subi .- Int32(1)
  subj_ = subj .- Int32(1)
  valij_ = valij
  @MSK_putaijlist64(task.task,num,subi_,subj_,valij_)
  nothing
end
function putaijlist(task::MSKtask,subi::T0,subj::T1,valij::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putaijlist(
    task,
    convert(Vector{Int32},subi),
    convert(Vector{Int32},subj),
    convert(Vector{Float64},valij))
end


"""
  putacol(task::MSKtask,j::Int32,subj::Vector{Int32},valj::Vector{Float64})
  putacol(task::MSKtask,j::T0,subj::T1,valj::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Replaces all elements in one column of the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Column index.
    subj::Vector{Int32} Row indexes of non-zero values in column.
    valj::Vector{Float64} New non-zero values of column.
"""
function putacol end
function putacol(task::MSKtask,j::Int32,subj::Vector{Int32},valj::Vector{Float64})
  nzj = Int32(min(length(subj),length(valj)))
  subj_ = subj .- Int32(1)
  valj_ = valj
  @MSK_putacol(task.task,j-Int32(1),nzj,subj_,valj_)
  nothing
end
function putacol(task::MSKtask,j::T0,subj::T1,valj::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putacol(
    task,
    convert(Int32,j),
    convert(Vector{Int32},subj),
    convert(Vector{Float64},valj))
end


"""
  putarow(task::MSKtask,i::Int32,subi::Vector{Int32},vali::Vector{Float64})
  putarow(task::MSKtask,i::T0,subi::T1,vali::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Replaces all elements in one row of the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Row index.
    subi::Vector{Int32} Column indexes of non-zero values in row.
    vali::Vector{Float64} New non-zero values of row.
"""
function putarow end
function putarow(task::MSKtask,i::Int32,subi::Vector{Int32},vali::Vector{Float64})
  nzi = Int32(min(length(subi),length(vali)))
  subi_ = subi .- Int32(1)
  vali_ = vali
  @MSK_putarow(task.task,i-Int32(1),nzi,subi_,vali_)
  nothing
end
function putarow(task::MSKtask,i::T0,subi::T1,vali::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putarow(
    task,
    convert(Int32,i),
    convert(Vector{Int32},subi),
    convert(Vector{Float64},vali))
end


"""
  putarowslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  putarowslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 
  putarowslice(task::MSKtask,first::T0,last::T1,At:: SparseMatrixCSC{Float64})

  Replaces all elements in several rows the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First row in the slice.
    last::Int32 Last row plus one in the slice.
    ptrb::Vector{Int64} Array of pointers to the first element in the rows.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the rows.
    asub::Vector{Int32} Column indexes of new elements.
    aval::Vector{Float64} Coefficient values.
    At::SparseMatrixCSC{{Float64} Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced
"""
function putarowslice end
function putarowslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  if length(ptrb) < (last - first)
    throw(BoundsError())
  end
  ptrb_ = ptrb .- Int64(1)
  if length(ptre) < (last - first)
    throw(BoundsError())
  end
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putarowslice64(task.task,first-Int32(1),last-Int32(1),ptrb_,ptre_,asub_,aval_)
  nothing
end
function putarowslice(task::MSKtask,first::T0,last::T1,At:: SparseMatrixCSC{Float64}) where {T0<:Integer,T1<:Integer}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowslice(task,first,last,ptrb,ptre,asub,aval)
end
function putarowslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putarowslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Int64},ptrb),
    convert(Vector{Int64},ptre),
    convert(Vector{Int32},asub),
    convert(Vector{Float64},aval))
end


"""
  putarowlist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  putarowlist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 
  putarowlist(task::MSKtask,sub::T0,At:: SparseMatrixCSC{Float64})

  Replaces all elements in several rows of the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    sub::Vector{Int32} Indexes of rows or columns that should be replaced.
    ptrb::Vector{Int64} Array of pointers to the first element in the rows.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the rows.
    asub::Vector{Int32} Variable indexes.
    aval::Vector{Float64} Coefficient values.
    At::SparseMatrixCSC{{Float64} Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced
"""
function putarowlist end
function putarowlist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  num = Int32(min(length(sub),length(ptrb),length(ptre)))
  sub_ = sub .- Int32(1)
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putarowlist64(task.task,num,sub_,ptrb_,ptre_,asub_,aval_)
  nothing
end
function putarowlist(task::MSKtask,sub::T0,At:: SparseMatrixCSC{Float64}) where {T0<:AbstractVector{<:Integer}}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowlist(task,sub,ptrb,ptre,asub,aval)
end
function putarowlist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putarowlist(
    task,
    convert(Vector{Int32},sub),
    convert(Vector{Int64},ptrb),
    convert(Vector{Int64},ptre),
    convert(Vector{Int32},asub),
    convert(Vector{Float64},aval))
end


"""
  putacolslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  putacolslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 
  putacolslice(task::MSKtask,first::T0,last::T1,A:: SparseMatrixCSC{Float64})

  Replaces all elements in a sequence of columns the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First column in the slice.
    last::Int32 Last column plus one in the slice.
    ptrb::Vector{Int64} Array of pointers to the first element in the columns.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the columns.
    asub::Vector{Int32} Row indexes
    aval::Vector{Float64} Coefficient values.
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
"""
function putacolslice end
function putacolslice(task::MSKtask,first::Int32,last::Int32,ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putacolslice64(task.task,first-Int32(1),last-Int32(1),ptrb_,ptre_,asub_,aval_)
  nothing
end
function putacolslice(task::MSKtask,first::T0,last::T1,A:: SparseMatrixCSC{Float64}) where {T0<:Integer,T1<:Integer}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacolslice(task,first,last,ptrb,ptre,asub,aval)
end
function putacolslice(task::MSKtask,first::T0,last::T1,ptrb::T2,ptre::T3,asub::T4,aval::T5) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putacolslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Int64},ptrb),
    convert(Vector{Int64},ptre),
    convert(Vector{Int32},asub),
    convert(Vector{Float64},aval))
end


"""
  putacollist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  putacollist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 
  putacollist(task::MSKtask,sub::T0,A:: SparseMatrixCSC{Float64})

  Replaces all elements in several columns the linear constraint matrix.

  Arguments
    task::MSKtask An optimization task.
    sub::Vector{Int32} Indexes of columns that should be replaced.
    ptrb::Vector{Int64} Array of pointers to the first element in the columns.
    ptre::Vector{Int64} Array of pointers to the last element plus one in the columns.
    asub::Vector{Int32} Row indexes
    aval::Vector{Float64} Coefficient values.
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
"""
function putacollist end
function putacollist(task::MSKtask,sub::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},asub::Vector{Int32},aval::Vector{Float64})
  num = Int32(min(length(sub),length(ptrb),length(ptre)))
  sub_ = sub .- Int32(1)
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  asub_ = asub .- Int32(1)
  aval_ = aval
  @MSK_putacollist64(task.task,num,sub_,ptrb_,ptre_,asub_,aval_)
  nothing
end
function putacollist(task::MSKtask,sub::T0,A:: SparseMatrixCSC{Float64}) where {T0<:AbstractVector{<:Integer}}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacollist(task,sub,ptrb,ptre,asub,aval)
end
function putacollist(task::MSKtask,sub::T0,ptrb::T1,ptre::T2,asub::T3,aval::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putacollist(
    task,
    convert(Vector{Int32},sub),
    convert(Vector{Int64},ptrb),
    convert(Vector{Int64},ptre),
    convert(Vector{Int32},asub),
    convert(Vector{Float64},aval))
end


"""
  putbaraij(task::MSKtask,i::Int32,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
  putbaraij(task::MSKtask,i::T0,j::T1,sub::T2,weights::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

  Inputs an element of barA.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Row index of barA.
    j::Int32 Column index of barA.
    sub::Vector{Int64} Element indexes in matrix storage.
    weights::Vector{Float64} Weights in the weighted sum.
"""
function putbaraij end
function putbaraij(task::MSKtask,i::Int32,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
  num = Int64(min(length(sub),length(weights)))
  sub_ = sub .- Int64(1)
  weights_ = weights
  @MSK_putbaraij(task.task,i-Int32(1),j-Int32(1),num,sub_,weights_)
  nothing
end
function putbaraij(task::MSKtask,i::T0,j::T1,sub::T2,weights::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putbaraij(
    task,
    convert(Int32,i),
    convert(Int32,j),
    convert(Vector{Int64},sub),
    convert(Vector{Float64},weights))
end


"""
  putbaraijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},alphaptrb::Vector{Int64},alphaptre::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
  putbaraijlist(task::MSKtask,subi::T0,subj::T1,alphaptrb::T2,alphaptre::T3,matidx::T4,weights::T5) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 
  putbaraijlist(task::MSKtask,subi::T0,subj::T1,A:: SparseMatrixCSC{Float64})

  Inputs list of elements of barA.

  Arguments
    task::MSKtask An optimization task.
    subi::Vector{Int32} Row index of barA.
    subj::Vector{Int32} Column index of barA.
    alphaptrb::Vector{Int64} Start entries for terms in the weighted sum.
    alphaptre::Vector{Int64} End entries for terms in the weighted sum.
    matidx::Vector{Int64} Element indexes in matrix storage.
    weights::Vector{Float64} Weights in the weighted sum.
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
"""
function putbaraijlist end
function putbaraijlist(task::MSKtask,subi::Vector{Int32},subj::Vector{Int32},alphaptrb::Vector{Int64},alphaptre::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
  num = Int32(min(length(subi),length(subj),length(alphaptrb),length(alphaptre)))
  subi_ = subi .- Int32(1)
  subj_ = subj .- Int32(1)
  alphaptrb_ = alphaptrb
  alphaptre_ = alphaptre
  matidx_ = matidx .- Int64(1)
  weights_ = weights
  @MSK_putbaraijlist(task.task,num,subi_,subj_,alphaptrb_,alphaptre_,matidx_,weights_)
  nothing
end
function putbaraijlist(task::MSKtask,subi::T0,subj::T1,A:: SparseMatrixCSC{Float64}) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer}}
  alphaptrb = A.colptr[1:size(A,2)]
  alphaptre = A.colptr[2:size(A,2)+1]
  matidx = A.rowval
  weights = A.nzval
  putbaraijlist(task,subi,subj,alphaptrb,alphaptre,matidx,weights)
end
function putbaraijlist(task::MSKtask,subi::T0,subj::T1,alphaptrb::T2,alphaptre::T3,matidx::T4,weights::T5) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putbaraijlist(
    task,
    convert(Vector{Int32},subi),
    convert(Vector{Int32},subj),
    convert(Vector{Int64},alphaptrb),
    convert(Vector{Int64},alphaptre),
    convert(Vector{Int64},matidx),
    convert(Vector{Float64},weights))
end


"""
  putbararowlist(task::MSKtask,subi::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},subj::Vector{Int32},nummat::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
  putbararowlist(task::MSKtask,subi::T0,ptrb::T1,ptre::T2,subj::T3,nummat::T4,matidx::T5,weights::T6) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number}} 
  putbararowlist(task::MSKtask,subi::T0,A:: SparseMatrixCSC{Float64},matidx::T5,weights::T6)

  Replace a set of rows of barA

  Arguments
    task::MSKtask An optimization task.
    subi::Vector{Int32} Row indexes of barA.
    ptrb::Vector{Int64} Start of rows in barA.
    ptre::Vector{Int64} End of rows in barA.
    subj::Vector{Int32} Column index of barA.
    nummat::Vector{Int64} Number of entries in weighted sum of matrixes.
    matidx::Vector{Int64} Matrix indexes for weighted sum of matrixes.
    weights::Vector{Float64} Weights for weighted sum of matrixes.
    A::SparseMatrixCSC{{Float64} Sparse matrix defining the column values
"""
function putbararowlist end
function putbararowlist(task::MSKtask,subi::Vector{Int32},ptrb::Vector{Int64},ptre::Vector{Int64},subj::Vector{Int32},nummat::Vector{Int64},matidx::Vector{Int64},weights::Vector{Float64})
  num = Int32(min(length(subi),length(ptrb),length(ptre)))
  subi_ = subi .- Int32(1)
  ptrb_ = ptrb .- Int64(1)
  ptre_ = ptre .- Int64(1)
  subj_ = subj .- Int32(1)
  if length(nummat) < length(subj)
    throw(BoundsError())
  end
  nummat_ = nummat .- Int64(1)
  if length(matidx) < sum(nummat)
    throw(BoundsError())
  end
  matidx_ = matidx .- Int64(1)
  if length(weights) < sum(nummat)
    throw(BoundsError())
  end
  weights_ = weights .- Float64(1)
  @MSK_putbararowlist(task.task,num,subi_,ptrb_,ptre_,subj_,nummat_,matidx_,weights_)
  nothing
end
function putbararowlist(task::MSKtask,subi::T0,A:: SparseMatrixCSC{Float64},matidx::T5,weights::T6) where {T0<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number}}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  subj = A.rowval
  nummat = A.nzval
  putbararowlist(task,subi,ptrb,ptre,subj,nummat,matidx,weights)
end
function putbararowlist(task::MSKtask,subi::T0,ptrb::T1,ptre::T2,subj::T3,nummat::T4,matidx::T5,weights::T6) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number} }
  putbararowlist(
    task,
    convert(Vector{Int32},subi),
    convert(Vector{Int64},ptrb),
    convert(Vector{Int64},ptre),
    convert(Vector{Int32},subj),
    convert(Vector{Int64},nummat),
    convert(Vector{Int64},matidx),
    convert(Vector{Float64},weights))
end


"""
  getnumbarcnz(task::MSKtask) :: nz

  Obtains the number of nonzero elements in barc.

  Arguments
    task::MSKtask An optimization task.
  Returns
    nz::Int64 The number of nonzero elements in barc.
"""
function getnumbarcnz end
function getnumbarcnz(task::MSKtask)
  nz_ = Ref{Int64}()
  @MSK_getnumbarcnz(task.task,nz_)
  nz_[]
end


"""
  getnumbaranz(task::MSKtask) :: nz

  Get the number of nonzero elements in barA.

  Arguments
    task::MSKtask An optimization task.
  Returns
    nz::Int64 The number of nonzero block elements in barA.
"""
function getnumbaranz end
function getnumbaranz(task::MSKtask)
  nz_ = Ref{Int64}()
  @MSK_getnumbaranz(task.task,nz_)
  nz_[]
end


"""
  getbarcsparsity(task::MSKtask) :: (numnz,idxj)

  Get the positions of the nonzero elements in barc.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numnz::Int64 Number of nonzero elements in barc.
    idxj::Vector{Int64} Internal positions of the nonzeros elements in barc.
"""
function getbarcsparsity end
function getbarcsparsity(task::MSKtask)
  __tmp_396 = Ref{Int64}()
  @MSK_getnumbarcnz(task.task,__tmp_396)
  __tmp_395 = __tmp_396[]
  maxnumnz = Int64(__tmp_395)
  numnz_ = Ref{Int64}()
  idxj_ = Vector{Int64}(undef,maxnumnz)
  @MSK_getbarcsparsity(task.task,maxnumnz,numnz_,idxj_)
  idxj = idxj_;
  idxj .+= 1
  numnz_[],idxj
end


"""
  getbarasparsity(task::MSKtask) :: (numnz,idxij)

  Obtains the sparsity pattern of the barA matrix.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numnz::Int64 Number of nonzero elements in barA.
    idxij::Vector{Int64} Position of each nonzero element in the vector representation of barA.
"""
function getbarasparsity end
function getbarasparsity(task::MSKtask)
  __tmp_399 = Ref{Int64}()
  @MSK_getnumbaranz(task.task,__tmp_399)
  __tmp_398 = __tmp_399[]
  maxnumnz = Int64(__tmp_398)
  numnz_ = Ref{Int64}()
  idxij_ = Vector{Int64}(undef,maxnumnz)
  @MSK_getbarasparsity(task.task,maxnumnz,numnz_,idxij_)
  idxij = idxij_;
  idxij .+= 1
  numnz_[],idxij
end


"""
  getbarcidxinfo(task::MSKtask,idx::Int64) :: num
  getbarcidxinfo(task::MSKtask,idx::T0) where {T0<:Integer}  :: num

  Obtains information about an element in barc.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 Index of the element for which information should be obtained. The value is an index of a symmetric sparse variable.
  Returns
    num::Int64 Number of terms that appear in the weighted sum that forms the requested element.
"""
function getbarcidxinfo end
function getbarcidxinfo(task::MSKtask,idx::Int64)
  num_ = Ref{Int64}()
  @MSK_getbarcidxinfo(task.task,idx-Int64(1),num_)
  num_[]
end
function getbarcidxinfo(task::MSKtask,idx::T0) where { T0<:Integer }
  getbarcidxinfo(
    task,
    convert(Int64,idx))
end


"""
  getbarcidxj(task::MSKtask,idx::Int64) :: j
  getbarcidxj(task::MSKtask,idx::T0) where {T0<:Integer}  :: j

  Obtains the row index of an element in barc.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 Index of the element for which information should be obtained.
  Returns
    j::Int32 Row index in barc.
"""
function getbarcidxj end
function getbarcidxj(task::MSKtask,idx::Int64)
  j_ = Ref{Int32}()
  @MSK_getbarcidxj(task.task,idx-Int64(1),j_)
  j_[]+Int32(1)
end
function getbarcidxj(task::MSKtask,idx::T0) where { T0<:Integer }
  getbarcidxj(
    task,
    convert(Int64,idx))
end


"""
  getbarcidx(task::MSKtask,idx::Int64) :: (j,num,sub,weights)
  getbarcidx(task::MSKtask,idx::T0) where {T0<:Integer}  :: (j,num,sub,weights)

  Obtains information about an element in barc.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 Index of the element for which information should be obtained.
  Returns
    j::Int32 Row index in barc.
    num::Int64 Number of terms in the weighted sum.
    sub::Vector{Int64} Elements appearing the weighted sum.
    weights::Vector{Float64} Weights of terms in the weighted sum.
"""
function getbarcidx end
function getbarcidx(task::MSKtask,idx::Int64)
  __tmp_404 = Ref{Int64}()
  @MSK_getbarcidxinfo(task.task,idx-Int64(1),__tmp_404)
  __tmp_403 = __tmp_404[]
  maxnum = Int64(__tmp_403)
  j_ = Ref{Int32}()
  num_ = Ref{Int64}()
  sub_ = Vector{Int64}(undef,maxnum)
  weights_ = Vector{Float64}(undef,maxnum)
  @MSK_getbarcidx(task.task,idx-Int64(1),maxnum,j_,num_,sub_,weights_)
  sub = sub_;
  sub .+= 1
  weights = weights_;
  j_[]+Int32(1),num_[],sub,weights
end
function getbarcidx(task::MSKtask,idx::T0) where { T0<:Integer }
  getbarcidx(
    task,
    convert(Int64,idx))
end


"""
  getbaraidxinfo(task::MSKtask,idx::Int64) :: num
  getbaraidxinfo(task::MSKtask,idx::T0) where {T0<:Integer}  :: num

  Obtains the number of terms in the weighted sum that form a particular element in barA.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 The internal position of the element for which information should be obtained.
  Returns
    num::Int64 Number of terms in the weighted sum that form the specified element in barA.
"""
function getbaraidxinfo end
function getbaraidxinfo(task::MSKtask,idx::Int64)
  num_ = Ref{Int64}()
  @MSK_getbaraidxinfo(task.task,idx-Int64(1),num_)
  num_[]
end
function getbaraidxinfo(task::MSKtask,idx::T0) where { T0<:Integer }
  getbaraidxinfo(
    task,
    convert(Int64,idx))
end


"""
  getbaraidxij(task::MSKtask,idx::Int64) :: (i,j)
  getbaraidxij(task::MSKtask,idx::T0) where {T0<:Integer}  :: (i,j)

  Obtains information about an element in barA.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 Position of the element in the vectorized form.
  Returns
    i::Int32 Row index of the element at position idx.
    j::Int32 Column index of the element at position idx.
"""
function getbaraidxij end
function getbaraidxij(task::MSKtask,idx::Int64)
  i_ = Ref{Int32}()
  j_ = Ref{Int32}()
  @MSK_getbaraidxij(task.task,idx-Int64(1),i_,j_)
  i_[]+Int32(1),j_[]+Int32(1)
end
function getbaraidxij(task::MSKtask,idx::T0) where { T0<:Integer }
  getbaraidxij(
    task,
    convert(Int64,idx))
end


"""
  getbaraidx(task::MSKtask,idx::Int64) :: (i,j,num,sub,weights)
  getbaraidx(task::MSKtask,idx::T0) where {T0<:Integer}  :: (i,j,num,sub,weights)

  Obtains information about an element in barA.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 Position of the element in the vectorized form.
  Returns
    i::Int32 Row index of the element at position idx.
    j::Int32 Column index of the element at position idx.
    num::Int64 Number of terms in weighted sum that forms the element.
    sub::Vector{Int64} A list indexes of the elements from symmetric matrix storage that appear in the weighted sum.
    weights::Vector{Float64} The weights associated with each term in the weighted sum.
"""
function getbaraidx end
function getbaraidx(task::MSKtask,idx::Int64)
  __tmp_409 = Ref{Int64}()
  @MSK_getbaraidxinfo(task.task,idx-Int64(1),__tmp_409)
  __tmp_408 = __tmp_409[]
  maxnum = Int64(__tmp_408)
  i_ = Ref{Int32}()
  j_ = Ref{Int32}()
  num_ = Ref{Int64}()
  sub_ = Vector{Int64}(undef,maxnum)
  weights_ = Vector{Float64}(undef,maxnum)
  @MSK_getbaraidx(task.task,idx-Int64(1),maxnum,i_,j_,num_,sub_,weights_)
  sub = sub_;
  sub .+= 1
  weights = weights_;
  i_[]+Int32(1),j_[]+Int32(1),num_[],sub,weights
end
function getbaraidx(task::MSKtask,idx::T0) where { T0<:Integer }
  getbaraidx(
    task,
    convert(Int64,idx))
end


"""
  getnumbarcblocktriplets(task::MSKtask) :: num

  Obtains an upper bound on the number of elements in the block triplet form of barc.

  Arguments
    task::MSKtask An optimization task.
  Returns
    num::Int64 An upper bound on the number of elements in the block triplet form of barc.
"""
function getnumbarcblocktriplets end
function getnumbarcblocktriplets(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumbarcblocktriplets(task.task,num_)
  num_[]
end


"""
  putbarcblocktriplet(task::MSKtask,num::Int64,subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valjkl::Vector{Float64})
  putbarcblocktriplet(task::MSKtask,num::T0,subj::T1,subk::T2,subl::T3,valjkl::T4) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 

  Inputs barC in block triplet form.

  Arguments
    task::MSKtask An optimization task.
    num::Int64 Number of elements in the block triplet form.
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valjkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function putbarcblocktriplet end
function putbarcblocktriplet(task::MSKtask,num::Int64,subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valjkl::Vector{Float64})
  if length(subj) < num
    throw(BoundsError())
  end
  subj_ = subj .- Int32(1)
  if length(subk) < num
    throw(BoundsError())
  end
  subk_ = subk .- Int32(1)
  if length(subl) < num
    throw(BoundsError())
  end
  subl_ = subl .- Int32(1)
  if length(valjkl) < num
    throw(BoundsError())
  end
  valjkl_ = valjkl
  @MSK_putbarcblocktriplet(task.task,num,subj_,subk_,subl_,valjkl_)
  nothing
end
function putbarcblocktriplet(task::MSKtask,num::T0,subj::T1,subk::T2,subl::T3,valjkl::T4) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putbarcblocktriplet(
    task,
    convert(Int64,num),
    convert(Vector{Int32},subj),
    convert(Vector{Int32},subk),
    convert(Vector{Int32},subl),
    convert(Vector{Float64},valjkl))
end


"""
  getbarcblocktriplet(task::MSKtask) :: (num,subj,subk,subl,valjkl)

  Obtains barC in block triplet form.

  Arguments
    task::MSKtask An optimization task.
  Returns
    num::Int64 Number of elements in the block triplet form.
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valjkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function getbarcblocktriplet end
function getbarcblocktriplet(task::MSKtask)
  __tmp_414 = Ref{Int64}()
  @MSK_getnumbarcblocktriplets(task.task,__tmp_414)
  __tmp_413 = __tmp_414[]
  maxnum = Int64(__tmp_413)
  num_ = Ref{Int64}()
  subj_ = Vector{Int32}(undef,maxnum)
  subk_ = Vector{Int32}(undef,maxnum)
  subl_ = Vector{Int32}(undef,maxnum)
  valjkl_ = Vector{Float64}(undef,maxnum)
  @MSK_getbarcblocktriplet(task.task,maxnum,num_,subj_,subk_,subl_,valjkl_)
  subj = subj_;
  subj .+= 1
  subk = subk_;
  subk .+= 1
  subl = subl_;
  subl .+= 1
  valjkl = valjkl_;
  num_[],subj,subk,subl,valjkl
end


"""
  putbarablocktriplet(task::MSKtask,num::Int64,subi::Vector{Int32},subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valijkl::Vector{Float64})
  putbarablocktriplet(task::MSKtask,num::T0,subi::T1,subj::T2,subk::T3,subl::T4,valijkl::T5) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 

  Inputs barA in block triplet form.

  Arguments
    task::MSKtask An optimization task.
    num::Int64 Number of elements in the block triplet form.
    subi::Vector{Int32} Constraint index.
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valijkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function putbarablocktriplet end
function putbarablocktriplet(task::MSKtask,num::Int64,subi::Vector{Int32},subj::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valijkl::Vector{Float64})
  if length(subi) < num
    throw(BoundsError())
  end
  subi_ = subi .- Int32(1)
  if length(subj) < num
    throw(BoundsError())
  end
  subj_ = subj .- Int32(1)
  if length(subk) < num
    throw(BoundsError())
  end
  subk_ = subk .- Int32(1)
  if length(subl) < num
    throw(BoundsError())
  end
  subl_ = subl .- Int32(1)
  if length(valijkl) < num
    throw(BoundsError())
  end
  valijkl_ = valijkl
  @MSK_putbarablocktriplet(task.task,num,subi_,subj_,subk_,subl_,valijkl_)
  nothing
end
function putbarablocktriplet(task::MSKtask,num::T0,subi::T1,subj::T2,subk::T3,subl::T4,valijkl::T5) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putbarablocktriplet(
    task,
    convert(Int64,num),
    convert(Vector{Int32},subi),
    convert(Vector{Int32},subj),
    convert(Vector{Int32},subk),
    convert(Vector{Int32},subl),
    convert(Vector{Float64},valijkl))
end


"""
  getnumbarablocktriplets(task::MSKtask) :: num

  Obtains an upper bound on the number of scalar elements in the block triplet form of bara.

  Arguments
    task::MSKtask An optimization task.
  Returns
    num::Int64 An upper bound on the number of elements in the block triplet form of bara.
"""
function getnumbarablocktriplets end
function getnumbarablocktriplets(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumbarablocktriplets(task.task,num_)
  num_[]
end


"""
  getbarablocktriplet(task::MSKtask) :: (num,subi,subj,subk,subl,valijkl)

  Obtains barA in block triplet form.

  Arguments
    task::MSKtask An optimization task.
  Returns
    num::Int64 Number of elements in the block triplet form.
    subi::Vector{Int32} Constraint index.
    subj::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valijkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function getbarablocktriplet end
function getbarablocktriplet(task::MSKtask)
  __tmp_419 = Ref{Int64}()
  @MSK_getnumbarablocktriplets(task.task,__tmp_419)
  __tmp_418 = __tmp_419[]
  maxnum = Int64(__tmp_418)
  num_ = Ref{Int64}()
  subi_ = Vector{Int32}(undef,maxnum)
  subj_ = Vector{Int32}(undef,maxnum)
  subk_ = Vector{Int32}(undef,maxnum)
  subl_ = Vector{Int32}(undef,maxnum)
  valijkl_ = Vector{Float64}(undef,maxnum)
  @MSK_getbarablocktriplet(task.task,maxnum,num_,subi_,subj_,subk_,subl_,valijkl_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  subk = subk_;
  subk .+= 1
  subl = subl_;
  subl .+= 1
  valijkl = valijkl_;
  num_[],subi,subj,subk,subl,valijkl
end


"""
  putmaxnumafe(task::MSKtask,maxnumafe::Int64)
  putmaxnumafe(task::MSKtask,maxnumafe::T0) where {T0<:Integer} 

  Sets the number of preallocated affine expressions in the optimization task.

  Arguments
    task::MSKtask An optimization task.
    maxnumafe::Int64 Number of preallocated affine expressions.
"""
function putmaxnumafe end
function putmaxnumafe(task::MSKtask,maxnumafe::Int64)
  @MSK_putmaxnumafe(task.task,maxnumafe)
  nothing
end
function putmaxnumafe(task::MSKtask,maxnumafe::T0) where { T0<:Integer }
  putmaxnumafe(
    task,
    convert(Int64,maxnumafe))
end


"""
  getnumafe(task::MSKtask) :: numafe

  Obtains the number of affine expressions.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numafe::Int64 Number of affine expressions.
"""
function getnumafe end
function getnumafe(task::MSKtask)
  numafe_ = Ref{Int64}()
  @MSK_getnumafe(task.task,numafe_)
  numafe_[]
end


"""
  appendafes(task::MSKtask,num::Int64)
  appendafes(task::MSKtask,num::T0) where {T0<:Integer} 

  Appends a number of empty affine expressions to the optimization task.

  Arguments
    task::MSKtask An optimization task.
    num::Int64 Number of empty affine expressions which should be appended.
"""
function appendafes end
function appendafes(task::MSKtask,num::Int64)
  @MSK_appendafes(task.task,num)
  nothing
end
function appendafes(task::MSKtask,num::T0) where { T0<:Integer }
  appendafes(
    task,
    convert(Int64,num))
end


"""
  putafefentry(task::MSKtask,afeidx::Int64,varidx::Int32,value::Float64)
  putafefentry(task::MSKtask,afeidx::T0,varidx::T1,value::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

  Replaces one entry in F.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index in F.
    varidx::Int32 Column index in F.
    value::Float64 Value of the entry.
"""
function putafefentry end
function putafefentry(task::MSKtask,afeidx::Int64,varidx::Int32,value::Float64)
  @MSK_putafefentry(task.task,afeidx-Int64(1),varidx-Int32(1),value)
  nothing
end
function putafefentry(task::MSKtask,afeidx::T0,varidx::T1,value::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putafefentry(
    task,
    convert(Int64,afeidx),
    convert(Int32,varidx),
    convert(Float64,value))
end


"""
  putafefentrylist(task::MSKtask,afeidx::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
  putafefentrylist(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Replaces a list of entries in F.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Vector{Int64} Row indices in F.
    varidx::Vector{Int32} Column indices in F.
    val::Vector{Float64} Values of the entries in F.
"""
function putafefentrylist end
function putafefentrylist(task::MSKtask,afeidx::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
  numentr = Int64(min(length(afeidx),length(varidx),length(val)))
  afeidx_ = afeidx .- Int64(1)
  varidx_ = varidx .- Int32(1)
  val_ = val
  @MSK_putafefentrylist(task.task,numentr,afeidx_,varidx_,val_)
  nothing
end
function putafefentrylist(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putafefentrylist(
    task,
    convert(Vector{Int64},afeidx),
    convert(Vector{Int32},varidx),
    convert(Vector{Float64},val))
end


"""
  emptyafefrow(task::MSKtask,afeidx::Int64)
  emptyafefrow(task::MSKtask,afeidx::T0) where {T0<:Integer} 

  Clears a row in F.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index.
"""
function emptyafefrow end
function emptyafefrow(task::MSKtask,afeidx::Int64)
  @MSK_emptyafefrow(task.task,afeidx-Int64(1))
  nothing
end
function emptyafefrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  emptyafefrow(
    task,
    convert(Int64,afeidx))
end


"""
  emptyafefcol(task::MSKtask,varidx::Int32)
  emptyafefcol(task::MSKtask,varidx::T0) where {T0<:Integer} 

  Clears a column in F.

  Arguments
    task::MSKtask An optimization task.
    varidx::Int32 Variable index.
"""
function emptyafefcol end
function emptyafefcol(task::MSKtask,varidx::Int32)
  @MSK_emptyafefcol(task.task,varidx-Int32(1))
  nothing
end
function emptyafefcol(task::MSKtask,varidx::T0) where { T0<:Integer }
  emptyafefcol(
    task,
    convert(Int32,varidx))
end


"""
  emptyafefrowlist(task::MSKtask,afeidx::Vector{Int64})
  emptyafefrowlist(task::MSKtask,afeidx::T0) where {T0<:AbstractVector{<:Integer}} 

  Clears rows in F.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Vector{Int64} Indices of rows in F to clear.
"""
function emptyafefrowlist end
function emptyafefrowlist(task::MSKtask,afeidx::Vector{Int64})
  numafeidx = Int64(length(afeidx))
  afeidx_ = afeidx .- Int64(1)
  @MSK_emptyafefrowlist(task.task,numafeidx,afeidx_)
  nothing
end
function emptyafefrowlist(task::MSKtask,afeidx::T0) where { T0<:AbstractVector{<:Integer} }
  emptyafefrowlist(
    task,
    convert(Vector{Int64},afeidx))
end


"""
  emptyafefcollist(task::MSKtask,varidx::Vector{Int32})
  emptyafefcollist(task::MSKtask,varidx::T0) where {T0<:AbstractVector{<:Integer}} 

  Clears columns in F.

  Arguments
    task::MSKtask An optimization task.
    varidx::Vector{Int32} Indices of variables in F to clear.
"""
function emptyafefcollist end
function emptyafefcollist(task::MSKtask,varidx::Vector{Int32})
  numvaridx = Int64(length(varidx))
  varidx_ = varidx .- Int32(1)
  @MSK_emptyafefcollist(task.task,numvaridx,varidx_)
  nothing
end
function emptyafefcollist(task::MSKtask,varidx::T0) where { T0<:AbstractVector{<:Integer} }
  emptyafefcollist(
    task,
    convert(Vector{Int32},varidx))
end


"""
  putafefrow(task::MSKtask,afeidx::Int64,varidx::Vector{Int32},val::Vector{Float64})
  putafefrow(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Replaces all elements in one row of the F matrix in the affine expressions.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index.
    varidx::Vector{Int32} Column indexes of non-zero values in the row.
    val::Vector{Float64} New non-zero values in the row.
"""
function putafefrow end
function putafefrow(task::MSKtask,afeidx::Int64,varidx::Vector{Int32},val::Vector{Float64})
  numnz = Int32(min(length(varidx),length(val)))
  varidx_ = varidx .- Int32(1)
  val_ = val
  @MSK_putafefrow(task.task,afeidx-Int64(1),numnz,varidx_,val_)
  nothing
end
function putafefrow(task::MSKtask,afeidx::T0,varidx::T1,val::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putafefrow(
    task,
    convert(Int64,afeidx),
    convert(Vector{Int32},varidx),
    convert(Vector{Float64},val))
end


"""
  putafefrowlist(task::MSKtask,afeidx::Vector{Int64},numnzrow::Vector{Int32},ptrrow::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
  putafefrowlist(task::MSKtask,afeidx::T0,numnzrow::T1,ptrrow::T2,varidx::T3,val::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}} 

  Replaces all elements in a number of rows of the F matrix in the affine expressions.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Vector{Int64} Row indices.
    numnzrow::Vector{Int32} Number of non-zeros in each row.
    ptrrow::Vector{Int64} Pointer to the first nonzero in each row.
    varidx::Vector{Int32} Column indexes of non-zero values.
    val::Vector{Float64} New non-zero values in the rows.
"""
function putafefrowlist end
function putafefrowlist(task::MSKtask,afeidx::Vector{Int64},numnzrow::Vector{Int32},ptrrow::Vector{Int64},varidx::Vector{Int32},val::Vector{Float64})
  numafeidx = Int64(min(length(afeidx),length(numnzrow),length(ptrrow)))
  afeidx_ = afeidx .- Int64(1)
  numnzrow_ = numnzrow
  ptrrow_ = ptrrow .- Int64(1)
  lenidxval = Int64(min(length(varidx),length(val)))
  varidx_ = varidx .- Int32(1)
  val_ = val
  @MSK_putafefrowlist(task.task,numafeidx,afeidx_,numnzrow_,ptrrow_,lenidxval,varidx_,val_)
  nothing
end
function putafefrowlist(task::MSKtask,afeidx::T0,numnzrow::T1,ptrrow::T2,varidx::T3,val::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  putafefrowlist(
    task,
    convert(Vector{Int64},afeidx),
    convert(Vector{Int32},numnzrow),
    convert(Vector{Int64},ptrrow),
    convert(Vector{Int32},varidx),
    convert(Vector{Float64},val))
end


"""
  putafefcol(task::MSKtask,varidx::Int32,afeidx::Vector{Int64},val::Vector{Float64})
  putafefcol(task::MSKtask,varidx::T0,afeidx::T1,val::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Replaces all elements in one column of the F matrix in the affine expressions.

  Arguments
    task::MSKtask An optimization task.
    varidx::Int32 Column index.
    afeidx::Vector{Int64} Row indexes of non-zero values in the column.
    val::Vector{Float64} New non-zero values in the column.
"""
function putafefcol end
function putafefcol(task::MSKtask,varidx::Int32,afeidx::Vector{Int64},val::Vector{Float64})
  numnz = Int64(min(length(afeidx),length(val)))
  afeidx_ = afeidx .- Int64(1)
  val_ = val
  @MSK_putafefcol(task.task,varidx-Int32(1),numnz,afeidx_,val_)
  nothing
end
function putafefcol(task::MSKtask,varidx::T0,afeidx::T1,val::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putafefcol(
    task,
    convert(Int32,varidx),
    convert(Vector{Int64},afeidx),
    convert(Vector{Float64},val))
end


"""
  getafefrownumnz(task::MSKtask,afeidx::Int64) :: numnz
  getafefrownumnz(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: numnz

  Obtains the number of nonzeros in a row of F.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index.
  Returns
    numnz::Int32 Number of non-zeros in the row.
"""
function getafefrownumnz end
function getafefrownumnz(task::MSKtask,afeidx::Int64)
  numnz_ = Ref{Int32}()
  @MSK_getafefrownumnz(task.task,afeidx-Int64(1),numnz_)
  numnz_[]
end
function getafefrownumnz(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafefrownumnz(
    task,
    convert(Int64,afeidx))
end


"""
  getafefnumnz(task::MSKtask) :: numnz

  Obtains the total number of nonzeros in F.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numnz::Int64 Number of nonzeros in F.
"""
function getafefnumnz end
function getafefnumnz(task::MSKtask)
  numnz_ = Ref{Int64}()
  @MSK_getafefnumnz(task.task,numnz_)
  numnz_[]
end


"""
  getafefrow(task::MSKtask,afeidx::Int64) :: (numnz,varidx,val)
  getafefrow(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: (numnz,varidx,val)

  Obtains one row of F in sparse format.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index.
  Returns
    numnz::Int32 Number of non-zeros in the row obtained.
    varidx::Vector{Int32} Column indices of the non-zeros in the row obtained.
    val::Vector{Float64} Values of the non-zeros in the row obtained.
"""
function getafefrow end
function getafefrow(task::MSKtask,afeidx::Int64)
  numnz_ = Ref{Int32}()
  __tmp_436 = Ref{Int32}()
  @MSK_getafefrownumnz(task.task,afeidx-Int64(1),__tmp_436)
  __tmp_435 = __tmp_436[]
  varidx_ = Vector{Int32}(undef,__tmp_435)
  __tmp_438 = Ref{Int32}()
  @MSK_getafefrownumnz(task.task,afeidx-Int64(1),__tmp_438)
  __tmp_437 = __tmp_438[]
  val_ = Vector{Float64}(undef,__tmp_437)
  @MSK_getafefrow(task.task,afeidx-Int64(1),numnz_,varidx_,val_)
  varidx = varidx_;
  varidx .+= 1
  val = val_;
  numnz_[],varidx,val
end
function getafefrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafefrow(
    task,
    convert(Int64,afeidx))
end


"""
  getafeftrip(task::MSKtask) :: (afeidx,varidx,val)

  Obtains the F matrix in triplet format.

  Arguments
    task::MSKtask An optimization task.
  Returns
    afeidx::Vector{Int64} Row indices of nonzeros.
    varidx::Vector{Int32} Column indices of nonzeros.
    val::Vector{Float64} Values of nonzero entries.
"""
function getafeftrip end
function getafeftrip(task::MSKtask)
  __tmp_441 = Ref{Int64}()
  @MSK_getafefnumnz(task.task,__tmp_441)
  __tmp_440 = __tmp_441[]
  afeidx_ = Vector{Int64}(undef,__tmp_440)
  __tmp_443 = Ref{Int64}()
  @MSK_getafefnumnz(task.task,__tmp_443)
  __tmp_442 = __tmp_443[]
  varidx_ = Vector{Int32}(undef,__tmp_442)
  __tmp_445 = Ref{Int64}()
  @MSK_getafefnumnz(task.task,__tmp_445)
  __tmp_444 = __tmp_445[]
  val_ = Vector{Float64}(undef,__tmp_444)
  @MSK_getafeftrip(task.task,afeidx_,varidx_,val_)
  afeidx = afeidx_;
  afeidx .+= 1
  varidx = varidx_;
  varidx .+= 1
  val = val_;
  afeidx,varidx,val
end


"""
  putafebarfentry(task::MSKtask,afeidx::Int64,barvaridx::Int32,termidx::Vector{Int64},termweight::Vector{Float64})
  putafebarfentry(task::MSKtask,afeidx::T0,barvaridx::T1,termidx::T2,termweight::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

  Inputs one entry in barF.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index of barF.
    barvaridx::Int32 Semidefinite variable index.
    termidx::Vector{Int64} Element indices in matrix storage.
    termweight::Vector{Float64} Weights in the weighted sum.
"""
function putafebarfentry end
function putafebarfentry(task::MSKtask,afeidx::Int64,barvaridx::Int32,termidx::Vector{Int64},termweight::Vector{Float64})
  numterm = Int64(min(length(termidx),length(termweight)))
  termidx_ = termidx .- Int64(1)
  termweight_ = termweight
  @MSK_putafebarfentry(task.task,afeidx-Int64(1),barvaridx-Int32(1),numterm,termidx_,termweight_)
  nothing
end
function putafebarfentry(task::MSKtask,afeidx::T0,barvaridx::T1,termidx::T2,termweight::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putafebarfentry(
    task,
    convert(Int64,afeidx),
    convert(Int32,barvaridx),
    convert(Vector{Int64},termidx),
    convert(Vector{Float64},termweight))
end


"""
  putafebarfentrylist(task::MSKtask,afeidx::Vector{Int64},barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
  putafebarfentrylist(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 

  Inputs a list of entries in barF.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Vector{Int64} Row indexes of barF.
    barvaridx::Vector{Int32} Semidefinite variable indexes.
    numterm::Vector{Int64} Number of terms in the weighted sums.
    ptrterm::Vector{Int64} Pointer to the terms forming each entry.
    termidx::Vector{Int64} Concatenated element indexes in matrix storage.
    termweight::Vector{Float64} Concatenated weights in the weighted sum.
"""
function putafebarfentrylist end
function putafebarfentrylist(task::MSKtask,afeidx::Vector{Int64},barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
  numafeidx = Int64(min(length(afeidx),length(barvaridx),length(numterm),length(ptrterm)))
  afeidx_ = afeidx .- Int64(1)
  barvaridx_ = barvaridx .- Int32(1)
  numterm_ = numterm .- Int64(1)
  ptrterm_ = ptrterm .- Int64(1)
  lenterm = Int64(min(length(termidx),length(termweight)))
  termidx_ = termidx .- Int64(1)
  termweight_ = termweight
  @MSK_putafebarfentrylist(task.task,numafeidx,afeidx_,barvaridx_,numterm_,ptrterm_,lenterm,termidx_,termweight_)
  nothing
end
function putafebarfentrylist(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putafebarfentrylist(
    task,
    convert(Vector{Int64},afeidx),
    convert(Vector{Int32},barvaridx),
    convert(Vector{Int64},numterm),
    convert(Vector{Int64},ptrterm),
    convert(Vector{Int64},termidx),
    convert(Vector{Float64},termweight))
end


"""
  putafebarfrow(task::MSKtask,afeidx::Int64,barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
  putafebarfrow(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 

  Inputs a row of barF.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index of barF.
    barvaridx::Vector{Int32} Semidefinite variable indexes.
    numterm::Vector{Int64} Number of terms in the weighted sums.
    ptrterm::Vector{Int64} Pointer to the terms forming each entry.
    termidx::Vector{Int64} Concatenated element indexes in matrix storage.
    termweight::Vector{Float64} Concatenated weights in the weighted sum.
"""
function putafebarfrow end
function putafebarfrow(task::MSKtask,afeidx::Int64,barvaridx::Vector{Int32},numterm::Vector{Int64},ptrterm::Vector{Int64},termidx::Vector{Int64},termweight::Vector{Float64})
  numentr = Int32(min(length(barvaridx),length(numterm),length(ptrterm)))
  barvaridx_ = barvaridx .- Int32(1)
  numterm_ = numterm
  ptrterm_ = ptrterm .- Int64(1)
  lenterm = Int64(min(length(termidx),length(termweight)))
  termidx_ = termidx .- Int64(1)
  termweight_ = termweight
  @MSK_putafebarfrow(task.task,afeidx-Int64(1),numentr,barvaridx_,numterm_,ptrterm_,lenterm,termidx_,termweight_)
  nothing
end
function putafebarfrow(task::MSKtask,afeidx::T0,barvaridx::T1,numterm::T2,ptrterm::T3,termidx::T4,termweight::T5) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putafebarfrow(
    task,
    convert(Int64,afeidx),
    convert(Vector{Int32},barvaridx),
    convert(Vector{Int64},numterm),
    convert(Vector{Int64},ptrterm),
    convert(Vector{Int64},termidx),
    convert(Vector{Float64},termweight))
end


"""
  emptyafebarfrow(task::MSKtask,afeidx::Int64)
  emptyafebarfrow(task::MSKtask,afeidx::T0) where {T0<:Integer} 

  Clears a row in barF

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index of barF.
"""
function emptyafebarfrow end
function emptyafebarfrow(task::MSKtask,afeidx::Int64)
  @MSK_emptyafebarfrow(task.task,afeidx-Int64(1))
  nothing
end
function emptyafebarfrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  emptyafebarfrow(
    task,
    convert(Int64,afeidx))
end


"""
  emptyafebarfrowlist(task::MSKtask,afeidxlist::Vector{Int64})
  emptyafebarfrowlist(task::MSKtask,afeidxlist::T0) where {T0<:AbstractVector{<:Integer}} 

  Clears rows in barF.

  Arguments
    task::MSKtask An optimization task.
    afeidxlist::Vector{Int64} Indices of rows in barF to clear.
"""
function emptyafebarfrowlist end
function emptyafebarfrowlist(task::MSKtask,afeidxlist::Vector{Int64})
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  @MSK_emptyafebarfrowlist(task.task,numafeidx,afeidxlist_)
  nothing
end
function emptyafebarfrowlist(task::MSKtask,afeidxlist::T0) where { T0<:AbstractVector{<:Integer} }
  emptyafebarfrowlist(
    task,
    convert(Vector{Int64},afeidxlist))
end


"""
  putafebarfblocktriplet(task::MSKtask,numtrip::Int64,afeidx::Vector{Int64},barvaridx::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valkl::Vector{Float64})
  putafebarfblocktriplet(task::MSKtask,numtrip::T0,afeidx::T1,barvaridx::T2,subk::T3,subl::T4,valkl::T5) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number}} 

  Inputs barF in block triplet form.

  Arguments
    task::MSKtask An optimization task.
    numtrip::Int64 Number of elements in the block triplet form.
    afeidx::Vector{Int64} Constraint index.
    barvaridx::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function putafebarfblocktriplet end
function putafebarfblocktriplet(task::MSKtask,numtrip::Int64,afeidx::Vector{Int64},barvaridx::Vector{Int32},subk::Vector{Int32},subl::Vector{Int32},valkl::Vector{Float64})
  if length(afeidx) < numtrip
    throw(BoundsError())
  end
  afeidx_ = afeidx .- Int64(1)
  if length(barvaridx) < numtrip
    throw(BoundsError())
  end
  barvaridx_ = barvaridx .- Int32(1)
  if length(subk) < numtrip
    throw(BoundsError())
  end
  subk_ = subk .- Int32(1)
  if length(subl) < numtrip
    throw(BoundsError())
  end
  subl_ = subl .- Int32(1)
  if length(valkl) < numtrip
    throw(BoundsError())
  end
  valkl_ = valkl
  @MSK_putafebarfblocktriplet(task.task,numtrip,afeidx_,barvaridx_,subk_,subl_,valkl_)
  nothing
end
function putafebarfblocktriplet(task::MSKtask,numtrip::T0,afeidx::T1,barvaridx::T2,subk::T3,subl::T4,valkl::T5) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Number} }
  putafebarfblocktriplet(
    task,
    convert(Int64,numtrip),
    convert(Vector{Int64},afeidx),
    convert(Vector{Int32},barvaridx),
    convert(Vector{Int32},subk),
    convert(Vector{Int32},subl),
    convert(Vector{Float64},valkl))
end


"""
  getafebarfnumblocktriplets(task::MSKtask) :: numtrip

  Obtains an upper bound on the number of elements in the block triplet form of barf.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numtrip::Int64 An upper bound on the number of elements in the block triplet form of barf.
"""
function getafebarfnumblocktriplets end
function getafebarfnumblocktriplets(task::MSKtask)
  numtrip_ = Ref{Int64}()
  @MSK_getafebarfnumblocktriplets(task.task,numtrip_)
  numtrip_[]
end


"""
  getafebarfblocktriplet(task::MSKtask) :: (numtrip,afeidx,barvaridx,subk,subl,valkl)

  Obtains barF in block triplet form.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numtrip::Int64 Number of elements in the block triplet form.
    afeidx::Vector{Int64} Constraint index.
    barvaridx::Vector{Int32} Symmetric matrix variable index.
    subk::Vector{Int32} Block row index.
    subl::Vector{Int32} Block column index.
    valkl::Vector{Float64} The numerical value associated with each block triplet.
"""
function getafebarfblocktriplet end
function getafebarfblocktriplet(task::MSKtask)
  __tmp_455 = Ref{Int64}()
  @MSK_getafebarfnumblocktriplets(task.task,__tmp_455)
  __tmp_454 = __tmp_455[]
  maxnumtrip = Int64(__tmp_454)
  numtrip_ = Ref{Int64}()
  afeidx_ = Vector{Int64}(undef,maxnumtrip)
  barvaridx_ = Vector{Int32}(undef,maxnumtrip)
  subk_ = Vector{Int32}(undef,maxnumtrip)
  subl_ = Vector{Int32}(undef,maxnumtrip)
  valkl_ = Vector{Float64}(undef,maxnumtrip)
  @MSK_getafebarfblocktriplet(task.task,maxnumtrip,numtrip_,afeidx_,barvaridx_,subk_,subl_,valkl_)
  afeidx = afeidx_;
  afeidx .+= 1
  barvaridx = barvaridx_;
  barvaridx .+= 1
  subk = subk_;
  subk .+= 1
  subl = subl_;
  subl .+= 1
  valkl = valkl_;
  numtrip_[],afeidx,barvaridx,subk,subl,valkl
end


"""
  getafebarfnumrowentries(task::MSKtask,afeidx::Int64) :: numentr
  getafebarfnumrowentries(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: numentr

  Obtains the number of nonzero entries in a row of barF.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index of barF.
  Returns
    numentr::Int32 Number of nonzero entries in a row of barF.
"""
function getafebarfnumrowentries end
function getafebarfnumrowentries(task::MSKtask,afeidx::Int64)
  numentr_ = Ref{Int32}()
  @MSK_getafebarfnumrowentries(task.task,afeidx-Int64(1),numentr_)
  numentr_[]
end
function getafebarfnumrowentries(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafebarfnumrowentries(
    task,
    convert(Int64,afeidx))
end


"""
  getafebarfrowinfo(task::MSKtask,afeidx::Int64) :: (numentr,numterm)
  getafebarfrowinfo(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: (numentr,numterm)

  Obtains information about one row of barF.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index of barF.
  Returns
    numentr::Int32 Number of nonzero entries in a row of barF.
    numterm::Int64 Number of terms in the weighted sums representation of the row of barF.
"""
function getafebarfrowinfo end
function getafebarfrowinfo(task::MSKtask,afeidx::Int64)
  numentr_ = Ref{Int32}()
  numterm_ = Ref{Int64}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),numentr_,numterm_)
  numentr_[],numterm_[]
end
function getafebarfrowinfo(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafebarfrowinfo(
    task,
    convert(Int64,afeidx))
end


"""
  getafebarfrow(task::MSKtask,afeidx::Int64) :: (barvaridx,ptrterm,numterm,termidx,termweight)
  getafebarfrow(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: (barvaridx,ptrterm,numterm,termidx,termweight)

  Obtains nonzero entries in one row of barF.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index of barF.
  Returns
    barvaridx::Vector{Int32} Semidefinite variable indices.
    ptrterm::Vector{Int64} Pointers to the description of entries.
    numterm::Vector{Int64} Number of terms in each entry.
    termidx::Vector{Int64} Indices of semidefinite matrices from E.
    termweight::Vector{Float64} Weights appearing in the weighted sum representation.
"""
function getafebarfrow end
function getafebarfrow(task::MSKtask,afeidx::Int64)
  __tmp_460 = Ref{Int32}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),__tmp_460,Ref{Int64}())
  __tmp_459 = __tmp_460[]
  barvaridx_ = Vector{Int32}(undef,__tmp_459)
  __tmp_462 = Ref{Int32}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),__tmp_462,Ref{Int64}())
  __tmp_461 = __tmp_462[]
  ptrterm_ = Vector{Int64}(undef,__tmp_461)
  __tmp_464 = Ref{Int32}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),__tmp_464,Ref{Int64}())
  __tmp_463 = __tmp_464[]
  numterm_ = Vector{Int64}(undef,__tmp_463)
  __tmp_466 = Ref{Int64}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),Ref{Int32}(),__tmp_466)
  __tmp_465 = __tmp_466[]
  termidx_ = Vector{Int64}(undef,__tmp_465)
  __tmp_468 = Ref{Int64}()
  @MSK_getafebarfrowinfo(task.task,afeidx-Int64(1),Ref{Int32}(),__tmp_468)
  __tmp_467 = __tmp_468[]
  termweight_ = Vector{Float64}(undef,__tmp_467)
  @MSK_getafebarfrow(task.task,afeidx-Int64(1),barvaridx_,ptrterm_,numterm_,termidx_,termweight_)
  barvaridx = barvaridx_;
  barvaridx .+= 1
  ptrterm = ptrterm_;
  ptrterm .+= 1
  numterm = numterm_;
  termidx = termidx_;
  termidx .+= 1
  termweight = termweight_;
  barvaridx,ptrterm,numterm,termidx,termweight
end
function getafebarfrow(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafebarfrow(
    task,
    convert(Int64,afeidx))
end


"""
  putafeg(task::MSKtask,afeidx::Int64,g::Float64)
  putafeg(task::MSKtask,afeidx::T0,g::T1) where {T0<:Integer,T1<:Number} 

  Replaces one element in the g vector in the affine expressions.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Row index.
    g::Float64 New value for the element of g.
"""
function putafeg end
function putafeg(task::MSKtask,afeidx::Int64,g::Float64)
  @MSK_putafeg(task.task,afeidx-Int64(1),g)
  nothing
end
function putafeg(task::MSKtask,afeidx::T0,g::T1) where { T0<:Integer,T1<:Number }
  putafeg(
    task,
    convert(Int64,afeidx),
    convert(Float64,g))
end


"""
  putafeglist(task::MSKtask,afeidx::Vector{Int64},g::Vector{Float64})
  putafeglist(task::MSKtask,afeidx::T0,g::T1) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number}} 

  Replaces a list of elements in the g vector in the affine expressions.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Vector{Int64} Indices of entries in g.
    g::Vector{Float64} New values for the elements of g.
"""
function putafeglist end
function putafeglist(task::MSKtask,afeidx::Vector{Int64},g::Vector{Float64})
  numafeidx = Int64(min(length(afeidx),length(g)))
  afeidx_ = afeidx .- Int64(1)
  g_ = g
  @MSK_putafeglist(task.task,numafeidx,afeidx_,g_)
  nothing
end
function putafeglist(task::MSKtask,afeidx::T0,g::T1) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number} }
  putafeglist(
    task,
    convert(Vector{Int64},afeidx),
    convert(Vector{Float64},g))
end


"""
  getafeg(task::MSKtask,afeidx::Int64) :: g
  getafeg(task::MSKtask,afeidx::T0) where {T0<:Integer}  :: g

  Obtains a single coefficient in g.

  Arguments
    task::MSKtask An optimization task.
    afeidx::Int64 Element index.
  Returns
    g::Float64 The entry in g.
"""
function getafeg end
function getafeg(task::MSKtask,afeidx::Int64)
  g_ = Ref{Float64}()
  @MSK_getafeg(task.task,afeidx-Int64(1),g_)
  g_[]
end
function getafeg(task::MSKtask,afeidx::T0) where { T0<:Integer }
  getafeg(
    task,
    convert(Int64,afeidx))
end


"""
  getafegslice(task::MSKtask,first::Int64,last::Int64) :: g
  getafegslice(task::MSKtask,first::T0,last::T1) where {T0<:Integer,T1<:Integer}  :: g

  Obtains a sequence of coefficients from the vector g.

  Arguments
    task::MSKtask An optimization task.
    first::Int64 First index in the sequence.
    last::Int64 Last index plus 1 in the sequence.
  Returns
    g::Vector{Float64} The slice of g as a dense vector.
"""
function getafegslice end
function getafegslice(task::MSKtask,first::Int64,last::Int64)
  g_ = Vector{Float64}(undef,(last - first))
  @MSK_getafegslice(task.task,first-Int64(1),last-Int64(1),g_)
  g = g_;
  g
end
function getafegslice(task::MSKtask,first::T0,last::T1) where { T0<:Integer,T1<:Integer }
  getafegslice(
    task,
    convert(Int64,first),
    convert(Int64,last))
end


"""
  putafegslice(task::MSKtask,first::Int64,last::Int64,slice::Vector{Float64})
  putafegslice(task::MSKtask,first::T0,last::T1,slice::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Modifies a slice of the vector g.

  Arguments
    task::MSKtask An optimization task.
    first::Int64 First index in the sequence.
    last::Int64 Last index plus 1 in the sequence.
    slice::Vector{Float64} The slice of g as a dense vector.
"""
function putafegslice end
function putafegslice(task::MSKtask,first::Int64,last::Int64,slice::Vector{Float64})
  if length(slice) < (last - first)
    throw(BoundsError())
  end
  slice_ = slice
  @MSK_putafegslice(task.task,first-Int64(1),last-Int64(1),slice_)
  nothing
end
function putafegslice(task::MSKtask,first::T0,last::T1,slice::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putafegslice(
    task,
    convert(Int64,first),
    convert(Int64,last),
    convert(Vector{Float64},slice))
end


"""
  putmaxnumdjc(task::MSKtask,maxnumdjc::Int64)
  putmaxnumdjc(task::MSKtask,maxnumdjc::T0) where {T0<:Integer} 

  Sets the number of preallocated disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
    maxnumdjc::Int64 Number of preallocated disjunctive constraints in the task.
"""
function putmaxnumdjc end
function putmaxnumdjc(task::MSKtask,maxnumdjc::Int64)
  @MSK_putmaxnumdjc(task.task,maxnumdjc)
  nothing
end
function putmaxnumdjc(task::MSKtask,maxnumdjc::T0) where { T0<:Integer }
  putmaxnumdjc(
    task,
    convert(Int64,maxnumdjc))
end


"""
  getnumdjc(task::MSKtask) :: num

  Obtains the number of disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    num::Int64 The number of disjunctive constraints.
"""
function getnumdjc end
function getnumdjc(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumdjc(task.task,num_)
  num_[]
end


"""
  getdjcnumdomain(task::MSKtask,djcidx::Int64) :: numdomain
  getdjcnumdomain(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: numdomain

  Obtains the number of domains in the disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
  Returns
    numdomain::Int64 Number of domains in the disjunctive constraint.
"""
function getdjcnumdomain end
function getdjcnumdomain(task::MSKtask,djcidx::Int64)
  numdomain_ = Ref{Int64}()
  @MSK_getdjcnumdomain(task.task,djcidx-Int64(1),numdomain_)
  numdomain_[]
end
function getdjcnumdomain(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnumdomain(
    task,
    convert(Int64,djcidx))
end


"""
  getdjcnumdomaintot(task::MSKtask) :: numdomaintot

  Obtains the number of domains in all disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numdomaintot::Int64 Number of domains in all disjunctive constraints.
"""
function getdjcnumdomaintot end
function getdjcnumdomaintot(task::MSKtask)
  numdomaintot_ = Ref{Int64}()
  @MSK_getdjcnumdomaintot(task.task,numdomaintot_)
  numdomaintot_[]
end


"""
  getdjcnumafe(task::MSKtask,djcidx::Int64) :: numafe
  getdjcnumafe(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: numafe

  Obtains the number of affine expressions in the disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
  Returns
    numafe::Int64 Number of affine expressions in the disjunctive constraint.
"""
function getdjcnumafe end
function getdjcnumafe(task::MSKtask,djcidx::Int64)
  numafe_ = Ref{Int64}()
  @MSK_getdjcnumafe(task.task,djcidx-Int64(1),numafe_)
  numafe_[]
end
function getdjcnumafe(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnumafe(
    task,
    convert(Int64,djcidx))
end


"""
  getdjcnumafetot(task::MSKtask) :: numafetot

  Obtains the number of affine expressions in all disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numafetot::Int64 Number of affine expressions in all disjunctive constraints.
"""
function getdjcnumafetot end
function getdjcnumafetot(task::MSKtask)
  numafetot_ = Ref{Int64}()
  @MSK_getdjcnumafetot(task.task,numafetot_)
  numafetot_[]
end


"""
  getdjcnumterm(task::MSKtask,djcidx::Int64) :: numterm
  getdjcnumterm(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: numterm

  Obtains the number terms in the disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
  Returns
    numterm::Int64 Number of terms in the disjunctive constraint.
"""
function getdjcnumterm end
function getdjcnumterm(task::MSKtask,djcidx::Int64)
  numterm_ = Ref{Int64}()
  @MSK_getdjcnumterm(task.task,djcidx-Int64(1),numterm_)
  numterm_[]
end
function getdjcnumterm(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcnumterm(
    task,
    convert(Int64,djcidx))
end


"""
  getdjcnumtermtot(task::MSKtask) :: numtermtot

  Obtains the number of terms in all disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numtermtot::Int64 Total number of terms in all disjunctive constraints.
"""
function getdjcnumtermtot end
function getdjcnumtermtot(task::MSKtask)
  numtermtot_ = Ref{Int64}()
  @MSK_getdjcnumtermtot(task.task,numtermtot_)
  numtermtot_[]
end


"""
  putmaxnumacc(task::MSKtask,maxnumacc::Int64)
  putmaxnumacc(task::MSKtask,maxnumacc::T0) where {T0<:Integer} 

  Sets the number of preallocated affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
    maxnumacc::Int64 Number of preallocated affine conic constraints.
"""
function putmaxnumacc end
function putmaxnumacc(task::MSKtask,maxnumacc::Int64)
  @MSK_putmaxnumacc(task.task,maxnumacc)
  nothing
end
function putmaxnumacc(task::MSKtask,maxnumacc::T0) where { T0<:Integer }
  putmaxnumacc(
    task,
    convert(Int64,maxnumacc))
end


"""
  getnumacc(task::MSKtask) :: num

  Obtains the number of affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    num::Int64 The number of affine conic constraints.
"""
function getnumacc end
function getnumacc(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumacc(task.task,num_)
  num_[]
end


"""
  appendacc(task::MSKtask,domidx::Int64,afeidxlist::Vector{Int64},b::Vector{Float64})
  appendacc(task::MSKtask,domidx::T0,afeidxlist::T1,b::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Appends an affine conic constraint to the task.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Domain index.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, can be NULL.
"""
function appendacc end
function appendacc(task::MSKtask,domidx::Int64,afeidxlist::Vector{Int64},b::Vector{Float64})
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  @MSK_appendacc(task.task,domidx-Int64(1),numafeidx,afeidxlist_,b_)
  nothing
end
function appendacc(task::MSKtask,domidx::T0,afeidxlist::T1,b::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  appendacc(
    task,
    convert(Int64,domidx),
    convert(Vector{Int64},afeidxlist),
    convert(Vector{Float64},b))
end


"""
  appendaccs(task::MSKtask,domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64})
  appendaccs(task::MSKtask,domidxs::T0,afeidxlist::T1,b::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Appends a number of affine conic constraint to the task.

  Arguments
    task::MSKtask An optimization task.
    domidxs::Vector{Int64} Domain indices.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, can be NULL.
"""
function appendaccs end
function appendaccs(task::MSKtask,domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64})
  numaccs = Int64(length(domidxs))
  domidxs_ = domidxs .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  @MSK_appendaccs(task.task,numaccs,domidxs_,numafeidx,afeidxlist_,b_)
  nothing
end
function appendaccs(task::MSKtask,domidxs::T0,afeidxlist::T1,b::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  appendaccs(
    task,
    convert(Vector{Int64},domidxs),
    convert(Vector{Int64},afeidxlist),
    convert(Vector{Float64},b))
end


"""
  appendaccseq(task::MSKtask,domidx::Int64,afeidxfirst::Int64,b::Vector{Float64})
  appendaccseq(task::MSKtask,domidx::T0,afeidxfirst::T1,b::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Appends an affine conic constraint to the task.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Domain index.
    afeidxfirst::Int64 Index of the first affine expression.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, can be NULL.
"""
function appendaccseq end
function appendaccseq(task::MSKtask,domidx::Int64,afeidxfirst::Int64,b::Vector{Float64})
  __tmp_488 = Ref{Int64}()
  @MSK_getdomainn(task.task,domidx-Int64(1),__tmp_488)
  __tmp_487 = __tmp_488[]
  numafeidx = Int64(__tmp_487)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  @MSK_appendaccseq(task.task,domidx-Int64(1),numafeidx,afeidxfirst-Int64(1),b_)
  nothing
end
function appendaccseq(task::MSKtask,domidx::T0,afeidxfirst::T1,b::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  appendaccseq(
    task,
    convert(Int64,domidx),
    convert(Int64,afeidxfirst),
    convert(Vector{Float64},b))
end


"""
  appendaccsseq(task::MSKtask,domidxs::Vector{Int64},numafeidx::Int64,afeidxfirst::Int64,b::Vector{Float64})
  appendaccsseq(task::MSKtask,domidxs::T0,numafeidx::T1,afeidxfirst::T2,b::T3) where {T0<:AbstractVector{<:Integer},T1<:Integer,T2<:Integer,T3<:AbstractVector{<:Number}} 

  Appends a number of affine conic constraint to the task.

  Arguments
    task::MSKtask An optimization task.
    domidxs::Vector{Int64} Domain indices.
    numafeidx::Int64 Number of affine expressions in the affine expression list (must equal the sum of dimensions of the domains).
    afeidxfirst::Int64 Index of the first affine expression.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, can be NULL.
"""
function appendaccsseq end
function appendaccsseq(task::MSKtask,domidxs::Vector{Int64},numafeidx::Int64,afeidxfirst::Int64,b::Vector{Float64})
  numaccs = Int64(length(domidxs))
  domidxs_ = domidxs .- Int64(1)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  @MSK_appendaccsseq(task.task,numaccs,domidxs_,numafeidx,afeidxfirst-Int64(1),b_)
  nothing
end
function appendaccsseq(task::MSKtask,domidxs::T0,numafeidx::T1,afeidxfirst::T2,b::T3) where { T0<:AbstractVector{<:Integer},T1<:Integer,T2<:Integer,T3<:AbstractVector{<:Number} }
  appendaccsseq(
    task,
    convert(Vector{Int64},domidxs),
    convert(Int64,numafeidx),
    convert(Int64,afeidxfirst),
    convert(Vector{Float64},b))
end


"""
  putacc(task::MSKtask,accidx::Int64,domidx::Int64,afeidxlist::Vector{Int64},b::Vector{Float64})
  putacc(task::MSKtask,accidx::T0,domidx::T1,afeidxlist::T2,b::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

  Puts an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Affine conic constraint index.
    domidx::Int64 Domain index.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, can be NULL.
"""
function putacc end
function putacc(task::MSKtask,accidx::Int64,domidx::Int64,afeidxlist::Vector{Int64},b::Vector{Float64})
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  @MSK_putacc(task.task,accidx-Int64(1),domidx-Int64(1),numafeidx,afeidxlist_,b_)
  nothing
end
function putacc(task::MSKtask,accidx::T0,domidx::T1,afeidxlist::T2,b::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putacc(
    task,
    convert(Int64,accidx),
    convert(Int64,domidx),
    convert(Vector{Int64},afeidxlist),
    convert(Vector{Float64},b))
end


"""
  putacclist(task::MSKtask,accidxs::Vector{Int64},domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64})
  putacclist(task::MSKtask,accidxs::T0,domidxs::T1,afeidxlist::T2,b::T3) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

  Puts a number of affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
    accidxs::Vector{Int64} Affine conic constraint indices.
    domidxs::Vector{Int64} Domain indices.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, can be NULL.
"""
function putacclist end
function putacclist(task::MSKtask,accidxs::Vector{Int64},domidxs::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64})
  numaccs = Int64(min(length(domidxs),length(accidxs)))
  accidxs_ = accidxs .- Int64(1)
  domidxs_ = domidxs .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  @MSK_putacclist(task.task,numaccs,accidxs_,domidxs_,numafeidx,afeidxlist_,b_)
  nothing
end
function putacclist(task::MSKtask,accidxs::T0,domidxs::T1,afeidxlist::T2,b::T3) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putacclist(
    task,
    convert(Vector{Int64},accidxs),
    convert(Vector{Int64},domidxs),
    convert(Vector{Int64},afeidxlist),
    convert(Vector{Float64},b))
end


"""
  putaccb(task::MSKtask,accidx::Int64,b::Vector{Float64})
  putaccb(task::MSKtask,accidx::T0,b::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}} 

  Puts the constant vector b in an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Affine conic constraint index.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, can be NULL.
"""
function putaccb end
function putaccb(task::MSKtask,accidx::Int64,b::Vector{Float64})
  lengthb = Int64(length(b))
  b_ = b
  @MSK_putaccb(task.task,accidx-Int64(1),lengthb,b_)
  nothing
end
function putaccb(task::MSKtask,accidx::T0,b::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  putaccb(
    task,
    convert(Int64,accidx),
    convert(Vector{Float64},b))
end


"""
  putaccbj(task::MSKtask,accidx::Int64,j::Int64,bj::Float64)
  putaccbj(task::MSKtask,accidx::T0,j::T1,bj::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

  Sets one element in the b vector of an affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Affine conic constraint index.
    j::Int64 The index of an element in b to change.
    bj::Float64 The new value of b[j].
"""
function putaccbj end
function putaccbj(task::MSKtask,accidx::Int64,j::Int64,bj::Float64)
  @MSK_putaccbj(task.task,accidx-Int64(1),j-Int64(1),bj)
  nothing
end
function putaccbj(task::MSKtask,accidx::T0,j::T1,bj::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putaccbj(
    task,
    convert(Int64,accidx),
    convert(Int64,j),
    convert(Float64,bj))
end


"""
  getaccdomain(task::MSKtask,accidx::Int64) :: domidx
  getaccdomain(task::MSKtask,accidx::T0) where {T0<:Integer}  :: domidx

  Obtains the domain appearing in the affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 The index of the affine conic constraint.
  Returns
    domidx::Int64 The index of domain in the affine conic constraint.
"""
function getaccdomain end
function getaccdomain(task::MSKtask,accidx::Int64)
  domidx_ = Ref{Int64}()
  @MSK_getaccdomain(task.task,accidx-Int64(1),domidx_)
  domidx_[]+Int64(1)
end
function getaccdomain(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccdomain(
    task,
    convert(Int64,accidx))
end


"""
  getaccn(task::MSKtask,accidx::Int64) :: n
  getaccn(task::MSKtask,accidx::T0) where {T0<:Integer}  :: n

  Obtains the dimension of the affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 The index of the affine conic constraint.
  Returns
    n::Int64 The dimension of the affine conic constraint (equal to the dimension of its domain).
"""
function getaccn end
function getaccn(task::MSKtask,accidx::Int64)
  n_ = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),n_)
  n_[]
end
function getaccn(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccn(
    task,
    convert(Int64,accidx))
end


"""
  getaccntot(task::MSKtask) :: n

  Obtains the total dimension of all affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    n::Int64 The total dimension of all affine conic constraints.
"""
function getaccntot end
function getaccntot(task::MSKtask)
  n_ = Ref{Int64}()
  @MSK_getaccntot(task.task,n_)
  n_[]
end


"""
  getaccafeidxlist(task::MSKtask,accidx::Int64) :: afeidxlist
  getaccafeidxlist(task::MSKtask,accidx::T0) where {T0<:Integer}  :: afeidxlist

  Obtains the list of affine expressions appearing in the affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Index of the affine conic constraint.
  Returns
    afeidxlist::Vector{Int64} List of indexes of affine expressions appearing in the constraint.
"""
function getaccafeidxlist end
function getaccafeidxlist(task::MSKtask,accidx::Int64)
  __tmp_499 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_499)
  __tmp_498 = __tmp_499[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_498)
  @MSK_getaccafeidxlist(task.task,accidx-Int64(1),afeidxlist_)
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  afeidxlist
end
function getaccafeidxlist(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccafeidxlist(
    task,
    convert(Int64,accidx))
end


"""
  getaccb(task::MSKtask,accidx::Int64) :: b
  getaccb(task::MSKtask,accidx::T0) where {T0<:Integer}  :: b

  Obtains the additional constant term vector appearing in the affine conic constraint.

  Arguments
    task::MSKtask An optimization task.
    accidx::Int64 Index of the affine conic constraint.
  Returns
    b::Vector{Float64} The vector b appearing in the constraint.
"""
function getaccb end
function getaccb(task::MSKtask,accidx::Int64)
  __tmp_502 = Ref{Int64}()
  @MSK_getaccn(task.task,accidx-Int64(1),__tmp_502)
  __tmp_501 = __tmp_502[]
  b_ = Vector{Float64}(undef,__tmp_501)
  @MSK_getaccb(task.task,accidx-Int64(1),b_)
  b = b_;
  b
end
function getaccb(task::MSKtask,accidx::T0) where { T0<:Integer }
  getaccb(
    task,
    convert(Int64,accidx))
end


"""
  getaccs(task::MSKtask) :: (domidxlist,afeidxlist,b)

  Obtains full data of all affine conic constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    domidxlist::Vector{Int64} The list of domains appearing in all affine conic constraints.
    afeidxlist::Vector{Int64} The concatenation of index lists of affine expressions appearing in all affine conic constraints.
    b::Vector{Float64} The concatenation of vectors b appearing in all affine conic constraints.
"""
function getaccs end
function getaccs(task::MSKtask)
  __tmp_505 = Ref{Int64}()
  @MSK_getnumacc(task.task,__tmp_505)
  __tmp_504 = __tmp_505[]
  domidxlist_ = Vector{Int64}(undef,__tmp_504)
  __tmp_507 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_507)
  __tmp_506 = __tmp_507[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_506)
  __tmp_509 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_509)
  __tmp_508 = __tmp_509[]
  b_ = Vector{Float64}(undef,__tmp_508)
  @MSK_getaccs(task.task,domidxlist_,afeidxlist_,b_)
  domidxlist = domidxlist_;
  domidxlist .+= 1
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  b = b_;
  domidxlist,afeidxlist,b
end


"""
  getaccfnumnz(task::MSKtask) :: accfnnz

  Obtains the total number of nonzeros in the ACC implied F matrix.

  Arguments
    task::MSKtask An optimization task.
  Returns
    accfnnz::Int64 Number of nonzeros in the F matrix implied by ACCs.
"""
function getaccfnumnz end
function getaccfnumnz(task::MSKtask)
  accfnnz_ = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,accfnnz_)
  accfnnz_[]
end


"""
  getaccftrip(task::MSKtask) :: (frow,fcol,fval)

  Obtains the F matrix (implied by the AFE ordering within the ACCs) in triplet format.

  Arguments
    task::MSKtask An optimization task.
  Returns
    frow::Vector{Int64} Row indices of nonzeros in the implied F matrix.
    fcol::Vector{Int32} Column indices of nonzeros in the implied F matrix.
    fval::Vector{Float64} Values of nonzero entries in the implied F matrix.
"""
function getaccftrip end
function getaccftrip(task::MSKtask)
  __tmp_513 = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,__tmp_513)
  __tmp_512 = __tmp_513[]
  frow_ = Vector{Int64}(undef,__tmp_512)
  __tmp_515 = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,__tmp_515)
  __tmp_514 = __tmp_515[]
  fcol_ = Vector{Int32}(undef,__tmp_514)
  __tmp_517 = Ref{Int64}()
  @MSK_getaccfnumnz(task.task,__tmp_517)
  __tmp_516 = __tmp_517[]
  fval_ = Vector{Float64}(undef,__tmp_516)
  @MSK_getaccftrip(task.task,frow_,fcol_,fval_)
  frow = frow_;
  frow .+= 1
  fcol = fcol_;
  fcol .+= 1
  fval = fval_;
  frow,fcol,fval
end


"""
  getaccgvector(task::MSKtask) :: g

  The g vector as used within the ACCs.

  Arguments
    task::MSKtask An optimization task.
  Returns
    g::Vector{Float64} The g vector as used within the ACCs.
"""
function getaccgvector end
function getaccgvector(task::MSKtask)
  __tmp_520 = Ref{Int64}()
  @MSK_getaccntot(task.task,__tmp_520)
  __tmp_519 = __tmp_520[]
  g_ = Vector{Float64}(undef,__tmp_519)
  @MSK_getaccgvector(task.task,g_)
  g = g_;
  g
end


"""
  getaccbarfnumblocktriplets(task::MSKtask) :: numtrip

  Obtains an upper bound on the number of elements in the block triplet form of barf, as used within the ACCs.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numtrip::Int64 An upper bound on the number of elements in the block triplet form of barf, as used within the ACCs.
"""
function getaccbarfnumblocktriplets end
function getaccbarfnumblocktriplets(task::MSKtask)
  numtrip_ = Ref{Int64}()
  @MSK_getaccbarfnumblocktriplets(task.task,numtrip_)
  numtrip_[]
end


"""
  getaccbarfblocktriplet(task::MSKtask) :: (numtrip,acc_afe,bar_var,blk_row,blk_col,blk_val)

  Obtains barF, implied by the ACCs, in block triplet form.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numtrip::Int64 Number of elements in the block triplet form.
    acc_afe::Vector{Int64} Index of the AFE within the concatenated list of AFEs in ACCs.
    bar_var::Vector{Int32} Symmetric matrix variable index.
    blk_row::Vector{Int32} Block row index.
    blk_col::Vector{Int32} Block column index.
    blk_val::Vector{Float64} The numerical value associated with each block triplet.
"""
function getaccbarfblocktriplet end
function getaccbarfblocktriplet(task::MSKtask)
  __tmp_524 = Ref{Int64}()
  @MSK_getaccbarfnumblocktriplets(task.task,__tmp_524)
  __tmp_523 = __tmp_524[]
  maxnumtrip = Int64(__tmp_523)
  numtrip_ = Ref{Int64}()
  acc_afe_ = Vector{Int64}(undef,maxnumtrip)
  bar_var_ = Vector{Int32}(undef,maxnumtrip)
  blk_row_ = Vector{Int32}(undef,maxnumtrip)
  blk_col_ = Vector{Int32}(undef,maxnumtrip)
  blk_val_ = Vector{Float64}(undef,maxnumtrip)
  @MSK_getaccbarfblocktriplet(task.task,maxnumtrip,numtrip_,acc_afe_,bar_var_,blk_row_,blk_col_,blk_val_)
  acc_afe = acc_afe_;
  acc_afe .+= 1
  bar_var = bar_var_;
  bar_var .+= 1
  blk_row = blk_row_;
  blk_row .+= 1
  blk_col = blk_col_;
  blk_col .+= 1
  blk_val = blk_val_;
  numtrip_[],acc_afe,bar_var,blk_row,blk_col,blk_val
end


"""
  appenddjcs(task::MSKtask,num::Int64)
  appenddjcs(task::MSKtask,num::T0) where {T0<:Integer} 

  Appends a number of empty disjunctive constraints to the task.

  Arguments
    task::MSKtask An optimization task.
    num::Int64 Number of empty disjunctive constraints which should be appended.
"""
function appenddjcs end
function appenddjcs(task::MSKtask,num::Int64)
  @MSK_appenddjcs(task.task,num)
  nothing
end
function appenddjcs(task::MSKtask,num::T0) where { T0<:Integer }
  appenddjcs(
    task,
    convert(Int64,num))
end


"""
  putdjc(task::MSKtask,djcidx::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64},termsizelist::Vector{Int64})
  putdjc(task::MSKtask,djcidx::T0,domidxlist::T1,afeidxlist::T2,b::T3,termsizelist::T4) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Integer}} 

  Inputs a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
    domidxlist::Vector{Int64} List of domain indexes.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Vector{Float64} The vector of constant terms added to affine expressions.
    termsizelist::Vector{Int64} List of term sizes.
"""
function putdjc end
function putdjc(task::MSKtask,djcidx::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64},termsizelist::Vector{Int64})
  numdomidx = Int64(length(domidxlist))
  domidxlist_ = domidxlist .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  numterms = Int64(length(termsizelist))
  termsizelist_ = termsizelist
  @MSK_putdjc(task.task,djcidx-Int64(1),numdomidx,domidxlist_,numafeidx,afeidxlist_,b_,numterms,termsizelist_)
  nothing
end
function putdjc(task::MSKtask,djcidx::T0,domidxlist::T1,afeidxlist::T2,b::T3,termsizelist::T4) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Integer} }
  putdjc(
    task,
    convert(Int64,djcidx),
    convert(Vector{Int64},domidxlist),
    convert(Vector{Int64},afeidxlist),
    convert(Vector{Float64},b),
    convert(Vector{Int64},termsizelist))
end


"""
  putdjcslice(task::MSKtask,idxfirst::Int64,idxlast::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64},termsizelist::Vector{Int64},termsindjc::Vector{Int64})
  putdjcslice(task::MSKtask,idxfirst::T0,idxlast::T1,domidxlist::T2,afeidxlist::T3,b::T4,termsizelist::T5,termsindjc::T6) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer}} 

  Inputs a slice of disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
    idxfirst::Int64 Index of the first disjunctive constraint in the slice.
    idxlast::Int64 Index of the last disjunctive constraint in the slice plus 1.
    domidxlist::Vector{Int64} List of domain indexes.
    afeidxlist::Vector{Int64} List of affine expression indexes.
    b::Vector{Float64} The vector of constant terms added to affine expressions. Optional, may be NULL.
    termsizelist::Vector{Int64} List of term sizes.
    termsindjc::Vector{Int64} Number of terms in each of the disjunctive constraints in the slice.
"""
function putdjcslice end
function putdjcslice(task::MSKtask,idxfirst::Int64,idxlast::Int64,domidxlist::Vector{Int64},afeidxlist::Vector{Int64},b::Vector{Float64},termsizelist::Vector{Int64},termsindjc::Vector{Int64})
  numdomidx = Int64(length(domidxlist))
  domidxlist_ = domidxlist .- Int64(1)
  numafeidx = Int64(length(afeidxlist))
  afeidxlist_ = afeidxlist .- Int64(1)
  if length(b) < numafeidx
    throw(BoundsError())
  end
  b_ = b
  numterms = Int64(length(termsizelist))
  termsizelist_ = termsizelist
  if length(termsindjc) < (idxlast - idxfirst)
    throw(BoundsError())
  end
  termsindjc_ = termsindjc
  @MSK_putdjcslice(task.task,idxfirst-Int64(1),idxlast-Int64(1),numdomidx,domidxlist_,numafeidx,afeidxlist_,b_,numterms,termsizelist_,termsindjc_)
  nothing
end
function putdjcslice(task::MSKtask,idxfirst::T0,idxlast::T1,domidxlist::T2,afeidxlist::T3,b::T4,termsizelist::T5,termsindjc::T6) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Integer} }
  putdjcslice(
    task,
    convert(Int64,idxfirst),
    convert(Int64,idxlast),
    convert(Vector{Int64},domidxlist),
    convert(Vector{Int64},afeidxlist),
    convert(Vector{Float64},b),
    convert(Vector{Int64},termsizelist),
    convert(Vector{Int64},termsindjc))
end


"""
  getdjcdomainidxlist(task::MSKtask,djcidx::Int64) :: domidxlist
  getdjcdomainidxlist(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: domidxlist

  Obtains the list of domain indexes in a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
  Returns
    domidxlist::Vector{Int64} List of term sizes.
"""
function getdjcdomainidxlist end
function getdjcdomainidxlist(task::MSKtask,djcidx::Int64)
  __tmp_530 = Ref{Int64}()
  @MSK_getdjcnumdomain(task.task,djcidx-Int64(1),__tmp_530)
  __tmp_529 = __tmp_530[]
  domidxlist_ = Vector{Int64}(undef,__tmp_529)
  @MSK_getdjcdomainidxlist(task.task,djcidx-Int64(1),domidxlist_)
  domidxlist = domidxlist_;
  domidxlist .+= 1
  domidxlist
end
function getdjcdomainidxlist(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcdomainidxlist(
    task,
    convert(Int64,djcidx))
end


"""
  getdjcafeidxlist(task::MSKtask,djcidx::Int64) :: afeidxlist
  getdjcafeidxlist(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: afeidxlist

  Obtains the list of affine expression indexes in a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
  Returns
    afeidxlist::Vector{Int64} List of affine expression indexes.
"""
function getdjcafeidxlist end
function getdjcafeidxlist(task::MSKtask,djcidx::Int64)
  __tmp_533 = Ref{Int64}()
  @MSK_getdjcnumafe(task.task,djcidx-Int64(1),__tmp_533)
  __tmp_532 = __tmp_533[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_532)
  @MSK_getdjcafeidxlist(task.task,djcidx-Int64(1),afeidxlist_)
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  afeidxlist
end
function getdjcafeidxlist(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcafeidxlist(
    task,
    convert(Int64,djcidx))
end


"""
  getdjcb(task::MSKtask,djcidx::Int64) :: b
  getdjcb(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: b

  Obtains the optional constant term vector of a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
  Returns
    b::Vector{Float64} The vector b.
"""
function getdjcb end
function getdjcb(task::MSKtask,djcidx::Int64)
  __tmp_536 = Ref{Int64}()
  @MSK_getdjcnumafe(task.task,djcidx-Int64(1),__tmp_536)
  __tmp_535 = __tmp_536[]
  b_ = Vector{Float64}(undef,__tmp_535)
  @MSK_getdjcb(task.task,djcidx-Int64(1),b_)
  b = b_;
  b
end
function getdjcb(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjcb(
    task,
    convert(Int64,djcidx))
end


"""
  getdjctermsizelist(task::MSKtask,djcidx::Int64) :: termsizelist
  getdjctermsizelist(task::MSKtask,djcidx::T0) where {T0<:Integer}  :: termsizelist

  Obtains the list of term sizes in a disjunctive constraint.

  Arguments
    task::MSKtask An optimization task.
    djcidx::Int64 Index of the disjunctive constraint.
  Returns
    termsizelist::Vector{Int64} List of term sizes.
"""
function getdjctermsizelist end
function getdjctermsizelist(task::MSKtask,djcidx::Int64)
  __tmp_539 = Ref{Int64}()
  @MSK_getdjcnumterm(task.task,djcidx-Int64(1),__tmp_539)
  __tmp_538 = __tmp_539[]
  termsizelist_ = Vector{Int64}(undef,__tmp_538)
  @MSK_getdjctermsizelist(task.task,djcidx-Int64(1),termsizelist_)
  termsizelist = termsizelist_;
  termsizelist
end
function getdjctermsizelist(task::MSKtask,djcidx::T0) where { T0<:Integer }
  getdjctermsizelist(
    task,
    convert(Int64,djcidx))
end


"""
  getdjcs(task::MSKtask) :: (domidxlist,afeidxlist,b,termsizelist,numterms)

  Obtains full data of all disjunctive constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    domidxlist::Vector{Int64} The concatenation of index lists of domains appearing in all disjunctive constraints.
    afeidxlist::Vector{Int64} The concatenation of index lists of affine expressions appearing in all disjunctive constraints.
    b::Vector{Float64} The concatenation of vectors b appearing in all disjunctive constraints.
    termsizelist::Vector{Int64} The concatenation of lists of term sizes appearing in all disjunctive constraints.
    numterms::Vector{Int64} The number of terms in each of the disjunctive constraints.
"""
function getdjcs end
function getdjcs(task::MSKtask)
  __tmp_542 = Ref{Int64}()
  @MSK_getdjcnumdomaintot(task.task,__tmp_542)
  __tmp_541 = __tmp_542[]
  domidxlist_ = Vector{Int64}(undef,__tmp_541)
  __tmp_544 = Ref{Int64}()
  @MSK_getdjcnumafetot(task.task,__tmp_544)
  __tmp_543 = __tmp_544[]
  afeidxlist_ = Vector{Int64}(undef,__tmp_543)
  __tmp_546 = Ref{Int64}()
  @MSK_getdjcnumafetot(task.task,__tmp_546)
  __tmp_545 = __tmp_546[]
  b_ = Vector{Float64}(undef,__tmp_545)
  __tmp_548 = Ref{Int64}()
  @MSK_getdjcnumtermtot(task.task,__tmp_548)
  __tmp_547 = __tmp_548[]
  termsizelist_ = Vector{Int64}(undef,__tmp_547)
  __tmp_550 = Ref{Int64}()
  @MSK_getnumdjc(task.task,__tmp_550)
  __tmp_549 = __tmp_550[]
  numterms_ = Vector{Int64}(undef,__tmp_549)
  @MSK_getdjcs(task.task,domidxlist_,afeidxlist_,b_,termsizelist_,numterms_)
  domidxlist = domidxlist_;
  domidxlist .+= 1
  afeidxlist = afeidxlist_;
  afeidxlist .+= 1
  b = b_;
  termsizelist = termsizelist_;
  numterms = numterms_;
  domidxlist,afeidxlist,b,termsizelist,numterms
end


"""
  putconbound(task::MSKtask,i::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
  putconbound(task::MSKtask,i::T0,bkc::Boundkey,blc::T1,buc::T2) where {T0<:Integer,T1<:Number,T2<:Number} 

  Changes the bound for one constraint.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the constraint.
    bkc::Boundkey New bound key.
    blc::Float64 New lower bound.
    buc::Float64 New upper bound.
"""
function putconbound end
function putconbound(task::MSKtask,i::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
  @MSK_putconbound(task.task,i-Int32(1),bkc.value,blc,buc)
  nothing
end
function putconbound(task::MSKtask,i::T0,bkc::Boundkey,blc::T1,buc::T2) where { T0<:Integer,T1<:Number,T2<:Number }
  putconbound(
    task,
    convert(Int32,i),
    bkc,
    convert(Float64,blc),
    convert(Float64,buc))
end


"""
  putconboundlist(task::MSKtask,sub::Vector{Int32},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
  putconboundlist(task::MSKtask,sub::T0,bkc::Vector{Boundkey},blc::T1,buc::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number}} 

  Changes the bounds of a list of constraints.

  Arguments
    task::MSKtask An optimization task.
    sub::Vector{Int32} List of constraint indexes.
    bkc::Vector{Boundkey} Bound keys for the constraints.
    blc::Vector{Float64} Lower bounds for the constraints.
    buc::Vector{Float64} Upper bounds for the constraints.
"""
function putconboundlist end
function putconboundlist(task::MSKtask,sub::Vector{Int32},bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
  num = Int32(min(length(sub),length(bkc),length(blc),length(buc)))
  sub_ = sub .- Int32(1)
  bkc_ = Int32[item.value for item in bkc]
  blc_ = blc
  buc_ = buc
  @MSK_putconboundlist(task.task,num,sub_,bkc_,blc_,buc_)
  nothing
end
function putconboundlist(task::MSKtask,sub::T0,bkc::Vector{Boundkey},blc::T1,buc::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number} }
  putconboundlist(
    task,
    convert(Vector{Int32},sub),
    bkc,
    convert(Vector{Float64},blc),
    convert(Vector{Float64},buc))
end


"""
  putconboundlistconst(task::MSKtask,sub::Vector{Int32},bkc::Boundkey,blc::Float64,buc::Float64)
  putconboundlistconst(task::MSKtask,sub::T0,bkc::Boundkey,blc::T1,buc::T2) where {T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number} 

  Changes the bounds of a list of constraints.

  Arguments
    task::MSKtask An optimization task.
    sub::Vector{Int32} List of constraint indexes.
    bkc::Boundkey New bound key for all constraints in the list.
    blc::Float64 New lower bound for all constraints in the list.
    buc::Float64 New upper bound for all constraints in the list.
"""
function putconboundlistconst end
function putconboundlistconst(task::MSKtask,sub::Vector{Int32},bkc::Boundkey,blc::Float64,buc::Float64)
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  @MSK_putconboundlistconst(task.task,num,sub_,bkc.value,blc,buc)
  nothing
end
function putconboundlistconst(task::MSKtask,sub::T0,bkc::Boundkey,blc::T1,buc::T2) where { T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number }
  putconboundlistconst(
    task,
    convert(Vector{Int32},sub),
    bkc,
    convert(Float64,blc),
    convert(Float64,buc))
end


"""
  putconboundslice(task::MSKtask,first::Int32,last::Int32,bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
  putconboundslice(task::MSKtask,first::T0,last::T1,bkc::Vector{Boundkey},blc::T2,buc::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number}} 

  Changes the bounds for a slice of the constraints.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    bkc::Vector{Boundkey} Bound keys for the constraints.
    blc::Vector{Float64} Lower bounds for the constraints.
    buc::Vector{Float64} Upper bounds for the constraints.
"""
function putconboundslice end
function putconboundslice(task::MSKtask,first::Int32,last::Int32,bkc::Vector{Boundkey},blc::Vector{Float64},buc::Vector{Float64})
  if length(bkc) < (last - first)
    throw(BoundsError())
  end
  bkc_ = Int32[item.value for item in bkc]
  if length(blc) < (last - first)
    throw(BoundsError())
  end
  blc_ = blc
  if length(buc) < (last - first)
    throw(BoundsError())
  end
  buc_ = buc
  @MSK_putconboundslice(task.task,first-Int32(1),last-Int32(1),bkc_,blc_,buc_)
  nothing
end
function putconboundslice(task::MSKtask,first::T0,last::T1,bkc::Vector{Boundkey},blc::T2,buc::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number} }
  putconboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkc,
    convert(Vector{Float64},blc),
    convert(Vector{Float64},buc))
end


"""
  putconboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
  putconboundsliceconst(task::MSKtask,first::T0,last::T1,bkc::Boundkey,blc::T2,buc::T3) where {T0<:Integer,T1<:Integer,T2<:Number,T3<:Number} 

  Changes the bounds for a slice of the constraints.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    bkc::Boundkey New bound key for all constraints in the slice.
    blc::Float64 New lower bound for all constraints in the slice.
    buc::Float64 New upper bound for all constraints in the slice.
"""
function putconboundsliceconst end
function putconboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkc::Boundkey,blc::Float64,buc::Float64)
  @MSK_putconboundsliceconst(task.task,first-Int32(1),last-Int32(1),bkc.value,blc,buc)
  nothing
end
function putconboundsliceconst(task::MSKtask,first::T0,last::T1,bkc::Boundkey,blc::T2,buc::T3) where { T0<:Integer,T1<:Integer,T2<:Number,T3<:Number }
  putconboundsliceconst(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkc,
    convert(Float64,blc),
    convert(Float64,buc))
end


"""
  putvarbound(task::MSKtask,j::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
  putvarbound(task::MSKtask,j::T0,bkx::Boundkey,blx::T1,bux::T2) where {T0<:Integer,T1<:Number,T2<:Number} 

  Changes the bounds for one variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable.
    bkx::Boundkey New bound key.
    blx::Float64 New lower bound.
    bux::Float64 New upper bound.
"""
function putvarbound end
function putvarbound(task::MSKtask,j::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
  @MSK_putvarbound(task.task,j-Int32(1),bkx.value,blx,bux)
  nothing
end
function putvarbound(task::MSKtask,j::T0,bkx::Boundkey,blx::T1,bux::T2) where { T0<:Integer,T1<:Number,T2<:Number }
  putvarbound(
    task,
    convert(Int32,j),
    bkx,
    convert(Float64,blx),
    convert(Float64,bux))
end


"""
  putvarboundlist(task::MSKtask,sub::Vector{Int32},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  putvarboundlist(task::MSKtask,sub::T0,bkx::Vector{Boundkey},blx::T1,bux::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number}} 

  Changes the bounds of a list of variables.

  Arguments
    task::MSKtask An optimization task.
    sub::Vector{Int32} List of variable indexes.
    bkx::Vector{Boundkey} Bound keys for the variables.
    blx::Vector{Float64} Lower bounds for the variables.
    bux::Vector{Float64} Upper bounds for the variables.
"""
function putvarboundlist end
function putvarboundlist(task::MSKtask,sub::Vector{Int32},bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  num = Int32(min(length(sub),length(bkx),length(blx),length(bux)))
  sub_ = sub .- Int32(1)
  bkx_ = Int32[item.value for item in bkx]
  blx_ = blx
  bux_ = bux
  @MSK_putvarboundlist(task.task,num,sub_,bkx_,blx_,bux_)
  nothing
end
function putvarboundlist(task::MSKtask,sub::T0,bkx::Vector{Boundkey},blx::T1,bux::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number} }
  putvarboundlist(
    task,
    convert(Vector{Int32},sub),
    bkx,
    convert(Vector{Float64},blx),
    convert(Vector{Float64},bux))
end


"""
  putvarboundlistconst(task::MSKtask,sub::Vector{Int32},bkx::Boundkey,blx::Float64,bux::Float64)
  putvarboundlistconst(task::MSKtask,sub::T0,bkx::Boundkey,blx::T1,bux::T2) where {T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number} 

  Changes the bounds of a list of variables.

  Arguments
    task::MSKtask An optimization task.
    sub::Vector{Int32} List of variable indexes.
    bkx::Boundkey New bound key for all variables in the list.
    blx::Float64 New lower bound for all variables in the list.
    bux::Float64 New upper bound for all variables in the list.
"""
function putvarboundlistconst end
function putvarboundlistconst(task::MSKtask,sub::Vector{Int32},bkx::Boundkey,blx::Float64,bux::Float64)
  num = Int32(length(sub))
  sub_ = sub .- Int32(1)
  @MSK_putvarboundlistconst(task.task,num,sub_,bkx.value,blx,bux)
  nothing
end
function putvarboundlistconst(task::MSKtask,sub::T0,bkx::Boundkey,blx::T1,bux::T2) where { T0<:AbstractVector{<:Integer},T1<:Number,T2<:Number }
  putvarboundlistconst(
    task,
    convert(Vector{Int32},sub),
    bkx,
    convert(Float64,blx),
    convert(Float64,bux))
end


"""
  putvarboundslice(task::MSKtask,first::Int32,last::Int32,bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  putvarboundslice(task::MSKtask,first::T0,last::T1,bkx::Vector{Boundkey},blx::T2,bux::T3) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number}} 

  Changes the bounds for a slice of the variables.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    bkx::Vector{Boundkey} Bound keys for the variables.
    blx::Vector{Float64} Lower bounds for the variables.
    bux::Vector{Float64} Upper bounds for the variables.
"""
function putvarboundslice end
function putvarboundslice(task::MSKtask,first::Int32,last::Int32,bkx::Vector{Boundkey},blx::Vector{Float64},bux::Vector{Float64})
  if length(bkx) < (last - first)
    throw(BoundsError())
  end
  bkx_ = Int32[item.value for item in bkx]
  if length(blx) < (last - first)
    throw(BoundsError())
  end
  blx_ = blx
  if length(bux) < (last - first)
    throw(BoundsError())
  end
  bux_ = bux
  @MSK_putvarboundslice(task.task,first-Int32(1),last-Int32(1),bkx_,blx_,bux_)
  nothing
end
function putvarboundslice(task::MSKtask,first::T0,last::T1,bkx::Vector{Boundkey},blx::T2,bux::T3) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number} }
  putvarboundslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkx,
    convert(Vector{Float64},blx),
    convert(Vector{Float64},bux))
end


"""
  putvarboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
  putvarboundsliceconst(task::MSKtask,first::T0,last::T1,bkx::Boundkey,blx::T2,bux::T3) where {T0<:Integer,T1<:Integer,T2<:Number,T3<:Number} 

  Changes the bounds for a slice of the variables.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First index in the sequence.
    last::Int32 Last index plus 1 in the sequence.
    bkx::Boundkey New bound key for all variables in the slice.
    blx::Float64 New lower bound for all variables in the slice.
    bux::Float64 New upper bound for all variables in the slice.
"""
function putvarboundsliceconst end
function putvarboundsliceconst(task::MSKtask,first::Int32,last::Int32,bkx::Boundkey,blx::Float64,bux::Float64)
  @MSK_putvarboundsliceconst(task.task,first-Int32(1),last-Int32(1),bkx.value,blx,bux)
  nothing
end
function putvarboundsliceconst(task::MSKtask,first::T0,last::T1,bkx::Boundkey,blx::T2,bux::T3) where { T0<:Integer,T1<:Integer,T2<:Number,T3<:Number }
  putvarboundsliceconst(
    task,
    convert(Int32,first),
    convert(Int32,last),
    bkx,
    convert(Float64,blx),
    convert(Float64,bux))
end


"""
  putcfix(task::MSKtask,cfix::Float64)
  putcfix(task::MSKtask,cfix::T0) where {T0<:Number} 

  Replaces the fixed term in the objective.

  Arguments
    task::MSKtask An optimization task.
    cfix::Float64 Fixed term in the objective.
"""
function putcfix end
function putcfix(task::MSKtask,cfix::Float64)
  @MSK_putcfix(task.task,cfix)
  nothing
end
function putcfix(task::MSKtask,cfix::T0) where { T0<:Number }
  putcfix(
    task,
    convert(Float64,cfix))
end


"""
  putcj(task::MSKtask,j::Int32,cj::Float64)
  putcj(task::MSKtask,j::T0,cj::T1) where {T0<:Integer,T1<:Number} 

  Modifies one linear coefficient in the objective.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable whose objective coefficient should be changed.
    cj::Float64 New coefficient value.
"""
function putcj end
function putcj(task::MSKtask,j::Int32,cj::Float64)
  @MSK_putcj(task.task,j-Int32(1),cj)
  nothing
end
function putcj(task::MSKtask,j::T0,cj::T1) where { T0<:Integer,T1<:Number }
  putcj(
    task,
    convert(Int32,j),
    convert(Float64,cj))
end


"""
  putobjsense(task::MSKtask,sense::Objsense)

  Sets the objective sense.

  Arguments
    task::MSKtask An optimization task.
    sense::Objsense The objective sense of the task
"""
function putobjsense end
function putobjsense(task::MSKtask,sense::Objsense)
  @MSK_putobjsense(task.task,sense.value)
  nothing
end


"""
  getobjsense(task::MSKtask) :: sense

  Gets the objective sense.

  Arguments
    task::MSKtask An optimization task.
  Returns
    sense::Objsense The returned objective sense.
"""
function getobjsense end
function getobjsense(task::MSKtask)
  sense_ = Ref{Int32}()
  @MSK_getobjsense(task.task,sense_)
  sense = Objsense(sense_[])
  sense
end


"""
  putclist(task::MSKtask,subj::Vector{Int32},val::Vector{Float64})
  putclist(task::MSKtask,subj::T0,val::T1) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number}} 

  Modifies a part of the linear objective coefficients.

  Arguments
    task::MSKtask An optimization task.
    subj::Vector{Int32} Indices of variables for which objective coefficients should be changed.
    val::Vector{Float64} New numerical values for the objective coefficients that should be modified.
"""
function putclist end
function putclist(task::MSKtask,subj::Vector{Int32},val::Vector{Float64})
  num = Int32(min(length(subj),length(val)))
  subj_ = subj .- Int32(1)
  val_ = val
  @MSK_putclist(task.task,num,subj_,val_)
  nothing
end
function putclist(task::MSKtask,subj::T0,val::T1) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Number} }
  putclist(
    task,
    convert(Vector{Int32},subj),
    convert(Vector{Float64},val))
end


"""
  putcslice(task::MSKtask,first::Int32,last::Int32,slice::Vector{Float64})
  putcslice(task::MSKtask,first::T0,last::T1,slice::T2) where {T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number}} 

  Modifies a slice of the linear objective coefficients.

  Arguments
    task::MSKtask An optimization task.
    first::Int32 First element in the slice of c.
    last::Int32 Last element plus 1 of the slice in c to be changed.
    slice::Vector{Float64} New numerical values for the objective coefficients that should be modified.
"""
function putcslice end
function putcslice(task::MSKtask,first::Int32,last::Int32,slice::Vector{Float64})
  if length(slice) < (last - first)
    throw(BoundsError())
  end
  slice_ = slice
  @MSK_putcslice(task.task,first-Int32(1),last-Int32(1),slice_)
  nothing
end
function putcslice(task::MSKtask,first::T0,last::T1,slice::T2) where { T0<:Integer,T1<:Integer,T2<:AbstractVector{<:Number} }
  putcslice(
    task,
    convert(Int32,first),
    convert(Int32,last),
    convert(Vector{Float64},slice))
end


"""
  putbarcj(task::MSKtask,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
  putbarcj(task::MSKtask,j::T0,sub::T1,weights::T2) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 

  Changes one element in barc.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the element in barc` that should be changed.
    sub::Vector{Int64} sub is list of indexes of those symmetric matrices appearing in sum.
    weights::Vector{Float64} The weights of the terms in the weighted sum.
"""
function putbarcj end
function putbarcj(task::MSKtask,j::Int32,sub::Vector{Int64},weights::Vector{Float64})
  num = Int64(min(length(sub),length(weights)))
  sub_ = sub .- Int64(1)
  weights_ = weights
  @MSK_putbarcj(task.task,j-Int32(1),num,sub_,weights_)
  nothing
end
function putbarcj(task::MSKtask,j::T0,sub::T1,weights::T2) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putbarcj(
    task,
    convert(Int32,j),
    convert(Vector{Int64},sub),
    convert(Vector{Float64},weights))
end


"""
  putcone(task::MSKtask,k::Int32,ct::Conetype,conepar::Float64,submem::Vector{Int32})
  putcone(task::MSKtask,k::T0,ct::Conetype,conepar::T1,submem::T2) where {T0<:Integer,T1<:Number,T2<:AbstractVector{<:Integer}} 

  Replaces a conic constraint.

  Arguments
    task::MSKtask An optimization task.
    k::Int32 Index of the cone.
    ct::Conetype Specifies the type of the cone.
    conepar::Float64 For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
    submem::Vector{Int32} Variable subscripts of the members in the cone.
"""
function putcone end
function putcone(task::MSKtask,k::Int32,ct::Conetype,conepar::Float64,submem::Vector{Int32})
  nummem = Int32(length(submem))
  submem_ = submem .- Int32(1)
  @MSK_putcone(task.task,k-Int32(1),ct.value,conepar,nummem,submem_)
  nothing
end
function putcone(task::MSKtask,k::T0,ct::Conetype,conepar::T1,submem::T2) where { T0<:Integer,T1<:Number,T2<:AbstractVector{<:Integer} }
  putcone(
    task,
    convert(Int32,k),
    ct,
    convert(Float64,conepar),
    convert(Vector{Int32},submem))
end


"""
  putmaxnumdomain(task::MSKtask,maxnumdomain::Int64)
  putmaxnumdomain(task::MSKtask,maxnumdomain::T0) where {T0<:Integer} 

  Sets the number of preallocated domains in the optimization task.

  Arguments
    task::MSKtask An optimization task.
    maxnumdomain::Int64 Number of preallocated domains.
"""
function putmaxnumdomain end
function putmaxnumdomain(task::MSKtask,maxnumdomain::Int64)
  @MSK_putmaxnumdomain(task.task,maxnumdomain)
  nothing
end
function putmaxnumdomain(task::MSKtask,maxnumdomain::T0) where { T0<:Integer }
  putmaxnumdomain(
    task,
    convert(Int64,maxnumdomain))
end


"""
  getnumdomain(task::MSKtask) :: numdomain

  Obtain the number of domains defined.

  Arguments
    task::MSKtask An optimization task.
  Returns
    numdomain::Int64 Number of domains in the task.
"""
function getnumdomain end
function getnumdomain(task::MSKtask)
  numdomain_ = Ref{Int64}()
  @MSK_getnumdomain(task.task,numdomain_)
  numdomain_[]
end


"""
  appendrplusdomain(task::MSKtask,n::Int64) :: domidx
  appendrplusdomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the n dimensional positive orthant to the list of domains.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendrplusdomain end
function appendrplusdomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrplusdomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrplusdomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrplusdomain(
    task,
    convert(Int64,n))
end


"""
  appendrminusdomain(task::MSKtask,n::Int64) :: domidx
  appendrminusdomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the n dimensional negative orthant to the list of domains.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendrminusdomain end
function appendrminusdomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrminusdomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrminusdomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrminusdomain(
    task,
    convert(Int64,n))
end


"""
  appendrdomain(task::MSKtask,n::Int64) :: domidx
  appendrdomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the n dimensional real number domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendrdomain end
function appendrdomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrdomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrdomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrdomain(
    task,
    convert(Int64,n))
end


"""
  appendrzerodomain(task::MSKtask,n::Int64) :: domidx
  appendrzerodomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the n dimensional 0 domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendrzerodomain end
function appendrzerodomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrzerodomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrzerodomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrzerodomain(
    task,
    convert(Int64,n))
end


"""
  appendquadraticconedomain(task::MSKtask,n::Int64) :: domidx
  appendquadraticconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the n dimensional quadratic cone domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendquadraticconedomain end
function appendquadraticconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendquadraticconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendquadraticconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendquadraticconedomain(
    task,
    convert(Int64,n))
end


"""
  appendrquadraticconedomain(task::MSKtask,n::Int64) :: domidx
  appendrquadraticconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the n dimensional rotated quadratic cone domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendrquadraticconedomain end
function appendrquadraticconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendrquadraticconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendrquadraticconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendrquadraticconedomain(
    task,
    convert(Int64,n))
end


"""
  appendprimalexpconedomain(task::MSKtask) :: domidx

  Appends the primal exponential cone domain.

  Arguments
    task::MSKtask An optimization task.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendprimalexpconedomain end
function appendprimalexpconedomain(task::MSKtask)
  domidx_ = Ref{Int64}()
  @MSK_appendprimalexpconedomain(task.task,domidx_)
  domidx_[]+Int64(1)
end


"""
  appenddualexpconedomain(task::MSKtask) :: domidx

  Appends the dual exponential cone domain.

  Arguments
    task::MSKtask An optimization task.
  Returns
    domidx::Int64 Index of the domain.
"""
function appenddualexpconedomain end
function appenddualexpconedomain(task::MSKtask)
  domidx_ = Ref{Int64}()
  @MSK_appenddualexpconedomain(task.task,domidx_)
  domidx_[]+Int64(1)
end


"""
  appendprimalgeomeanconedomain(task::MSKtask,n::Int64) :: domidx
  appendprimalgeomeanconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the primal geometric mean cone domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendprimalgeomeanconedomain end
function appendprimalgeomeanconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendprimalgeomeanconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendprimalgeomeanconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendprimalgeomeanconedomain(
    task,
    convert(Int64,n))
end


"""
  appenddualgeomeanconedomain(task::MSKtask,n::Int64) :: domidx
  appenddualgeomeanconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the dual geometric mean cone domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimmension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appenddualgeomeanconedomain end
function appenddualgeomeanconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appenddualgeomeanconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appenddualgeomeanconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appenddualgeomeanconedomain(
    task,
    convert(Int64,n))
end


"""
  appendprimalpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64}) :: domidx
  appendprimalpowerconedomain(task::MSKtask,n::T0,alpha::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}}  :: domidx

  Appends the primal power cone domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimension of the domain.
    alpha::Vector{Float64} The sequence proportional to exponents. Must be positive.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendprimalpowerconedomain end
function appendprimalpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64})
  nleft = Int64(length(alpha))
  alpha_ = alpha
  domidx_ = Ref{Int64}()
  @MSK_appendprimalpowerconedomain(task.task,n,nleft,alpha_,domidx_)
  domidx_[]+Int64(1)
end
function appendprimalpowerconedomain(task::MSKtask,n::T0,alpha::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  appendprimalpowerconedomain(
    task,
    convert(Int64,n),
    convert(Vector{Float64},alpha))
end


"""
  appenddualpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64}) :: domidx
  appenddualpowerconedomain(task::MSKtask,n::T0,alpha::T1) where {T0<:Integer,T1<:AbstractVector{<:Number}}  :: domidx

  Appends the dual power cone domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimension of the domain.
    alpha::Vector{Float64} The sequence proportional to exponents. Must be positive.
  Returns
    domidx::Int64 Index of the domain.
"""
function appenddualpowerconedomain end
function appenddualpowerconedomain(task::MSKtask,n::Int64,alpha::Vector{Float64})
  nleft = Int64(length(alpha))
  alpha_ = alpha
  domidx_ = Ref{Int64}()
  @MSK_appenddualpowerconedomain(task.task,n,nleft,alpha_,domidx_)
  domidx_[]+Int64(1)
end
function appenddualpowerconedomain(task::MSKtask,n::T0,alpha::T1) where { T0<:Integer,T1<:AbstractVector{<:Number} }
  appenddualpowerconedomain(
    task,
    convert(Int64,n),
    convert(Vector{Float64},alpha))
end


"""
  appendsvecpsdconedomain(task::MSKtask,n::Int64) :: domidx
  appendsvecpsdconedomain(task::MSKtask,n::T0) where {T0<:Integer}  :: domidx

  Appends the vectorized SVEC PSD cone domain.

  Arguments
    task::MSKtask An optimization task.
    n::Int64 Dimension of the domain.
  Returns
    domidx::Int64 Index of the domain.
"""
function appendsvecpsdconedomain end
function appendsvecpsdconedomain(task::MSKtask,n::Int64)
  domidx_ = Ref{Int64}()
  @MSK_appendsvecpsdconedomain(task.task,n,domidx_)
  domidx_[]+Int64(1)
end
function appendsvecpsdconedomain(task::MSKtask,n::T0) where { T0<:Integer }
  appendsvecpsdconedomain(
    task,
    convert(Int64,n))
end


"""
  getdomaintype(task::MSKtask,domidx::Int64) :: domtype
  getdomaintype(task::MSKtask,domidx::T0) where {T0<:Integer}  :: domtype

  Returns the type of the domain.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Index of the domain.
  Returns
    domtype::Domaintype The type of the domain.
"""
function getdomaintype end
function getdomaintype(task::MSKtask,domidx::Int64)
  domtype_ = Ref{Int32}()
  @MSK_getdomaintype(task.task,domidx-Int64(1),domtype_)
  domtype = Domaintype(domtype_[])
  domtype
end
function getdomaintype(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomaintype(
    task,
    convert(Int64,domidx))
end


"""
  getdomainn(task::MSKtask,domidx::Int64) :: n
  getdomainn(task::MSKtask,domidx::T0) where {T0<:Integer}  :: n

  Obtains the dimension of the domain.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Index of the domain.
  Returns
    n::Int64 Dimension of the domain.
"""
function getdomainn end
function getdomainn(task::MSKtask,domidx::Int64)
  n_ = Ref{Int64}()
  @MSK_getdomainn(task.task,domidx-Int64(1),n_)
  n_[]
end
function getdomainn(task::MSKtask,domidx::T0) where { T0<:Integer }
  getdomainn(
    task,
    convert(Int64,domidx))
end


"""
  getpowerdomaininfo(task::MSKtask,domidx::Int64) :: (n,nleft)
  getpowerdomaininfo(task::MSKtask,domidx::T0) where {T0<:Integer}  :: (n,nleft)

  Obtains structural information about a power domain.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Index of the domain.
  Returns
    n::Int64 Dimension of the domain.
    nleft::Int64 Number of variables on the left hand side.
"""
function getpowerdomaininfo end
function getpowerdomaininfo(task::MSKtask,domidx::Int64)
  n_ = Ref{Int64}()
  nleft_ = Ref{Int64}()
  @MSK_getpowerdomaininfo(task.task,domidx-Int64(1),n_,nleft_)
  n_[],nleft_[]
end
function getpowerdomaininfo(task::MSKtask,domidx::T0) where { T0<:Integer }
  getpowerdomaininfo(
    task,
    convert(Int64,domidx))
end


"""
  getpowerdomainalpha(task::MSKtask,domidx::Int64) :: alpha
  getpowerdomainalpha(task::MSKtask,domidx::T0) where {T0<:Integer}  :: alpha

  Obtains the exponent vector of a power domain.

  Arguments
    task::MSKtask An optimization task.
    domidx::Int64 Index of the domain.
  Returns
    alpha::Vector{Float64} The exponent vector of the domain.
"""
function getpowerdomainalpha end
function getpowerdomainalpha(task::MSKtask,domidx::Int64)
  __tmp_589 = Ref{Int64}()
  @MSK_getpowerdomaininfo(task.task,domidx-Int64(1),Ref{Int64}(),__tmp_589)
  __tmp_588 = __tmp_589[]
  alpha_ = Vector{Float64}(undef,__tmp_588)
  @MSK_getpowerdomainalpha(task.task,domidx-Int64(1),alpha_)
  alpha = alpha_;
  alpha
end
function getpowerdomainalpha(task::MSKtask,domidx::T0) where { T0<:Integer }
  getpowerdomainalpha(
    task,
    convert(Int64,domidx))
end


"""
  appendsparsesymmat(task::MSKtask,dim::Int32,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64}) :: idx
  appendsparsesymmat(task::MSKtask,dim::T0,subi::T1,subj::T2,valij::T3) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}}  :: idx
  appendsparsesymmat(task::MSKtask,dim::T0,data:: SparseMatrixCSC{Float64}) :: idx

  Appends a general sparse symmetric matrix to the storage of symmetric matrices.

  Arguments
    task::MSKtask An optimization task.
    dim::Int32 Dimension of the symmetric matrix that is appended.
    subi::Vector{Int32} Row subscript in the triplets.
    subj::Vector{Int32} Column subscripts in the triplets.
    valij::Vector{Float64} Values of each triplet.
    subi::SparseMatrixCSC{Float64} Sparse matrix defining the column values
  Returns
    idx::Int64 Unique index assigned to the inputted matrix.
"""
function appendsparsesymmat end
function appendsparsesymmat(task::MSKtask,dim::Int32,subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
  nz = Int64(min(length(subi),length(subj),length(valij)))
  subi_ = subi .- Int32(1)
  subj_ = subj .- Int32(1)
  valij_ = valij
  idx_ = Ref{Int64}()
  @MSK_appendsparsesymmat(task.task,dim,nz,subi_,subj_,valij_,idx_)
  idx_[]+Int64(1)
end
function appendsparsesymmat(task::MSKtask,dim::T0,data:: SparseMatrixCSC{Float64}) where {T0<:Integer}
  subi,subj,valij = tril(data)
  appendsparsesymmat(task,dim,subi,subj,valij)
end
function appendsparsesymmat(task::MSKtask,dim::T0,subi::T1,subj::T2,valij::T3) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  appendsparsesymmat(
    task,
    convert(Int32,dim),
    convert(Vector{Int32},subi),
    convert(Vector{Int32},subj),
    convert(Vector{Float64},valij))
end


"""
  appendsparsesymmatlist(task::MSKtask,dims::Vector{Int32},nz::Vector{Int64},subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64}) :: idx
  appendsparsesymmatlist(task::MSKtask,dims::T0,nz::T1,subi::T2,subj::T3,valij::T4) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number}}  :: idx

  Appends a general sparse symmetric matrix to the storage of symmetric matrices.

  Arguments
    task::MSKtask An optimization task.
    dims::Vector{Int32} Dimensions of the symmetric matrixes.
    nz::Vector{Int64} Number of nonzeros for each matrix.
    subi::Vector{Int32} Row subscript in the triplets.
    subj::Vector{Int32} Column subscripts in the triplets.
    valij::Vector{Float64} Values of each triplet.
  Returns
    idx::Vector{Int64} Unique index assigned to the inputted matrix.
"""
function appendsparsesymmatlist end
function appendsparsesymmatlist(task::MSKtask,dims::Vector{Int32},nz::Vector{Int64},subi::Vector{Int32},subj::Vector{Int32},valij::Vector{Float64})
  num = Int32(min(length(dims),length(nz)))
  dims_ = dims
  nz_ = nz
  if length(subi) < sum(nz)
    throw(BoundsError())
  end
  subi_ = subi .- Int32(1)
  if length(subj) < sum(nz)
    throw(BoundsError())
  end
  subj_ = subj .- Int32(1)
  if length(valij) < sum(nz)
    throw(BoundsError())
  end
  valij_ = valij
  idx_ = Vector{Int64}(undef,num)
  @MSK_appendsparsesymmatlist(task.task,num,dims_,nz_,subi_,subj_,valij_,idx_)
  idx = idx_;
  idx .+= 1
  idx
end
function appendsparsesymmatlist(task::MSKtask,dims::T0,nz::T1,subi::T2,subj::T3,valij::T4) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Number} }
  appendsparsesymmatlist(
    task,
    convert(Vector{Int32},dims),
    convert(Vector{Int64},nz),
    convert(Vector{Int32},subi),
    convert(Vector{Int32},subj),
    convert(Vector{Float64},valij))
end


"""
  getsymmatinfo(task::MSKtask,idx::Int64) :: (dim,nz,mattype)
  getsymmatinfo(task::MSKtask,idx::T0) where {T0<:Integer}  :: (dim,nz,mattype)

  Obtains information about a matrix from the symmetric matrix storage.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 Index of the matrix for which information is requested.
  Returns
    dim::Int32 Returns the dimension of the requested matrix.
    nz::Int64 Returns the number of non-zeros in the requested matrix.
    mattype::Symmattype Returns the type of the requested matrix.
"""
function getsymmatinfo end
function getsymmatinfo(task::MSKtask,idx::Int64)
  dim_ = Ref{Int32}()
  nz_ = Ref{Int64}()
  mattype_ = Ref{Int32}()
  @MSK_getsymmatinfo(task.task,idx-Int64(1),dim_,nz_,mattype_)
  mattype = Symmattype(mattype_[])
  dim_[],nz_[],mattype
end
function getsymmatinfo(task::MSKtask,idx::T0) where { T0<:Integer }
  getsymmatinfo(
    task,
    convert(Int64,idx))
end


"""
  getnumsymmat(task::MSKtask) :: num

  Obtains the number of symmetric matrices stored.

  Arguments
    task::MSKtask An optimization task.
  Returns
    num::Int64 The number of symmetric sparse matrices.
"""
function getnumsymmat end
function getnumsymmat(task::MSKtask)
  num_ = Ref{Int64}()
  @MSK_getnumsymmat(task.task,num_)
  num_[]
end


"""
  getsparsesymmat(task::MSKtask,idx::Int64) :: (subi,subj,valij)
  getsparsesymmat(task::MSKtask,idx::T0) where {T0<:Integer}  :: (subi,subj,valij)

  Gets a single symmetric matrix from the matrix store.

  Arguments
    task::MSKtask An optimization task.
    idx::Int64 Index of the matrix to retrieve.
  Returns
    subi::Vector{Int32} Row subscripts of the matrix non-zero elements.
    subj::Vector{Int32} Column subscripts of the matrix non-zero elements.
    valij::Vector{Float64} Coefficients of the matrix non-zero elements.
"""
function getsparsesymmat end
function getsparsesymmat(task::MSKtask,idx::Int64)
  __tmp_596 = Ref{Int64}()
  @MSK_getsymmatinfo(task.task,idx-Int64(1),Ref{Int32}(),__tmp_596,Ref{Int32}())
  __tmp_595 = __tmp_596[]
  maxlen = Int64(__tmp_595)
  subi_ = Vector{Int32}(undef,maxlen)
  subj_ = Vector{Int32}(undef,maxlen)
  valij_ = Vector{Float64}(undef,maxlen)
  @MSK_getsparsesymmat(task.task,idx-Int64(1),maxlen,subi_,subj_,valij_)
  subi = subi_;
  subi .+= 1
  subj = subj_;
  subj .+= 1
  valij = valij_;
  subi,subj,valij
end
function getsparsesymmat(task::MSKtask,idx::T0) where { T0<:Integer }
  getsparsesymmat(
    task,
    convert(Int64,idx))
end


"""
  putdouparam(task::MSKtask,param::Dparam,parvalue::Float64)
  putdouparam(task::MSKtask,param::Dparam,parvalue::T0) where {T0<:Number} 

  Sets a double parameter.

  Arguments
    task::MSKtask An optimization task.
    param::Dparam Which parameter.
    parvalue::Float64 Parameter value.
"""
function putdouparam end
function putdouparam(task::MSKtask,param::Dparam,parvalue::Float64)
  @MSK_putdouparam(task.task,param.value,parvalue)
  nothing
end
function putdouparam(task::MSKtask,param::Dparam,parvalue::T0) where { T0<:Number }
  putdouparam(
    task,
    param,
    convert(Float64,parvalue))
end


"""
  putintparam(task::MSKtask,param::Iparam,parvalue::Int32)
  putintparam(task::MSKtask,param::Iparam,parvalue::T0) where {T0<:Integer} 

  Sets an integer parameter.

  Arguments
    task::MSKtask An optimization task.
    param::Iparam Which parameter.
    parvalue::Int32 Parameter value.
"""
function putintparam end
function putintparam(task::MSKtask,param::Iparam,parvalue::Int32)
  @MSK_putintparam(task.task,param.value,parvalue)
  nothing
end
function putintparam(task::MSKtask,param::Iparam,parvalue::T0) where { T0<:Integer }
  putintparam(
    task,
    param,
    convert(Int32,parvalue))
end


"""
  putmaxnumcon(task::MSKtask,maxnumcon::Int32)
  putmaxnumcon(task::MSKtask,maxnumcon::T0) where {T0<:Integer} 

  Sets the number of preallocated constraints in the optimization task.

  Arguments
    task::MSKtask An optimization task.
    maxnumcon::Int32 Number of preallocated constraints in the optimization task.
"""
function putmaxnumcon end
function putmaxnumcon(task::MSKtask,maxnumcon::Int32)
  @MSK_putmaxnumcon(task.task,maxnumcon)
  nothing
end
function putmaxnumcon(task::MSKtask,maxnumcon::T0) where { T0<:Integer }
  putmaxnumcon(
    task,
    convert(Int32,maxnumcon))
end


"""
  putmaxnumcone(task::MSKtask,maxnumcone::Int32)
  putmaxnumcone(task::MSKtask,maxnumcone::T0) where {T0<:Integer} 

  Sets the number of preallocated conic constraints in the optimization task.

  Arguments
    task::MSKtask An optimization task.
    maxnumcone::Int32 Number of preallocated conic constraints in the optimization task.
"""
function putmaxnumcone end
function putmaxnumcone(task::MSKtask,maxnumcone::Int32)
  @MSK_putmaxnumcone(task.task,maxnumcone)
  nothing
end
function putmaxnumcone(task::MSKtask,maxnumcone::T0) where { T0<:Integer }
  putmaxnumcone(
    task,
    convert(Int32,maxnumcone))
end


"""
  getmaxnumcone(task::MSKtask) :: maxnumcone

  Obtains the number of preallocated cones in the optimization task.

  Arguments
    task::MSKtask An optimization task.
  Returns
    maxnumcone::Int32 Number of preallocated conic constraints in the optimization task.
"""
function getmaxnumcone end
function getmaxnumcone(task::MSKtask)
  maxnumcone_ = Ref{Int32}()
  @MSK_getmaxnumcone(task.task,maxnumcone_)
  maxnumcone_[]
end


"""
  putmaxnumvar(task::MSKtask,maxnumvar::Int32)
  putmaxnumvar(task::MSKtask,maxnumvar::T0) where {T0<:Integer} 

  Sets the number of preallocated variables in the optimization task.

  Arguments
    task::MSKtask An optimization task.
    maxnumvar::Int32 Number of preallocated variables in the optimization task.
"""
function putmaxnumvar end
function putmaxnumvar(task::MSKtask,maxnumvar::Int32)
  @MSK_putmaxnumvar(task.task,maxnumvar)
  nothing
end
function putmaxnumvar(task::MSKtask,maxnumvar::T0) where { T0<:Integer }
  putmaxnumvar(
    task,
    convert(Int32,maxnumvar))
end


"""
  putmaxnumbarvar(task::MSKtask,maxnumbarvar::Int32)
  putmaxnumbarvar(task::MSKtask,maxnumbarvar::T0) where {T0<:Integer} 

  Sets the number of preallocated symmetric matrix variables.

  Arguments
    task::MSKtask An optimization task.
    maxnumbarvar::Int32 Number of preallocated symmetric matrix variables.
"""
function putmaxnumbarvar end
function putmaxnumbarvar(task::MSKtask,maxnumbarvar::Int32)
  @MSK_putmaxnumbarvar(task.task,maxnumbarvar)
  nothing
end
function putmaxnumbarvar(task::MSKtask,maxnumbarvar::T0) where { T0<:Integer }
  putmaxnumbarvar(
    task,
    convert(Int32,maxnumbarvar))
end


"""
  putmaxnumanz(task::MSKtask,maxnumanz::Int64)
  putmaxnumanz(task::MSKtask,maxnumanz::T0) where {T0<:Integer} 

  Sets the number of preallocated non-zero entries in the linear coefficient matrix.

  Arguments
    task::MSKtask An optimization task.
    maxnumanz::Int64 New size of the storage reserved for storing the linear coefficient matrix.
"""
function putmaxnumanz end
function putmaxnumanz(task::MSKtask,maxnumanz::Int64)
  @MSK_putmaxnumanz(task.task,maxnumanz)
  nothing
end
function putmaxnumanz(task::MSKtask,maxnumanz::T0) where { T0<:Integer }
  putmaxnumanz(
    task,
    convert(Int64,maxnumanz))
end


"""
  putmaxnumqnz(task::MSKtask,maxnumqnz::Int64)
  putmaxnumqnz(task::MSKtask,maxnumqnz::T0) where {T0<:Integer} 

  Sets the number of preallocated non-zero entries in quadratic terms.

  Arguments
    task::MSKtask An optimization task.
    maxnumqnz::Int64 Number of non-zero elements preallocated in quadratic coefficient matrices.
"""
function putmaxnumqnz end
function putmaxnumqnz(task::MSKtask,maxnumqnz::Int64)
  @MSK_putmaxnumqnz(task.task,maxnumqnz)
  nothing
end
function putmaxnumqnz(task::MSKtask,maxnumqnz::T0) where { T0<:Integer }
  putmaxnumqnz(
    task,
    convert(Int64,maxnumqnz))
end


"""
  getmaxnumqnz(task::MSKtask) :: maxnumqnz

  Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints.

  Arguments
    task::MSKtask An optimization task.
  Returns
    maxnumqnz::Int64 Number of non-zero elements preallocated in quadratic coefficient matrices.
"""
function getmaxnumqnz end
function getmaxnumqnz(task::MSKtask)
  maxnumqnz_ = Ref{Int64}()
  @MSK_getmaxnumqnz64(task.task,maxnumqnz_)
  maxnumqnz_[]
end


"""
  putnadouparam(task::MSKtask,paramname::AbstractString,parvalue::Float64)
  putnadouparam(task::MSKtask,paramname::AbstractString,parvalue::T0) where {T0<:Number} 

  Sets a double parameter.

  Arguments
    task::MSKtask An optimization task.
    paramname::AbstractString Name of a parameter.
    parvalue::Float64 Parameter value.
"""
function putnadouparam end
function putnadouparam(task::MSKtask,paramname::AbstractString,parvalue::Float64)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  @MSK_putnadouparam(task.task,paramname_,parvalue)
  nothing
end
function putnadouparam(task::MSKtask,paramname::AbstractString,parvalue::T0) where { T0<:Number }
  putnadouparam(
    task,
    paramname,
    convert(Float64,parvalue))
end


"""
  putnaintparam(task::MSKtask,paramname::AbstractString,parvalue::Int32)
  putnaintparam(task::MSKtask,paramname::AbstractString,parvalue::T0) where {T0<:Integer} 

  Sets an integer parameter.

  Arguments
    task::MSKtask An optimization task.
    paramname::AbstractString Name of a parameter.
    parvalue::Int32 Parameter value.
"""
function putnaintparam end
function putnaintparam(task::MSKtask,paramname::AbstractString,parvalue::Int32)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  @MSK_putnaintparam(task.task,paramname_,parvalue)
  nothing
end
function putnaintparam(task::MSKtask,paramname::AbstractString,parvalue::T0) where { T0<:Integer }
  putnaintparam(
    task,
    paramname,
    convert(Int32,parvalue))
end


"""
  putnastrparam(task::MSKtask,paramname::AbstractString,parvalue::AbstractString)

  Sets a string parameter.

  Arguments
    task::MSKtask An optimization task.
    paramname::AbstractString Name of a parameter.
    parvalue::AbstractString Parameter value.
"""
function putnastrparam end
function putnastrparam(task::MSKtask,paramname::AbstractString,parvalue::AbstractString)
  paramname_ = Vector{UInt8}(paramname); push!(paramname_,UInt8(0))
  parvalue_ = Vector{UInt8}(parvalue); push!(parvalue_,UInt8(0))
  @MSK_putnastrparam(task.task,paramname_,parvalue_)
  nothing
end


"""
  putobjname(task::MSKtask,objname::AbstractString)

  Assigns a new name to the objective.

  Arguments
    task::MSKtask An optimization task.
    objname::AbstractString Name of the objective.
"""
function putobjname end
function putobjname(task::MSKtask,objname::AbstractString)
  objname_ = Vector{UInt8}(objname); push!(objname_,UInt8(0))
  @MSK_putobjname(task.task,objname_)
  nothing
end


"""
  putparam(task::MSKtask,parname::AbstractString,parvalue::AbstractString)

  Modifies the value of parameter.

  Arguments
    task::MSKtask An optimization task.
    parname::AbstractString Parameter name.
    parvalue::AbstractString Parameter value.
"""
function putparam end
function putparam(task::MSKtask,parname::AbstractString,parvalue::AbstractString)
  parname_ = Vector{UInt8}(parname); push!(parname_,UInt8(0))
  parvalue_ = Vector{UInt8}(parvalue); push!(parvalue_,UInt8(0))
  @MSK_putparam(task.task,parname_,parvalue_)
  nothing
end


"""
  putqcon(task::MSKtask,qcsubk::Vector{Int32},qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
  putqcon(task::MSKtask,qcsubk::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 

  Replaces all quadratic terms in constraints.

  Arguments
    task::MSKtask An optimization task.
    qcsubk::Vector{Int32} Constraint subscripts for quadratic coefficients.
    qcsubi::Vector{Int32} Row subscripts for quadratic constraint matrix.
    qcsubj::Vector{Int32} Column subscripts for quadratic constraint matrix.
    qcval::Vector{Float64} Quadratic constraint coefficient values.
"""
function putqcon end
function putqcon(task::MSKtask,qcsubk::Vector{Int32},qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
  numqcnz = Int32(min(length(qcsubi),length(qcsubj),length(qcval)))
  qcsubk_ = qcsubk .- Int32(1)
  qcsubi_ = qcsubi .- Int32(1)
  qcsubj_ = qcsubj .- Int32(1)
  qcval_ = qcval
  @MSK_putqcon(task.task,numqcnz,qcsubk_,qcsubi_,qcsubj_,qcval_)
  nothing
end
function putqcon(task::MSKtask,qcsubk::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putqcon(
    task,
    convert(Vector{Int32},qcsubk),
    convert(Vector{Int32},qcsubi),
    convert(Vector{Int32},qcsubj),
    convert(Vector{Float64},qcval))
end


"""
  putqconk(task::MSKtask,k::Int32,qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
  putqconk(task::MSKtask,k::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where {T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number}} 
  putqconk(task::MSKtask,k::T0,Qk:: SparseMatrixCSC{Float64})

  Replaces all quadratic terms in a single constraint.

  Arguments
    task::MSKtask An optimization task.
    k::Int32 The constraint in which the new quadratic elements are inserted.
    qcsubi::Vector{Int32} Row subscripts for quadratic constraint matrix.
    qcsubj::Vector{Int32} Column subscripts for quadratic constraint matrix.
    qcval::Vector{Float64} Quadratic constraint coefficient values.
    qcsubi::SparseMatrixCSC{Float64} Sparse matrix defining the column values
"""
function putqconk end
function putqconk(task::MSKtask,k::Int32,qcsubi::Vector{Int32},qcsubj::Vector{Int32},qcval::Vector{Float64})
  numqcnz = Int32(min(length(qcsubi),length(qcsubj),length(qcval)))
  qcsubi_ = qcsubi .- Int32(1)
  qcsubj_ = qcsubj .- Int32(1)
  qcval_ = qcval
  @MSK_putqconk(task.task,k-Int32(1),numqcnz,qcsubi_,qcsubj_,qcval_)
  nothing
end
function putqconk(task::MSKtask,k::T0,Qk:: SparseMatrixCSC{Float64}) where {T0<:Integer}
  qcsubi,qcsubj,qcval = tril(Qk)
  putqconk(task,k,qcsubi,qcsubj,qcval)
end
function putqconk(task::MSKtask,k::T0,qcsubi::T1,qcsubj::T2,qcval::T3) where { T0<:Integer,T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Integer},T3<:AbstractVector{<:Number} }
  putqconk(
    task,
    convert(Int32,k),
    convert(Vector{Int32},qcsubi),
    convert(Vector{Int32},qcsubj),
    convert(Vector{Float64},qcval))
end


"""
  putqobj(task::MSKtask,qosubi::Vector{Int32},qosubj::Vector{Int32},qoval::Vector{Float64})
  putqobj(task::MSKtask,qosubi::T0,qosubj::T1,qoval::T2) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number}} 
  putqobj(task::MSKtask,Qk:: SparseMatrixCSC{Float64})

  Replaces all quadratic terms in the objective.

  Arguments
    task::MSKtask An optimization task.
    qosubi::Vector{Int32} Row subscripts for quadratic objective coefficients.
    qosubj::Vector{Int32} Column subscripts for quadratic objective coefficients.
    qoval::Vector{Float64} Quadratic objective coefficient values.
    qosubi::SparseMatrixCSC{Float64} Sparse matrix defining the column values
"""
function putqobj end
function putqobj(task::MSKtask,qosubi::Vector{Int32},qosubj::Vector{Int32},qoval::Vector{Float64})
  numqonz = Int32(min(length(qosubi),length(qosubj),length(qoval)))
  qosubi_ = qosubi .- Int32(1)
  qosubj_ = qosubj .- Int32(1)
  qoval_ = qoval
  @MSK_putqobj(task.task,numqonz,qosubi_,qosubj_,qoval_)
  nothing
end
function putqobj(task::MSKtask,Qk:: SparseMatrixCSC{Float64})
  qosubi,qosubj,qoval = tril(Qk)
  putqobj(task,qosubi,qosubj,qoval)
end
function putqobj(task::MSKtask,qosubi::T0,qosubj::T1,qoval::T2) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer},T2<:AbstractVector{<:Number} }
  putqobj(
    task,
    convert(Vector{Int32},qosubi),
    convert(Vector{Int32},qosubj),
    convert(Vector{Float64},qoval))
end


"""
  putqobjij(task::MSKtask,i::Int32,j::Int32,qoij::Float64)
  putqobjij(task::MSKtask,i::T0,j::T1,qoij::T2) where {T0<:Integer,T1<:Integer,T2<:Number} 

  Replaces one coefficient in the quadratic term in the objective.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Row index for the coefficient to be replaced.
    j::Int32 Column index for the coefficient to be replaced.
    qoij::Float64 The new coefficient value.
"""
function putqobjij end
function putqobjij(task::MSKtask,i::Int32,j::Int32,qoij::Float64)
  @MSK_putqobjij(task.task,i-Int32(1),j-Int32(1),qoij)
  nothing
end
function putqobjij(task::MSKtask,i::T0,j::T1,qoij::T2) where { T0<:Integer,T1<:Integer,T2<:Number }
  putqobjij(
    task,
    convert(Int32,i),
    convert(Int32,j),
    convert(Float64,qoij))
end


"""
  putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Vector{Float64},xx::Vector{Float64},y::Vector{Float64},slc::Vector{Float64},suc::Vector{Float64},slx::Vector{Float64},sux::Vector{Float64},snx::Vector{Float64})
  putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number}} 

  Inserts a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    skc::Vector{Stakey} Status keys for the constraints.
    skx::Vector{Stakey} Status keys for the variables.
    skn::Vector{Stakey} Status keys for the conic constraints.
    xc::Vector{Float64} Primal constraint solution.
    xx::Vector{Float64} Primal variable solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
"""
function putsolution end
function putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Vector{Float64},xx::Vector{Float64},y::Vector{Float64},slc::Vector{Float64},suc::Vector{Float64},slx::Vector{Float64},sux::Vector{Float64},snx::Vector{Float64})
  skc_ = Int32[item.value for item in skc]
  skx_ = Int32[item.value for item in skx]
  skn_ = Int32[item.value for item in skn]
  xc_ = xc
  xx_ = xx
  y_ = y
  slc_ = slc
  suc_ = suc
  slx_ = slx
  sux_ = sux
  snx_ = snx
  @MSK_putsolution(task.task,whichsol.value,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_)
  nothing
end
function putsolution(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number} }
  putsolution(
    task,
    whichsol,
    skc,
    skx,
    skn,
    convert(Vector{Float64},xc),
    convert(Vector{Float64},xx),
    convert(Vector{Float64},y),
    convert(Vector{Float64},slc),
    convert(Vector{Float64},suc),
    convert(Vector{Float64},slx),
    convert(Vector{Float64},sux),
    convert(Vector{Float64},snx))
end


"""
  putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Vector{Float64},xx::Vector{Float64},y::Vector{Float64},slc::Vector{Float64},suc::Vector{Float64},slx::Vector{Float64},sux::Vector{Float64},snx::Vector{Float64},doty::Vector{Float64})
  putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7,doty::T8) where {T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number}} 

  Inserts a solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    skc::Vector{Stakey} Status keys for the constraints.
    skx::Vector{Stakey} Status keys for the variables.
    skn::Vector{Stakey} Status keys for the conic constraints.
    xc::Vector{Float64} Primal constraint solution.
    xx::Vector{Float64} Primal variable solution.
    y::Vector{Float64} Vector of dual variables corresponding to the constraints.
    slc::Vector{Float64} Dual variables corresponding to the lower bounds on the constraints.
    suc::Vector{Float64} Dual variables corresponding to the upper bounds on the constraints.
    slx::Vector{Float64} Dual variables corresponding to the lower bounds on the variables.
    sux::Vector{Float64} Dual variables corresponding to the upper bounds on the variables.
    snx::Vector{Float64} Dual variables corresponding to the conic constraints on the variables.
    doty::Vector{Float64} Dual variables corresponding to affine conic constraints.
"""
function putsolutionnew end
function putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::Vector{Float64},xx::Vector{Float64},y::Vector{Float64},slc::Vector{Float64},suc::Vector{Float64},slx::Vector{Float64},sux::Vector{Float64},snx::Vector{Float64},doty::Vector{Float64})
  skc_ = Int32[item.value for item in skc]
  skx_ = Int32[item.value for item in skx]
  skn_ = Int32[item.value for item in skn]
  xc_ = xc
  xx_ = xx
  y_ = y
  slc_ = slc
  suc_ = suc
  slx_ = slx
  sux_ = sux
  snx_ = snx
  doty_ = doty
  @MSK_putsolutionnew(task.task,whichsol.value,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_,doty_)
  nothing
end
function putsolutionnew(task::MSKtask,whichsol::Soltype,skc::Vector{Stakey},skx::Vector{Stakey},skn::Vector{Stakey},xc::T0,xx::T1,y::T2,slc::T3,suc::T4,slx::T5,sux::T6,snx::T7,doty::T8) where { T0<:AbstractVector{<:Number},T1<:AbstractVector{<:Number},T2<:AbstractVector{<:Number},T3<:AbstractVector{<:Number},T4<:AbstractVector{<:Number},T5<:AbstractVector{<:Number},T6<:AbstractVector{<:Number},T7<:AbstractVector{<:Number},T8<:AbstractVector{<:Number} }
  putsolutionnew(
    task,
    whichsol,
    skc,
    skx,
    skn,
    convert(Vector{Float64},xc),
    convert(Vector{Float64},xx),
    convert(Vector{Float64},y),
    convert(Vector{Float64},slc),
    convert(Vector{Float64},suc),
    convert(Vector{Float64},slx),
    convert(Vector{Float64},sux),
    convert(Vector{Float64},snx),
    convert(Vector{Float64},doty))
end


"""
  putconsolutioni(task::MSKtask,i::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64)
  putconsolutioni(task::MSKtask,i::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3) where {T0<:Integer,T1<:Number,T2<:Number,T3<:Number} 

  Sets the primal and dual solution information for a single constraint.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the constraint.
    whichsol::Soltype Selects a solution.
    sk::Stakey Status key of the constraint.
    x::Float64 Primal solution value of the constraint.
    sl::Float64 Solution value of the dual variable associated with the lower bound.
    su::Float64 Solution value of the dual variable associated with the upper bound.
"""
function putconsolutioni end
function putconsolutioni(task::MSKtask,i::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64)
  @MSK_putconsolutioni(task.task,i-Int32(1),whichsol.value,sk.value,x,sl,su)
  nothing
end
function putconsolutioni(task::MSKtask,i::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3) where { T0<:Integer,T1<:Number,T2<:Number,T3<:Number }
  putconsolutioni(
    task,
    convert(Int32,i),
    whichsol,
    sk,
    convert(Float64,x),
    convert(Float64,sl),
    convert(Float64,su))
end


"""
  putvarsolutionj(task::MSKtask,j::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64,sn::Float64)
  putvarsolutionj(task::MSKtask,j::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3,sn::T4) where {T0<:Integer,T1<:Number,T2<:Number,T3<:Number,T4<:Number} 

  Sets the primal and dual solution information for a single variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable.
    whichsol::Soltype Selects a solution.
    sk::Stakey Status key of the variable.
    x::Float64 Primal solution value of the variable.
    sl::Float64 Solution value of the dual variable associated with the lower bound.
    su::Float64 Solution value of the dual variable associated with the upper bound.
    sn::Float64 Solution value of the dual variable associated with the conic constraint.
"""
function putvarsolutionj end
function putvarsolutionj(task::MSKtask,j::Int32,whichsol::Soltype,sk::Stakey,x::Float64,sl::Float64,su::Float64,sn::Float64)
  @MSK_putvarsolutionj(task.task,j-Int32(1),whichsol.value,sk.value,x,sl,su,sn)
  nothing
end
function putvarsolutionj(task::MSKtask,j::T0,whichsol::Soltype,sk::Stakey,x::T1,sl::T2,su::T3,sn::T4) where { T0<:Integer,T1<:Number,T2<:Number,T3<:Number,T4<:Number }
  putvarsolutionj(
    task,
    convert(Int32,j),
    whichsol,
    sk,
    convert(Float64,x),
    convert(Float64,sl),
    convert(Float64,su),
    convert(Float64,sn))
end


"""
  putsolutionyi(task::MSKtask,i::Int32,whichsol::Soltype,y::Float64)
  putsolutionyi(task::MSKtask,i::T0,whichsol::Soltype,y::T1) where {T0<:Integer,T1<:Number} 

  Inputs the dual variable of a solution.

  Arguments
    task::MSKtask An optimization task.
    i::Int32 Index of the dual variable.
    whichsol::Soltype Selects a solution.
    y::Float64 Solution value of the dual variable.
"""
function putsolutionyi end
function putsolutionyi(task::MSKtask,i::Int32,whichsol::Soltype,y::Float64)
  @MSK_putsolutionyi(task.task,i-Int32(1),whichsol.value,y)
  nothing
end
function putsolutionyi(task::MSKtask,i::T0,whichsol::Soltype,y::T1) where { T0<:Integer,T1<:Number }
  putsolutionyi(
    task,
    convert(Int32,i),
    whichsol,
    convert(Float64,y))
end


"""
  putstrparam(task::MSKtask,param::Sparam,parvalue::AbstractString)

  Sets a string parameter.

  Arguments
    task::MSKtask An optimization task.
    param::Sparam Which parameter.
    parvalue::AbstractString Parameter value.
"""
function putstrparam end
function putstrparam(task::MSKtask,param::Sparam,parvalue::AbstractString)
  parvalue_ = Vector{UInt8}(parvalue); push!(parvalue_,UInt8(0))
  @MSK_putstrparam(task.task,param.value,parvalue_)
  nothing
end


"""
  puttaskname(task::MSKtask,taskname::AbstractString)

  Assigns a new name to the task.

  Arguments
    task::MSKtask An optimization task.
    taskname::AbstractString Name assigned to the task.
"""
function puttaskname end
function puttaskname(task::MSKtask,taskname::AbstractString)
  taskname_ = Vector{UInt8}(taskname); push!(taskname_,UInt8(0))
  @MSK_puttaskname(task.task,taskname_)
  nothing
end


"""
  putvartype(task::MSKtask,j::Int32,vartype::Variabletype)
  putvartype(task::MSKtask,j::T0,vartype::Variabletype) where {T0<:Integer} 

  Sets the variable type of one variable.

  Arguments
    task::MSKtask An optimization task.
    j::Int32 Index of the variable.
    vartype::Variabletype The new variable type.
"""
function putvartype end
function putvartype(task::MSKtask,j::Int32,vartype::Variabletype)
  @MSK_putvartype(task.task,j-Int32(1),vartype.value)
  nothing
end
function putvartype(task::MSKtask,j::T0,vartype::Variabletype) where { T0<:Integer }
  putvartype(
    task,
    convert(Int32,j),
    vartype)
end


"""
  putvartypelist(task::MSKtask,subj::Vector{Int32},vartype::Vector{Variabletype})
  putvartypelist(task::MSKtask,subj::T0,vartype::Vector{Variabletype}) where {T0<:AbstractVector{<:Integer}} 

  Sets the variable type for one or more variables.

  Arguments
    task::MSKtask An optimization task.
    subj::Vector{Int32} A list of variable indexes for which the variable type should be changed.
    vartype::Vector{Variabletype} A list of variable types.
"""
function putvartypelist end
function putvartypelist(task::MSKtask,subj::Vector{Int32},vartype::Vector{Variabletype})
  num = Int32(min(length(subj),length(vartype)))
  subj_ = subj .- Int32(1)
  vartype_ = Int32[item.value for item in vartype]
  @MSK_putvartypelist(task.task,num,subj_,vartype_)
  nothing
end
function putvartypelist(task::MSKtask,subj::T0,vartype::Vector{Variabletype}) where { T0<:AbstractVector{<:Integer} }
  putvartypelist(
    task,
    convert(Vector{Int32},subj),
    vartype)
end


"""
  readdataformat(task::MSKtask,filename::AbstractString,format::Dataformat,compress::Compresstype)

  Reads problem data from a file.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
    format::Dataformat File data format.
    compress::Compresstype File compression type.
"""
function readdataformat end
function readdataformat(task::MSKtask,filename::AbstractString,format::Dataformat,compress::Compresstype)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readdataformat(task.task,filename_,format.value,compress.value)
  nothing
end


"""
  readdata(task::MSKtask,filename::AbstractString)

  Reads problem data from a file.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function readdata end
function readdata(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readdataautoformat(task.task,filename_)
  nothing
end


"""
  readparamfile(task::MSKtask,filename::AbstractString)

  Reads a parameter file.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function readparamfile end
function readparamfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readparamfile(task.task,filename_)
  nothing
end


"""
  readsolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)

  Reads a solution from a file.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    filename::AbstractString A valid file name.
"""
function readsolution end
function readsolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readsolution(task.task,whichsol.value,filename_)
  nothing
end


"""
  readsummary(task::MSKtask,whichstream::Streamtype)

  Prints information about last file read.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function readsummary end
function readsummary(task::MSKtask,whichstream::Streamtype)
  @MSK_readsummary(task.task,whichstream.value)
  nothing
end


"""
  resizetask(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,maxnumcone::Int32,maxnumanz::Int64,maxnumqnz::Int64)
  resizetask(task::MSKtask,maxnumcon::T0,maxnumvar::T1,maxnumcone::T2,maxnumanz::T3,maxnumqnz::T4) where {T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer,T4<:Integer} 

  Resizes an optimization task.

  Arguments
    task::MSKtask An optimization task.
    maxnumcon::Int32 New maximum number of constraints.
    maxnumvar::Int32 New maximum number of variables.
    maxnumcone::Int32 New maximum number of cones.
    maxnumanz::Int64 New maximum number of linear non-zero elements.
    maxnumqnz::Int64 New maximum number of quadratic non-zeros elements.
"""
function resizetask end
function resizetask(task::MSKtask,maxnumcon::Int32,maxnumvar::Int32,maxnumcone::Int32,maxnumanz::Int64,maxnumqnz::Int64)
  @MSK_resizetask(task.task,maxnumcon,maxnumvar,maxnumcone,maxnumanz,maxnumqnz)
  nothing
end
function resizetask(task::MSKtask,maxnumcon::T0,maxnumvar::T1,maxnumcone::T2,maxnumanz::T3,maxnumqnz::T4) where { T0<:Integer,T1<:Integer,T2<:Integer,T3<:Integer,T4<:Integer }
  resizetask(
    task,
    convert(Int32,maxnumcon),
    convert(Int32,maxnumvar),
    convert(Int32,maxnumcone),
    convert(Int64,maxnumanz),
    convert(Int64,maxnumqnz))
end


"""
  checkmem(task::MSKtask,file::AbstractString,line::Int32)
  checkmem(task::MSKtask,file::AbstractString,line::T0) where {T0<:Integer} 

  Checks the memory allocated by the task.

  Arguments
    task::MSKtask An optimization task.
    file::AbstractString File from which the function is called.
    line::Int32 Line in the file from which the function is called.
"""
function checkmem end
function checkmem(task::MSKtask,file::AbstractString,line::Int32)
  file_ = Vector{UInt8}(file); push!(file_,UInt8(0))
  @MSK_checkmemtask(task.task,file_,line)
  nothing
end
function checkmem(task::MSKtask,file::AbstractString,line::T0) where { T0<:Integer }
  checkmem(
    task,
    file,
    convert(Int32,line))
end


"""
  getmemusage(task::MSKtask) :: (meminuse,maxmemuse)

  Obtains information about the amount of memory used by a task.

  Arguments
    task::MSKtask An optimization task.
  Returns
    meminuse::Int64 Amount of memory currently used by the task.
    maxmemuse::Int64 Maximum amount of memory used by the task until now.
"""
function getmemusage end
function getmemusage(task::MSKtask)
  meminuse_ = Ref{Int64}()
  maxmemuse_ = Ref{Int64}()
  @MSK_getmemusagetask(task.task,meminuse_,maxmemuse_)
  meminuse_[],maxmemuse_[]
end


"""
  setdefaults(task::MSKtask)

  Resets all parameter values.

  Arguments
    task::MSKtask An optimization task.
"""
function setdefaults end
function setdefaults(task::MSKtask)
  @MSK_setdefaults(task.task)
  nothing
end


"""
  solutiondef(task::MSKtask,whichsol::Soltype) :: isdef

  Checks whether a solution is defined.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
  Returns
    isdef::Bool Is non-zero if the requested solution is defined.
"""
function solutiondef end
function solutiondef(task::MSKtask,whichsol::Soltype)
  isdef_ = Ref{Int32}()
  @MSK_solutiondef(task.task,whichsol.value,isdef_)
  isdef_[] != 0
end


"""
  deletesolution(task::MSKtask,whichsol::Soltype)

  Undefine a solution and free the memory it uses.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function deletesolution end
function deletesolution(task::MSKtask,whichsol::Soltype)
  @MSK_deletesolution(task.task,whichsol.value)
  nothing
end


"""
  onesolutionsummary(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)

  Prints a short summary of a specified solution.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
    whichsol::Soltype Selects a solution.
"""
function onesolutionsummary end
function onesolutionsummary(task::MSKtask,whichstream::Streamtype,whichsol::Soltype)
  @MSK_onesolutionsummary(task.task,whichstream.value,whichsol.value)
  nothing
end


"""
  solutionsummary(task::MSKtask,whichstream::Streamtype)

  Prints a short summary of the current solutions.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function solutionsummary end
function solutionsummary(task::MSKtask,whichstream::Streamtype)
  @MSK_solutionsummary(task.task,whichstream.value)
  nothing
end


"""
  updatesolutioninfo(task::MSKtask,whichsol::Soltype)

  Update the information items related to the solution.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
"""
function updatesolutioninfo end
function updatesolutioninfo(task::MSKtask,whichsol::Soltype)
  @MSK_updatesolutioninfo(task.task,whichsol.value)
  nothing
end


"""
  optimizersummary(task::MSKtask,whichstream::Streamtype)

  Prints a short summary with optimizer statistics from last optimization.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function optimizersummary end
function optimizersummary(task::MSKtask,whichstream::Streamtype)
  @MSK_optimizersummary(task.task,whichstream.value)
  nothing
end


"""
  strtoconetype(task::MSKtask,str::AbstractString) :: conetype

  Obtains a cone type code.

  Arguments
    task::MSKtask An optimization task.
    str::AbstractString String corresponding to the cone type code.
  Returns
    conetype::Conetype The cone type corresponding to str.
"""
function strtoconetype end
function strtoconetype(task::MSKtask,str::AbstractString)
  str_ = Vector{UInt8}(str); push!(str_,UInt8(0))
  conetype_ = Ref{Int32}()
  @MSK_strtoconetype(task.task,str_,conetype_)
  conetype = Conetype(conetype_[])
  conetype
end


"""
  strtosk(task::MSKtask,str::AbstractString) :: sk

  Obtains a status key.

  Arguments
    task::MSKtask An optimization task.
    str::AbstractString A status key abbreviation string.
  Returns
    sk::Stakey Status key corresponding to the string.
"""
function strtosk end
function strtosk(task::MSKtask,str::AbstractString)
  str_ = Vector{UInt8}(str); push!(str_,UInt8(0))
  sk_ = Ref{Int32}()
  @MSK_strtosk(task.task,str_,sk_)
  sk = Stakey(sk_[])
  sk
end


"""
  writedata(task::MSKtask,filename::AbstractString)

  Writes problem data to a file.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function writedata end
function writedata(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writedata(task.task,filename_)
  nothing
end


"""
  writetask(task::MSKtask,filename::AbstractString)

  Write a complete binary dump of the task data.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function writetask end
function writetask(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writetask(task.task,filename_)
  nothing
end


"""
  writebsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)

  Write a binary dump of the task solution and information items.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
    compress::Compresstype 
"""
function writebsolution end
function writebsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writebsolution(task.task,filename_,compress.value)
  nothing
end


"""
  readbsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)

  Read a binary dump of the task solution and information items.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
    compress::Compresstype 
"""
function readbsolution end
function readbsolution(task::MSKtask,filename::AbstractString,compress::Compresstype)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readbsolution(task.task,filename_,compress.value)
  nothing
end


"""
  writesolutionfile(task::MSKtask,filename::AbstractString)

  Write solution file in format determined by the filename

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function writesolutionfile end
function writesolutionfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writesolutionfile(task.task,filename_)
  nothing
end


"""
  readsolutionfile(task::MSKtask,filename::AbstractString)

  Read solution file in format determined by the filename

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function readsolutionfile end
function readsolutionfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readsolutionfile(task.task,filename_)
  nothing
end


"""
  readtask(task::MSKtask,filename::AbstractString)

  Load task data from a file.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function readtask end
function readtask(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_readtask(task.task,filename_)
  nothing
end


"""
  readopfstring(task::MSKtask,data::AbstractString)

  Load task data from a string in OPF format.

  Arguments
    task::MSKtask An optimization task.
    data::AbstractString Problem data in text format.
"""
function readopfstring end
function readopfstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readopfstring(task.task,data_)
  nothing
end


"""
  readlpstring(task::MSKtask,data::AbstractString)

  Load task data from a string in LP format.

  Arguments
    task::MSKtask An optimization task.
    data::AbstractString Problem data in text format.
"""
function readlpstring end
function readlpstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readlpstring(task.task,data_)
  nothing
end


"""
  readjsonstring(task::MSKtask,data::AbstractString)

  Load task data from a string in JSON format.

  Arguments
    task::MSKtask An optimization task.
    data::AbstractString Problem data in text format.
"""
function readjsonstring end
function readjsonstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readjsonstring(task.task,data_)
  nothing
end


"""
  readptfstring(task::MSKtask,data::AbstractString)

  Load task data from a string in PTF format.

  Arguments
    task::MSKtask An optimization task.
    data::AbstractString Problem data in text format.
"""
function readptfstring end
function readptfstring(task::MSKtask,data::AbstractString)
  data_ = Vector{UInt8}(data); push!(data_,UInt8(0))
  @MSK_readptfstring(task.task,data_)
  nothing
end


"""
  writeparamfile(task::MSKtask,filename::AbstractString)

  Writes all the parameters to a parameter file.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function writeparamfile end
function writeparamfile(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writeparamfile(task.task,filename_)
  nothing
end


"""
  getinfeasiblesubproblem(task::MSKtask,whichsol::Soltype) :: inftask

  Obtains an infeasible subproblem.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Which solution to use when determining the infeasible subproblem.
  Returns
    inftask::MSKtask A new task containing the infeasible subproblem.
"""
function getinfeasiblesubproblem end
function getinfeasiblesubproblem(task::MSKtask,whichsol::Soltype)
  inftask_ = Ref{Ptr{Nothing}}()
  @MSK_getinfeasiblesubproblem(task.task,whichsol.value,inftask_)
  inftask = Task(inftask_[],False)
  inftask
end


"""
  writesolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)

  Write a solution to a file.

  Arguments
    task::MSKtask An optimization task.
    whichsol::Soltype Selects a solution.
    filename::AbstractString A valid file name.
"""
function writesolution end
function writesolution(task::MSKtask,whichsol::Soltype,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writesolution(task.task,whichsol.value,filename_)
  nothing
end


"""
  writejsonsol(task::MSKtask,filename::AbstractString)

  Writes a solution to a JSON file.

  Arguments
    task::MSKtask An optimization task.
    filename::AbstractString A valid file name.
"""
function writejsonsol end
function writejsonsol(task::MSKtask,filename::AbstractString)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_writejsonsol(task.task,filename_)
  nothing
end


"""
  primalsensitivity(task::MSKtask,subi::Vector{Int32},marki::Vector{Mark},subj::Vector{Int32},markj::Vector{Mark}) :: (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej)
  primalsensitivity(task::MSKtask,subi::T0,marki::Vector{Mark},subj::T1,markj::Vector{Mark}) where {T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer}}  :: (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej)

  Perform sensitivity analysis on bounds.

  Arguments
    task::MSKtask An optimization task.
    subi::Vector{Int32} Indexes of constraints to analyze.
    marki::Vector{Mark} Mark which constraint bounds to analyze.
    subj::Vector{Int32} Indexes of variables to analyze.
    markj::Vector{Mark} Mark which variable bounds to analyze.
  Returns
    leftpricei::Vector{Float64} Left shadow price for constraints.
    rightpricei::Vector{Float64} Right shadow price for constraints.
    leftrangei::Vector{Float64} Left range for constraints.
    rightrangei::Vector{Float64} Right range for constraints.
    leftpricej::Vector{Float64} Left shadow price for variables.
    rightpricej::Vector{Float64} Right shadow price for variables.
    leftrangej::Vector{Float64} Left range for variables.
    rightrangej::Vector{Float64} Right range for variables.
"""
function primalsensitivity end
function primalsensitivity(task::MSKtask,subi::Vector{Int32},marki::Vector{Mark},subj::Vector{Int32},markj::Vector{Mark})
  numi = Int32(min(length(subi),length(marki)))
  subi_ = subi .- Int32(1)
  marki_ = Int32[item.value for item in marki]
  numj = Int32(min(length(subj),length(markj)))
  subj_ = subj .- Int32(1)
  markj_ = Int32[item.value for item in markj]
  leftpricei_ = Vector{Float64}(undef,numi)
  rightpricei_ = Vector{Float64}(undef,numi)
  leftrangei_ = Vector{Float64}(undef,numi)
  rightrangei_ = Vector{Float64}(undef,numi)
  leftpricej_ = Vector{Float64}(undef,numj)
  rightpricej_ = Vector{Float64}(undef,numj)
  leftrangej_ = Vector{Float64}(undef,numj)
  rightrangej_ = Vector{Float64}(undef,numj)
  @MSK_primalsensitivity(task.task,numi,subi_,marki_,numj,subj_,markj_,leftpricei_,rightpricei_,leftrangei_,rightrangei_,leftpricej_,rightpricej_,leftrangej_,rightrangej_)
  leftpricei = leftpricei_;
  rightpricei = rightpricei_;
  leftrangei = leftrangei_;
  rightrangei = rightrangei_;
  leftpricej = leftpricej_;
  rightpricej = rightpricej_;
  leftrangej = leftrangej_;
  rightrangej = rightrangej_;
  leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej
end
function primalsensitivity(task::MSKtask,subi::T0,marki::Vector{Mark},subj::T1,markj::Vector{Mark}) where { T0<:AbstractVector{<:Integer},T1<:AbstractVector{<:Integer} }
  primalsensitivity(
    task,
    convert(Vector{Int32},subi),
    marki,
    convert(Vector{Int32},subj),
    markj)
end


"""
  sensitivityreport(task::MSKtask,whichstream::Streamtype)

  Creates a sensitivity report.

  Arguments
    task::MSKtask An optimization task.
    whichstream::Streamtype Index of the stream.
"""
function sensitivityreport end
function sensitivityreport(task::MSKtask,whichstream::Streamtype)
  @MSK_sensitivityreport(task.task,whichstream.value)
  nothing
end


"""
  dualsensitivity(task::MSKtask,subj::Vector{Int32}) :: (leftpricej,rightpricej,leftrangej,rightrangej)
  dualsensitivity(task::MSKtask,subj::T0) where {T0<:AbstractVector{<:Integer}}  :: (leftpricej,rightpricej,leftrangej,rightrangej)

  Performs sensitivity analysis on objective coefficients.

  Arguments
    task::MSKtask An optimization task.
    subj::Vector{Int32} Indexes of objective coefficients to analyze.
  Returns
    leftpricej::Vector{Float64} Left shadow prices for requested coefficients.
    rightpricej::Vector{Float64} Right shadow prices for requested coefficients.
    leftrangej::Vector{Float64} Left range for requested coefficients.
    rightrangej::Vector{Float64} Right range for requested coefficients.
"""
function dualsensitivity end
function dualsensitivity(task::MSKtask,subj::Vector{Int32})
  numj = Int32(length(subj))
  subj_ = subj .- Int32(1)
  leftpricej_ = Vector{Float64}(undef,numj)
  rightpricej_ = Vector{Float64}(undef,numj)
  leftrangej_ = Vector{Float64}(undef,numj)
  rightrangej_ = Vector{Float64}(undef,numj)
  @MSK_dualsensitivity(task.task,numj,subj_,leftpricej_,rightpricej_,leftrangej_,rightrangej_)
  leftpricej = leftpricej_;
  rightpricej = rightpricej_;
  leftrangej = leftrangej_;
  rightrangej = rightrangej_;
  leftpricej,rightpricej,leftrangej,rightrangej
end
function dualsensitivity(task::MSKtask,subj::T0) where { T0<:AbstractVector{<:Integer} }
  dualsensitivity(
    task,
    convert(Vector{Int32},subj))
end


"""
  getlasterror(task::MSKtask) :: (lastrescode,lastmsglen,lastmsg)

  Obtains the last error code and error message reported in MOSEK.

  Arguments
    task::MSKtask An optimization task.
  Returns
    lastrescode::Rescode Returns the last error code reported in the task.
    lastmsglen::Int64 Returns the length of the last error message reported in the task.
    lastmsg::String Returns the last error message reported in the task.
"""
function getlasterror end
function getlasterror(task::MSKtask)
  lastrescode_ = Ref{Int32}()
  __tmp_662 = Ref{Int64}()
  @MSK_getlasterror64(task.task,Ref{Int32}(),0,__tmp_662,C_NULL)
  __tmp_661 = __tmp_662[]
  sizelastmsg = Int64((__tmp_661 + Int64(1)))
  lastmsglen_ = Ref{Int64}()
  lastmsg_ = Array{UInt8}(undef,sizelastmsg)
  @MSK_getlasterror64(task.task,lastrescode_,sizelastmsg,lastmsglen_,lastmsg_)
  lastrescode = Rescode(lastrescode_[])
  lastmsg_len = findfirst(_c->_c==0,lastmsg_)
  lastmsg = if lastmsg_len === nothing
    String(lastmsg_)
  else
    String(lastmsg_[1:lastmsg_len-1])
  end
  lastrescode,lastmsglen_[],lastmsg
end


"""
  optimizermt(task::MSKtask,address::AbstractString,accesstoken::AbstractString) :: trmcode

  Offload the optimization task to a solver server and wait for the solution.

  Arguments
    task::MSKtask An optimization task.
    address::AbstractString Address of the OptServer.
    accesstoken::AbstractString Access token.
  Returns
    trmcode::Rescode Is either OK or a termination response code.
"""
function optimizermt end
function optimizermt(task::MSKtask,address::AbstractString,accesstoken::AbstractString)
  address_ = Vector{UInt8}(address); push!(address_,UInt8(0))
  accesstoken_ = Vector{UInt8}(accesstoken); push!(accesstoken_,UInt8(0))
  trmcode_ = Ref{Int32}()
  @MSK_optimizermt(task.task,address_,accesstoken_,trmcode_)
  trmcode = Rescode(trmcode_[])
  trmcode
end


"""
  putoptserverhost(task::MSKtask,host::AbstractString)

  Specify an OptServer for remote calls.

  Arguments
    task::MSKtask An optimization task.
    host::AbstractString A URL specifying the optimization server to be used.
"""
function putoptserverhost end
function putoptserverhost(task::MSKtask,host::AbstractString)
  host_ = Vector{UInt8}(host); push!(host_,UInt8(0))
  @MSK_putoptserverhost(task.task,host_)
  nothing
end


"""
  optimizebatch(env::MSKenv,israce::Int32,maxtime::Float64,numthreads::Int32,task::Vector{MSKtask}) :: (trmcode,rcode)
  optimizebatch(env::MSKenv,israce::T0,maxtime::T1,numthreads::T2,task::Vector{MSKtask}) where {T0<:Integer,T1<:Number,T2<:Integer}  :: (trmcode,rcode)

  Optimize a number of tasks in parallel using a specified number of threads.

  Arguments
    env::MSKenv The MOSEK environment.
    israce::Int32 If nonzero, then the function is terminated after the first task has been completed.
    maxtime::Float64 Time limit for the function.
    numthreads::Int32 Number of threads to be employed.
    task::Vector{MSKtask} An array of tasks to optimize in parallel.
  Returns
    trmcode::Vector{Rescode} The termination code for each task.
    rcode::Vector{Rescode} The response code for each task.
"""
function optimizebatch end
function optimizebatch(env::MSKenv,israce::Int32,maxtime::Float64,numthreads::Int32,task::Vector{MSKtask})
  numtask = Int64(length(task))
  if length(task) < numtask
    throw(BoundsError())
  end
  task_ = Ptr{Nothing}[item.task for item in task]
  trmcode_ = Vector{Int32}(undef,numtask)
  rcode_ = Vector{Int32}(undef,numtask)
  @MSK_optimizebatch(env.env,israce,maxtime,numthreads,numtask,task_,trmcode_,rcode_)
  trmcode = Rescode[Rescode(item) for item in trmcode_]
  rcode = Rescode[Rescode(item) for item in rcode_]
  trmcode,rcode
end
function optimizebatch(env::MSKenv,israce::T0,maxtime::T1,numthreads::T2,task::Vector{MSKtask}) where { T0<:Integer,T1<:Number,T2<:Integer }
  optimizebatch(
    env,
    convert(Int32,israce),
    convert(Float64,maxtime),
    convert(Int32,numthreads),
    task)
end


"""
  checkoutlicense(env::MSKenv,feature::Feature)

  Check out a license feature from the license server ahead of time.

  Arguments
    env::MSKenv The MOSEK environment.
    feature::Feature Feature to check out from the license system.
"""
function checkoutlicense end
function checkoutlicense(env::MSKenv,feature::Feature)
  @MSK_checkoutlicense(env.env,feature.value)
  nothing
end


"""
  checkinlicense(env::MSKenv,feature::Feature)

  Check in a license feature back to the license server ahead of time.

  Arguments
    env::MSKenv The MOSEK environment.
    feature::Feature Feature to check in to the license system.
"""
function checkinlicense end
function checkinlicense(env::MSKenv,feature::Feature)
  @MSK_checkinlicense(env.env,feature.value)
  nothing
end


"""
  checkinall(env::MSKenv)

  Check in all unused license features to the license token server.

  Arguments
    env::MSKenv The MOSEK environment.
"""
function checkinall end
function checkinall(env::MSKenv)
  @MSK_checkinall(env.env)
  nothing
end


"""
  expirylicenses(env::MSKenv) :: expiry

  Reports when the first license feature expires.

  Arguments
    env::MSKenv The MOSEK environment.
  Returns
    expiry::Int64 If nonnegative, then it is the minimum number days to expiry of any feature that has been checked out.
"""
function expirylicenses end
function expirylicenses(env::MSKenv)
  expiry_ = Ref{Int64}()
  @MSK_expirylicenses(env.env,expiry_)
  expiry_[]
end


"""
  resetexpirylicenses(env::MSKenv)

  Reset the license expiry reporting startpoint.

  Arguments
    env::MSKenv The MOSEK environment.
"""
function resetexpirylicenses end
function resetexpirylicenses(env::MSKenv)
  @MSK_resetexpirylicenses(env.env)
  nothing
end


"""
  echointro(env::MSKenv,longver::Int32)
  echointro(env::MSKenv,longver::T0) where {T0<:Integer} 

  Prints an intro to message stream.

  Arguments
    env::MSKenv The MOSEK environment.
    longver::Int32 If non-zero, then the intro is slightly longer.
"""
function echointro end
function echointro(env::MSKenv,longver::Int32)
  @MSK_echointro(env.env,longver)
  nothing
end
function echointro(env::MSKenv,longver::T0) where { T0<:Integer }
  echointro(
    env,
    convert(Int32,longver))
end


"""
  getcodedesc(code::Rescode) :: (symname,str)

  Obtains a short description of a response code.

  Arguments
    code::Rescode A valid response code.
  Returns
    symname::String Symbolic name corresponding to the code.
    str::String Obtains a short description of a response code.
"""
function getcodedesc end
function getcodedesc(code::Rescode)
  symname_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  str_ = Array{UInt8}(undef,MSK_MAX_STR_LEN)
  @MSK_getcodedesc(code.value,symname_,str_)
  symname_len = findfirst(_c->_c==0,symname_)
  symname = if symname_len === nothing
    String(symname_)
  else
    String(symname_[1:symname_len-1])
  end
  str_len = findfirst(_c->_c==0,str_)
  str = if str_len === nothing
    String(str_)
  else
    String(str_[1:str_len-1])
  end
  symname,str
end


"""
  getversion() :: (major,minor,revision)

  Obtains MOSEK version information.

  Returns
    major::Int32 Major version number.
    minor::Int32 Minor version number.
    revision::Int32 Revision number.
"""
function getversion end
function getversion()
  major_ = Ref{Int32}()
  minor_ = Ref{Int32}()
  revision_ = Ref{Int32}()
  @MSK_getversion(major_,minor_,revision_)
  major_[],minor_[],revision_[]
end


"""
  linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::AbstractString,append::Int32)
  linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::AbstractString,append::T0) where {T0<:Integer} 

  Directs all output from a stream to a file.

  Arguments
    env::MSKenv The MOSEK environment.
    whichstream::Streamtype Index of the stream.
    filename::AbstractString A valid file name.
    append::Int32 If this argument is 0 the file will be overwritten, otherwise it will be appended to.
"""
function linkfiletostream end
function linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::AbstractString,append::Int32)
  filename_ = Vector{UInt8}(filename); push!(filename_,UInt8(0))
  @MSK_linkfiletoenvstream(env.env,whichstream.value,filename_,append)
  nothing
end
function linkfiletostream(env::MSKenv,whichstream::Streamtype,filename::AbstractString,append::T0) where { T0<:Integer }
  linkfiletostream(
    env,
    whichstream,
    filename,
    convert(Int32,append))
end


"""
  putlicensedebug(env::MSKenv,licdebug::Int32)
  putlicensedebug(env::MSKenv,licdebug::T0) where {T0<:Integer} 

  Enables debug information for the license system.

  Arguments
    env::MSKenv The MOSEK environment.
    licdebug::Int32 Enable output of license check-out debug information.
"""
function putlicensedebug end
function putlicensedebug(env::MSKenv,licdebug::Int32)
  @MSK_putlicensedebug(env.env,licdebug)
  nothing
end
function putlicensedebug(env::MSKenv,licdebug::T0) where { T0<:Integer }
  putlicensedebug(
    env,
    convert(Int32,licdebug))
end


"""
  putlicensecode(env::MSKenv,code::Vector{Int32})
  putlicensecode(env::MSKenv,code::T0) where {T0<:AbstractVector{<:Integer}} 

  Input a runtime license code.

  Arguments
    env::MSKenv The MOSEK environment.
    code::Vector{Int32} A license key string.
"""
function putlicensecode end
function putlicensecode(env::MSKenv,code::Vector{Int32})
  if length(code) < MSK_LICENSE_BUFFER_LENGTH
    throw(BoundsError())
  end
  code_ = code
  @MSK_putlicensecode(env.env,code_)
  nothing
end
function putlicensecode(env::MSKenv,code::T0) where { T0<:AbstractVector{<:Integer} }
  putlicensecode(
    env,
    convert(Vector{Int32},code))
end


"""
  putlicensewait(env::MSKenv,licwait::Int32)
  putlicensewait(env::MSKenv,licwait::T0) where {T0<:Integer} 

  Control whether mosek should wait for an available license if no license is available.

  Arguments
    env::MSKenv The MOSEK environment.
    licwait::Int32 Enable waiting for a license.
"""
function putlicensewait end
function putlicensewait(env::MSKenv,licwait::Int32)
  @MSK_putlicensewait(env.env,licwait)
  nothing
end
function putlicensewait(env::MSKenv,licwait::T0) where { T0<:Integer }
  putlicensewait(
    env,
    convert(Int32,licwait))
end


"""
  putlicensepath(env::MSKenv,licensepath::AbstractString)

  Set the path to the license file.

  Arguments
    env::MSKenv The MOSEK environment.
    licensepath::AbstractString A path specifying where to search for the license.
"""
function putlicensepath end
function putlicensepath(env::MSKenv,licensepath::AbstractString)
  licensepath_ = Vector{UInt8}(licensepath); push!(licensepath_,UInt8(0))
  @MSK_putlicensepath(env.env,licensepath_)
  nothing
end


"""
  computesparsecholesky(env::MSKenv,numthreads::Int32,ordermethod::Int32,tolsingular::Float64,anzc::Vector{Int32},aptrc::Vector{Int64},asubc::Vector{Int32},avalc::Vector{Float64}) :: (perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)
  computesparsecholesky(env::MSKenv,numthreads::T0,ordermethod::T1,tolsingular::T2,anzc::T3,aptrc::T4,asubc::T5,avalc::T6) where {T0<:Integer,T1<:Integer,T2<:Number,T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number}}  :: (perm,diag,lnzc,lptrc,lensubnval,lsubc,lvalc)

  Computes a Cholesky factorization of sparse matrix.

  Arguments
    env::MSKenv The MOSEK environment.
    numthreads::Int32 The number threads that can be used to do the computation. 0 means the code makes the choice.
    ordermethod::Int32 If nonzero, then a sparsity preserving ordering will be employed.
    tolsingular::Float64 A positive parameter controlling when a pivot is declared zero.
    anzc::Vector{Int32} anzc[j] is the number of nonzeros in the jth column of A.
    aptrc::Vector{Int64} aptrc[j] is a pointer to the first element in column j.
    asubc::Vector{Int32} Row indexes for each column stored in increasing order.
    avalc::Vector{Float64} The value corresponding to row indexed stored in asubc.
  Returns
    perm::Int32 Permutation array used to specify the permutation matrix P computed by the function.
    diag::Float64 The diagonal elements of matrix D.
    lnzc::Int32 lnzc[j] is the number of non zero elements in column j.
    lptrc::Int64 lptrc[j] is a pointer to the first row index and value in column j.
    lensubnval::Int64 Number of elements in lsubc and lvalc.
    lsubc::Int32 Row indexes for each column stored in increasing order.
    lvalc::Float64 The values corresponding to row indexed stored in lsubc.
"""
function computesparsecholesky end
function computesparsecholesky(env::MSKenv,numthreads::Int32,ordermethod::Int32,tolsingular::Float64,anzc::Vector{Int32},aptrc::Vector{Int64},asubc::Vector{Int32},avalc::Vector{Float64})
  n = Int32(min(length(anzc),length(aptrc)))
  anzc_ = anzc
  aptrc_ = aptrc
  asubc_ = asubc
  avalc_ = avalc
  perm_ = Ref{Ptr{Int32}}()
  diag_ = Ref{Ptr{Float64}}()
  lnzc_ = Ref{Ptr{Int32}}()
  lptrc_ = Ref{Ptr{Int64}}()
  lensubnval_ = Ref{Int64}()
  lsubc_ = Ref{Ptr{Int32}}()
  lvalc_ = Ref{Ptr{Float64}}()
  @MSK_computesparsecholesky(env.env,numthreads,ordermethod,tolsingular,n,anzc_,aptrc_,asubc_,avalc_,perm_,diag_,lnzc_,lptrc_,lensubnval_,lsubc_,lvalc_)
  __tmp_686 = n
  perm = copy(unsafe_wrap(Array,perm_[],__tmp_686))
  @MSK_freeenv(env,perm_[])
  __tmp_687 = n
  diag = copy(unsafe_wrap(Array,diag_[],__tmp_687))
  @MSK_freeenv(env,diag_[])
  __tmp_688 = n
  lnzc = copy(unsafe_wrap(Array,lnzc_[],__tmp_688))
  @MSK_freeenv(env,lnzc_[])
  __tmp_689 = n
  lptrc = copy(unsafe_wrap(Array,lptrc_[],__tmp_689))
  @MSK_freeenv(env,lptrc_[])
  __tmp_690 = lensubnval
  lsubc = copy(unsafe_wrap(Array,lsubc_[],__tmp_690))
  @MSK_freeenv(env,lsubc_[])
  __tmp_691 = lensubnval
  lvalc = copy(unsafe_wrap(Array,lvalc_[],__tmp_691))
  @MSK_freeenv(env,lvalc_[])
  perm,diag,lnzc,lptrc,lensubnval_[],lsubc,lvalc
end
function computesparsecholesky(env::MSKenv,numthreads::T0,ordermethod::T1,tolsingular::T2,anzc::T3,aptrc::T4,asubc::T5,avalc::T6) where { T0<:Integer,T1<:Integer,T2<:Number,T3<:AbstractVector{<:Integer},T4<:AbstractVector{<:Integer},T5<:AbstractVector{<:Integer},T6<:AbstractVector{<:Number} }
  computesparsecholesky(
    env,
    convert(Int32,numthreads),
    convert(Int32,ordermethod),
    convert(Float64,tolsingular),
    convert(Vector{Int32},anzc),
    convert(Vector{Int64},aptrc),
    convert(Vector{Int32},asubc),
    convert(Vector{Float64},avalc))
end


"""
  licensecleanup()

  Stops all threads and delete all handles used by the license system.

"""
function licensecleanup end
function licensecleanup()
  @MSK_licensecleanup()
  nothing
end


