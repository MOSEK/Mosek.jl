# Contents of this file is generated. Do not edit by hand!
# MOSEK 8.1.0.58

export
  analyzenames,
  analyzeproblem,
  analyzesolution,
  appendbarvars,
  appendcone,
  appendconeseq,
  appendconesseq,
  appendcons,
  appendsparsesymmat,
  appendvars,
  basiscond,
  bktostr,
  callbackcodetostr,
  checkconvexity,
  checkinall,
  checkinlicense,
  checkmem,
  checkoutlicense,
  chgbound,
  chgconbound,
  chgvarbound,
  commitchanges,
  conetypetostr,
  deletesolution,
  dualsensitivity,
  echointro,
  getacol,
  getacolnumnz,
  getacolslicetrip,
  getaij,
  getapiecenumnz,
  getarow,
  getarownumnz,
  getarowslicetrip,
  getaslice,
  getaslicenumnz,
  getbarablocktriplet,
  getbaraidx,
  getbaraidxij,
  getbaraidxinfo,
  getbarasparsity,
  getbarcblocktriplet,
  getbarcidx,
  getbarcidxinfo,
  getbarcidxj,
  getbarcsparsity,
  getbarsj,
  getbarvarname,
  getbarvarnameindex,
  getbarvarnamelen,
  getbarxj,
  getbound,
  getboundslice,
  getc,
  getcfix,
  getcj,
  getcodedesc,
  getconbound,
  getconboundslice,
  getcone,
  getconeinfo,
  getconename,
  getconenameindex,
  getconenamelen,
  getconname,
  getconnameindex,
  getconnamelen,
  getcslice,
  getdimbarvarj,
  getdouinf,
  getdouparam,
  getdualobj,
  getdualsolutionnorms,
  getdviolbarvar,
  getdviolcon,
  getdviolcones,
  getdviolvar,
  getinfeasiblesubproblem,
  getinfname,
  getintinf,
  getintparam,
  getlenbarvarj,
  getlintinf,
  getmaxnumanz,
  getmaxnumbarvar,
  getmaxnumcon,
  getmaxnumcone,
  getmaxnumqnz,
  getmaxnumvar,
  getmemusage,
  getnadouinf,
  getnadouparam,
  getnaintinf,
  getnaintparam,
  getnastrparam,
  getnumanz,
  getnumanz64,
  getnumbarablocktriplets,
  getnumbaranz,
  getnumbarcblocktriplets,
  getnumbarcnz,
  getnumbarvar,
  getnumcon,
  getnumcone,
  getnumconemem,
  getnumintvar,
  getnumparam,
  getnumqconknz,
  getnumqobjnz,
  getnumsymmat,
  getnumvar,
  getobjname,
  getobjnamelen,
  getobjsense,
  getparamname,
  getprimalobj,
  getprimalsolutionnorms,
  getprobtype,
  getprosta,
  getpviolbarvar,
  getpviolcon,
  getpviolcones,
  getpviolvar,
  getqconk,
  getqobj,
  getqobjij,
  getreducedcosts,
  getskc,
  getskcslice,
  getskx,
  getskxslice,
  getslc,
  getslcslice,
  getslx,
  getslxslice,
  getsnx,
  getsnxslice,
  getsolsta,
  getsolution,
  getsolutioni,
  getsolutioninfo,
  getsolutionslice,
  getsparsesymmat,
  getstrparam,
  getstrparamlen,
  getsuc,
  getsucslice,
  getsux,
  getsuxslice,
  getsymmatinfo,
  gettaskname,
  gettasknamelen,
  getvarbound,
  getvarboundslice,
  getvarname,
  getvarnameindex,
  getvarnamelen,
  getvartype,
  getvartypelist,
  getversion,
  getxc,
  getxcslice,
  getxx,
  getxxslice,
  gety,
  getyslice,
  initbasissolve,
  inputdata,
  isdouparname,
  isintparname,
  isstrparname,
  licensecleanup,
  linkfiletostream,
  onesolutionsummary,
  optimize,
  optimizersummary,
  primalrepair,
  primalsensitivity,
  printdata,
  printparam,
  putacol,
  putacollist,
  putacolslice,
  putaij,
  putaijlist,
  putarow,
  putarowlist,
  putarowslice,
  putbarablocktriplet,
  putbaraij,
  putbarcblocktriplet,
  putbarcj,
  putbarsj,
  putbarvarname,
  putbarxj,
  putbound,
  putboundlist,
  putboundslice,
  putcfix,
  putcj,
  putclist,
  putconbound,
  putconboundlist,
  putconboundslice,
  putcone,
  putconename,
  putconname,
  putcslice,
  putdouparam,
  putintparam,
  putlicensecode,
  putlicensedebug,
  putlicensepath,
  putlicensewait,
  putmaxnumanz,
  putmaxnumbarvar,
  putmaxnumcon,
  putmaxnumcone,
  putmaxnumqnz,
  putmaxnumvar,
  putnadouparam,
  putnaintparam,
  putnastrparam,
  putobjname,
  putobjsense,
  putparam,
  putqcon,
  putqconk,
  putqobj,
  putqobjij,
  putskc,
  putskcslice,
  putskx,
  putskxslice,
  putslc,
  putslcslice,
  putslx,
  putslxslice,
  putsnx,
  putsnxslice,
  putsolution,
  putsolutioni,
  putsolutionyi,
  putstrparam,
  putsuc,
  putsucslice,
  putsux,
  putsuxslice,
  puttaskname,
  putvarbound,
  putvarboundlist,
  putvarboundslice,
  putvarname,
  putvartype,
  putvartypelist,
  putxc,
  putxcslice,
  putxx,
  putxxslice,
  puty,
  putyslice,
  readdata,
  readdataformat,
  readparamfile,
  readsolution,
  readsummary,
  readtask,
  removebarvars,
  removecones,
  removecons,
  removevars,
  resizetask,
  sensitivityreport,
  setdefaults,
  solutiondef,
  solutionsummary,
  solvewithbasis,
  strtoconetype,
  strtosk,
  updatesolutioninfo,
  writedata,
  writejsonsol,
  writeparamfile,
  writesolution,
  writetask

"""
    analyzenames(task_:: MSKtask,whichstream_:: Streamtype,nametype_:: Nametype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `nametype :: Nametype`. The type of names e.g. valid in MPS or LP files.

The function analyzes the names and issues an error if a name is invalid.
"""
function analyzenames end
function analyzenames(task_:: MSKtask,whichstream_:: Streamtype,nametype_:: Nametype)
  res = disable_sigint() do
    @msk_ccall( "analyzenames",Int32,(Ptr{Nothing},Int32,Int32,),task_.task,whichstream_.value,nametype_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    analyzeproblem(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

The function analyzes the data of a task and writes out a report.
"""
function analyzeproblem end
function analyzeproblem(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @msk_ccall( "analyzeproblem",Int32,(Ptr{Nothing},Int32,),task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    analyzesolution(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `whichsol :: Soltype`. Selects a solution.

Print information related to the quality of the solution and
other solution statistics.

By default this function prints information about the
largest infeasibilites in the solution, the primal (and
possibly dual) objective value and the solution status.

Following parameters can be used to configure the printed statistics:

* `MSK_IPAR_ANA_SOL_BASIS`` enables or disables printing of statistics specific to the basis solution (condition number, number of basic variables etc.). Default is on.
* `MSK_IPAR_ANA_SOL_PRINT_VIOLATED`` enables or disables listing names of all constraints (both primal and dual) which are violated by the solution. Default is off.
* `MSK_DPAR_ANA_SOL_INFEAS_TOL`` is the tolerance defining when a constraint is considered violated. If a constraint is violated more than this, it will be listed in the summary.
"""
function analyzesolution end
function analyzesolution(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)
  res = disable_sigint() do
    @msk_ccall( "analyzesolution",Int32,(Ptr{Nothing},Int32,Int32,),task_.task,whichstream_.value,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendbarvars{T1}(task:: MSKtask,dim:: Vector{T1})
    appendbarvars(task_:: MSKtask,dim_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `dim :: Vector{Int32}`. Dimensions of symmetric matrix variables to be added.

Appends positive semidefinite matrix variables of dimensions given by `dim` to the problem.
"""
function appendbarvars end
appendbarvars(task:: MSKtask,dim:: Vector{T1}) where {T1} = appendbarvars(task,convert(Vector{Int32},dim))
function appendbarvars(task_:: MSKtask,dim_:: Vector{Int32})
  num_ = minimum([ length(dim_) ])
  res = disable_sigint() do
    @msk_ccall( "appendbarvars",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,num_,dim_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendcone{T2,T3}(task:: MSKtask,ct:: Conetype,conepar:: T2,submem:: Vector{T3})
    appendcone(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. This argument is currently not used. It can be set to 0
* `submem :: Vector{Int32}`. Variable subscripts of the members in the cone.

Appends a new conic constraint to the problem. Hence, add a constraint

```math
 \\hat{x} \\in \\mathcal{K}
```
to the problem where ``\\mathcal{K}`` is a convex cone. ``\\hat{x}`` is a
subset of the variables which will be specified by the argument
`submem`.

Depending on the value of `ct` this function
appends a normal (`MSK_CT_QUAD`) or
rotated quadratic cone
(`MSK_CT_RQUAD`).

Define 

```math
 \\hat{x} = x_{\\mathtt{submem}[0]},\\ldots,x_{\\mathtt{submem}[\\mathtt{nummem}-1]}.
```
Depending on the value of `ct` this function appends one of the constraints:

* Quadratic cone (`MSK_CT_QUAD`) : 

```math
 \\hat{x}_0 \\geq \\sqrt{\\sum_{i=1}^{i<\\mathtt{nummem}} \\hat{x}_i^2}
```
* Rotated quadratic cone (`MSK_CT_RQUAD`) : 

```math
 2 \\hat{x}_0 \\hat{x}_1 \\geq \\sum_{i=2}^{i<\\mathtt{nummem}} \\hat{x}^2_i, \\mathcal{C}_q \\hat{x}_{0}, \\hat{x}_1 \\geq 0
```
Please note that the sets of variables appearing in different conic constraints must be disjoint.

For an explained code example see Section :ref:`doc.tutorial_cqo`.
"""
function appendcone end
appendcone(task:: MSKtask,ct:: Conetype,conepar:: T2,submem:: Vector{T3}) where {T2,T3} = appendcone(task,ct,Float64(conepar),convert(Vector{Int32},submem))
function appendcone(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})
  nummem_ = minimum([ length(submem_) ])
  res = disable_sigint() do
    @msk_ccall( "appendcone",Int32,(Ptr{Nothing},Int32,Float64,Int32,Ptr{Int32},),task_.task,ct_.value,conepar_,nummem_,submem_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendconeseq{T2,T3,T4}(task:: MSKtask,ct:: Conetype,conepar:: T2,nummem:: T3,j:: T4)
    appendconeseq(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,nummem_:: Int32,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. This argument is currently not used. It can be set to 0
* `nummem :: Int32`. Number of member variables in the cone.
* `j :: Int32`. Index of the first variable in the conic constraint.

Appends a new conic constraint to the problem, as in `Mosek.appendcone`. The
function assumes the members of cone are sequential
where the first member has index `j` and the last
`j+nummem-1`.
"""
function appendconeseq end
appendconeseq(task:: MSKtask,ct:: Conetype,conepar:: T2,nummem:: T3,j:: T4) where {T2,T3,T4} = appendconeseq(task,ct,Float64(conepar),Int32(nummem),Int32(j))
function appendconeseq(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,nummem_:: Int32,j_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "appendconeseq",Int32,(Ptr{Nothing},Int32,Float64,Int32,Int32,),task_.task,ct_.value,conepar_,nummem_,j_-1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendconesseq{T2,T3,T4}(task:: MSKtask,ct:: Vector{Conetype},conepar:: Vector{T2},nummem:: Vector{T3},j:: T4)
    appendconesseq(task_:: MSKtask,ct_:: Vector{Conetype},conepar_:: Vector{Float64},nummem_:: Vector{Int32},j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `ct :: Vector{Int32}`. Specifies the type of the cone.
* `conepar :: Vector{Float64}`. This argument is currently not used. It can be set to 0
* `nummem :: Vector{Int32}`. Numbers of member variables in the cones.
* `j :: Int32`. Index of the first variable in the first cone to be appended.

Appends a number of conic constraints to the problem, as in `Mosek.appendcone`.
The ``k`` th cone is assumed to be of dimension `nummem[k]`. Moreover, it is assumed
that the first variable of the first cone has index ``j`` and starting from there the
sequentially following variables belong to the first cone, then to the second cone and so on.
"""
function appendconesseq end
appendconesseq(task:: MSKtask,ct:: Vector{Conetype},conepar:: Vector{T2},nummem:: Vector{T3},j:: T4) where {T2,T3,T4} = appendconesseq(task,ct,convert(Vector{Float64},conepar),convert(Vector{Int32},nummem),Int32(j))
function appendconesseq(task_:: MSKtask,ct_:: Vector{Conetype},conepar_:: Vector{Float64},nummem_:: Vector{Int32},j_:: Int32)
  ct_i32 = Int32[item.value for item in ct_]
  num_ = minimum([ length(ct_),length(conepar_),length(nummem_) ])
  res = disable_sigint() do
    @msk_ccall( "appendconesseq",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Int32},Int32,),task_.task,num_,ct_,conepar_,nummem_,j_-1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendcons{T1}(task:: MSKtask,num:: T1)
    appendcons(task_:: MSKtask,num_:: Int32)

* `task :: MSKtask`. An optimization task.
* `num :: Int32`. Number of constraints which should be appended.

Appends a number of constraints to the
model. Appended constraints will be declared
free. Please note that MOSEK will automatically
expand the problem dimension to accommodate the
additional constraints.
"""
function appendcons end
appendcons(task:: MSKtask,num:: T1) where {T1} = appendcons(task,Int32(num))
function appendcons(task_:: MSKtask,num_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "appendcons",Int32,(Ptr{Nothing},Int32,),task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    idx = appendsparsesymmat{T1,T2,T3,T4}(task:: MSKtask,dim:: T1,subi:: Vector{T2},subj:: Vector{T3},valij:: Vector{T4})
    idx = appendsparsesymmat(task_:: MSKtask,dim_:: Int32,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `dim :: Int32`. Dimension of the symmetric matrix that is appended.
* `subi :: Vector{Int32}`. Row subscript in the triplets.
* `subj :: Vector{Int32}`. Column subscripts in the triplets.
* `valij :: Vector{Float64}`. Values of each triplet.
* `idx :: Int64`. Unique index assigned to the inputted matrix.

MOSEK maintains a storage of symmetric data matrices that is used to build
``\\bar C`` and ``\\bar A``. The storage can be thought of as a vector of
symmetric matrices denoted ``E``. Hence, ``E_i`` is a symmetric matrix of certain
dimension.

This function appends a general sparse symmetric matrix on triplet form to the
vector ``E`` of symmetric matrices.  The vectors `subi`, `subj`, and
`valij` contains the row subscripts, column subscripts and values of each
element in the symmetric matrix to be appended.  Since the matrix that is
appended is symmetric, only the lower triangular part should be specified.
Moreover, duplicates are not allowed.

Observe the function reports the index (position) of the appended matrix in
``E``. This index should be used for later references to the appended matrix.
"""
function appendsparsesymmat end
appendsparsesymmat(task:: MSKtask,dim:: T1,subi:: Vector{T2},subj:: Vector{T3},valij:: Vector{T4}) where {T1,T2,T3,T4} = appendsparsesymmat(task,Int32(dim),convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Float64},valij))
function appendsparsesymmat(task_:: MSKtask,dim_:: Int32,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})
  idx_ = Vector{Int64}(undef,1)
  nz_ = minimum([ length(subi_),length(subj_),length(valij_) ])
  res = disable_sigint() do
    @msk_ccall( "appendsparsesymmat",Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Int64},),task_.task,dim_,nz_,subi_ .- Int32(1),subj_ .- Int32(1),valij_,idx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,idx_[1]+1))
end

"""
    appendvars{T1}(task:: MSKtask,num:: T1)
    appendvars(task_:: MSKtask,num_:: Int32)

* `task :: MSKtask`. An optimization task.
* `num :: Int32`. Number of variables which should be appended.

Appends a number of variables to the model. Appended
variables will be fixed at zero. Please note that
MOSEK will automatically expand the problem
dimension to accommodate the additional variables.
"""
function appendvars end
appendvars(task:: MSKtask,num:: T1) where {T1} = appendvars(task,Int32(num))
function appendvars(task_:: MSKtask,num_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "appendvars",Int32,(Ptr{Nothing},Int32,),task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    (nrmbasis,nrminvbasis) = basiscond(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `nrmbasis :: Float64`. An estimate for the 1-norm of the basis.
* `nrminvbasis :: Float64`. An estimate for the 1-norm of the inverse of the basis.

If a basic solution is available and it defines a nonsingular basis, then
this function computes the 1-norm estimate of the basis matrix and a 1-norm estimate
for the inverse of the basis matrix. The 1-norm estimates are computed using the method
outlined in :cite:`STEWART:98:A`, pp. 388-391.

By definition the 1-norm condition number of a matrix ``B`` is defined as

```math
 \\kappa_1(B) := \\|B\\|_1 \\|B^{-1}\\|_1.
```
Moreover, the larger the condition number is the harder it is to solve
linear equation systems involving ``B``.  Given estimates for
``\\|B\\|_1`` and ``\\|B^{-1}\\|_1`` it is also possible to
estimate ``\\kappa_1(B)``.
"""
function basiscond end
function basiscond(task_:: MSKtask)
  nrmbasis_ = Vector{Float64}(undef,1)
  nrminvbasis_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "basiscond",Int32,(Ptr{Nothing},Ptr{Float64},Ptr{Float64},),task_.task,nrmbasis_,nrminvbasis_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,nrmbasis_[1]),convert(Float64,nrminvbasis_[1]))
end

"""
    str = bktostr(task_:: MSKtask,bk_:: Boundkey)

* `task :: MSKtask`. An optimization task.
* `bk :: Boundkey`. Bound key.
* `str :: AbstractString`. String corresponding to the bound key.

Obtains an identifier string corresponding to a bound key.
"""
function bktostr end
function bktostr(task_:: MSKtask,bk_:: Boundkey)
  str_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @msk_ccall( "bktostr",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,bk_.value,str_)
  end
  str_str = convert(String,str_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (str_str[1:searchindex(str_str,'\0')-1])
end

"""
    callbackcodestr = callbackcodetostr(code_:: Callbackcode)

* `code :: Callbackcode`. A callback code.
* `callbackcodestr :: AbstractString`. String corresponding to the callback code.

Obtains the string representation of a callback code.
"""
function callbackcodetostr end
function callbackcodetostr(code_:: Callbackcode)
  callbackcodestr_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @msk_ccall( "callbackcodetostr",Int32,(Int32,Ptr{UInt8},),code_.value,callbackcodestr_)
  end
  callbackcodestr_str = convert(String,callbackcodestr_)
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
  (callbackcodestr_str[1:searchindex(callbackcodestr_str,'\0')-1])
end

"""
    checkconvexity(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.

This function checks if a quadratic optimization problem is convex. The amount of checking is controlled by `MSK_IPAR_CHECK_CONVEXITY``.

The function reports an error if the problem is not convex.
"""
function checkconvexity end
function checkconvexity(task_:: MSKtask)
  res = disable_sigint() do
    @msk_ccall( "checkconvexity",Int32,(Ptr{Nothing},),task_.task)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    checkmem{T2}(task:: MSKtask,file:: AbstractString,line:: T2)
    checkmem(task_:: MSKtask,file_:: AbstractString,line_:: Int32)

* `task :: MSKtask`. An optimization task.
* `file :: String`. File from which the function is called.
* `line :: Int32`. Line in the file from which the function is called.

Checks the memory allocated by the task.
"""
function checkmem end
checkmem(task:: MSKtask,file:: AbstractString,line:: T2) where {T2} = checkmem(task,file,Int32(line))
function checkmem(task_:: MSKtask,file_:: AbstractString,line_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "checkmemtask",Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),task_.task,string(file_),line_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    chgbound{T2,T3,T4,T5}(task:: MSKtask,accmode:: Accmode,i:: T2,lower:: T3,finite:: T4,value:: T5)
    chgbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).
* `i :: Int32`. Index of the constraint or variable for which the bounds should be changed.
* `lower :: Int32`. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
* `finite :: Int32`. If non-zero, then the given value is assumed to be finite.
* `value :: Float64`. New value for the bound.

Changes a bound for one constraint or variable. If
`accmode` equals `MSK_ACC_CON`, a
constraint bound is changed, otherwise a variable
bound is changed.

If `lower` is non-zero, then the lower bound is changed as follows:

```math
\\mbox{new lower bound} =
    \\left\\{
        \\begin{array}{ll}
            - \\infty,     & \\mathtt{finite}=0, \\\\
            \\mathtt{value} & \\mbox{otherwise}. 
        \\end{array}
    \\right.
```
Otherwise if `lower` is zero, then

```math
\\mbox{new upper bound} = 
    \\left\\{ 
        \\begin{array}{ll}
            \\infty,     & \\mathtt{finite}=0, \\\\
            \\mathtt{value} & \\mbox{otherwise}. 
        \\end{array}
    \\right.
```
Please note that this function automatically
updates the bound key for bound, in particular, if
the lower and upper bounds are identical, the
bound key is changed to `fixed`.
"""
function chgbound end
chgbound(task:: MSKtask,accmode:: Accmode,i:: T2,lower:: T3,finite:: T4,value:: T5) where {T2,T3,T4,T5} = chgbound(task,accmode,Int32(i),Int32(lower),Int32(finite),Float64(value))
function chgbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "chgbound",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Float64,),task_.task,accmode_.value,i_-1,lower_,finite_,value_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    chgconbound{T1,T2,T3,T4}(task:: MSKtask,i:: T1,lower:: T2,finite:: T3,value:: T4)
    chgconbound(task_:: MSKtask,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint for which the bounds should be changed.
* `lower :: Int32`. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
* `finite :: Int32`. If non-zero, then the given value is assumed to be finite.
* `value :: Float64`. New value for the bound.

Changes a bound for one constraint.

If `lower` is non-zero, then the lower bound is changed as follows:

```math
\\mbox{new lower bound} =
  \\left\\{
    \\begin{array}{ll}
      - \\infty,       & \\mathtt{finite}=0, \\\\
      \\mathtt{value}  & \\mbox{otherwise}. 
    \\end{array}
  \\right.
```
Otherwise if `lower` is zero, then

```math
\\mbox{new upper bound} = 
  \\left\\{
    \\begin{array}{ll}
      \\infty,        & \\mathtt{finite}=0, \\\\
      \\mathtt{value} & \\mbox{otherwise}. 
    \\end{array}
  \\right.
```
Please note that this function automatically updates the bound key for the 
bound, in particular, if the lower and upper bounds are identical, the
bound key is changed to `fixed`.
"""
function chgconbound end
chgconbound(task:: MSKtask,i:: T1,lower:: T2,finite:: T3,value:: T4) where {T1,T2,T3,T4} = chgconbound(task,Int32(i),Int32(lower),Int32(finite),Float64(value))
function chgconbound(task_:: MSKtask,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "chgconbound",Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,),task_.task,i_-1,lower_,finite_,value_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    chgvarbound{T1,T2,T3,T4}(task:: MSKtask,j:: T1,lower:: T2,finite:: T3,value:: T4)
    chgvarbound(task_:: MSKtask,j_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable for which the bounds should be changed.
* `lower :: Int32`. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
* `finite :: Int32`. If non-zero, then the given value is assumed to be finite.
* `value :: Float64`. New value for the bound.

Changes a bound for one variable.

If `lower` is non-zero, then the lower bound is changed as follows:

```math
\\mbox{new lower bound} =
  \\left\\{
    \\begin{array}{ll}
      - \\infty,     & \\mathtt{finite}=0, \\\\
      \\mathtt{value} & \\mbox{otherwise}. 
    \\end{array}
  \\right.
```
Otherwise if `lower` is zero, then

```math
\\mbox{new upper bound} = 
  \\left\\{
    \\begin{array}{ll}
      \\infty,     & \\mathtt{finite}=0, \\\\
      \\mathtt{value} & \\mbox{otherwise}. 
    \\end{array}
  \\right.
```
Please note that this function automatically updates the bound key for the bound,
in particular, if the lower and upper bounds are identical, the bound key is
changed to `fixed`.
"""
function chgvarbound end
chgvarbound(task:: MSKtask,j:: T1,lower:: T2,finite:: T3,value:: T4) where {T1,T2,T3,T4} = chgvarbound(task,Int32(j),Int32(lower),Int32(finite),Float64(value))
function chgvarbound(task_:: MSKtask,j_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "chgvarbound",Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,),task_.task,j_-1,lower_,finite_,value_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    commitchanges(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.

Commits all cached problem changes to the task. It is usually not necessary to call this function explicitly since changes will be committed automatically when required.
"""
function commitchanges end
function commitchanges(task_:: MSKtask)
  res = disable_sigint() do
    @msk_ccall( "commitchanges",Int32,(Ptr{Nothing},),task_.task)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    str = conetypetostr(task_:: MSKtask,ct_:: Conetype)

* `task :: MSKtask`. An optimization task.
* `ct :: Conetype`. Specifies the type of the cone.
* `str :: AbstractString`. String corresponding to the cone type.

Obtains the cone string identifier corresponding to a cone type.
"""
function conetypetostr end
function conetypetostr(task_:: MSKtask,ct_:: Conetype)
  str_ = zeros(UInt8,1024+1)
  res = disable_sigint() do
    @msk_ccall( "conetypetostr",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,ct_.value,str_)
  end
  str_str = convert(String,str_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (str_str[1:searchindex(str_str,'\0')-1])
end

"""
    deletesolution(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.

Undefine a solution and free the memory it uses.
"""
function deletesolution end
function deletesolution(task_:: MSKtask,whichsol_:: Soltype)
  res = disable_sigint() do
    @msk_ccall( "deletesolution",Int32,(Ptr{Nothing},Int32,),task_.task,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    (leftpricej,rightpricej,leftrangej,rightrangej) = dualsensitivity{T1}(task:: MSKtask,subj:: Vector{T1})
    (leftpricej,rightpricej,leftrangej,rightrangej) = dualsensitivity(task_:: MSKtask,subj_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. Indexes of objective coefficients to analyze.
* `leftpricej :: Vector{Float64}`. Left shadow prices for requested coefficients.
* `rightpricej :: Vector{Float64}`. Right shadow prices for requested coefficients.
* `leftrangej :: Vector{Float64}`. Left range for requested coefficients.
* `rightrangej :: Vector{Float64}`. Right range for requested coefficients.

Calculates sensitivity information for objective coefficients. The indexes of the coefficients to analyze are

```math
 \\{\\mathtt{subj}[i] ~|~ i = 0,\\ldots,\\mathtt{numj}-1\\}
```
The type of sensitivity analysis to perform (basis or optimal partition) is controlled by the parameter `MSK_IPAR_SENSITIVITY_TYPE``.

For an example, please see Section :ref:`doc.shared.sensitivity_example`.
"""
function dualsensitivity end
dualsensitivity(task:: MSKtask,subj:: Vector{T1}) where {T1} = dualsensitivity(task,convert(Vector{Int32},subj))
function dualsensitivity(task_:: MSKtask,subj_:: Vector{Int32})
  numj_ = minimum([ length(subj_) ])
  __tmp_var_0 = (numj_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  leftpricej_ = __tmp_var_1
  __tmp_var_4 = (numj_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  leftrangej_ = __tmp_var_5
  __tmp_var_2 = (numj_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  rightpricej_ = __tmp_var_3
  __tmp_var_6 = (numj_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  rightrangej_ = __tmp_var_7
  res = disable_sigint() do
    @msk_ccall( "dualsensitivity",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,numj_,subj_ .- Int32(1),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
end

"""
    (nzj,subj,valj) = getacol{T1}(task:: MSKtask,j:: T1)
    (nzj,subj,valj) = getacol(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the column.
* `nzj :: Int32`. Number of non-zeros in the column obtained.
* `subj :: Vector{Int32}`. Row indices of the non-zeros in the column obtained.
* `valj :: Vector{Float64}`. Numerical values in the column obtained.

Obtains one column of ``A`` in a sparse format.
"""
function getacol end
getacol(task:: MSKtask,j:: T1) where {T1} = getacol(task,Int32(j))
function getacol(task_:: MSKtask,j_:: Int32)
  nzj_ = Vector{Int32}(undef,1)
  __tmp_var_0 = getacolnumnz(task_,(j_))
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subj_ = __tmp_var_1
  __tmp_var_2 = getacolnumnz(task_,(j_))
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  valj_ = __tmp_var_3
  res = disable_sigint() do
    @msk_ccall( "getacol",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,j_-1,nzj_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzj_[1]),__tmp_var_1,__tmp_var_3)
end

"""
    nzj = getacolnumnz{T1}(task:: MSKtask,i:: T1)
    nzj = getacolnumnz(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the column.
* `nzj :: Int32`. Number of non-zeros in the j'th column of (A).

Obtains the number of non-zero elements in one column of ``A``.
"""
function getacolnumnz end
getacolnumnz(task:: MSKtask,i:: T1) where {T1} = getacolnumnz(task,Int32(i))
function getacolnumnz(task_:: MSKtask,i_:: Int32)
  nzj_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getacolnumnz",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,i_-1,nzj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzj_[1]))
end

"""
    (subi,subj,val) = getacolslicetrip{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (subi,subj,val) = getacolslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first column in the sequence.
* `last :: Int32`. Index of the last column in the sequence plus one.
* `subi :: Vector{Int32}`. Constraint subscripts.
* `subj :: Vector{Int32}`. Column subscripts.
* `val :: Vector{Float64}`. Values.

Obtains a sequence of columns from ``A`` in sparse triplet format. The function returns the content of all columns whose index `j` satisfies `first <= j < last`. The triplets corresponding to nonzero entries are stored in the arrays `subi`, `subj` and `val`.
"""
function getacolslicetrip end
getacolslicetrip(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getacolslicetrip(task,Int32(first),Int32(last))
function getacolslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)
  maxnumnz_ = getaslicenumnz(task_,MSK_ACC_VAR,(first_),(last_))
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxnumnz_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxnumnz_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  val_ = __tmp_var_5
  surp_ = convert(Int64,length(subi_))
  res = disable_sigint() do
    @msk_ccall( "getacolslicetrip",Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,first_-1,last_-1,maxnumnz_,Ref(surp_),__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    aij = getaij{T1,T2}(task:: MSKtask,i:: T1,j:: T2)
    aij = getaij(task_:: MSKtask,i_:: Int32,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index of the coefficient to be returned.
* `j :: Int32`. Column index of the coefficient to be returned.
* `aij :: Float64`. Returns the requested coefficient.

Obtains a single coefficient in ``A``.
"""
function getaij end
getaij(task:: MSKtask,i:: T1,j:: T2) where {T1,T2} = getaij(task,Int32(i),Int32(j))
function getaij(task_:: MSKtask,i_:: Int32,j_:: Int32)
  aij_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getaij",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,i_-1,j_-1,aij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,aij_[1]))
end

"""
    numnz = getapiecenumnz{T1,T2,T3,T4}(task:: MSKtask,firsti:: T1,lasti:: T2,firstj:: T3,lastj:: T4)
    numnz = getapiecenumnz(task_:: MSKtask,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32)

* `task :: MSKtask`. An optimization task.
* `firsti :: Int32`. Index of the first row in the rectangular piece.
* `lasti :: Int32`. Index of the last row plus one in the rectangular piece.
* `firstj :: Int32`. Index of the first column in the rectangular piece.
* `lastj :: Int32`. Index of the last column plus one in the rectangular piece.
* `numnz :: Int32`. Number of non-zero elements in the rectangular piece of the linear constraint matrix.

Obtains the number non-zeros in a rectangular piece of ``A``, i.e. the number of elements in the set

```math
 \\{ (i,j)~:~ a_{i,j} \\neq 0,~ \\mathtt{firsti} \\leq i \\leq \\mathtt{lasti}-1, ~\\mathtt{firstj} \\leq j \\leq \\mathtt{lastj}-1\\}
```
This function is not an efficient way to obtain the number of non-zeros in one
row or column. In that case use the function `Mosek.getarownumnz` or `Mosek.getacolnumnz`.
"""
function getapiecenumnz end
getapiecenumnz(task:: MSKtask,firsti:: T1,lasti:: T2,firstj:: T3,lastj:: T4) where {T1,T2,T3,T4} = getapiecenumnz(task,Int32(firsti),Int32(lasti),Int32(firstj),Int32(lastj))
function getapiecenumnz(task_:: MSKtask,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32)
  numnz_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getapiecenumnz",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Int32},),task_.task,firsti_-1,lasti_-1,firstj_-1,lastj_-1,numnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numnz_[1]))
end

"""
    (nzi,subi,vali) = getarow{T1}(task:: MSKtask,i:: T1)
    (nzi,subi,vali) = getarow(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the row.
* `nzi :: Int32`. Number of non-zeros in the row obtained.
* `subi :: Vector{Int32}`. Column indices of the non-zeros in the row obtained.
* `vali :: Vector{Float64}`. Numerical values of the row obtained.

Obtains one row of ``A`` in a sparse format.
"""
function getarow end
getarow(task:: MSKtask,i:: T1) where {T1} = getarow(task,Int32(i))
function getarow(task_:: MSKtask,i_:: Int32)
  nzi_ = Vector{Int32}(undef,1)
  __tmp_var_0 = getarownumnz(task_,(i_))
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = getarownumnz(task_,(i_))
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  vali_ = __tmp_var_3
  res = disable_sigint() do
    @msk_ccall( "getarow",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,i_-1,nzi_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzi_[1]),__tmp_var_1,__tmp_var_3)
end

"""
    nzi = getarownumnz{T1}(task:: MSKtask,i:: T1)
    nzi = getarownumnz(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the row.
* `nzi :: Int32`. Number of non-zeros in the i'th row of `A`.

Obtains the number of non-zero elements in one row of ``A``.
"""
function getarownumnz end
getarownumnz(task:: MSKtask,i:: T1) where {T1} = getarownumnz(task,Int32(i))
function getarownumnz(task_:: MSKtask,i_:: Int32)
  nzi_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getarownumnz",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,i_-1,nzi_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzi_[1]))
end

"""
    (subi,subj,val) = getarowslicetrip{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (subi,subj,val) = getarowslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first row in the sequence.
* `last :: Int32`. Index of the last row in the sequence plus one.
* `subi :: Vector{Int32}`. Constraint subscripts.
* `subj :: Vector{Int32}`. Column subscripts.
* `val :: Vector{Float64}`. Values.

Obtains a sequence of rows from ``A`` in sparse triplet format. The function returns the
content of all rows whose index `i` satisfies `first <= i < last`. 
The triplets corresponding to nonzero entries are stored in the arrays `subi`, `subj` and `val`.
"""
function getarowslicetrip end
getarowslicetrip(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getarowslicetrip(task,Int32(first),Int32(last))
function getarowslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)
  maxnumnz_ = getaslicenumnz(task_,MSK_ACC_CON,(first_),(last_))
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxnumnz_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxnumnz_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  val_ = __tmp_var_5
  surp_ = convert(Int64,length(subi_))
  res = disable_sigint() do
    @msk_ccall( "getarowslicetrip",Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,first_-1,last_-1,maxnumnz_,Ref(surp_),__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    (ptrb,ptre,sub,val) = getaslice{T2,T3}(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3)
    (ptrb,ptre,sub,val) = getaslice(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines whether a column slice or a row slice is requested.
* `first :: Int32`. Index of the first row or column in the sequence.
* `last :: Int32`. Index of the last row or column in the sequence plus one.
* `ptrb :: Vector{Int64}`. Row or column start pointers.
* `ptre :: Vector{Int64}`. Row or column end pointers.
* `sub :: Vector{Int32}`. Contains the row or column subscripts.
* `val :: Vector{Float64}`. Contains the coefficient values.

Obtains a sequence of rows or columns from ``A`` in sparse format.
"""
function getaslice end
getaslice(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3) where {T2,T3} = getaslice(task,accmode,Int32(first),Int32(last))
function getaslice(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)
  maxnumnz_ = getaslicenumnz(task_,(accmode_),(first_),(last_))
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  ptrb_ = __tmp_var_1
  __tmp_var_2 = ((last_) - (first_))
  __tmp_var_3 = zeros(Int64,__tmp_var_2)
  ptre_ = __tmp_var_3
  __tmp_var_4 = (maxnumnz_)
  __tmp_var_5 = zeros(Int32,__tmp_var_4)
  sub_ = __tmp_var_5
  __tmp_var_6 = (maxnumnz_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  val_ = __tmp_var_7
  surp_ = convert(Int64,length(sub_))
  res = disable_sigint() do
    @msk_ccall( "getaslice64",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),task_.task,accmode_.value,first_-1,last_-1,maxnumnz_,Ref(surp_),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  __tmp_var_5 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
end

"""
    numnz = getaslicenumnz{T2,T3}(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3)
    numnz = getaslicenumnz(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines whether non-zeros are counted in a column slice or a row slice.
* `first :: Int32`. Index of the first row or column in the sequence.
* `last :: Int32`. Index of the last row or column plus one in the sequence.
* `numnz :: Int64`. Number of non-zeros in the slice.

Obtains the number of non-zeros in a slice of rows or columns of ``A``.
"""
function getaslicenumnz end
getaslicenumnz(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3) where {T2,T3} = getaslicenumnz(task,accmode,Int32(first),Int32(last))
function getaslicenumnz(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)
  numnz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getaslicenumnz64",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int64},),task_.task,accmode_.value,first_-1,last_-1,numnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numnz_[1]))
end

"""
    (num,subi,subj,subk,subl,valijkl) = getbarablocktriplet(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subi :: Vector{Int32}`. Constraint index.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valijkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Obtains ``\\bar A`` in block triplet form.
"""
function getbarablocktriplet end
function getbarablocktriplet(task_:: MSKtask)
  maxnum_ = getnumbarablocktriplets(task_)
  num_ = Vector{Int64}(undef,1)
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxnum_)
  __tmp_var_5 = zeros(Int32,__tmp_var_4)
  subk_ = __tmp_var_5
  __tmp_var_6 = (maxnum_)
  __tmp_var_7 = zeros(Int32,__tmp_var_6)
  subl_ = __tmp_var_7
  __tmp_var_8 = (maxnum_)
  __tmp_var_9 = zeros(Float64,__tmp_var_8)
  valijkl_ = __tmp_var_9
  res = disable_sigint() do
    @msk_ccall( "getbarablocktriplet",Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,maxnum_,num_,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  __tmp_var_5 += 1
  __tmp_var_7 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_[1]),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
end

"""
    (i,j,num,sub,weights) = getbaraidx{T1}(task:: MSKtask,idx:: T1)
    (i,j,num,sub,weights) = getbaraidx(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Position of the element in the vectorized form.
* `i :: Int32`. Row index of the element at position idx.
* `j :: Int32`. Column index of the element at position idx.
* `num :: Int64`. Number of terms in weighted sum that forms the element.
* `sub :: Vector{Int64}`. A list indexes of the elements from symmetric matrix storage that appear in the weighted sum.
* `weights :: Vector{Float64}`. The weights associated with each term in the weighted sum.

Obtains information about an element in ``\\bar A``. Since ``\\bar A``
is a sparse matrix of symmetric matrices, only the nonzero elements in
``\\bar A`` are stored in order to save space. Now ``\\bar A`` is
stored vectorized i.e. as one long vector. This function makes it
possible to obtain information such as the row index and the column index of a
particular element of the vectorized form of ``\\bar A``.

Please observe if one element of ``\\bar A`` is inputted multiple times
then it may be stored several times in vectorized form. In that case the
element with the highest index is the one that is used.
"""
function getbaraidx end
getbaraidx(task:: MSKtask,idx:: T1) where {T1} = getbaraidx(task,Int64(idx))
function getbaraidx(task_:: MSKtask,idx_:: Int64)
  i_ = Vector{Int32}(undef,1)
  j_ = Vector{Int32}(undef,1)
  num_ = Vector{Int64}(undef,1)
  maxnum_ = getbaraidxinfo(task_,(idx_))
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  sub_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  weights_ = __tmp_var_3
  res = disable_sigint() do
    @msk_ccall( "getbaraidx",Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int32},Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Float64},),task_.task,idx_-1,maxnum_,i_,j_,num_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,i_[1]+1),convert(Int32,j_[1]+1),convert(Int64,num_[1]),__tmp_var_1,__tmp_var_3)
end

"""
    (i,j) = getbaraidxij{T1}(task:: MSKtask,idx:: T1)
    (i,j) = getbaraidxij(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Position of the element in the vectorized form.
* `i :: Int32`. Row index of the element at position idx.
* `j :: Int32`. Column index of the element at position idx.

Obtains information about an element in ``\\bar A``. Since ``\\bar A``
is a sparse matrix of symmetric matrices, only the nonzero elements in
``\\bar A`` are stored in order to save space. Now ``\\bar A`` is
stored vectorized i.e. as one long vector.  This function makes it
possible to obtain information such as the row index and the column index of a
particular element of the vectorized form of ``\\bar A``.

Please note that if one element of ``\\bar A`` is inputted multiple times
then it may be stored several times in vectorized form. In that case the
element with the highest index is the one that is used.
"""
function getbaraidxij end
getbaraidxij(task:: MSKtask,idx:: T1) where {T1} = getbaraidxij(task,Int64(idx))
function getbaraidxij(task_:: MSKtask,idx_:: Int64)
  i_ = Vector{Int32}(undef,1)
  j_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getbaraidxij",Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},),task_.task,idx_-1,i_,j_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,i_[1]+1),convert(Int32,j_[1]+1))
end

"""
    num = getbaraidxinfo{T1}(task:: MSKtask,idx:: T1)
    num = getbaraidxinfo(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. The internal position of the element for which information should be obtained.
* `num :: Int64`. Number of terms in the weighted sum that form the specified element in barA.

Each nonzero element in ``\\bar A_{ij}`` is formed as a weighted sum of
symmetric matrices. Using this function the number of terms in the weighted sum
can be obtained. See description of `Mosek.appendsparsesymmat` for details
about the weighted sum.
"""
function getbaraidxinfo end
getbaraidxinfo(task:: MSKtask,idx:: T1) where {T1} = getbaraidxinfo(task,Int64(idx))
function getbaraidxinfo(task_:: MSKtask,idx_:: Int64)
  num_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getbaraidxinfo",Int32,(Ptr{Nothing},Int64,Ptr{Int64},),task_.task,idx_-1,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_[1]))
end

"""
    (numnz,idxij) = getbarasparsity(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numnz :: Int64`. Number of nonzero elements in barA.
* `idxij :: Vector{Int64}`. Position of each nonzero element in the vector representation of barA.

The matrix ``\\bar A`` is assumed to be a sparse matrix of symmetric matrices.
This implies that many of the elements in ``\\bar A`` are likely to be zero matrices.
Therefore, in order to save space, only nonzero elements in ``\\bar A`` are stored
on vectorized form. This function is used to obtain the sparsity pattern of
``\\bar A`` and the position of each nonzero element in the vectorized form of
``\\bar A``. From the index detailed information about each nonzero ``\\bar A_{i,j}`` can be
obtained using `Mosek.getbaraidxinfo` and `Mosek.getbaraidx`.
"""
function getbarasparsity end
function getbarasparsity(task_:: MSKtask)
  maxnumnz_ = getnumbaranz(task_)
  numnz_ = Vector{Int64}(undef,1)
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  idxij_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getbarasparsity",Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int64},),task_.task,maxnumnz_,numnz_,__tmp_var_1)
  end
  __tmp_var_1 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numnz_[1]),__tmp_var_1)
end

"""
    (num,subj,subk,subl,valjkl) = getbarcblocktriplet(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valjkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Obtains ``\\bar C`` in block triplet form.
"""
function getbarcblocktriplet end
function getbarcblocktriplet(task_:: MSKtask)
  maxnum_ = getnumbarcblocktriplets(task_)
  num_ = Vector{Int64}(undef,1)
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subj_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subk_ = __tmp_var_3
  __tmp_var_4 = (maxnum_)
  __tmp_var_5 = zeros(Int32,__tmp_var_4)
  subl_ = __tmp_var_5
  __tmp_var_6 = (maxnum_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  valjkl_ = __tmp_var_7
  res = disable_sigint() do
    @msk_ccall( "getbarcblocktriplet",Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,maxnum_,num_,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  __tmp_var_5 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_[1]),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
end

"""
    (j,num,sub,weights) = getbarcidx{T1}(task:: MSKtask,idx:: T1)
    (j,num,sub,weights) = getbarcidx(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the element for which information should be obtained.
* `j :: Int32`. Row index in barc.
* `num :: Int64`. Number of terms in the weighted sum.
* `sub :: Vector{Int64}`. Elements appearing the weighted sum.
* `weights :: Vector{Float64}`. Weights of terms in the weighted sum.

Obtains information about an element in ``\\bar C``.
"""
function getbarcidx end
getbarcidx(task:: MSKtask,idx:: T1) where {T1} = getbarcidx(task,Int64(idx))
function getbarcidx(task_:: MSKtask,idx_:: Int64)
  j_ = Vector{Int32}(undef,1)
  num_ = Vector{Int64}(undef,1)
  maxnum_ = getbarcidxinfo(task_,(idx_))
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  sub_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  weights_ = __tmp_var_3
  res = disable_sigint() do
    @msk_ccall( "getbarcidx",Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Float64},),task_.task,idx_-1,maxnum_,j_,num_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,j_[1]+1),convert(Int64,num_[1]),__tmp_var_1,__tmp_var_3)
end

"""
    num = getbarcidxinfo{T1}(task:: MSKtask,idx:: T1)
    num = getbarcidxinfo(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the element for which information should be obtained. The value is an index of a symmetric sparse variable.
* `num :: Int64`. Number of terms that appear in the weighted sum that forms the requested element.

Obtains the number of terms in the weighted sum that forms a particular element in ``\\bar C``.
"""
function getbarcidxinfo end
getbarcidxinfo(task:: MSKtask,idx:: T1) where {T1} = getbarcidxinfo(task,Int64(idx))
function getbarcidxinfo(task_:: MSKtask,idx_:: Int64)
  num_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getbarcidxinfo",Int32,(Ptr{Nothing},Int64,Ptr{Int64},),task_.task,idx_-1,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_[1]))
end

"""
    j = getbarcidxj{T1}(task:: MSKtask,idx:: T1)
    j = getbarcidxj(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the element for which information should be obtained.
* `j :: Int32`. Row index in barc.

Obtains the row index of an element in ``\\bar C``.
"""
function getbarcidxj end
getbarcidxj(task:: MSKtask,idx:: T1) where {T1} = getbarcidxj(task,Int64(idx))
function getbarcidxj(task_:: MSKtask,idx_:: Int64)
  j_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getbarcidxj",Int32,(Ptr{Nothing},Int64,Ptr{Int32},),task_.task,idx_-1,j_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,j_[1]+1))
end

"""
    (numnz,idxj) = getbarcsparsity(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numnz :: Int64`. Number of nonzero elements in barc.
* `idxj :: Vector{Int64}`. Internal positions of the nonzeros elements in barc.

Internally only the nonzero elements of ``\\bar C`` are stored 
in a vector. This function is used to obtain the nonzero elements of ``\\bar C``
and their indexes in the internal vector representation (in `idx`). From the index
detailed information about each nonzero ``\\bar C_j`` can be
obtained using `Mosek.getbarcidxinfo` and `Mosek.getbarcidx`.
"""
function getbarcsparsity end
function getbarcsparsity(task_:: MSKtask)
  maxnumnz_ = getnumbarcnz(task_)
  numnz_ = Vector{Int64}(undef,1)
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  idxj_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getbarcsparsity",Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int64},),task_.task,maxnumnz_,numnz_,__tmp_var_1)
  end
  __tmp_var_1 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numnz_[1]),__tmp_var_1)
end

"""
    barsj = getbarsj{T2}(task:: MSKtask,whichsol:: Soltype,j:: T2)
    barsj = getbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barsj :: Vector{Float64}`. Value of the j'th dual variable of barx.

Obtains the dual solution for a semidefinite variable. Only the lower triangular part of ``\\bar S_j`` is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.
"""
function getbarsj end
getbarsj(task:: MSKtask,whichsol:: Soltype,j:: T2) where {T2} = getbarsj(task,whichsol,Int32(j))
function getbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  barsj_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getbarsj",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,j_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    name = getbarvarname{T1}(task:: MSKtask,i:: T1)
    name = getbarvarname(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the variable.
* `name :: AbstractString`. The requested name is copied to this buffer.

Obtains the name of a semidefinite variable.
"""
function getbarvarname end
getbarvarname(task:: MSKtask,i:: T1) where {T1} = getbarvarname(task,Int32(i))
function getbarvarname(task_:: MSKtask,i_:: Int32)
  sizename_ = (1 + getbarvarnamelen(task_,(i_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @msk_ccall( "getbarvarname",Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),task_.task,i_-1,sizename_,name_)
  end
  name_str = convert(String,name_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str[1:searchindex(name_str,'\0')-1])
end

"""
    (asgn,index) = getbarvarnameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name of the variable.
* `asgn :: Int32`. Non-zero if the name somename is assigned to some semidefinite variable.
* `index :: Int32`. The index of a semidefinite variable with the name somename (if one exists).

Obtains the index of semidefinite variable from its name.
"""
function getbarvarnameindex end
function getbarvarnameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Vector{Int32}(undef,1)
  index_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getbarvarnameindex",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},Ptr{Int32},),task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_[1]),convert(Int32,index_[1]+1))
end

"""
    len = getbarvarnamelen{T1}(task:: MSKtask,i:: T1)
    len = getbarvarnamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the variable.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a semidefinite variable.
"""
function getbarvarnamelen end
getbarvarnamelen(task:: MSKtask,i:: T1) where {T1} = getbarvarnamelen(task,Int32(i))
function getbarvarnamelen(task_:: MSKtask,i_:: Int32)
  len_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getbarvarnamelen",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]))
end

"""
    barxj = getbarxj{T2}(task:: MSKtask,whichsol:: Soltype,j:: T2)
    barxj = getbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barxj :: Vector{Float64}`. Value of the j'th variable of barx.

Obtains the primal solution for a semidefinite variable. Only the lower triangular part of ``\\bar X_j`` is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.
"""
function getbarxj end
getbarxj(task:: MSKtask,whichsol:: Soltype,j:: T2) where {T2} = getbarxj(task,whichsol,Int32(j))
function getbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  barxj_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getbarxj",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,j_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (bk,bl,bu) = getbound{T2}(task:: MSKtask,accmode:: Accmode,i:: T2)
    (bk,bl,bu) = getbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).
* `i :: Int32`. Index of the constraint or variable for which the bound information should be obtained.
* `bk :: Boundkey`. Bound keys.
* `bl :: Float64`. Values for lower bounds.
* `bu :: Float64`. Values for upper bounds.

Obtains bound information for one constraint or variable.
"""
function getbound end
getbound(task:: MSKtask,accmode:: Accmode,i:: T2) where {T2} = getbound(task,accmode,Int32(i))
function getbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32)
  bk_ = Vector{Int32}(undef,1)
  bl_ = Vector{Float64}(undef,1)
  bu_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getbound",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,accmode_.value,i_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey(bk_[1]),convert(Float64,bl_[1]),convert(Float64,bu_[1]))
end

"""
    (bk,bl,bu) = getboundslice{T2,T3}(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3)
    (bk,bl,bu) = getboundslice(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines if operations are performed row-wise (constraint-oriented) or column-wise (variable-oriented).
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Boundkey}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Obtains bounds information for a slice of variables or constraints.
"""
function getboundslice end
getboundslice(task:: MSKtask,accmode:: Accmode,first:: T2,last:: T3) where {T2,T3} = getboundslice(task,accmode,Int32(first),Int32(last))
function getboundslice(task_:: MSKtask,accmode_:: Accmode,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  bk_ = Vector{Int32}(__tmp_var_0)
  __tmp_var_1 = ((last_) - (first_))
  __tmp_var_2 = zeros(Float64,__tmp_var_1)
  bl_ = __tmp_var_2
  __tmp_var_3 = ((last_) - (first_))
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  bu_ = __tmp_var_4
  res = disable_sigint() do
    @msk_ccall( "getboundslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,accmode_.value,first_-1,last_-1,bk_,__tmp_var_2,__tmp_var_4)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey[ Boundkey(i) for i in bk_],__tmp_var_2,__tmp_var_4)
end

"""
    c = getc(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `c :: Vector{Float64}`. Linear terms of the objective as a dense vector. The length is the number of variables.

Obtains all objective coefficients ``c``.
"""
function getc end
function getc(task_:: MSKtask)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  c_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getc",Int32,(Ptr{Nothing},Ptr{Float64},),task_.task,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    cfix = getcfix(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `cfix :: Float64`. Fixed term in the objective.

Obtains the fixed term in the objective.
"""
function getcfix end
function getcfix(task_:: MSKtask)
  cfix_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getcfix",Int32,(Ptr{Nothing},Ptr{Float64},),task_.task,cfix_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,cfix_[1]))
end

"""
    cj = getcj{T1}(task:: MSKtask,j:: T1)
    cj = getcj(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable for which the c coefficient should be obtained.
* `cj :: Float64`. The c coefficient value.

Obtains one coefficient of ``c``.
"""
function getcj end
getcj(task:: MSKtask,j:: T1) where {T1} = getcj(task,Int32(j))
function getcj(task_:: MSKtask,j_:: Int32)
  cj_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getcj",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,j_-1,cj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,cj_[1]))
end

"""
    (bk,bl,bu) = getconbound{T1}(task:: MSKtask,i:: T1)
    (bk,bl,bu) = getconbound(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint for which the bound information should be obtained.
* `bk :: Boundkey`. Bound keys.
* `bl :: Float64`. Values for lower bounds.
* `bu :: Float64`. Values for upper bounds.

Obtains bound information for one constraint.
"""
function getconbound end
getconbound(task:: MSKtask,i:: T1) where {T1} = getconbound(task,Int32(i))
function getconbound(task_:: MSKtask,i_:: Int32)
  bk_ = Vector{Int32}(undef,1)
  bl_ = Vector{Float64}(undef,1)
  bu_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getconbound",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,i_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey(bk_[1]),convert(Float64,bl_[1]),convert(Float64,bu_[1]))
end

"""
    (bk,bl,bu) = getconboundslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (bk,bl,bu) = getconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Boundkey}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Obtains bounds information for a slice of the constraints.
"""
function getconboundslice end
getconboundslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getconboundslice(task,Int32(first),Int32(last))
function getconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  bk_ = Vector{Int32}(__tmp_var_0)
  __tmp_var_1 = ((last_) - (first_))
  __tmp_var_2 = zeros(Float64,__tmp_var_1)
  bl_ = __tmp_var_2
  __tmp_var_3 = ((last_) - (first_))
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  bu_ = __tmp_var_4
  res = disable_sigint() do
    @msk_ccall( "getconboundslice",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,first_-1,last_-1,bk_,__tmp_var_2,__tmp_var_4)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey[ Boundkey(i) for i in bk_],__tmp_var_2,__tmp_var_4)
end

"""
    (ct,conepar,nummem,submem) = getcone{T1}(task:: MSKtask,k:: T1)
    (ct,conepar,nummem,submem) = getcone(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. This argument is currently not used. It can be set to 0
* `nummem :: Int32`. Number of member variables in the cone.
* `submem :: Vector{Int32}`. Variable subscripts of the members in the cone.

Obtains a cone.
"""
function getcone end
getcone(task:: MSKtask,k:: T1) where {T1} = getcone(task,Int32(k))
function getcone(task_:: MSKtask,k_:: Int32)
  conepar_ = Vector{Float64}(undef,1)
  ct_ = Vector{Int32}(undef,1)
  nummem_ = Vector{Int32}(undef,1)
  __tmp_var_0 = getconeinfo(task_,(k_))[3]
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  submem_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getcone",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Int32},Ptr{Int32},),task_.task,k_-1,ct_,conepar_,nummem_,__tmp_var_1)
  end
  __tmp_var_1 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Conetype(ct_[1]),convert(Float64,conepar_[1]),convert(Int32,nummem_[1]),__tmp_var_1)
end

"""
    (ct,conepar,nummem) = getconeinfo{T1}(task:: MSKtask,k:: T1)
    (ct,conepar,nummem) = getconeinfo(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. This argument is currently not used. It can be set to 0
* `nummem :: Int32`. Number of member variables in the cone.

Obtains information about a cone.
"""
function getconeinfo end
getconeinfo(task:: MSKtask,k:: T1) where {T1} = getconeinfo(task,Int32(k))
function getconeinfo(task_:: MSKtask,k_:: Int32)
  conepar_ = Vector{Float64}(undef,1)
  ct_ = Vector{Int32}(undef,1)
  nummem_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getconeinfo",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Int32},),task_.task,k_-1,ct_,conepar_,nummem_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Conetype(ct_[1]),convert(Float64,conepar_[1]),convert(Int32,nummem_[1]))
end

"""
    name = getconename{T1}(task:: MSKtask,i:: T1)
    name = getconename(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the cone.
* `name :: AbstractString`. The required name.

Obtains the name of a cone.
"""
function getconename end
getconename(task:: MSKtask,i:: T1) where {T1} = getconename(task,Int32(i))
function getconename(task_:: MSKtask,i_:: Int32)
  sizename_ = (1 + getconenamelen(task_,(i_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @msk_ccall( "getconename",Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),task_.task,i_-1,sizename_,name_)
  end
  name_str = convert(String,name_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str[1:searchindex(name_str,'\0')-1])
end

"""
    (asgn,index) = getconenameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name which should be checked.
* `asgn :: Int32`. Is non-zero if the name somename is assigned to some cone.
* `index :: Int32`. If the name somename is assigned to some cone, this is the index of the cone.

Checks whether the name `somename` has been assigned to any cone. If it has been assigned to a cone, then the index of the cone is reported.
"""
function getconenameindex end
function getconenameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Vector{Int32}(undef,1)
  index_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getconenameindex",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},Ptr{Int32},),task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_[1]),convert(Int32,index_[1]+1))
end

"""
    len = getconenamelen{T1}(task:: MSKtask,i:: T1)
    len = getconenamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the cone.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a cone.
"""
function getconenamelen end
getconenamelen(task:: MSKtask,i:: T1) where {T1} = getconenamelen(task,Int32(i))
function getconenamelen(task_:: MSKtask,i_:: Int32)
  len_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getconenamelen",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]))
end

"""
    name = getconname{T1}(task:: MSKtask,i:: T1)
    name = getconname(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `name :: AbstractString`. The required name.

Obtains the name of a constraint.
"""
function getconname end
getconname(task:: MSKtask,i:: T1) where {T1} = getconname(task,Int32(i))
function getconname(task_:: MSKtask,i_:: Int32)
  sizename_ = (1 + getconnamelen(task_,(i_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @msk_ccall( "getconname",Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),task_.task,i_-1,sizename_,name_)
  end
  name_str = convert(String,name_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str[1:searchindex(name_str,'\0')-1])
end

"""
    (asgn,index) = getconnameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name which should be checked.
* `asgn :: Int32`. Is non-zero if the name somename is assigned to some constraint.
* `index :: Int32`. If the name somename is assigned to a constraint, then return the index of the constraint.

Checks whether the name `somename` has been assigned to any constraint. If so, the index of the constraint is reported.
"""
function getconnameindex end
function getconnameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Vector{Int32}(undef,1)
  index_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getconnameindex",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},Ptr{Int32},),task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_[1]),convert(Int32,index_[1]+1))
end

"""
    len = getconnamelen{T1}(task:: MSKtask,i:: T1)
    len = getconnamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a constraint.
"""
function getconnamelen end
getconnamelen(task:: MSKtask,i:: T1) where {T1} = getconnamelen(task,Int32(i))
function getconnamelen(task_:: MSKtask,i_:: Int32)
  len_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getconnamelen",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]))
end

"""
    c = getcslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    c = getcslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `c :: Vector{Float64}`. Linear terms of the requested slice of the objective as a dense vector.

Obtains a sequence of elements in ``c``.
"""
function getcslice end
getcslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getcslice(task,Int32(first),Int32(last))
function getcslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  c_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getcslice",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    dimbarvarj = getdimbarvarj{T1}(task:: MSKtask,j:: T1)
    dimbarvarj = getdimbarvarj(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the semidefinite variable whose dimension is requested.
* `dimbarvarj :: Int32`. The dimension of the j'th semidefinite variable.

Obtains the dimension of a symmetric matrix variable.
"""
function getdimbarvarj end
getdimbarvarj(task:: MSKtask,j:: T1) where {T1} = getdimbarvarj(task,Int32(j))
function getdimbarvarj(task_:: MSKtask,j_:: Int32)
  dimbarvarj_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getdimbarvarj",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,j_-1,dimbarvarj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,dimbarvarj_[1]))
end

"""
    dvalue = getdouinf(task_:: MSKtask,whichdinf_:: Dinfitem)

* `task :: MSKtask`. An optimization task.
* `whichdinf :: Dinfitem`. Specifies a double information item.
* `dvalue :: Float64`. The value of the required double information item.

Obtains a double information item from the task information database.
"""
function getdouinf end
function getdouinf(task_:: MSKtask,whichdinf_:: Dinfitem)
  dvalue_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getdouinf",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichdinf_.value,dvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,dvalue_[1]))
end

"""
    parvalue = getdouparam(task_:: MSKtask,param_:: Dparam)

* `task :: MSKtask`. An optimization task.
* `param :: Dparam`. Which parameter.
* `parvalue :: Float64`. Parameter value.

Obtains the value of a double parameter.
"""
function getdouparam end
function getdouparam(task_:: MSKtask,param_:: Dparam)
  parvalue_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getdouparam",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,parvalue_[1]))
end

"""
    dualobj = getdualobj(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `dualobj :: Float64`. Objective value corresponding to the dual solution.

Computes the dual objective value associated with the solution. Note that if the solution is a primal infeasibility certificate, then the fixed term in the objective value is not included. 

Moreover, since there is no dual solution associated with an integer solution, an error will be reported if the dual objective value is requested for the integer solution.
"""
function getdualobj end
function getdualobj(task_:: MSKtask,whichsol_:: Soltype)
  dualobj_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getdualobj",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,dualobj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,dualobj_[1]))
end

"""
    (nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars) = getdualsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `nrmy :: Float64`. The norm of the y vector.
* `nrmslc :: Float64`. The norm of the slc vector.
* `nrmsuc :: Float64`. The norm of the suc vector.
* `nrmslx :: Float64`. The norm of the slx vector.
* `nrmsux :: Float64`. The norm of the sux vector.
* `nrmsnx :: Float64`. The norm of the snx vector.
* `nrmbars :: Float64`. The norm of the bars vector.

Compute norms of the dual solution.
"""
function getdualsolutionnorms end
function getdualsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)
  nrmbars_ = Vector{Float64}(undef,1)
  nrmslc_ = Vector{Float64}(undef,1)
  nrmslx_ = Vector{Float64}(undef,1)
  nrmsnx_ = Vector{Float64}(undef,1)
  nrmsuc_ = Vector{Float64}(undef,1)
  nrmsux_ = Vector{Float64}(undef,1)
  nrmy_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getdualsolutionnorms",Int32,(Ptr{Nothing},Int32,Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,whichsol_.value,nrmy_,nrmslc_,nrmsuc_,nrmslx_,nrmsux_,nrmsnx_,nrmbars_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,nrmy_[1]),convert(Float64,nrmslc_[1]),convert(Float64,nrmsuc_[1]),convert(Float64,nrmslx_[1]),convert(Float64,nrmsux_[1]),convert(Float64,nrmsnx_[1]),convert(Float64,nrmbars_[1]))
end

"""
    viol = getdviolbarvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of barx variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Let ``(\\bar S_j)^*`` be the value of variable ``\\bar S_j`` for the
specified solution.  Then the dual violation of the solution associated with
variable ``\\bar S_j`` is given by

```math
 \\max(-\\lambda_{\\min}(\\bar S_j),\\ 0.0).
```
Both when the solution is a certificate of primal infeasibility and when it is
dual feasible solution the violation should be small.
"""
function getdviolbarvar end
getdviolbarvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolbarvar(task,whichsol,convert(Vector{Int32},sub))
function getdviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getdviolbarvar",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getdviolcon{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

The violation of the dual solution associated with the ``i``-th constraint
is computed as follows

```math
 \\max( \\rho( (s_l^c)_i^*,(b_l^c)_i ),\\ \\rho( (s_u^c)_i^*, -(b_u^c)_i ),\\ |-y_i+(s_l^c)_i^*-(s_u^c)_i^*| )
```
where

```math
\\rho(x,l) =
  \\left\\{
    \\begin{array}{ll}
       -x,   & l > -\\infty , \\\\
       |x|, &  \\mbox{otherwise}.\\\\
    \\end{array}
  \\right.
```
Both when the solution is a certificate of primal infeasibility or it is a dual feasible solution the violation should be small.
"""
function getdviolcon end
getdviolcon(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolcon(task,whichsol,convert(Vector{Int32},sub))
function getdviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getdviolcon",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getdviolcones{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of conic constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Let ``(s_n^x)^*`` be the value of variable ``(s_n^x)`` for the
specified solution. For simplicity let us assume that ``s_n^x`` is a member
of a quadratic cone, then the violation is computed as follows

```math
\\left\\{
  \\begin{array}{ll}
    \\max(0,(\\|s_n^x\\|_{2:n}^*-(s_n^x)_1^*) / \\sqrt{2}, & (s_n^x)^* \\geq -\\|(s_n^x)_{2:n}^*\\|, \\\\
    \\|(s_n^x)^*\\|, & \\mbox{otherwise.}
  \\end{array}
\\right.
```
Both when the solution is a certificate of primal infeasibility or when it is a
dual feasible solution the violation should be small.
"""
function getdviolcones end
getdviolcones(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolcones(task,whichsol,convert(Vector{Int32},sub))
function getdviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getdviolcones",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getdviolvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of x variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

The violation of the dual solution associated with the ``j``-th variable is
computed as follows

```math
 \\max \\left(\\rho((s_l^x)_j^*,(b_l^x)_j),\\ \\rho((s_u^x)_j^*,-(b_u^x)_j),\\ |\\sum_{i=1}^{+1{numcon}} a_{ij} y_i+(s_l^x)_j^*-(s_u^x)_j^* - \\tau c_j| \\right)
```
where

```math
\\rho(x,l) =
  \\left\\{
    \\begin{array}{ll}
       -x,   & l > -\\infty , \\\\
       |x|, &  \\mbox{otherwise}
    \\end{array}
  \\right.
```
and ``\\tau=0`` if the solution is a certificate of primal infeasibility and ``\\tau=1`` otherwise. The formula for computing the violation is only shown
for the linear case but is generalized appropriately for the more general problems. Both when the solution is a certificate of primal infeasibility or when it is a dual feasible solution the violation should be small.
"""
function getdviolvar end
getdviolvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolvar(task,whichsol,convert(Vector{Int32},sub))
function getdviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getdviolvar",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    inftask = getinfeasiblesubproblem(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Which solution to use when determining the infeasible subproblem.
* `inftask :: MSKtask`. A new task containing the infeasible subproblem.

Given the solution is a certificate of primal or dual infeasibility then a
primal or dual infeasible subproblem is obtained respectively.  The subproblem
tends to be much smaller than the original problem and hence it is easier to locate
the infeasibility inspecting the subproblem than the original problem.

For the procedure to be useful it is important to assign meaningful
names to constraints, variables etc. in the original task because those names
will be duplicated in the subproblem.

The function is only applicable to linear and conic quadratic optimization
problems.

For more information see Section :ref:`doc.shared.feas_repair`.
"""
function getinfeasiblesubproblem end
function getinfeasiblesubproblem(task_:: MSKtask,whichsol_:: Soltype)
  inftask_ = Vector{Ptr{Nothing}}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getinfeasiblesubproblem",Int32,(Ptr{Nothing},Int32,Ptr{Ptr{Nothing}},),task_.task,whichsol_.value,inftask_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(MSKtask,inftask_[1]))
end

"""
    infname = getinfname{T2}(task:: MSKtask,inftype:: Inftype,whichinf:: T2)
    infname = getinfname(task_:: MSKtask,inftype_:: Inftype,whichinf_:: Int32)

* `task :: MSKtask`. An optimization task.
* `inftype :: Inftype`. Type of the information item.
* `whichinf :: Int32`. An information item.
* `infname :: AbstractString`. Name of the information item.

Obtains the name of an information item.
"""
function getinfname end
getinfname(task:: MSKtask,inftype:: Inftype,whichinf:: T2) where {T2} = getinfname(task,inftype,Int32(whichinf))
function getinfname(task_:: MSKtask,inftype_:: Inftype,whichinf_:: Int32)
  infname_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @msk_ccall( "getinfname",Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),task_.task,inftype_.value,whichinf_,infname_)
  end
  infname_str = convert(String,infname_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (infname_str[1:searchindex(infname_str,'\0')-1])
end

"""
    ivalue = getintinf(task_:: MSKtask,whichiinf_:: Iinfitem)

* `task :: MSKtask`. An optimization task.
* `whichiinf :: Iinfitem`. Specifies an integer information item.
* `ivalue :: Int32`. The value of the required integer information item.

Obtains an integer information item from the task information database.
"""
function getintinf end
function getintinf(task_:: MSKtask,whichiinf_:: Iinfitem)
  ivalue_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getintinf",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichiinf_.value,ivalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,ivalue_[1]))
end

"""
    parvalue = getintparam(task_:: MSKtask,param_:: Iparam)

* `task :: MSKtask`. An optimization task.
* `param :: Iparam`. Which parameter.
* `parvalue :: Int32`. Parameter value.

Obtains the value of an integer parameter.
"""
function getintparam end
function getintparam(task_:: MSKtask,param_:: Iparam)
  parvalue_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getintparam",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,parvalue_[1]))
end

"""
    lenbarvarj = getlenbarvarj{T1}(task:: MSKtask,j:: T1)
    lenbarvarj = getlenbarvarj(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the semidefinite variable whose length if requested.
* `lenbarvarj :: Int64`. Number of scalar elements in the lower triangular part of the semidefinite variable.

Obtains the length of the ``j``-th semidefinite variable i.e. the number of elements in the lower triangular part.
"""
function getlenbarvarj end
getlenbarvarj(task:: MSKtask,j:: T1) where {T1} = getlenbarvarj(task,Int32(j))
function getlenbarvarj(task_:: MSKtask,j_:: Int32)
  lenbarvarj_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getlenbarvarj",Int32,(Ptr{Nothing},Int32,Ptr{Int64},),task_.task,j_-1,lenbarvarj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,lenbarvarj_[1]))
end

"""
    ivalue = getlintinf(task_:: MSKtask,whichliinf_:: Liinfitem)

* `task :: MSKtask`. An optimization task.
* `whichliinf :: Liinfitem`. Specifies a long information item.
* `ivalue :: Int64`. The value of the required long integer information item.

Obtains a long integer information item from the task information database.
"""
function getlintinf end
function getlintinf(task_:: MSKtask,whichliinf_:: Liinfitem)
  ivalue_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getlintinf",Int32,(Ptr{Nothing},Int32,Ptr{Int64},),task_.task,whichliinf_.value,ivalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,ivalue_[1]))
end

"""
    maxnumanz = getmaxnumanz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumanz :: Int64`. Number of preallocated non-zero linear matrix elements.

Obtains number of preallocated non-zeros in ``A``. When this number of non-zeros is reached MOSEK will automatically allocate more space for ``A``.
"""
function getmaxnumanz end
function getmaxnumanz(task_:: MSKtask)
  maxnumanz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getmaxnumanz64",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,maxnumanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,maxnumanz_[1]))
end

"""
    maxnumbarvar = getmaxnumbarvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumbarvar :: Int32`. Maximum number of symmetric matrix variables for which space is currently preallocated.

Obtains maximum number of symmetric matrix variables for which space is currently preallocated.
"""
function getmaxnumbarvar end
function getmaxnumbarvar(task_:: MSKtask)
  maxnumbarvar_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getmaxnumbarvar",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,maxnumbarvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumbarvar_[1]))
end

"""
    maxnumcon = getmaxnumcon(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. Number of preallocated constraints in the optimization task.

Obtains the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.
"""
function getmaxnumcon end
function getmaxnumcon(task_:: MSKtask)
  maxnumcon_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getmaxnumcon",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,maxnumcon_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumcon_[1]))
end

"""
    maxnumcone = getmaxnumcone(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumcone :: Int32`. Number of preallocated conic constraints in the optimization task.

Obtains the number of preallocated cones in the optimization task. When this
number of cones is reached MOSEK will automatically allocate space for more
cones.
"""
function getmaxnumcone end
function getmaxnumcone(task_:: MSKtask)
  maxnumcone_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getmaxnumcone",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,maxnumcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumcone_[1]))
end

"""
    maxnumqnz = getmaxnumqnz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumqnz :: Int64`. Number of non-zero elements preallocated in quadratic coefficient matrices.

Obtains the number of preallocated non-zeros for ``Q`` (both objective and
constraints). When this number of non-zeros is reached MOSEK will
automatically allocate more space for ``Q``.
"""
function getmaxnumqnz end
function getmaxnumqnz(task_:: MSKtask)
  maxnumqnz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getmaxnumqnz64",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,maxnumqnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,maxnumqnz_[1]))
end

"""
    maxnumvar = getmaxnumvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumvar :: Int32`. Number of preallocated variables in the optimization task.

Obtains the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for variables.
"""
function getmaxnumvar end
function getmaxnumvar(task_:: MSKtask)
  maxnumvar_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getmaxnumvar",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,maxnumvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumvar_[1]))
end

"""
    (meminuse,maxmemuse) = getmemusage(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `meminuse :: Int64`. Amount of memory currently used by the task.
* `maxmemuse :: Int64`. Maximum amount of memory used by the task until now.

Obtains information about the amount of memory used by a task.
"""
function getmemusage end
function getmemusage(task_:: MSKtask)
  maxmemuse_ = Vector{Int64}(undef,1)
  meminuse_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getmemusagetask",Int32,(Ptr{Nothing},Ptr{Int64},Ptr{Int64},),task_.task,meminuse_,maxmemuse_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,meminuse_[1]),convert(Int64,maxmemuse_[1]))
end

"""
    dvalue = getnadouinf(task_:: MSKtask,infitemname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `infitemname :: String`. The name of a double information item.
* `dvalue :: Float64`. The value of the required double information item.

Obtains a named double information item from task information database.
"""
function getnadouinf end
function getnadouinf(task_:: MSKtask,infitemname_:: AbstractString)
  dvalue_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnadouinf",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Float64},),task_.task,string(infitemname_),dvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,dvalue_[1]))
end

"""
    parvalue = getnadouparam(task_:: MSKtask,paramname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Float64`. Parameter value.

Obtains the value of a named double parameter.
"""
function getnadouparam end
function getnadouparam(task_:: MSKtask,paramname_:: AbstractString)
  parvalue_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnadouparam",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Float64},),task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,parvalue_[1]))
end

"""
    ivalue = getnaintinf(task_:: MSKtask,infitemname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `infitemname :: String`. The name of an integer information item.
* `ivalue :: Int32`. The value of the required integer information item.

Obtains a named integer information item from the task information database.
"""
function getnaintinf end
function getnaintinf(task_:: MSKtask,infitemname_:: AbstractString)
  ivalue_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnaintinf",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},),task_.task,string(infitemname_),ivalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,ivalue_[1]))
end

"""
    parvalue = getnaintparam(task_:: MSKtask,paramname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Int32`. Parameter value.

Obtains the value of a named integer parameter.
"""
function getnaintparam end
function getnaintparam(task_:: MSKtask,paramname_:: AbstractString)
  parvalue_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnaintparam",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},),task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,parvalue_[1]))
end

"""
    (len,parvalue) = getnastrparam{T2}(task:: MSKtask,paramname:: AbstractString,sizeparamname:: T2)
    (len,parvalue) = getnastrparam(task_:: MSKtask,paramname_:: AbstractString,sizeparamname_:: Int32)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `sizeparamname :: Int32`. Size of the name buffer.
* `len :: Int32`. Returns the length of the parameter value.
* `parvalue :: AbstractString`. Parameter value.

Obtains the value of a named string parameter.
"""
function getnastrparam end
getnastrparam(task:: MSKtask,paramname:: AbstractString,sizeparamname:: T2) where {T2} = getnastrparam(task,paramname,Int32(sizeparamname))
function getnastrparam(task_:: MSKtask,paramname_:: AbstractString,sizeparamname_:: Int32)
  len_ = Vector{Int32}(undef,1)
  parvalue_ = zeros(UInt8,(sizeparamname_)+1)
  res = disable_sigint() do
    @msk_ccall( "getnastrparam",Int32,(Ptr{Nothing},Ptr{UInt8},Int32,Ptr{Int32},Ptr{UInt8},),task_.task,string(paramname_),sizeparamname_,len_,parvalue_)
  end
  parvalue_str = convert(String,parvalue_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]),parvalue_str[1:searchindex(parvalue_str,'\0')-1])
end

"""
    numanz = getnumanz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numanz :: Int32`. Number of non-zero elements in the linear constraint matrix.

Obtains the number of non-zeros in ``A``.
"""
function getnumanz end
function getnumanz(task_:: MSKtask)
  numanz_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumanz",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,numanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numanz_[1]))
end

"""
    numanz = getnumanz64(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numanz :: Int64`. Number of non-zero elements in the linear constraint matrix.

Obtains the number of non-zeros in ``A``.
"""
function getnumanz64 end
function getnumanz64(task_:: MSKtask)
  numanz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumanz64",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,numanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numanz_[1]))
end

"""
    num = getnumbarablocktriplets(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. An upper bound on the number of elements in the block triplet form of bara.

Obtains an upper bound on the number of elements in the block triplet form of ``\\bar A``.
"""
function getnumbarablocktriplets end
function getnumbarablocktriplets(task_:: MSKtask)
  num_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumbarablocktriplets",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_[1]))
end

"""
    nz = getnumbaranz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `nz :: Int64`. The number of nonzero block elements in barA.

Get the number of nonzero elements in ``\\bar A``.
"""
function getnumbaranz end
function getnumbaranz(task_:: MSKtask)
  nz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumbaranz",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,nz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,nz_[1]))
end

"""
    num = getnumbarcblocktriplets(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. An upper bound on the number of elements in the block triplet form of barc.

Obtains an upper bound on the number of elements in the block triplet form of ``\\bar C``.
"""
function getnumbarcblocktriplets end
function getnumbarcblocktriplets(task_:: MSKtask)
  num_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumbarcblocktriplets",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_[1]))
end

"""
    nz = getnumbarcnz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `nz :: Int64`. The number of nonzero elements in barc.

Obtains the number of nonzero elements in ``\\bar C``.
"""
function getnumbarcnz end
function getnumbarcnz(task_:: MSKtask)
  nz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumbarcnz",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,nz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,nz_[1]))
end

"""
    numbarvar = getnumbarvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numbarvar :: Int32`. Number of semidefinite variables in the problem.

Obtains the number of semidefinite variables.
"""
function getnumbarvar end
function getnumbarvar(task_:: MSKtask)
  numbarvar_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumbarvar",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,numbarvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numbarvar_[1]))
end

"""
    numcon = getnumcon(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numcon :: Int32`. Number of constraints.

Obtains the number of constraints.
"""
function getnumcon end
function getnumcon(task_:: MSKtask)
  numcon_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumcon",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,numcon_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numcon_[1]))
end

"""
    numcone = getnumcone(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numcone :: Int32`. Number of conic constraints.

Obtains the number of cones.
"""
function getnumcone end
function getnumcone(task_:: MSKtask)
  numcone_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumcone",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,numcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numcone_[1]))
end

"""
    nummem = getnumconemem{T1}(task:: MSKtask,k:: T1)
    nummem = getnumconemem(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `nummem :: Int32`. Number of member variables in the cone.

Obtains the number of members in a cone.
"""
function getnumconemem end
getnumconemem(task:: MSKtask,k:: T1) where {T1} = getnumconemem(task,Int32(k))
function getnumconemem(task_:: MSKtask,k_:: Int32)
  nummem_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumconemem",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,k_-1,nummem_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nummem_[1]))
end

"""
    numintvar = getnumintvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numintvar :: Int32`. Number of integer variables.

Obtains the number of integer-constrained variables.
"""
function getnumintvar end
function getnumintvar(task_:: MSKtask)
  numintvar_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumintvar",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,numintvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numintvar_[1]))
end

"""
    numparam = getnumparam(task_:: MSKtask,partype_:: Parametertype)

* `task :: MSKtask`. An optimization task.
* `partype :: Parametertype`. Parameter type.
* `numparam :: Int32`. Returns the number of parameters of the requested type.

Obtains the number of parameters of a given type.
"""
function getnumparam end
function getnumparam(task_:: MSKtask,partype_:: Parametertype)
  numparam_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumparam",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,partype_.value,numparam_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numparam_[1]))
end

"""
    numqcnz = getnumqconknz{T1}(task:: MSKtask,k:: T1)
    numqcnz = getnumqconknz(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the constraint for which the number quadratic terms should be obtained.
* `numqcnz :: Int64`. Number of quadratic terms.

Obtains the number of non-zero quadratic terms in a constraint.
"""
function getnumqconknz end
getnumqconknz(task:: MSKtask,k:: T1) where {T1} = getnumqconknz(task,Int32(k))
function getnumqconknz(task_:: MSKtask,k_:: Int32)
  numqcnz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumqconknz64",Int32,(Ptr{Nothing},Int32,Ptr{Int64},),task_.task,k_-1,numqcnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqcnz_[1]))
end

"""
    numqonz = getnumqobjnz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numqonz :: Int64`. Number of non-zero elements in the quadratic objective terms.

Obtains the number of non-zero quadratic terms in the objective.
"""
function getnumqobjnz end
function getnumqobjnz(task_:: MSKtask)
  numqonz_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumqobjnz64",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,numqonz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqonz_[1]))
end

"""
    num = getnumsymmat(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. The number of symmetric sparse matrices.

Obtains the number of symmetric matrices stored in the vector ``E``.
"""
function getnumsymmat end
function getnumsymmat(task_:: MSKtask)
  num_ = Vector{Int64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumsymmat",Int32,(Ptr{Nothing},Ptr{Int64},),task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_[1]))
end

"""
    numvar = getnumvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numvar :: Int32`. Number of variables.

Obtains the number of variables.
"""
function getnumvar end
function getnumvar(task_:: MSKtask)
  numvar_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getnumvar",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,numvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numvar_[1]))
end

"""
    objname = getobjname(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `objname :: AbstractString`. Assigned the objective name.

Obtains the name assigned to the objective function.
"""
function getobjname end
function getobjname(task_:: MSKtask)
  sizeobjname_ = (1 + getobjnamelen(task_))
  objname_ = zeros(UInt8,(sizeobjname_)+1)
  res = disable_sigint() do
    @msk_ccall( "getobjname",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,sizeobjname_,objname_)
  end
  objname_str = convert(String,objname_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (objname_str[1:searchindex(objname_str,'\0')-1])
end

"""
    len = getobjnamelen(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `len :: Int32`. Assigned the length of the objective name.

Obtains the length of the name assigned to the objective function.
"""
function getobjnamelen end
function getobjnamelen(task_:: MSKtask)
  len_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getobjnamelen",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]))
end

"""
    sense = getobjsense(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `sense :: Objsense`. The returned objective sense.

Gets the objective sense of the task.
"""
function getobjsense end
function getobjsense(task_:: MSKtask)
  sense_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getobjsense",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,sense_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Objsense(sense_[1]))
end

"""
    parname = getparamname{T2}(task:: MSKtask,partype:: Parametertype,param:: T2)
    parname = getparamname(task_:: MSKtask,partype_:: Parametertype,param_:: Int32)

* `task :: MSKtask`. An optimization task.
* `partype :: Parametertype`. Parameter type.
* `param :: Int32`. Which parameter.
* `parname :: AbstractString`. Parameter name.

Obtains the name for a parameter `param` of type `partype`.
"""
function getparamname end
getparamname(task:: MSKtask,partype:: Parametertype,param:: T2) where {T2} = getparamname(task,partype,Int32(param))
function getparamname(task_:: MSKtask,partype_:: Parametertype,param_:: Int32)
  parname_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @msk_ccall( "getparamname",Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),task_.task,partype_.value,param_,parname_)
  end
  parname_str = convert(String,parname_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (parname_str[1:searchindex(parname_str,'\0')-1])
end

"""
    primalobj = getprimalobj(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `primalobj :: Float64`. Objective value corresponding to the primal solution.

Computes the primal objective value for the desired solution. Note that if the solution is an infeasibility certificate, then the fixed term in the objective is not included.
"""
function getprimalobj end
function getprimalobj(task_:: MSKtask,whichsol_:: Soltype)
  primalobj_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getprimalobj",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,primalobj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,primalobj_[1]))
end

"""
    (nrmxc,nrmxx,nrmbarx) = getprimalsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `nrmxc :: Float64`. The norm of the xc vector.
* `nrmxx :: Float64`. The norm of the xx vector.
* `nrmbarx :: Float64`. The norm of the barX vector.

Compute norms of the primal solution.
"""
function getprimalsolutionnorms end
function getprimalsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)
  nrmbarx_ = Vector{Float64}(undef,1)
  nrmxc_ = Vector{Float64}(undef,1)
  nrmxx_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getprimalsolutionnorms",Int32,(Ptr{Nothing},Int32,Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,whichsol_.value,nrmxc_,nrmxx_,nrmbarx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,nrmxc_[1]),convert(Float64,nrmxx_[1]),convert(Float64,nrmbarx_[1]))
end

"""
    probtype = getprobtype(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `probtype :: Problemtype`. The problem type.

Obtains the problem type.
"""
function getprobtype end
function getprobtype(task_:: MSKtask)
  probtype_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getprobtype",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,probtype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Problemtype(probtype_[1]))
end

"""
    prosta = getprosta(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `prosta :: Prosta`. Problem status.

Obtains the problem status.
"""
function getprosta end
function getprosta(task_:: MSKtask,whichsol_:: Soltype)
  prosta_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getprosta",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichsol_.value,prosta_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Prosta(prosta_[1]))
end

"""
    viol = getpviolbarvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of barX variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation for a set of semidefinite variables. 
Let ``(\\bar X_j)^*`` be the value of the variable ``\\bar X_j`` for the
specified solution.  Then the primal violation of the solution associated with
variable ``\\bar X_j`` is given by

```math
 \\max(-\\lambda_{\\min}(\\bar X_j),\\ 0.0).
```
Both when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.
"""
function getpviolbarvar end
getpviolbarvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolbarvar(task,whichsol,convert(Vector{Int32},sub))
function getpviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getpviolbarvar",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpviolcon{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation for a set of constraints. 
The primal violation of the solution associated with the ``i``-th constraint is given by

```math
 \\max(\\tau l_i^c - (x_i^c)^*,\\ (x_i^c)^* - \\tau u_i^c),\\ |\\sum_{j=1}^{+1{numvar}} a_{ij} x_j^* - x_i^c|)
```
where ``\\tau=0`` if the solution is a certificate of
dual infeasibility and ``\\tau=1`` otherwise. Both when
the solution is a certificate of dual infeasibility and when it is primal
feasible the violation should be small. The above formula applies for
the linear case but is appropriately generalized in other cases.
"""
function getpviolcon end
getpviolcon(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolcon(task,whichsol,convert(Vector{Int32},sub))
function getpviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getpviolcon",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpviolcones{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of conic constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation for a set of conic constraints. 
Let ``x^*`` be the value of the variable ``x`` for the specified solution.
For simplicity let us assume that ``x`` is a member of a quadratic cone, then
the violation is computed as follows

```math
\\left\\{
  \\begin{array}{ll}
    \\max(0,\\|x_{2:n}\\|-x_1) / \\sqrt{2}, & x_1 \\geq -\\|x_{2:n}\\|, \\\\
    \\|x\\|, & \\mbox{otherwise.}
  \\end{array}
\\right.
```
Both when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.
"""
function getpviolcones end
getpviolcones(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolcones(task,whichsol,convert(Vector{Int32},sub))
function getpviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getpviolcones",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpviolvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of x variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation associated to a set of variables. 
Let ``x_j^*`` be the value of ``x_j`` for the specified
solution.  Then the primal violation of the solution associated with variable
``x_j`` is given by

```math
 \\max( \\tau l_j^x - x_j^*,\\ x_j^* - \\tau u_j^x,\\ 0).
```
where ``\\tau=0`` if the solution is a certificate of
dual infeasibility and ``\\tau=1`` otherwise. Both when
the solution is a certificate of dual infeasibility and when it is primal
feasible the violation should be small.
"""
function getpviolvar end
getpviolvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolvar(task,whichsol,convert(Vector{Int32},sub))
function getpviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getpviolvar",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (numqcnz,qcsubi,qcsubj,qcval) = getqconk{T1}(task:: MSKtask,k:: T1)
    (numqcnz,qcsubi,qcsubj,qcval) = getqconk(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Which constraint.
* `numqcnz :: Int64`. Number of quadratic terms.
* `qcsubi :: Vector{Int32}`. Row subscripts for quadratic constraint matrix.
* `qcsubj :: Vector{Int32}`. Column subscripts for quadratic constraint matrix.
* `qcval :: Vector{Float64}`. Quadratic constraint coefficient values.

Obtains all the quadratic terms in a constraint. The quadratic
terms are stored sequentially in `qcsubi`, `qcsubj`, and `qcval`.
"""
function getqconk end
getqconk(task:: MSKtask,k:: T1) where {T1} = getqconk(task,Int32(k))
function getqconk(task_:: MSKtask,k_:: Int32)
  numqcnz_ = Vector{Int64}(undef,1)
  maxnumqcnz_ = getnumqconknz(task_,(k_))
  __tmp_var_0 = getnumqconknz(task_,(k_))
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  qcsubi_ = __tmp_var_1
  __tmp_var_2 = getnumqconknz(task_,(k_))
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  qcsubj_ = __tmp_var_3
  __tmp_var_4 = getnumqconknz(task_,(k_))
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  qcval_ = __tmp_var_5
  qcsurp_ = convert(Int64,length(qcsubi_))
  res = disable_sigint() do
    @msk_ccall( "getqconk64",Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,k_-1,maxnumqcnz_,Ref(qcsurp_),numqcnz_,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqcnz_[1]),__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    (numqonz,qosubi,qosubj,qoval) = getqobj(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numqonz :: Int64`. Number of non-zero elements in the quadratic objective terms.
* `qosubi :: Vector{Int32}`. Row subscripts for quadratic objective coefficients.
* `qosubj :: Vector{Int32}`. Column subscripts for quadratic objective coefficients.
* `qoval :: Vector{Float64}`. Quadratic objective coefficient values.

Obtains the quadratic terms in the objective. The required quadratic terms
are stored sequentially in `qosubi`, `qosubj`, and `qoval`.
"""
function getqobj end
function getqobj(task_:: MSKtask)
  maxnumqonz_ = getnumqobjnz(task_)
  numqonz_ = Vector{Int64}(undef,1)
  __tmp_var_0 = (maxnumqonz_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  qosubi_ = __tmp_var_1
  __tmp_var_2 = (maxnumqonz_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  qosubj_ = __tmp_var_3
  __tmp_var_4 = (maxnumqonz_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  qoval_ = __tmp_var_5
  qosurp_ = convert(Int64,length(qosubi_))
  res = disable_sigint() do
    @msk_ccall( "getqobj64",Int32,(Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,maxnumqonz_,Ref(qosurp_),numqonz_,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqonz_[1]),__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    qoij = getqobjij{T1,T2}(task:: MSKtask,i:: T1,j:: T2)
    qoij = getqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index of the coefficient.
* `j :: Int32`. Column index of coefficient.
* `qoij :: Float64`. The required coefficient.

Obtains one coefficient ``q_{ij}^o`` in the quadratic term of the objective.
"""
function getqobjij end
getqobjij(task:: MSKtask,i:: T1,j:: T2) where {T1,T2} = getqobjij(task,Int32(i),Int32(j))
function getqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32)
  qoij_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getqobjij",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,i_-1,j_-1,qoij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,qoij_[1]))
end

"""
    redcosts = getreducedcosts{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    redcosts = getreducedcosts(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. The index of the first variable in the sequence.
* `last :: Int32`. The index of the last variable in the sequence plus 1.
* `redcosts :: Vector{Float64}`. Returns the requested reduced costs.

Computes the reduced costs for a slice of variables and returns them in the array `redcosts` i.e.

```math
:label: ais-eq-redcost

\\mathtt{redcosts}[j-\\mathtt{first}] = (s_l^x)_j-(s_u^x)_j, ~j=\\mathtt{first},\\ldots,\\mathtt{last}-1
```

"""
function getreducedcosts end
getreducedcosts(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getreducedcosts(task,whichsol,Int32(first),Int32(last))
function getreducedcosts(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  redcosts_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getreducedcosts",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    skc = getskc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skc :: Vector{Stakey}`. Status keys for the constraints.

Obtains the status keys for the constraints.
"""
function getskc end
function getskc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  skc_ = Vector{Int32}(__tmp_var_0)
  res = disable_sigint() do
    @msk_ccall( "getskc",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichsol_.value,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skc_])
end

"""
    skc = getskcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    skc = getskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skc :: Vector{Stakey}`. Status keys for the constraints.

Obtains the status keys for a slice of the constraints.
"""
function getskcslice end
getskcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getskcslice(task,whichsol,Int32(first),Int32(last))
function getskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  skc_ = Vector{Int32}(__tmp_var_0)
  res = disable_sigint() do
    @msk_ccall( "getskcslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),task_.task,whichsol_.value,first_-1,last_-1,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skc_])
end

"""
    skx = getskx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skx :: Vector{Stakey}`. Status keys for the variables.

Obtains the status keys for the scalar variables.
"""
function getskx end
function getskx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  skx_ = Vector{Int32}(__tmp_var_0)
  res = disable_sigint() do
    @msk_ccall( "getskx",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichsol_.value,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skx_])
end

"""
    skx = getskxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    skx = getskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skx :: Vector{Stakey}`. Status keys for the variables.

Obtains the status keys for a slice of the scalar variables.
"""
function getskxslice end
getskxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getskxslice(task,whichsol,Int32(first),Int32(last))
function getskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  skx_ = Vector{Int32}(__tmp_var_0)
  res = disable_sigint() do
    @msk_ccall( "getskxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),task_.task,whichsol_.value,first_-1,last_-1,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skx_])
end

"""
    slc = getslc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Obtains the ``s_l^c`` vector for a solution.
"""
function getslc end
function getslc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slc_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getslc",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    slc = getslcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    slc = getslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Obtains a slice of the ``s_l^c`` vector for a solution.
"""
function getslcslice end
getslcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getslcslice(task,whichsol,Int32(first),Int32(last))
function getslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slc_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getslcslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    slx = getslx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Obtains the ``s_l^x`` vector for a solution.
"""
function getslx end
function getslx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slx_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getslx",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    slx = getslxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    slx = getslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Obtains a slice of the ``s_l^x`` vector for a solution.
"""
function getslxslice end
getslxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getslxslice(task,whichsol,Int32(first),Int32(last))
function getslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slx_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getslxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    snx = getsnx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Obtains the ``s_n^x`` vector for a solution.
"""
function getsnx end
function getsnx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  snx_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getsnx",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    snx = getsnxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    snx = getsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Obtains a slice of the ``s_n^x`` vector for a solution.
"""
function getsnxslice end
getsnxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getsnxslice(task,whichsol,Int32(first),Int32(last))
function getsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  snx_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getsnxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    solsta = getsolsta(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `solsta :: Solsta`. Solution status.

Obtains the solution status.
"""
function getsolsta end
function getsolsta(task_:: MSKtask,whichsol_:: Soltype)
  solsta_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getsolsta",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichsol_.value,solsta_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Solsta(solsta_[1]))
end

"""
    (prosta,solsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx) = getsolution(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `prosta :: Prosta`. Problem status.
* `solsta :: Solsta`. Solution status.
* `skc :: Vector{Stakey}`. Status keys for the constraints.
* `skx :: Vector{Stakey}`. Status keys for the variables.
* `skn :: Vector{Stakey}`. Status keys for the conic constraints.
* `xc :: Vector{Float64}`. Primal constraint solution.
* `xx :: Vector{Float64}`. Primal variable solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Obtains the complete solution.

Consider the case of linear programming. The primal problem is given by

```math
\\begin{array}{lccccl}
  \\mbox{minimize}              &      &      & c^T x+c^f &      &        \\\\
  \\mbox{subject to} &  l^c & \\leq & A x       & \\leq & u^c,     \\\\
  &  l^x & \\leq & x         & \\leq & u^x.   \\\\
\\end{array}
```
and the corresponding dual problem is

```math
\\begin{array}{lccl}
  \\mbox{maximize}   & (l^c)^T s_l^c - (u^c)^T s_u^c         &  \\\\
  & + (l^x)^T s_l^x - (u^x)^T s_u^x + c^f &  \\\\
  \\mbox{subject to} & A^T y + s_l^x - s_u^x                 & = & c, \\\\
  & -y    + s_l^c - s_u^c                 & = & 0, \\\\
  & s_l^c,s_u^c,s_l^x,s_u^x \\geq 0.       &   &    \\\\
\\end{array}
```
A conic optimization problem has the same primal variables as in the linear case. Recall that the dual of a conic optimization problem is given by:

```math
\\begin{array}{lccccc}
  \\mbox{maximize}   & (l^c)^T s_l^c - (u^c)^T s_u^c         &      &    \\\\
  & +(l^x)^T s_l^x - (u^x)^T s_u^x + c^f  &      &    \\\\
  \\mbox{subject to} & A^T y + s_l^x - s_u^x + s_n^x         & =    & c, \\\\
  & -y + s_l^c - s_u^c                    & =    & 0, \\\\
  & s_l^c,s_u^c,s_l^x,s_u^x               & \\geq & 0, \\\\
  & s_n^x \\in \\mathcal{K}^*                        &      &    \\\\
\\end{array}
```
The mapping between variables and arguments to the function is as follows:

* `xx` : Corresponds to variable ``x`` (also denoted ``x^x``).
* `xc` : Corresponds to ``x^c:=Ax``.
* `y`  : Corresponds to variable ``y``.
* `slc`: Corresponds to variable ``s_l^c``.
* `suc`: Corresponds to variable ``s_u^c``.
* `slx`: Corresponds to variable ``s_l^x``.
* `sux`: Corresponds to variable ``s_u^x``.
* `snx`: Corresponds to variable ``s_n^x``.

The meaning of the values returned by this function depend on the *solution status* returned in the argument `solsta`. The most important possible values  of `solsta` are:

* `MSK_SOL_STA_OPTIMAL` : An optimal solution satisfying the optimality criteria for continuous problems is returned.

* `MSK_SOL_STA_INTEGER_OPTIMAL` : An optimal solution satisfying the optimality criteria for integer problems is returned.

* `MSK_SOL_STA_PRIM_FEAS` : A solution satisfying the feasibility criteria.

* `MSK_SOL_STA_PRIM_INFEAS_CER` : A primal certificate of infeasibility is returned.

* `MSK_SOL_STA_DUAL_INFEAS_CER` : A dual certificate of infeasibility is returned.

In order to retrieve the primal and dual values of semidefinite variables see `Mosek.getbarxj` and `Mosek.getbarsj`.
"""
function getsolution end
function getsolution(task_:: MSKtask,whichsol_:: Soltype)
  prosta_ = Vector{Int32}(undef,1)
  __tmp_var_0 = getnumcon(task_)
  skc_ = Vector{Int32}(__tmp_var_0)
  __tmp_var_2 = getnumcone(task_)
  skn_ = Vector{Int32}(__tmp_var_2)
  __tmp_var_1 = getnumvar(task_)
  skx_ = Vector{Int32}(__tmp_var_1)
  __tmp_var_9 = getnumcon(task_)
  __tmp_var_10 = zeros(Float64,__tmp_var_9)
  slc_ = __tmp_var_10
  __tmp_var_13 = getnumvar(task_)
  __tmp_var_14 = zeros(Float64,__tmp_var_13)
  slx_ = __tmp_var_14
  __tmp_var_17 = getnumvar(task_)
  __tmp_var_18 = zeros(Float64,__tmp_var_17)
  snx_ = __tmp_var_18
  solsta_ = Vector{Int32}(undef,1)
  __tmp_var_11 = getnumcon(task_)
  __tmp_var_12 = zeros(Float64,__tmp_var_11)
  suc_ = __tmp_var_12
  __tmp_var_15 = getnumvar(task_)
  __tmp_var_16 = zeros(Float64,__tmp_var_15)
  sux_ = __tmp_var_16
  __tmp_var_3 = getnumcon(task_)
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  xc_ = __tmp_var_4
  __tmp_var_5 = getnumvar(task_)
  __tmp_var_6 = zeros(Float64,__tmp_var_5)
  xx_ = __tmp_var_6
  __tmp_var_7 = getnumcon(task_)
  __tmp_var_8 = zeros(Float64,__tmp_var_7)
  y_ = __tmp_var_8
  res = disable_sigint() do
    @msk_ccall( "getsolution",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,whichsol_.value,prosta_,solsta_,skc_,skx_,skn_,__tmp_var_4,__tmp_var_6,__tmp_var_8,__tmp_var_10,__tmp_var_12,__tmp_var_14,__tmp_var_16,__tmp_var_18)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Prosta(prosta_[1]),Solsta(solsta_[1]),Stakey[ Stakey(i) for i in skc_],Stakey[ Stakey(i) for i in skx_],Stakey[ Stakey(i) for i in skn_],__tmp_var_4,__tmp_var_6,__tmp_var_8,__tmp_var_10,__tmp_var_12,__tmp_var_14,__tmp_var_16,__tmp_var_18)
end

"""
    (sk,x,sl,su,sn) = getsolutioni{T2}(task:: MSKtask,accmode:: Accmode,i:: T2,whichsol:: Soltype)
    (sk,x,sl,su,sn) = getsolutioni(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines whether solution information for a constraint or for a variable is retrieved.
* `i :: Int32`. Index of the constraint or variable.
* `whichsol :: Soltype`. Selects a solution.
* `sk :: Stakey`. Status key of the constraint of variable.
* `x :: Float64`. Solution value of the primal variable.
* `sl :: Float64`. Solution value of the dual variable associated with the lower bound.
* `su :: Float64`. Solution value of the dual variable associated with the upper bound.
* `sn :: Float64`. Solution value of the dual variable associated with the cone constraint.

Obtains the primal and dual solution information for a single constraint or variable.
"""
function getsolutioni end
getsolutioni(task:: MSKtask,accmode:: Accmode,i:: T2,whichsol:: Soltype) where {T2} = getsolutioni(task,accmode,Int32(i),whichsol)
function getsolutioni(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,whichsol_:: Soltype)
  sk_ = Vector{Int32}(undef,1)
  sl_ = Vector{Float64}(undef,1)
  sn_ = Vector{Float64}(undef,1)
  su_ = Vector{Float64}(undef,1)
  x_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getsolutioni",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,accmode_.value,i_-1,whichsol_.value,sk_,x_,sl_,su_,sn_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey(sk_[1]),convert(Float64,x_[1]),convert(Float64,sl_[1]),convert(Float64,su_[1]),convert(Float64,sn_[1]))
end

"""
    (pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone) = getsolutioninfo(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `pobj :: Float64`. The primal objective value.
* `pviolcon :: Float64`. Maximal primal bound violation for a xc variable.
* `pviolvar :: Float64`. Maximal primal bound violation for a xx variable.
* `pviolbarvar :: Float64`. Maximal primal bound violation for a barx variable.
* `pviolcone :: Float64`. Maximal primal violation of the solution with respect to the conic constraints.
* `pviolitg :: Float64`. Maximal violation in the integer constraints.
* `dobj :: Float64`. Dual objective value.
* `dviolcon :: Float64`. Maximal dual bound violation for a xc variable.
* `dviolvar :: Float64`. Maximal dual bound violation for a xx variable.
* `dviolbarvar :: Float64`. Maximal dual bound violation for a bars variable.
* `dviolcone :: Float64`. Maximum violation of the dual solution in the dual conic constraints.

Obtains information about a solution.
"""
function getsolutioninfo end
function getsolutioninfo(task_:: MSKtask,whichsol_:: Soltype)
  dobj_ = Vector{Float64}(undef,1)
  dviolbarvar_ = Vector{Float64}(undef,1)
  dviolcon_ = Vector{Float64}(undef,1)
  dviolcone_ = Vector{Float64}(undef,1)
  dviolvar_ = Vector{Float64}(undef,1)
  pobj_ = Vector{Float64}(undef,1)
  pviolbarvar_ = Vector{Float64}(undef,1)
  pviolcon_ = Vector{Float64}(undef,1)
  pviolcone_ = Vector{Float64}(undef,1)
  pviolitg_ = Vector{Float64}(undef,1)
  pviolvar_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getsolutioninfo",Int32,(Ptr{Nothing},Int32,Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,whichsol_.value,pobj_,pviolcon_,pviolvar_,pviolbarvar_,pviolcone_,pviolitg_,dobj_,dviolcon_,dviolvar_,dviolbarvar_,dviolcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,pobj_[1]),convert(Float64,pviolcon_[1]),convert(Float64,pviolvar_[1]),convert(Float64,pviolbarvar_[1]),convert(Float64,pviolcone_[1]),convert(Float64,pviolitg_[1]),convert(Float64,dobj_[1]),convert(Float64,dviolcon_[1]),convert(Float64,dviolvar_[1]),convert(Float64,dviolbarvar_[1]),convert(Float64,dviolcone_[1]))
end

"""
    values = getsolutionslice{T3,T4}(task:: MSKtask,whichsol:: Soltype,solitem:: Solitem,first:: T3,last:: T4)
    values = getsolutionslice(task_:: MSKtask,whichsol_:: Soltype,solitem_:: Solitem,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `solitem :: Solitem`. Which part of the solution is required.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `values :: Vector{Float64}`. The values of the requested solution elements.

Obtains a slice of one item from the solution. The format of the solution is exactly as in `Mosek.getsolution`. The parameter `solitem` determines which of the solution vectors should be returned.
"""
function getsolutionslice end
getsolutionslice(task:: MSKtask,whichsol:: Soltype,solitem:: Solitem,first:: T3,last:: T4) where {T3,T4} = getsolutionslice(task,whichsol,solitem,Int32(first),Int32(last))
function getsolutionslice(task_:: MSKtask,whichsol_:: Soltype,solitem_:: Solitem,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  values_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getsolutionslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,solitem_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (subi,subj,valij) = getsparsesymmat{T1}(task:: MSKtask,idx:: T1)
    (subi,subj,valij) = getsparsesymmat(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the matrix to retrieve.
* `subi :: Vector{Int32}`. Row subscripts of the matrix non-zero elements.
* `subj :: Vector{Int32}`. Column subscripts of the matrix non-zero elements.
* `valij :: Vector{Float64}`. Coefficients of the matrix non-zero elements.

Get a single symmetric matrix from the matrix store.
"""
function getsparsesymmat end
getsparsesymmat(task:: MSKtask,idx:: T1) where {T1} = getsparsesymmat(task,Int64(idx))
function getsparsesymmat(task_:: MSKtask,idx_:: Int64)
  maxlen_ = getsymmatinfo(task_,(idx_))[2]
  __tmp_var_0 = (maxlen_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxlen_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxlen_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  valij_ = __tmp_var_5
  res = disable_sigint() do
    @msk_ccall( "getsparsesymmat",Int32,(Ptr{Nothing},Int64,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,idx_-1,maxlen_,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 += 1
  __tmp_var_3 += 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    (len,parvalue) = getstrparam(task_:: MSKtask,param_:: Sparam)

* `task :: MSKtask`. An optimization task.
* `param :: Sparam`. Which parameter.
* `len :: Int32`. The length of the parameter value.
* `parvalue :: AbstractString`. If this is not a null pointer, the parameter value is stored here.

Obtains the value of a string parameter.
"""
function getstrparam end
function getstrparam(task_:: MSKtask,param_:: Sparam)
  len_ = Vector{Int32}(undef,1)
  maxlen_ = (1 + getstrparamlen(task_,(param_)))
  parvalue_ = zeros(UInt8,(maxlen_)+1)
  res = disable_sigint() do
    @msk_ccall( "getstrparam",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{UInt8},),task_.task,param_.value,maxlen_,len_,parvalue_)
  end
  parvalue_str = convert(String,parvalue_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]),parvalue_str[1:searchindex(parvalue_str,'\0')-1])
end

"""
    len = getstrparamlen(task_:: MSKtask,param_:: Sparam)

* `task :: MSKtask`. An optimization task.
* `param :: Sparam`. Which parameter.
* `len :: Int32`. The length of the parameter value.

Obtains the length of a string parameter.
"""
function getstrparamlen end
function getstrparamlen(task_:: MSKtask,param_:: Sparam)
  len_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getstrparamlen",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,param_.value,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]))
end

"""
    suc = getsuc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Obtains the ``s_u^c`` vector for a solution.
"""
function getsuc end
function getsuc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  suc_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getsuc",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    suc = getsucslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    suc = getsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Obtains a slice of the ``s_u^c`` vector for a solution.
"""
function getsucslice end
getsucslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getsucslice(task,whichsol,Int32(first),Int32(last))
function getsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  suc_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getsucslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    sux = getsux(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Obtains the ``s_u^x`` vector for a solution.
"""
function getsux end
function getsux(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  sux_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getsux",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    sux = getsuxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    sux = getsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Obtains a slice of the ``s_u^x`` vector for a solution.
"""
function getsuxslice end
getsuxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getsuxslice(task,whichsol,Int32(first),Int32(last))
function getsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  sux_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getsuxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (dim,nz,type) = getsymmatinfo{T1}(task:: MSKtask,idx:: T1)
    (dim,nz,type) = getsymmatinfo(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the matrix for which information is requested.
* `dim :: Int32`. Returns the dimension of the requested matrix.
* `nz :: Int64`. Returns the number of non-zeros in the requested matrix.
* `type :: Symmattype`. Returns the type of the requested matrix.

MOSEK maintains a vector denoted by ``E`` of symmetric data matrices. This function makes it possible to obtain important information about a single matrix in ``E``.
"""
function getsymmatinfo end
getsymmatinfo(task:: MSKtask,idx:: T1) where {T1} = getsymmatinfo(task,Int64(idx))
function getsymmatinfo(task_:: MSKtask,idx_:: Int64)
  dim_ = Vector{Int32}(undef,1)
  nz_ = Vector{Int64}(undef,1)
  type_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getsymmatinfo",Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int64},Ptr{Int32},),task_.task,idx_-1,dim_,nz_,type_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,dim_[1]),convert(Int64,nz_[1]),Symmattype(type_[1]))
end

"""
    taskname = gettaskname(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `taskname :: AbstractString`. Returns the task name.

Obtains the name assigned to the task.
"""
function gettaskname end
function gettaskname(task_:: MSKtask)
  sizetaskname_ = (1 + gettasknamelen(task_))
  taskname_ = zeros(UInt8,(sizetaskname_)+1)
  res = disable_sigint() do
    @msk_ccall( "gettaskname",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,sizetaskname_,taskname_)
  end
  taskname_str = convert(String,taskname_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (taskname_str[1:searchindex(taskname_str,'\0')-1])
end

"""
    len = gettasknamelen(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `len :: Int32`. Returns the length of the task name.

Obtains the length the task name.
"""
function gettasknamelen end
function gettasknamelen(task_:: MSKtask)
  len_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "gettasknamelen",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]))
end

"""
    (bk,bl,bu) = getvarbound{T1}(task:: MSKtask,i:: T1)
    (bk,bl,bu) = getvarbound(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the variable for which the bound information should be obtained.
* `bk :: Boundkey`. Bound keys.
* `bl :: Float64`. Values for lower bounds.
* `bu :: Float64`. Values for upper bounds.

Obtains bound information for one variable.
"""
function getvarbound end
getvarbound(task:: MSKtask,i:: T1) where {T1} = getvarbound(task,Int32(i))
function getvarbound(task_:: MSKtask,i_:: Int32)
  bk_ = Vector{Int32}(undef,1)
  bl_ = Vector{Float64}(undef,1)
  bu_ = Vector{Float64}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getvarbound",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,i_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey(bk_[1]),convert(Float64,bl_[1]),convert(Float64,bu_[1]))
end

"""
    (bk,bl,bu) = getvarboundslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (bk,bl,bu) = getvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Boundkey}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Obtains bounds information for a slice of the variables.
"""
function getvarboundslice end
getvarboundslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getvarboundslice(task,Int32(first),Int32(last))
function getvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  bk_ = Vector{Int32}(__tmp_var_0)
  __tmp_var_1 = ((last_) - (first_))
  __tmp_var_2 = zeros(Float64,__tmp_var_1)
  bl_ = __tmp_var_2
  __tmp_var_3 = ((last_) - (first_))
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  bu_ = __tmp_var_4
  res = disable_sigint() do
    @msk_ccall( "getvarboundslice",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,first_-1,last_-1,bk_,__tmp_var_2,__tmp_var_4)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey[ Boundkey(i) for i in bk_],__tmp_var_2,__tmp_var_4)
end

"""
    name = getvarname{T1}(task:: MSKtask,j:: T1)
    name = getvarname(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of a variable.
* `name :: AbstractString`. Returns the required name.

Obtains the name of a variable.
"""
function getvarname end
getvarname(task:: MSKtask,j:: T1) where {T1} = getvarname(task,Int32(j))
function getvarname(task_:: MSKtask,j_:: Int32)
  sizename_ = (1 + getvarnamelen(task_,(j_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @msk_ccall( "getvarname",Int32,(Ptr{Nothing},Int32,Int32,Ptr{UInt8},),task_.task,j_-1,sizename_,name_)
  end
  name_str = convert(String,name_)
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str[1:searchindex(name_str,'\0')-1])
end

"""
    (asgn,index) = getvarnameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name which should be checked.
* `asgn :: Int32`. Is non-zero if the name somename is assigned to a variable.
* `index :: Int32`. If the name somename is assigned to a variable, then return the index of the variable.

Checks whether the name `somename` has been assigned to any variable. If so, the index of the variable is reported.
"""
function getvarnameindex end
function getvarnameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Vector{Int32}(undef,1)
  index_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getvarnameindex",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},Ptr{Int32},),task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_[1]),convert(Int32,index_[1]+1))
end

"""
    len = getvarnamelen{T1}(task:: MSKtask,i:: T1)
    len = getvarnamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of a variable.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a variable.
"""
function getvarnamelen end
getvarnamelen(task:: MSKtask,i:: T1) where {T1} = getvarnamelen(task,Int32(i))
function getvarnamelen(task_:: MSKtask,i_:: Int32)
  len_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getvarnamelen",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_[1]))
end

"""
    vartype = getvartype{T1}(task:: MSKtask,j:: T1)
    vartype = getvartype(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `vartype :: Variabletype`. Variable type of variable index j.

Gets the variable type of one variable.
"""
function getvartype end
getvartype(task:: MSKtask,j:: T1) where {T1} = getvartype(task,Int32(j))
function getvartype(task_:: MSKtask,j_:: Int32)
  vartype_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getvartype",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,j_-1,vartype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Variabletype(vartype_[1]))
end

"""
    vartype = getvartypelist{T1}(task:: MSKtask,subj:: Vector{T1})
    vartype = getvartypelist(task_:: MSKtask,subj_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. A list of variable indexes.
* `vartype :: Vector{Variabletype}`. Returns the variables types corresponding the variable indexes requested.

Obtains the variable type of one or more variables. Upon return `vartype[k]` is the variable type of variable `subj[k]`.
"""
function getvartypelist end
getvartypelist(task:: MSKtask,subj:: Vector{T1}) where {T1} = getvartypelist(task,convert(Vector{Int32},subj))
function getvartypelist(task_:: MSKtask,subj_:: Vector{Int32})
  num_ = minimum([ length(subj_) ])
  __tmp_var_0 = (num_)
  vartype_ = Vector{Int32}(__tmp_var_0)
  res = disable_sigint() do
    @msk_ccall( "getvartypelist",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},),task_.task,num_,subj_ .- Int32(1),vartype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Variabletype[ Variabletype(i) for i in vartype_])
end

"""
    xc = getxc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xc :: Vector{Float64}`. Primal constraint solution.

Obtains the ``x^c`` vector for a solution.
"""
function getxc end
function getxc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xc_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getxc",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    xc = getxcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    xc = getxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xc :: Vector{Float64}`. Primal constraint solution.

Obtains a slice of the ``x^c`` vector for a solution.
"""
function getxcslice end
getxcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getxcslice(task,whichsol,Int32(first),Int32(last))
function getxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xc_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getxcslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    xx = getxx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xx :: Vector{Float64}`. Primal variable solution.

Obtains the ``x^x`` vector for a solution.
"""
function getxx end
function getxx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xx_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getxx",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    xx = getxxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    xx = getxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xx :: Vector{Float64}`. Primal variable solution.

Obtains a slice of the ``x^x`` vector for a solution.
"""
function getxxslice end
getxxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getxxslice(task,whichsol,Int32(first),Int32(last))
function getxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xx_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getxxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    y = gety(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Obtains the ``y`` vector for a solution.
"""
function gety end
function gety(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  y_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "gety",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    y = getyslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    y = getyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Obtains a slice of the ``y`` vector for a solution.
"""
function getyslice end
getyslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getyslice(task,whichsol,Int32(first),Int32(last))
function getyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  y_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "getyslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    basis = initbasissolve(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `basis :: Vector{Int32}`. The array of basis indexes to use.

Prepare a task for use with the `Mosek.solvewithbasis` function.

This function should be called

* immediately before the first call to `Mosek.solvewithbasis`, and
* immediately before any subsequent call to `Mosek.solvewithbasis` if the task has been modified. 

If the basis is singular i.e. not invertible, then the error :msk:res:`err_basis_singular` is reported.
"""
function initbasissolve end
function initbasissolve(task_:: MSKtask)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  basis_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "initbasissolve",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    inputdata{T1,T2,T3,T4,T5,T6,T7,T8,T10,T11,T13,T14}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,aptrb:: Vector{T5},aptre:: Vector{T6},asub:: Vector{T7},aval:: Vector{T8},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14})
    inputdata{T1,T2,T3,T4,T10,T11,T13,T14}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,A:: SparseMatrixCSC{Float64},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14})
    inputdata(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,c_:: Vector{Float64},cfix_:: Float64,aptrb_:: Vector{Int64},aptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64},bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. Number of preallocated constraints in the optimization task.
* `maxnumvar :: Int32`. Number of preallocated variables in the optimization task.
* `c :: Vector{Float64}`. Linear terms of the objective as a dense vector. The length is the number of variables.
* `cfix :: Float64`. Fixed term in the objective.
* `aptrb :: Vector{Int64}`. Row or column start pointers.
* `aptre :: Vector{Int64}`. Row or column end pointers.
* `asub :: Vector{Int32}`. Coefficient subscripts.
* `aval :: Vector{Float64}`. Coefficient values.
* `bkc :: Vector{Int32}`. Bound keys for the constraints.
* `blc :: Vector{Float64}`. Lower bounds for the constraints.
* `buc :: Vector{Float64}`. Upper bounds for the constraints.
* `bkx :: Vector{Int32}`. Bound keys for the variables.
* `blx :: Vector{Float64}`. Lower bounds for the variables.
* `bux :: Vector{Float64}`. Upper bounds for the variables.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

Input the linear part of an optimization problem.


The non-zeros of ``A`` are inputted column-wise in the format described in Section :ref:`doc.optimizer.cmo_rmo_matrix`.

For an explained code example see Section :ref:`doc.tutorial_lo` and Section :ref:`doc.optimizer.matrix_formats`.
"""
function inputdata end
inputdata(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,aptrb:: Vector{T5},aptre:: Vector{T6},asub:: Vector{T7},aval:: Vector{T8},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14}) where {T1,T2,T3,T4,T5,T6,T7,T8,T10,T11,T13,T14} = inputdata(task,Int32(maxnumcon),Int32(maxnumvar),convert(Vector{Float64},c),Float64(cfix),convert(Vector{Int64},aptrb),convert(Vector{Int64},aptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval),bkc,convert(Vector{Float64},blc),convert(Vector{Float64},buc),bkx,convert(Vector{Float64},blx),convert(Vector{Float64},bux))
function inputdata(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,A:: SparseMatrixCSC{Float64},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14}) where {T1,T2,T3,T4,T10,T11,T13,T14}
  aptrb = A.colptr[1:size(A,2)]
  aptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  inputdata(task,maxnumcon,maxnumvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
end
function inputdata(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,c_:: Vector{Float64},cfix_:: Float64,aptrb_:: Vector{Int64},aptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64},bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})
  bkc_i32 = Int32[item.value for item in bkc_]
  bkx_i32 = Int32[item.value for item in bkx_]
  numcon_ = minimum([ length(buc_),length(blc_),length(bkc_) ])
  numvar_ = minimum([ length(c_),length(bux_),length(blx_),length(bkx_),length(aptrb_),length(aptre_) ])
  res = disable_sigint() do
    @msk_ccall( "inputdata64",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},Float64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,maxnumcon_,maxnumvar_,numcon_,numvar_,c_,cfix_,aptrb_ .- Int32(1),aptre_ .- Int32(1),asub_ .- Int32(1),aval_,bkc_,blc_,buc_,bkx_,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    param = isdouparname(task_:: MSKtask,parname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `param :: Dparam`. Returns the parameter corresponding to the name, if one exists.

Checks whether `parname` is a valid double parameter name.
"""
function isdouparname end
function isdouparname(task_:: MSKtask,parname_:: AbstractString)
  param_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "isdouparname",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},),task_.task,string(parname_),param_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Dparam(param_[1]))
end

"""
    param = isintparname(task_:: MSKtask,parname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `param :: Iparam`. Returns the parameter corresponding to the name, if one exists.

Checks whether `parname` is a valid integer parameter name.
"""
function isintparname end
function isintparname(task_:: MSKtask,parname_:: AbstractString)
  param_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "isintparname",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},),task_.task,string(parname_),param_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Iparam(param_[1]))
end

"""
    param = isstrparname(task_:: MSKtask,parname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `param :: Sparam`. Returns the parameter corresponding to the name, if one exists.

Checks whether `parname` is a valid string parameter name.
"""
function isstrparname end
function isstrparname(task_:: MSKtask,parname_:: AbstractString)
  param_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "isstrparname",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},),task_.task,string(parname_),param_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Sparam(param_[1]))
end

"""
    linkfiletostream{T3}(task:: MSKtask,whichstream:: Streamtype,filename:: AbstractString,append:: T3)
    linkfiletostream(task_:: MSKtask,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `filename :: String`. A valid file name.
* `append :: Int32`. If this argument is 0 the output file will be overwritten, otherwise it will be appended to.

Directs all output from a task stream `whichstream` to a file `filename`.
"""
function linkfiletostream end
linkfiletostream(task:: MSKtask,whichstream:: Streamtype,filename:: AbstractString,append:: T3) where {T3} = linkfiletostream(task,whichstream,filename,Int32(append))
function linkfiletostream(task_:: MSKtask,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "linkfiletotaskstream",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Int32,),task_.task,whichstream_.value,string(filename_),append_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    onesolutionsummary(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `whichsol :: Soltype`. Selects a solution.

Prints a short summary of a specified solution.
"""
function onesolutionsummary end
function onesolutionsummary(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)
  res = disable_sigint() do
    @msk_ccall( "onesolutionsummary",Int32,(Ptr{Nothing},Int32,Int32,),task_.task,whichstream_.value,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    optimizersummary(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Prints a short summary with optimizer statistics from last optimization.
"""
function optimizersummary end
function optimizersummary(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @msk_ccall( "optimizersummary",Int32,(Ptr{Nothing},Int32,),task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    trmcode = optimize(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `trmcode :: Rescode`. Is either OK or a termination response code.

Calls the optimizer. Depending on the problem type and the selected optimizer
this will call one of the optimizers in MOSEK. By default the interior point
optimizer will be selected for continuous problems.  The optimizer may be
selected manually by setting the parameter `MSK_IPAR_OPTIMIZER``.

.. msk_only:: c

   This function is equivalent to `Mosek.optimize` except for the handling of return values. This function returns errors on the left hand side. Warnings are not returned and termination codes are returned through the separate argument `trmcode`.

.. msk_only:: java and dotnet and python

   This function throws an exception if an error has occurred during the optimization, e.g the optimizer has run out of memory. Moreover it provides a termination code, relaying information about the conditions under which the optimizer terminated. For example `MSK_RES_TRM_MAX_ITERATIONS` indicates that the optimizer finished because it reached the maximum number of iterations specified by the user.
"""
function optimize end
function optimize(task_:: MSKtask)
  trmcode_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "optimizetrm",Int32,(Ptr{Nothing},Ptr{Int32},),task_.task,trmcode_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Rescode(trmcode_[1]))
end

"""
    primalrepair{T1,T2,T3,T4}(task:: MSKtask,wlc:: Vector{T1},wuc:: Vector{T2},wlx:: Vector{T3},wux:: Vector{T4})
    primalrepair(task_:: MSKtask,wlc_:: Vector{Float64},wuc_:: Vector{Float64},wlx_:: Vector{Float64},wux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `wlc :: Vector{Float64}`. Weights associated with relaxing lower bounds on the constraints.
* `wuc :: Vector{Float64}`. Weights associated with relaxing the upper bound on the constraints.
* `wlx :: Vector{Float64}`. Weights associated with relaxing the lower bounds of the variables.
* `wux :: Vector{Float64}`. Weights associated with relaxing the upper bounds of variables.

The function repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables where the adjustment
is computed as the minimal weighted sum of relaxations to the bounds on the constraints and variables. Observe the function only repairs the problem but does not
solve it. If an optimal solution is required the problem should be optimized after the repair.

The function is applicable to linear and conic problems possibly with integer variables.

Observe that when computing the minimal weighted relaxation the termination tolerance specified by the parameters of the task is employed. For instance
the parameter `MSK_IPAR_MIO_MODE`` can be used to make MOSEK ignore the integer constraints during the repair which usually leads to a much faster repair.
However, the drawback is of course that the repaired problem may not have an integer feasible solution.

Note the function modifies the task in place. If this is not desired, then apply the function to a cloned task.
"""
function primalrepair end
primalrepair(task:: MSKtask,wlc:: Vector{T1},wuc:: Vector{T2},wlx:: Vector{T3},wux:: Vector{T4}) where {T1,T2,T3,T4} = primalrepair(task,convert(Vector{Float64},wlc),convert(Vector{Float64},wuc),convert(Vector{Float64},wlx),convert(Vector{Float64},wux))
function primalrepair(task_:: MSKtask,wlc_:: Vector{Float64},wuc_:: Vector{Float64},wlx_:: Vector{Float64},wux_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(wlc_) < __tmp_var_0
    println("Array argument wlc is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = getnumvar(task_)
  if length(wlx_) < __tmp_var_2
    println("Array argument wlx is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = getnumcon(task_)
  if length(wuc_) < __tmp_var_1
    println("Array argument wuc is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = getnumvar(task_)
  if length(wux_) < __tmp_var_3
    println("Array argument wux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "primalrepair",Int32,(Ptr{Nothing},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,wlc_,wuc_,wlx_,wux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej) = primalsensitivity{T1,T3}(task:: MSKtask,subi:: Vector{T1},marki:: Vector{Mark},subj:: Vector{T3},markj:: Vector{Mark})
    (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej) = primalsensitivity(task_:: MSKtask,subi_:: Vector{Int32},marki_:: Vector{Mark},subj_:: Vector{Int32},markj_:: Vector{Mark})

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int32}`. Indexes of constraints to analyze.
* `marki :: Vector{Int32}`. Mark which constraint bounds to analyze.
* `subj :: Vector{Int32}`. Indexes of variables to analyze.
* `markj :: Vector{Int32}`. Mark which variable bounds to analyze.
* `leftpricei :: Vector{Float64}`. Left shadow price for constraints.
* `rightpricei :: Vector{Float64}`. Right shadow price for constraints.
* `leftrangei :: Vector{Float64}`. Left range for constraints.
* `rightrangei :: Vector{Float64}`. Right range for constraints.
* `leftpricej :: Vector{Float64}`. Left shadow price for variables.
* `rightpricej :: Vector{Float64}`. Right shadow price for variables.
* `leftrangej :: Vector{Float64}`. Left range for variables.
* `rightrangej :: Vector{Float64}`. Right range for variables.

Calculates sensitivity information for bounds on variables and constraints. For details on sensitivity 
analysis, the definitions of *shadow price* and *linearity interval* and an example see Section :ref:`doc.sensitivity_analysis`.

The type of sensitivity analysis to be performed (basis or optimal partition)
is controlled by the parameter `MSK_IPAR_SENSITIVITY_TYPE``.
"""
function primalsensitivity end
primalsensitivity(task:: MSKtask,subi:: Vector{T1},marki:: Vector{Mark},subj:: Vector{T3},markj:: Vector{Mark}) where {T1,T3} = primalsensitivity(task,convert(Vector{Int32},subi),marki,convert(Vector{Int32},subj),markj)
function primalsensitivity(task_:: MSKtask,subi_:: Vector{Int32},marki_:: Vector{Mark},subj_:: Vector{Int32},markj_:: Vector{Mark})
  marki_i32 = Int32[item.value for item in marki_]
  markj_i32 = Int32[item.value for item in markj_]
  numi_ = minimum([ length(subi_),length(marki_) ])
  numj_ = minimum([ length(subj_),length(markj_) ])
  __tmp_var_0 = (numi_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  leftpricei_ = __tmp_var_1
  __tmp_var_8 = (numj_)
  __tmp_var_9 = zeros(Float64,__tmp_var_8)
  leftpricej_ = __tmp_var_9
  __tmp_var_4 = (numi_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  leftrangei_ = __tmp_var_5
  __tmp_var_12 = (numj_)
  __tmp_var_13 = zeros(Float64,__tmp_var_12)
  leftrangej_ = __tmp_var_13
  __tmp_var_2 = (numi_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  rightpricei_ = __tmp_var_3
  __tmp_var_10 = (numj_)
  __tmp_var_11 = zeros(Float64,__tmp_var_10)
  rightpricej_ = __tmp_var_11
  __tmp_var_6 = (numi_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  rightrangei_ = __tmp_var_7
  __tmp_var_14 = (numj_)
  __tmp_var_15 = zeros(Float64,__tmp_var_14)
  rightrangej_ = __tmp_var_15
  res = disable_sigint() do
    @msk_ccall( "primalsensitivity",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,numi_,subi_ .- Int32(1),marki_,numj_,subj_ .- Int32(1),markj_,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9,__tmp_var_11,__tmp_var_13,__tmp_var_15)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9,__tmp_var_11,__tmp_var_13,__tmp_var_15)
end

"""
    printdata{T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15}(task:: MSKtask,whichstream:: Streamtype,firsti:: T2,lasti:: T3,firstj:: T4,lastj:: T5,firstk:: T6,lastk:: T7,c:: T8,qo:: T9,a:: T10,qc:: T11,bc:: T12,bx:: T13,vartype:: T14,cones:: T15)
    printdata(task_:: MSKtask,whichstream_:: Streamtype,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32,firstk_:: Int32,lastk_:: Int32,c_:: Int32,qo_:: Int32,a_:: Int32,qc_:: Int32,bc_:: Int32,bx_:: Int32,vartype_:: Int32,cones_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `firsti :: Int32`. Index of first constraint for which data should be printed.
* `lasti :: Int32`. Index of last constraint plus 1 for which data should be printed.
* `firstj :: Int32`. Index of first variable for which data should be printed.
* `lastj :: Int32`. Index of last variable plus 1 for which data should be printed.
* `firstk :: Int32`. Index of first cone for which data should be printed.
* `lastk :: Int32`. Index of last cone plus 1 for which data should be printed.
* `c :: Int32`. If non-zero the linear objective terms are printed.
* `qo :: Int32`. If non-zero the quadratic objective terms are printed.
* `a :: Int32`. If non-zero the linear constraint matrix is printed.
* `qc :: Int32`. If non-zero q'th     quadratic constraint terms are printed for the relevant constraints.
* `bc :: Int32`. If non-zero the constraint bounds are printed.
* `bx :: Int32`. If non-zero the variable bounds are printed.
* `vartype :: Int32`. If non-zero the variable types are printed.
* `cones :: Int32`. If non-zero the  conic data is printed.

Prints a part of the problem data to a stream. This function
is normally used for debugging purposes only, e.g. to verify
that the correct data has been inputted.
"""
function printdata end
printdata(task:: MSKtask,whichstream:: Streamtype,firsti:: T2,lasti:: T3,firstj:: T4,lastj:: T5,firstk:: T6,lastk:: T7,c:: T8,qo:: T9,a:: T10,qc:: T11,bc:: T12,bx:: T13,vartype:: T14,cones:: T15) where {T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15} = printdata(task,whichstream,Int32(firsti),Int32(lasti),Int32(firstj),Int32(lastj),Int32(firstk),Int32(lastk),Int32(c),Int32(qo),Int32(a),Int32(qc),Int32(bc),Int32(bx),Int32(vartype),Int32(cones))
function printdata(task_:: MSKtask,whichstream_:: Streamtype,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32,firstk_:: Int32,lastk_:: Int32,c_:: Int32,qo_:: Int32,a_:: Int32,qc_:: Int32,bc_:: Int32,bx_:: Int32,vartype_:: Int32,cones_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "printdata",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,Int32,),task_.task,whichstream_.value,firsti_-1,lasti_-1,firstj_-1,lastj_-1,firstk_-1,lastk_-1,c_,qo_,a_,qc_,bc_,bx_,vartype_,cones_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    printparam(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.

Prints the current parameter settings to the message stream.
"""
function printparam end
function printparam(task_:: MSKtask)
  res = disable_sigint() do
    @msk_ccall( "printparam",Int32,(Ptr{Nothing},),task_.task)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putacol{T1,T2,T3}(task:: MSKtask,j:: T1,subj:: Vector{T2},valj:: Vector{T3})
    putacol(task_:: MSKtask,j_:: Int32,subj_:: Vector{Int32},valj_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Column index.
* `subj :: Vector{Int32}`. Row indexes of non-zero values in column.
* `valj :: Vector{Float64}`. New non-zero values of column.

Change one column of the linear constraint matrix ``A``. Resets all the elements in column ``j`` to zero and then sets

```math
 a_{\\mathtt{subj}[k],\\mathtt{j}} = \\mathtt{valj}[k], \\mathcal{C}_q k=0,\\ldots,\\mathtt{nzj}-1.
```

"""
function putacol end
putacol(task:: MSKtask,j:: T1,subj:: Vector{T2},valj:: Vector{T3}) where {T1,T2,T3} = putacol(task,Int32(j),convert(Vector{Int32},subj),convert(Vector{Float64},valj))
function putacol(task_:: MSKtask,j_:: Int32,subj_:: Vector{Int32},valj_:: Vector{Float64})
  nzj_ = minimum([ length(subj_),length(valj_) ])
  res = disable_sigint() do
    @msk_ccall( "putacol",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,j_-1,nzj_,subj_ .- Int32(1),valj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putacollist{T1,T2,T3,T4,T5}(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5})
    putacollist{T1}(task:: MSKtask,sub:: Vector{T1},A:: SparseMatrixCSC{Float64})
    putacollist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. Indexes of columns that should be replaced.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the columns.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the columns.
* `asub :: Vector{Int32}`. Row indexes
* `aval :: Vector{Float64}`. Coefficient values.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

Change a set of columns in the linear constraint matrix ``A`` with data in sparse triplet format. The requested columns are set to zero and then updated with:

```math
\\begin{array}{rl}
  \\mathtt{for} & i=1,\\ldots,+1{num}\\\\
              & a_{\\mathtt{asub}[k],\\mathtt{sub}[i]} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1. 
\\end{array}
```

"""
function putacollist end
putacollist(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5}) where {T1,T2,T3,T4,T5} = putacollist(task,convert(Vector{Int32},sub),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putacollist(task:: MSKtask,sub:: Vector{T1},A:: SparseMatrixCSC{Float64}) where {T1}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacollist(task,sub,ptrb,ptre,asub,aval)
end
function putacollist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(ptrb_),length(ptre_) ])
  res = disable_sigint() do
    @msk_ccall( "putacollist64",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),task_.task,num_,sub_ .- Int32(1),ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putacolslice{T1,T2,T3,T4,T5,T6}(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6})
    putacolslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2,A:: SparseMatrixCSC{Float64})
    putacolslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First column in the slice.
* `last :: Int32`. Last column plus one in the slice.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the columns.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the columns.
* `asub :: Vector{Int32}`. Row indexes
* `aval :: Vector{Float64}`. Coefficient values.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

Change a slice of columns in the linear constraint matrix ``A`` with data in sparse triplet format. The requested columns are set to zero and then updated with: 

```math
\\begin{array}{rl}
  \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1\\\\
              & a_{\\mathtt{asub}[k],i} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1. 
\\end{array}
```

"""
function putacolslice end
putacolslice(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putacolslice(task,Int32(first),Int32(last),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putacolslice(task:: MSKtask,first:: T1,last:: T2,A:: SparseMatrixCSC{Float64}) where {T1,T2}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacolslice(task,first,last,ptrb,ptre,asub,aval)
end
function putacolslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  res = disable_sigint() do
    @msk_ccall( "putacolslice64",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),task_.task,first_-1,last_-1,ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putaij{T1,T2,T3}(task:: MSKtask,i:: T1,j:: T2,aij:: T3)
    putaij(task_:: MSKtask,i_:: Int32,j_:: Int32,aij_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Constraint (row) index.
* `j :: Int32`. Variable (column) index.
* `aij :: Float64`. New coefficient.

Changes a coefficient in the linear coefficient matrix ``A`` using the method

```math
 a_{i,j} = \\mathtt{aij}.
```

"""
function putaij end
putaij(task:: MSKtask,i:: T1,j:: T2,aij:: T3) where {T1,T2,T3} = putaij(task,Int32(i),Int32(j),Float64(aij))
function putaij(task_:: MSKtask,i_:: Int32,j_:: Int32,aij_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putaij",Int32,(Ptr{Nothing},Int32,Int32,Float64,),task_.task,i_-1,j_-1,aij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putaijlist{T1,T2,T3}(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},valij:: Vector{T3})
    putaijlist(task_:: MSKtask,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int32}`. Constraint (row) indices.
* `subj :: Vector{Int32}`. Variable (column) indices.
* `valij :: Vector{Float64}`. New coefficient values.

Changes one or more coefficients in ``A`` using the method

```math
 a_{\\mathtt{subi[k]},\\mathtt{subj[k]}} = \\mathtt{valij[k]}, \\mathcal{C}_q k=1,\\ldots,+1{num}.
```
Duplicates are not allowed.
"""
function putaijlist end
putaijlist(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},valij:: Vector{T3}) where {T1,T2,T3} = putaijlist(task,convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Float64},valij))
function putaijlist(task_:: MSKtask,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})
  num_ = minimum([ length(subi_),length(subj_),length(valij_) ])
  res = disable_sigint() do
    @msk_ccall( "putaijlist64",Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,num_,subi_ .- Int32(1),subj_ .- Int32(1),valij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putarow{T1,T2,T3}(task:: MSKtask,i:: T1,subi:: Vector{T2},vali:: Vector{T3})
    putarow(task_:: MSKtask,i_:: Int32,subi_:: Vector{Int32},vali_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index.
* `subi :: Vector{Int32}`. Column indexes of non-zero values in row.
* `vali :: Vector{Float64}`. New non-zero values of row.

Change one row of the linear constraint matrix ``A``. Resets all the elements in row ``i`` to zero and then sets

```math
 a_{\\mathtt{i},\\mathtt{subi}[k]} = \\mathtt{vali}[k], \\mathcal{C}_q k=0,\\ldots,\\mathtt{nzi}-1.
```

"""
function putarow end
putarow(task:: MSKtask,i:: T1,subi:: Vector{T2},vali:: Vector{T3}) where {T1,T2,T3} = putarow(task,Int32(i),convert(Vector{Int32},subi),convert(Vector{Float64},vali))
function putarow(task_:: MSKtask,i_:: Int32,subi_:: Vector{Int32},vali_:: Vector{Float64})
  nzi_ = minimum([ length(subi_),length(vali_) ])
  res = disable_sigint() do
    @msk_ccall( "putarow",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},),task_.task,i_-1,nzi_,subi_ .- Int32(1),vali_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putarowlist{T1,T2,T3,T4,T5}(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5})
    putarowlist{T1}(task:: MSKtask,sub:: Vector{T1},At:: SparseMatrixCSC{Float64})
    putarowlist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. Indexes of rows or columns that should be replaced.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the rows.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the rows.
* `asub :: Vector{Int32}`. Variable indexes.
* `aval :: Vector{Float64}`. Coefficient values.
* `At :: SparseMatrixCSC{Float64}`. Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced

Change a set of rows in the linear constraint matrix ``A`` with data in sparse triplet format. The requested rows are set to zero and then updated with:  

```math
\\begin{array}{rl}
  \\mathtt{for} & i=1,\\ldots,+1{num} \\\\
               & a_{\\mathtt{sub}[i],\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1. 
\\end{array}
```

"""
function putarowlist end
putarowlist(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5}) where {T1,T2,T3,T4,T5} = putarowlist(task,convert(Vector{Int32},sub),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putarowlist(task:: MSKtask,sub:: Vector{T1},At:: SparseMatrixCSC{Float64}) where {T1}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowlist(task,sub,ptrb,ptre,asub,aval)
end
function putarowlist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(ptrb_),length(ptre_) ])
  res = disable_sigint() do
    @msk_ccall( "putarowlist64",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),task_.task,num_,sub_ .- Int32(1),ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putarowslice{T1,T2,T3,T4,T5,T6}(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6})
    putarowslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2,At:: SparseMatrixCSC{Float64})
    putarowslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First row in the slice.
* `last :: Int32`. Last row plus one in the slice.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the rows.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the rows.
* `asub :: Vector{Int32}`. Column indexes of new elements.
* `aval :: Vector{Float64}`. Coefficient values.
* `At :: SparseMatrixCSC{Float64}`. Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced

Change a slice of rows in the linear constraint matrix ``A`` with data in sparse triplet format. The requested columns are set to zero and then updated with:

```math
\\begin{array}{rl}
  \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1 \\\\
               & a_{\\mathtt{sub}[i],\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1. 
\\end{array}
```

"""
function putarowslice end
putarowslice(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putarowslice(task,Int32(first),Int32(last),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putarowslice(task:: MSKtask,first:: T1,last:: T2,At:: SparseMatrixCSC{Float64}) where {T1,T2}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowslice(task,first,last,ptrb,ptre,asub,aval)
end
function putarowslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(ptrb_) < __tmp_var_0
    println("Array argument ptrb is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = ((last_) - (first_))
  if length(ptre_) < __tmp_var_1
    println("Array argument ptre is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putarowslice64",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},),task_.task,first_-1,last_-1,ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarablocktriplet{T1,T2,T3,T4,T5,T6}(task:: MSKtask,num:: T1,subi:: Vector{T2},subj:: Vector{T3},subk:: Vector{T4},subl:: Vector{T5},valijkl:: Vector{T6})
    putbarablocktriplet(task_:: MSKtask,num_:: Int64,subi_:: Vector{Int32},subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valijkl_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subi :: Vector{Int32}`. Constraint index.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valijkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Inputs the ``\\bar A`` matrix in block triplet form.
"""
function putbarablocktriplet end
putbarablocktriplet(task:: MSKtask,num:: T1,subi:: Vector{T2},subj:: Vector{T3},subk:: Vector{T4},subl:: Vector{T5},valijkl:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putbarablocktriplet(task,Int64(num),convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Int32},subk),convert(Vector{Int32},subl),convert(Vector{Float64},valijkl))
function putbarablocktriplet(task_:: MSKtask,num_:: Int64,subi_:: Vector{Int32},subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valijkl_:: Vector{Float64})
  __tmp_var_0 = (num_)
  if length(subi_) < __tmp_var_0
    println("Array argument subi is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = (num_)
  if length(subj_) < __tmp_var_1
    println("Array argument subj is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = (num_)
  if length(subk_) < __tmp_var_2
    println("Array argument subk is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = (num_)
  if length(subl_) < __tmp_var_3
    println("Array argument subl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_4 = (num_)
  if length(valijkl_) < __tmp_var_4
    println("Array argument valijkl is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putbarablocktriplet",Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,num_,subi_ .- Int32(1),subj_ .- Int32(1),subk_ .- Int32(1),subl_ .- Int32(1),valijkl_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbaraij{T1,T2,T3,T4}(task:: MSKtask,i:: T1,j:: T2,sub:: Vector{T3},weights:: Vector{T4})
    putbaraij(task_:: MSKtask,i_:: Int32,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index of barA.
* `j :: Int32`. Column index of barA.
* `sub :: Vector{Int64}`. Element indexes in matrix storage.
* `weights :: Vector{Float64}`. Weights in the weighted sum.

This function sets one element in the ``\\bar A`` matrix.

Each element in the ``\\bar A`` matrix is a weighted sum of
symmetric matrices from the symmetric matrix storage ``E``, so
``\\bar A_{ij}`` is a symmetric matrix. By default all elements in
``\\bar A`` are 0, so only non-zero elements need be added.
Setting the same element again will overwrite the earlier entry. 

The symmetric matrices from ``E`` are defined separately
using the function `Mosek.appendsparsesymmat`.
"""
function putbaraij end
putbaraij(task:: MSKtask,i:: T1,j:: T2,sub:: Vector{T3},weights:: Vector{T4}) where {T1,T2,T3,T4} = putbaraij(task,Int32(i),Int32(j),convert(Vector{Int64},sub),convert(Vector{Float64},weights))
function putbaraij(task_:: MSKtask,i_:: Int32,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(weights_) ])
  res = disable_sigint() do
    @msk_ccall( "putbaraij",Int32,(Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Float64},),task_.task,i_-1,j_-1,num_,sub_ .- Int32(1),weights_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarcblocktriplet{T1,T2,T3,T4,T5}(task:: MSKtask,num:: T1,subj:: Vector{T2},subk:: Vector{T3},subl:: Vector{T4},valjkl:: Vector{T5})
    putbarcblocktriplet(task_:: MSKtask,num_:: Int64,subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valjkl_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valjkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Inputs the ``\\bar C`` matrix in block triplet form.
"""
function putbarcblocktriplet end
putbarcblocktriplet(task:: MSKtask,num:: T1,subj:: Vector{T2},subk:: Vector{T3},subl:: Vector{T4},valjkl:: Vector{T5}) where {T1,T2,T3,T4,T5} = putbarcblocktriplet(task,Int64(num),convert(Vector{Int32},subj),convert(Vector{Int32},subk),convert(Vector{Int32},subl),convert(Vector{Float64},valjkl))
function putbarcblocktriplet(task_:: MSKtask,num_:: Int64,subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valjkl_:: Vector{Float64})
  __tmp_var_0 = (num_)
  if length(subj_) < __tmp_var_0
    println("Array argument subj is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = (num_)
  if length(subk_) < __tmp_var_1
    println("Array argument subk is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = (num_)
  if length(subl_) < __tmp_var_2
    println("Array argument subl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = (num_)
  if length(valjkl_) < __tmp_var_3
    println("Array argument valjkl is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putbarcblocktriplet",Int32,(Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,num_,subj_ .- Int32(1),subk_ .- Int32(1),subl_ .- Int32(1),valjkl_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarcj{T1,T2,T3}(task:: MSKtask,j:: T1,sub:: Vector{T2},weights:: Vector{T3})
    putbarcj(task_:: MSKtask,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the element in barc` that should be changed.
* `sub :: Vector{Int64}`. sub is list of indexes of those symmetric matrices appearing in sum.
* `weights :: Vector{Float64}`. The weights of the terms in the weighted sum.

This function sets one entry in the ``\\bar C`` vector.

Each element in the ``\\bar C`` vector is a weighted sum of
symmetric matrices from the symmetric matrix storage ``E``, so
``\\bar C_{j}`` is a symmetric matrix. By default all elements in
``\\bar C`` are 0, so only non-zero elements need be added.
Setting the same element again will overwrite the earlier entry. 

The symmetric matrices from ``E`` are defined separately
using the function `Mosek.appendsparsesymmat`.
"""
function putbarcj end
putbarcj(task:: MSKtask,j:: T1,sub:: Vector{T2},weights:: Vector{T3}) where {T1,T2,T3} = putbarcj(task,Int32(j),convert(Vector{Int64},sub),convert(Vector{Float64},weights))
function putbarcj(task_:: MSKtask,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(weights_) ])
  res = disable_sigint() do
    @msk_ccall( "putbarcj",Int32,(Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},),task_.task,j_-1,num_,sub_ .- Int32(1),weights_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarsj{T2,T3}(task:: MSKtask,whichsol:: Soltype,j:: T2,barsj:: Vector{T3})
    putbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barsj_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barsj :: Vector{Float64}`. Value of the j'th variable of barx.

Sets the dual solution for a semidefinite variable.
"""
function putbarsj end
putbarsj(task:: MSKtask,whichsol:: Soltype,j:: T2,barsj:: Vector{T3}) where {T2,T3} = putbarsj(task,whichsol,Int32(j),convert(Vector{Float64},barsj))
function putbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barsj_:: Vector{Float64})
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  if length(barsj_) < __tmp_var_0
    println("Array argument barsj is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putbarsj",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,j_-1,barsj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarvarname{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
    putbarvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `name :: String`. The variable name.

Sets the name of a semidefinite variable.
"""
function putbarvarname end
putbarvarname(task:: MSKtask,j:: T1,name:: AbstractString) where {T1} = putbarvarname(task,Int32(j),name)
function putbarvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putbarvarname",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,j_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarxj{T2,T3}(task:: MSKtask,whichsol:: Soltype,j:: T2,barxj:: Vector{T3})
    putbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barxj_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barxj :: Vector{Float64}`. Value of the j'th variable of barx.

Sets the primal solution for a semidefinite variable.
"""
function putbarxj end
putbarxj(task:: MSKtask,whichsol:: Soltype,j:: T2,barxj:: Vector{T3}) where {T2,T3} = putbarxj(task,whichsol,Int32(j),convert(Vector{Float64},barxj))
function putbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barxj_:: Vector{Float64})
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  if length(barxj_) < __tmp_var_0
    println("Array argument barxj is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putbarxj",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,j_-1,barxj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbound{T2,T4,T5}(task:: MSKtask,accmode:: Accmode,i:: T2,bk:: Boundkey,bl:: T4,bu:: T5)
    putbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines whether the bound for a constraint or a variable is changed.
* `i :: Int32`. Index of the constraint or variable.
* `bk :: Boundkey`. New bound key.
* `bl :: Float64`. New lower bound.
* `bu :: Float64`. New upper bound.

Changes the bound for either one constraint or one variable.
"""
function putbound end
putbound(task:: MSKtask,accmode:: Accmode,i:: T2,bk:: Boundkey,bl:: T4,bu:: T5) where {T2,T4,T5} = putbound(task,accmode,Int32(i),bk,Float64(bl),Float64(bu))
function putbound(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putbound",Int32,(Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,),task_.task,accmode_.value,i_-1,bk_.value,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putboundlist{T2,T4,T5}(task:: MSKtask,accmode:: Accmode,sub:: Vector{T2},bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5})
    putboundlist(task_:: MSKtask,accmode_:: Accmode,sub_:: Vector{Int32},bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines whether to access bounds on variables or constraints.
* `sub :: Vector{Int32}`. Subscripts of the constraints or variables that should be changed.
* `bk :: Vector{Int32}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Changes the bounds of constraints or variables.
"""
function putboundlist end
putboundlist(task:: MSKtask,accmode:: Accmode,sub:: Vector{T2},bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5}) where {T2,T4,T5} = putboundlist(task,accmode,convert(Vector{Int32},sub),bk,convert(Vector{Float64},bl),convert(Vector{Float64},bu))
function putboundlist(task_:: MSKtask,accmode_:: Accmode,sub_:: Vector{Int32},bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})
  bk_i32 = Int32[item.value for item in bk_]
  num_ = minimum([ length(sub_),length(bk_),length(bl_),length(bu_) ])
  res = disable_sigint() do
    @msk_ccall( "putboundlist",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,accmode_.value,num_,sub_ .- Int32(1),bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putboundslice{T2,T3,T5,T6}(task:: MSKtask,con:: Accmode,first:: T2,last:: T3,bk:: Vector{Boundkey},bl:: Vector{T5},bu:: Vector{T6})
    putboundslice(task_:: MSKtask,con_:: Accmode,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `con :: Accmode`. Determines whether variables or constraints are modified.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Int32}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Changes the bounds for a slice of constraints or variables.
"""
function putboundslice end
putboundslice(task:: MSKtask,con:: Accmode,first:: T2,last:: T3,bk:: Vector{Boundkey},bl:: Vector{T5},bu:: Vector{T6}) where {T2,T3,T5,T6} = putboundslice(task,con,Int32(first),Int32(last),bk,convert(Vector{Float64},bl),convert(Vector{Float64},bu))
function putboundslice(task_:: MSKtask,con_:: Accmode,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(bk_) < __tmp_var_0
    println("Array argument bk is not long enough")
    throw(BoundsError())
  end
  bk_i32 = Int32[item.value for item in bk_]
  __tmp_var_1 = ((last_) - (first_))
  if length(bl_) < __tmp_var_1
    println("Array argument bl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = ((last_) - (first_))
  if length(bu_) < __tmp_var_2
    println("Array argument bu is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putboundslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,con_.value,first_-1,last_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcfix{T1}(task:: MSKtask,cfix:: T1)
    putcfix(task_:: MSKtask,cfix_:: Float64)

* `task :: MSKtask`. An optimization task.
* `cfix :: Float64`. Fixed term in the objective.

Replaces the fixed term in the objective by a new one.
"""
function putcfix end
putcfix(task:: MSKtask,cfix:: T1) where {T1} = putcfix(task,Float64(cfix))
function putcfix(task_:: MSKtask,cfix_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putcfix",Int32,(Ptr{Nothing},Float64,),task_.task,cfix_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcj{T1,T2}(task:: MSKtask,j:: T1,cj:: T2)
    putcj(task_:: MSKtask,j_:: Int32,cj_:: Float64)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable whose objective coefficient should be changed.
* `cj :: Float64`. New coefficient value.

Modifies one coefficient in the linear objective vector ``c``, i.e.

```math
 c_{\\mathtt{j}} = \\mathtt{cj}.
```
If the absolute value exceeds `MSK_DPAR_DATA_TOL_C_HUGE`` an error is generated. If the absolute value exceeds `MSK_DPAR_DATA_TOL_CJ_LARGE``, a warning is generated, but the coefficient is inputted as specified.
"""
function putcj end
putcj(task:: MSKtask,j:: T1,cj:: T2) where {T1,T2} = putcj(task,Int32(j),Float64(cj))
function putcj(task_:: MSKtask,j_:: Int32,cj_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putcj",Int32,(Ptr{Nothing},Int32,Float64,),task_.task,j_-1,cj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putclist{T1,T2}(task:: MSKtask,subj:: Vector{T1},val:: Vector{T2})
    putclist(task_:: MSKtask,subj_:: Vector{Int32},val_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. Indices of variables for which objective coefficients should be changed.
* `val :: Vector{Float64}`. New numerical values for the objective coefficients that should be modified.

Modifies the coefficients in the linear term ``c`` in the objective using the principle

```math
 c_{\\mathtt{subj[t]}} = \\mathtt{val[t]}, \\mathcal{C}_q t=1,\\ldots,+1{num}.
```
If a variable index is specified multiple times in `subj` only the last entry is used. Data checks are performed as in `Mosek.putcj`.
"""
function putclist end
putclist(task:: MSKtask,subj:: Vector{T1},val:: Vector{T2}) where {T1,T2} = putclist(task,convert(Vector{Int32},subj),convert(Vector{Float64},val))
function putclist(task_:: MSKtask,subj_:: Vector{Int32},val_:: Vector{Float64})
  num_ = minimum([ length(subj_),length(val_) ])
  res = disable_sigint() do
    @msk_ccall( "putclist",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},),task_.task,num_,subj_ .- Int32(1),val_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconbound{T1,T3,T4}(task:: MSKtask,i:: T1,bk:: Boundkey,bl:: T3,bu:: T4)
    putconbound(task_:: MSKtask,i_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `bk :: Boundkey`. New bound key.
* `bl :: Float64`. New lower bound.
* `bu :: Float64`. New upper bound.

Changes the bounds for one constraint.

If the bound value specified is numerically larger than `MSK_DPAR_DATA_TOL_BOUND_INF`` it is considered infinite and the bound key is
changed accordingly. If a bound value is numerically larger than `MSK_DPAR_DATA_TOL_BOUND_WRN``, a warning will be displayed, but the bound is inputted as specified.
"""
function putconbound end
putconbound(task:: MSKtask,i:: T1,bk:: Boundkey,bl:: T3,bu:: T4) where {T1,T3,T4} = putconbound(task,Int32(i),bk,Float64(bl),Float64(bu))
function putconbound(task_:: MSKtask,i_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putconbound",Int32,(Ptr{Nothing},Int32,Int32,Float64,Float64,),task_.task,i_-1,bk_.value,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconboundlist{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bk:: Vector{Boundkey},bl:: Vector{T3},bu:: Vector{T4})
    putconboundlist(task_:: MSKtask,sub_:: Vector{Int32},bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. List of constraint indexes.
* `bk :: Vector{Int32}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Changes the bounds for a list of constraints. If multiple bound changes are specified for a constraint, then only the last change takes effect. Data checks are performed as in `Mosek.putconbound`.
"""
function putconboundlist end
putconboundlist(task:: MSKtask,sub:: Vector{T1},bk:: Vector{Boundkey},bl:: Vector{T3},bu:: Vector{T4}) where {T1,T3,T4} = putconboundlist(task,convert(Vector{Int32},sub),bk,convert(Vector{Float64},bl),convert(Vector{Float64},bu))
function putconboundlist(task_:: MSKtask,sub_:: Vector{Int32},bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})
  bk_i32 = Int32[item.value for item in bk_]
  num_ = minimum([ length(sub_),length(bk_),length(bl_),length(bu_) ])
  res = disable_sigint() do
    @msk_ccall( "putconboundlist",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,num_,sub_ .- Int32(1),bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconboundslice{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5})
    putconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Int32}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Changes the bounds for a slice of the constraints. Data checks are performed as in `Mosek.putconbound`.
"""
function putconboundslice end
putconboundslice(task:: MSKtask,first:: T1,last:: T2,bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5}) where {T1,T2,T4,T5} = putconboundslice(task,Int32(first),Int32(last),bk,convert(Vector{Float64},bl),convert(Vector{Float64},bu))
function putconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(bk_) < __tmp_var_0
    println("Array argument bk is not long enough")
    throw(BoundsError())
  end
  bk_i32 = Int32[item.value for item in bk_]
  __tmp_var_1 = ((last_) - (first_))
  if length(bl_) < __tmp_var_1
    println("Array argument bl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = ((last_) - (first_))
  if length(bu_) < __tmp_var_2
    println("Array argument bu is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putconboundslice",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,first_-1,last_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcone{T1,T3,T4}(task:: MSKtask,k:: T1,ct:: Conetype,conepar:: T3,submem:: Vector{T4})
    putcone(task_:: MSKtask,k_:: Int32,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. This argument is currently not used. It can be set to 0
* `submem :: Vector{Int32}`. Variable subscripts of the members in the cone.

Replaces a conic constraint.
"""
function putcone end
putcone(task:: MSKtask,k:: T1,ct:: Conetype,conepar:: T3,submem:: Vector{T4}) where {T1,T3,T4} = putcone(task,Int32(k),ct,Float64(conepar),convert(Vector{Int32},submem))
function putcone(task_:: MSKtask,k_:: Int32,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})
  nummem_ = minimum([ length(submem_) ])
  res = disable_sigint() do
    @msk_ccall( "putcone",Int32,(Ptr{Nothing},Int32,Int32,Float64,Int32,Ptr{Int32},),task_.task,k_-1,ct_.value,conepar_,nummem_,submem_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconename{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
    putconename(task_:: MSKtask,j_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the cone.
* `name :: String`. The name of the cone.

Sets the name of a cone.
"""
function putconename end
putconename(task:: MSKtask,j:: T1,name:: AbstractString) where {T1} = putconename(task,Int32(j),name)
function putconename(task_:: MSKtask,j_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putconename",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,j_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconname{T1}(task:: MSKtask,i:: T1,name:: AbstractString)
    putconname(task_:: MSKtask,i_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `name :: String`. The name of the constraint.

Sets the name of a constraint.
"""
function putconname end
putconname(task:: MSKtask,i:: T1,name:: AbstractString) where {T1} = putconname(task,Int32(i),name)
function putconname(task_:: MSKtask,i_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putconname",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,i_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcslice{T1,T2,T3}(task:: MSKtask,first:: T1,last:: T2,slice:: Vector{T3})
    putcslice(task_:: MSKtask,first_:: Int32,last_:: Int32,slice_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First element in the slice of c.
* `last :: Int32`. Last element plus 1 of the slice in c to be changed.
* `slice :: Vector{Float64}`. New numerical values for the objective coefficients that should be modified.

Modifies a slice in the linear term ``c`` in the objective using the principle

```math
 c_{\\mathtt{j}} = \\mathtt{slice[j-first]}, \\mathcal{C}_q j=first,..,+1{last}
```
Data checks are performed as in `Mosek.putcj`.
"""
function putcslice end
putcslice(task:: MSKtask,first:: T1,last:: T2,slice:: Vector{T3}) where {T1,T2,T3} = putcslice(task,Int32(first),Int32(last),convert(Vector{Float64},slice))
function putcslice(task_:: MSKtask,first_:: Int32,last_:: Int32,slice_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(slice_) < __tmp_var_0
    println("Array argument slice is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putcslice",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Float64},),task_.task,first_-1,last_-1,slice_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putdouparam{T2}(task:: MSKtask,param:: Dparam,parvalue:: T2)
    putdouparam(task_:: MSKtask,param_:: Dparam,parvalue_:: Float64)

* `task :: MSKtask`. An optimization task.
* `param :: Dparam`. Which parameter.
* `parvalue :: Float64`. Parameter value.

Sets the value of a double parameter.
"""
function putdouparam end
putdouparam(task:: MSKtask,param:: Dparam,parvalue:: T2) where {T2} = putdouparam(task,param,Float64(parvalue))
function putdouparam(task_:: MSKtask,param_:: Dparam,parvalue_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putdouparam",Int32,(Ptr{Nothing},Int32,Float64,),task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putintparam{T2}(task:: MSKtask,param:: Iparam,parvalue:: T2)
    putintparam(task_:: MSKtask,param_:: Iparam,parvalue_:: Int32)

* `task :: MSKtask`. An optimization task.
* `param :: Iparam`. Which parameter.
* `parvalue :: Int32`. Parameter value.

Sets the value of an integer parameter.

.. msk_only:: java

   Please notice that some parameters take values that are defined in Enum
   classes. This function accepts only integer values, so to use e.g. the value
   `MSK_ON`, is necessary to use the member `.value`. For example: ::

       task.putintparam(mosek.iparam.opf_write_problem, mosek.onoffkey.on.value)
"""
function putintparam end
putintparam(task:: MSKtask,param:: Iparam,parvalue:: T2) where {T2} = putintparam(task,param,Int32(parvalue))
function putintparam(task_:: MSKtask,param_:: Iparam,parvalue_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putintparam",Int32,(Ptr{Nothing},Int32,Int32,),task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumanz{T1}(task:: MSKtask,maxnumanz:: T1)
    putmaxnumanz(task_:: MSKtask,maxnumanz_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumanz :: Int64`. New size of the storage reserved for storing the linear coefficient matrix.

Sets the number of preallocated non-zero entries in ``A``. 

MOSEK stores only the non-zero elements in the linear coefficient matrix ``A`` and it 
cannot predict how much storage is required to store ``A``. Using this
function it is possible to specify the number of non-zeros to preallocate for
storing ``A``.

If the number of non-zeros in the problem is known, it is a good idea to set
`maxnumanz` slightly larger than this number, otherwise a rough estimate can
be used. In general, if ``A`` is inputted in many small chunks, setting
this value may speed up the data input phase.

It is not mandatory to call this function, since MOSEK will reallocate
internal structures whenever it is necessary.

The function call has no effect if both `maxnumcon` and `maxnumvar` are zero.
"""
function putmaxnumanz end
putmaxnumanz(task:: MSKtask,maxnumanz:: T1) where {T1} = putmaxnumanz(task,Int64(maxnumanz))
function putmaxnumanz(task_:: MSKtask,maxnumanz_:: Int64)
  res = disable_sigint() do
    @msk_ccall( "putmaxnumanz",Int32,(Ptr{Nothing},Int64,),task_.task,maxnumanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumbarvar{T1}(task:: MSKtask,maxnumbarvar:: T1)
    putmaxnumbarvar(task_:: MSKtask,maxnumbarvar_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumbarvar :: Int32`. Number of preallocated symmetric matrix variables.

Sets the number of preallocated symmetric matrix variables in the optimization
task. When this number of variables is reached MOSEK will automatically
allocate more space for variables.

It is not mandatory to call this function. It only gives a
hint about the amount of data to preallocate for efficiency reasons.

Please note that `maxnumbarvar` must be larger than the current number of
symmetric matrix variables in the task.
"""
function putmaxnumbarvar end
putmaxnumbarvar(task:: MSKtask,maxnumbarvar:: T1) where {T1} = putmaxnumbarvar(task,Int32(maxnumbarvar))
function putmaxnumbarvar(task_:: MSKtask,maxnumbarvar_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putmaxnumbarvar",Int32,(Ptr{Nothing},Int32,),task_.task,maxnumbarvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumcon{T1}(task:: MSKtask,maxnumcon:: T1)
    putmaxnumcon(task_:: MSKtask,maxnumcon_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. Number of preallocated constraints in the optimization task.

Sets the number of preallocated constraints in the optimization task. When this
number of constraints is reached MOSEK will automatically allocate more space
for constraints.

It is never mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.

Please note that `maxnumcon` must be larger than the current number of
constraints in the task.
"""
function putmaxnumcon end
putmaxnumcon(task:: MSKtask,maxnumcon:: T1) where {T1} = putmaxnumcon(task,Int32(maxnumcon))
function putmaxnumcon(task_:: MSKtask,maxnumcon_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putmaxnumcon",Int32,(Ptr{Nothing},Int32,),task_.task,maxnumcon_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumcone{T1}(task:: MSKtask,maxnumcone:: T1)
    putmaxnumcone(task_:: MSKtask,maxnumcone_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumcone :: Int32`. Number of preallocated conic constraints in the optimization task.

Sets the number of preallocated conic constraints in the optimization task.
When this number of conic constraints is reached MOSEK will automatically
allocate more space for conic constraints.

It is not mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.

Please note that `maxnumcon` must be larger than the current number of conic 
constraints in the task.
"""
function putmaxnumcone end
putmaxnumcone(task:: MSKtask,maxnumcone:: T1) where {T1} = putmaxnumcone(task,Int32(maxnumcone))
function putmaxnumcone(task_:: MSKtask,maxnumcone_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putmaxnumcone",Int32,(Ptr{Nothing},Int32,),task_.task,maxnumcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumqnz{T1}(task:: MSKtask,maxnumqnz:: T1)
    putmaxnumqnz(task_:: MSKtask,maxnumqnz_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumqnz :: Int64`. Number of non-zero elements preallocated in quadratic coefficient matrices.

Sets the number of preallocated non-zero entries in quadratic terms.

MOSEK stores only the non-zero elements in ``Q``. Therefore, MOSEK
cannot predict how much storage is required to store ``Q``. Using this
function it is possible to specify the number non-zeros to preallocate for
storing ``Q`` (both objective and constraints).

It may be advantageous to reserve more non-zeros for ``Q`` than actually
needed since it may improve the internal efficiency of MOSEK, however, it is
never worthwhile to specify more than the double of the anticipated number of
non-zeros in ``Q``.

It is not mandatory to call this function, since MOSEK will reallocate
internal structures whenever it is necessary.
"""
function putmaxnumqnz end
putmaxnumqnz(task:: MSKtask,maxnumqnz:: T1) where {T1} = putmaxnumqnz(task,Int64(maxnumqnz))
function putmaxnumqnz(task_:: MSKtask,maxnumqnz_:: Int64)
  res = disable_sigint() do
    @msk_ccall( "putmaxnumqnz",Int32,(Ptr{Nothing},Int64,),task_.task,maxnumqnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumvar{T1}(task:: MSKtask,maxnumvar:: T1)
    putmaxnumvar(task_:: MSKtask,maxnumvar_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumvar :: Int32`. Number of preallocated variables in the optimization task.

Sets the number of preallocated variables in the optimization task. When this
number of variables is reached MOSEK will automatically allocate more space
for variables.

It is not mandatory to call this function. It only gives 
a hint about the amount of data to preallocate for efficiency reasons.

Please note that `maxnumvar` must be larger than the current number of
variables in the task.
"""
function putmaxnumvar end
putmaxnumvar(task:: MSKtask,maxnumvar:: T1) where {T1} = putmaxnumvar(task,Int32(maxnumvar))
function putmaxnumvar(task_:: MSKtask,maxnumvar_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putmaxnumvar",Int32,(Ptr{Nothing},Int32,),task_.task,maxnumvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putnadouparam{T2}(task:: MSKtask,paramname:: AbstractString,parvalue:: T2)
    putnadouparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Float64)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Float64`. Parameter value.

Sets the value of a named double parameter.
"""
function putnadouparam end
putnadouparam(task:: MSKtask,paramname:: AbstractString,parvalue:: T2) where {T2} = putnadouparam(task,paramname,Float64(parvalue))
function putnadouparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putnadouparam",Int32,(Ptr{Nothing},Ptr{UInt8},Float64,),task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putnaintparam{T2}(task:: MSKtask,paramname:: AbstractString,parvalue:: T2)
    putnaintparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Int32)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Int32`. Parameter value.

Sets the value of a named integer parameter.
"""
function putnaintparam end
putnaintparam(task:: MSKtask,paramname:: AbstractString,parvalue:: T2) where {T2} = putnaintparam(task,paramname,Int32(parvalue))
function putnaintparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putnaintparam",Int32,(Ptr{Nothing},Ptr{UInt8},Int32,),task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putnastrparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: String`. Parameter value.

Sets the value of a named string parameter.
"""
function putnastrparam end
function putnastrparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putnastrparam",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},),task_.task,string(paramname_),string(parvalue_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putobjname(task_:: MSKtask,objname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `objname :: String`. Name of the objective.

Assigns a new name to the objective.
"""
function putobjname end
function putobjname(task_:: MSKtask,objname_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putobjname",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(objname_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putobjsense(task_:: MSKtask,sense_:: Objsense)

* `task :: MSKtask`. An optimization task.
* `sense :: Objsense`. The objective sense of the task

Sets the objective sense of the task.
"""
function putobjsense end
function putobjsense(task_:: MSKtask,sense_:: Objsense)
  res = disable_sigint() do
    @msk_ccall( "putobjsense",Int32,(Ptr{Nothing},Int32,),task_.task,sense_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putparam(task_:: MSKtask,parname_:: AbstractString,parvalue_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `parvalue :: String`. Parameter value.

Checks if `parname` is valid parameter name. If it is, the parameter is
assigned the value specified by `parvalue`.
"""
function putparam end
function putparam(task_:: MSKtask,parname_:: AbstractString,parvalue_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putparam",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},),task_.task,string(parname_),string(parvalue_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqcon{T1,T2,T3,T4}(task:: MSKtask,qcsubk:: Vector{T1},qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4})
    putqcon(task_:: MSKtask,qcsubk_:: Vector{Int32},qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `qcsubk :: Vector{Int32}`. Constraint subscripts for quadratic coefficients.
* `qcsubi :: Vector{Int32}`. Row subscripts for quadratic constraint matrix.
* `qcsubj :: Vector{Int32}`. Column subscripts for quadratic constraint matrix.
* `qcval :: Vector{Float64}`. Quadratic constraint coefficient values.

Replace all quadratic entries in the constraints. The list of constraints has the form

```math
 l_k^c \\leq  \\frac{1}{2} \\sum_{i=0}^{+1{numvar}} \\sum_{j=0}^{+1{numvar}} q_{ij}^k x_i x_j + \\sum_{j=0}^{+1{numvar}} a_{kj} x_j \\leq u_k^c, ~\\  k=0,\\ldots,m-1.
```
This function sets all the quadratic terms to zero and then performs the update:

```math
 q_{\\mathtt{qcsubi[t]},\\mathtt{qcsubj[t]}}^{\\mathtt{qcsubk[t]}} = q_{\\mathtt{\\mathtt{qcsubj[t]},qcsubi[t]}}^{\\mathtt{qcsubk[t]}} = q_{\\mathtt{\\mathtt{qcsubj[t]},qcsubi[t]}}^{\\mathtt{qcsubk[t]}}  + \\mathtt{qcval[t]},
```
for ``t=1,\\ldots,+1{numqcnz}``.

Please note that:

* For large problems it is essential for the efficiency that the function `Mosek.putmaxnumqnz` is employed to pre-allocate space.
* Only the lower triangular parts should be specified because the ``Q`` matrices are symmetric. Specifying entries where ``i < j`` will result in an error. 
* Only non-zero elements should be specified.
* The order in which the non-zero elements are specified is insignificant.
* Duplicate elements are added together as shown above. Hence, it is usually not recommended to specify the same entry multiple times.

For a code example see Section :ref:`doc.tutorial_qo`
"""
function putqcon end
putqcon(task:: MSKtask,qcsubk:: Vector{T1},qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4}) where {T1,T2,T3,T4} = putqcon(task,convert(Vector{Int32},qcsubk),convert(Vector{Int32},qcsubi),convert(Vector{Int32},qcsubj),convert(Vector{Float64},qcval))
function putqcon(task_:: MSKtask,qcsubk_:: Vector{Int32},qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})
  numqcnz_ = minimum([ length(qcsubi_),length(qcsubj_),length(qcval_) ])
  res = disable_sigint() do
    @msk_ccall( "putqcon",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,numqcnz_,qcsubk_ .- Int32(1),qcsubi_ .- Int32(1),qcsubj_ .- Int32(1),qcval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqconk{T1,T2,T3,T4}(task:: MSKtask,k:: T1,qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4})
    putqconk{T1}(task:: MSKtask,k:: T1,Qk:: SparseMatrixCSC{Float64})
    putqconk(task_:: MSKtask,k_:: Int32,qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. The constraint in which the new quadratic elements are inserted.
* `qcsubi :: Vector{Int32}`. Row subscripts for quadratic constraint matrix.
* `qcsubj :: Vector{Int32}`. Column subscripts for quadratic constraint matrix.
* `qcval :: Vector{Float64}`. Quadratic constraint coefficient values.
* `Qk :: SparseMatrixCSC{Float64}`. The symmetric matrix 1/2 (Qk' + Qk) is used

Replaces all the quadratic entries in one constraint. This function performs the same operations as `Mosek.putqcon` but only with respect to constraint number `k` and it does not modify the other constraints. See the description of `Mosek.putqcon` for definitions and important remarks.
"""
function putqconk end
putqconk(task:: MSKtask,k:: T1,qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4}) where {T1,T2,T3,T4} = putqconk(task,Int32(k),convert(Vector{Int32},qcsubi),convert(Vector{Int32},qcsubj),convert(Vector{Float64},qcval))
function putqconk(task:: MSKtask,k:: T1,Qk:: SparseMatrixCSC{Float64}) where {T1}
  ptrb = Qk.colptr[1:size(Qk,2)]
  ptre = Qk.colptr[2:size(Qk,2)+1]
  qcsubi = Qk.rowval
  qcsubi = Qk.rowval
  qcval = Qk.nzval
  putqconk(task,k,qcsubi,qcsubj,qcval)
end
function putqconk(task_:: MSKtask,k_:: Int32,qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})
  numqcnz_ = minimum([ length(qcsubi_),length(qcsubj_),length(qcval_) ])
  res = disable_sigint() do
    @msk_ccall( "putqconk",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,k_-1,numqcnz_,qcsubi_ .- Int32(1),qcsubj_ .- Int32(1),qcval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqobj{T1,T2,T3}(task:: MSKtask,qosubi:: Vector{T1},qosubj:: Vector{T2},qoval:: Vector{T3})
    putqobj(task:: MSKtask,Qk:: SparseMatrixCSC{Float64})
    putqobj(task_:: MSKtask,qosubi_:: Vector{Int32},qosubj_:: Vector{Int32},qoval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `qosubi :: Vector{Int32}`. Row subscripts for quadratic objective coefficients.
* `qosubj :: Vector{Int32}`. Column subscripts for quadratic objective coefficients.
* `qoval :: Vector{Float64}`. Quadratic objective coefficient values.
* `Qk :: SparseMatrixCSC{Float64}`. The symmetric matrix 1/2 (Qk' + Qk) is used

Replace all quadratic terms in the objective. If the objective has the form

```math
 \\frac{1}{2} \\sum_{i=0}^{+1{numvar}} \\sum_{j=0}^{+1{numvar}} q_{ij}^o x_i x_j + \\sum_{j=0}^{+1{numvar}} c_{j} x_j + c^f
```
then this function sets all the quadratic terms to zero and then performs the update:

```math
 q_{\\mathtt{qosubi[t]},\\mathtt{qosubj[t]}}^{o} = q_{\\mathtt{\\mathtt{qosubj[t]},qosubi[t]}}^{o} = q_{\\mathtt{\\mathtt{qosubj[t]},qosubi[t]}}^{o}  + \\mathtt{qoval[t]},
```
for ``t=1,\\ldots,+1{numqonz}``.

See the description of `Mosek.putqcon` for important remarks and example.
"""
function putqobj end
putqobj(task:: MSKtask,qosubi:: Vector{T1},qosubj:: Vector{T2},qoval:: Vector{T3}) where {T1,T2,T3} = putqobj(task,convert(Vector{Int32},qosubi),convert(Vector{Int32},qosubj),convert(Vector{Float64},qoval))
function putqobj(task:: MSKtask,Qk:: SparseMatrixCSC{Float64})
  ptrb = Qk.colptr[1:size(Qk,2)]
  ptre = Qk.colptr[2:size(Qk,2)+1]
  qosubi = Qk.rowval
  qosubi = Qk.rowval
  qoval = Qk.nzval
  putqobj(task,qosubi,qosubj,qoval)
end
function putqobj(task_:: MSKtask,qosubi_:: Vector{Int32},qosubj_:: Vector{Int32},qoval_:: Vector{Float64})
  numqonz_ = minimum([ length(qosubi_),length(qosubj_),length(qoval_) ])
  res = disable_sigint() do
    @msk_ccall( "putqobj",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,numqonz_,qosubi_ .- Int32(1),qosubj_ .- Int32(1),qoval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqobjij{T1,T2,T3}(task:: MSKtask,i:: T1,j:: T2,qoij:: T3)
    putqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32,qoij_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index for the coefficient to be replaced.
* `j :: Int32`. Column index for the coefficient to be replaced.
* `qoij :: Float64`. The new coefficient value.

Replaces one coefficient in the quadratic term in the objective. The function
performs the assignment

```math
 q_{ij}^o = q_{ji}^o = \\mathtt{qoij}.
```
Only the elements in the lower triangular part are accepted. Setting
``q_{ij}`` with ``j>i`` will cause an error.

Please note that replacing all quadratic elements one by one is more
computationally expensive than replacing them all at once. Use
`Mosek.putqobj` instead whenever possible.
"""
function putqobjij end
putqobjij(task:: MSKtask,i:: T1,j:: T2,qoij:: T3) where {T1,T2,T3} = putqobjij(task,Int32(i),Int32(j),Float64(qoij))
function putqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32,qoij_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putqobjij",Int32,(Ptr{Nothing},Int32,Int32,Float64,),task_.task,i_-1,j_-1,qoij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskc(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skc :: Vector{Int32}`. Status keys for the constraints.

Sets the status keys for the constraints.
"""
function putskc end
function putskc(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey})
  __tmp_var_0 = getnumcon(task_)
  if length(skc_) < __tmp_var_0
    println("Array argument skc is not long enough")
    throw(BoundsError())
  end
  skc_i32 = Int32[item.value for item in skc_]
  res = disable_sigint() do
    @msk_ccall( "putskc",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichsol_.value,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skc:: Vector{Stakey})
    putskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skc_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skc :: Vector{Int32}`. Status keys for the constraints.

Sets the status keys for a slice of the constraints.
"""
function putskcslice end
putskcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skc:: Vector{Stakey}) where {T2,T3} = putskcslice(task,whichsol,Int32(first),Int32(last),skc)
function putskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skc_:: Vector{Stakey})
  __tmp_var_0 = ((last_) - (first_))
  if length(skc_) < __tmp_var_0
    println("Array argument skc is not long enough")
    throw(BoundsError())
  end
  skc_i32 = Int32[item.value for item in skc_]
  res = disable_sigint() do
    @msk_ccall( "putskcslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),task_.task,whichsol_.value,first_-1,last_-1,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskx(task_:: MSKtask,whichsol_:: Soltype,skx_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skx :: Vector{Int32}`. Status keys for the variables.

Sets the status keys for the scalar variables.
"""
function putskx end
function putskx(task_:: MSKtask,whichsol_:: Soltype,skx_:: Vector{Stakey})
  __tmp_var_0 = getnumvar(task_)
  if length(skx_) < __tmp_var_0
    println("Array argument skx is not long enough")
    throw(BoundsError())
  end
  skx_i32 = Int32[item.value for item in skx_]
  res = disable_sigint() do
    @msk_ccall( "putskx",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichsol_.value,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skx:: Vector{Stakey})
    putskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skx_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skx :: Vector{Int32}`. Status keys for the variables.

Sets the status keys for a slice of the variables.
"""
function putskxslice end
putskxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skx:: Vector{Stakey}) where {T2,T3} = putskxslice(task,whichsol,Int32(first),Int32(last),skx)
function putskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skx_:: Vector{Stakey})
  __tmp_var_0 = ((last_) - (first_))
  if length(skx_) < __tmp_var_0
    println("Array argument skx is not long enough")
    throw(BoundsError())
  end
  skx_i32 = Int32[item.value for item in skx_]
  res = disable_sigint() do
    @msk_ccall( "putskxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},),task_.task,whichsol_.value,first_-1,last_-1,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslc{T2}(task:: MSKtask,whichsol:: Soltype,slc:: Vector{T2})
    putslc(task_:: MSKtask,whichsol_:: Soltype,slc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Sets the ``s_l^c`` vector for a solution.
"""
function putslc end
putslc(task:: MSKtask,whichsol:: Soltype,slc:: Vector{T2}) where {T2} = putslc(task,whichsol,convert(Vector{Float64},slc))
function putslc(task_:: MSKtask,whichsol_:: Soltype,slc_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(slc_) < __tmp_var_0
    println("Array argument slc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putslc",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,slc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslcslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slc:: Vector{T4})
    putslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Sets a slice of the ``s_l^c`` vector for a solution.
"""
function putslcslice end
putslcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slc:: Vector{T4}) where {T2,T3,T4} = putslcslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},slc))
function putslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slc_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(slc_) < __tmp_var_0
    println("Array argument slc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putslcslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,slc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslx{T2}(task:: MSKtask,whichsol:: Soltype,slx:: Vector{T2})
    putslx(task_:: MSKtask,whichsol_:: Soltype,slx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Sets the ``s_l^x`` vector for a solution.
"""
function putslx end
putslx(task:: MSKtask,whichsol:: Soltype,slx:: Vector{T2}) where {T2} = putslx(task,whichsol,convert(Vector{Float64},slx))
function putslx(task_:: MSKtask,whichsol_:: Soltype,slx_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(slx_) < __tmp_var_0
    println("Array argument slx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putslx",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,slx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slx:: Vector{T4})
    putslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Sets a slice of the ``s_l^x`` vector for a solution.
"""
function putslxslice end
putslxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slx:: Vector{T4}) where {T2,T3,T4} = putslxslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},slx))
function putslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slx_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(slx_) < __tmp_var_0
    println("Array argument slx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putslxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,slx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsnx{T2}(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2})
    putsnx(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Sets the ``s_n^x`` vector for a solution.
"""
function putsnx end
putsnx(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2}) where {T2} = putsnx(task,whichsol,convert(Vector{Float64},sux))
function putsnx(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(sux_) < __tmp_var_0
    println("Array argument sux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putsnx",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,sux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsnxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,snx:: Vector{T4})
    putsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,snx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Sets a slice of the ``s_n^x`` vector for a solution.
"""
function putsnxslice end
putsnxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,snx:: Vector{T4}) where {T2,T3,T4} = putsnxslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},snx))
function putsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,snx_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(snx_) < __tmp_var_0
    println("Array argument snx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putsnxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,snx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsolution{T5,T6,T7,T8,T9,T10,T11,T12}(task:: MSKtask,whichsol:: Soltype,skc:: Vector{Stakey},skx:: Vector{Stakey},skn:: Vector{Stakey},xc:: Vector{T5},xx:: Vector{T6},y:: Vector{T7},slc:: Vector{T8},suc:: Vector{T9},slx:: Vector{T10},sux:: Vector{T11},snx:: Vector{T12})
    putsolution(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey},skx_:: Vector{Stakey},skn_:: Vector{Stakey},xc_:: Vector{Float64},xx_:: Vector{Float64},y_:: Vector{Float64},slc_:: Vector{Float64},suc_:: Vector{Float64},slx_:: Vector{Float64},sux_:: Vector{Float64},snx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skc :: Vector{Int32}`. Status keys for the constraints.
* `skx :: Vector{Int32}`. Status keys for the variables.
* `skn :: Vector{Int32}`. Status keys for the conic constraints.
* `xc :: Vector{Float64}`. Primal constraint solution.
* `xx :: Vector{Float64}`. Primal variable solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Inserts a solution into the task.
"""
function putsolution end
putsolution(task:: MSKtask,whichsol:: Soltype,skc:: Vector{Stakey},skx:: Vector{Stakey},skn:: Vector{Stakey},xc:: Vector{T5},xx:: Vector{T6},y:: Vector{T7},slc:: Vector{T8},suc:: Vector{T9},slx:: Vector{T10},sux:: Vector{T11},snx:: Vector{T12}) where {T5,T6,T7,T8,T9,T10,T11,T12} = putsolution(task,whichsol,skc,skx,skn,convert(Vector{Float64},xc),convert(Vector{Float64},xx),convert(Vector{Float64},y),convert(Vector{Float64},slc),convert(Vector{Float64},suc),convert(Vector{Float64},slx),convert(Vector{Float64},sux),convert(Vector{Float64},snx))
function putsolution(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey},skx_:: Vector{Stakey},skn_:: Vector{Stakey},xc_:: Vector{Float64},xx_:: Vector{Float64},y_:: Vector{Float64},slc_:: Vector{Float64},suc_:: Vector{Float64},slx_:: Vector{Float64},sux_:: Vector{Float64},snx_:: Vector{Float64})
  skc_i32 = Int32[item.value for item in skc_]
  skn_i32 = Int32[item.value for item in skn_]
  skx_i32 = Int32[item.value for item in skx_]
  res = disable_sigint() do
    @msk_ccall( "putsolution",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},),task_.task,whichsol_.value,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsolutioni{T2,T5,T6,T7,T8}(task:: MSKtask,accmode:: Accmode,i:: T2,whichsol:: Soltype,sk:: Stakey,x:: T5,sl:: T6,su:: T7,sn:: T8)
    putsolutioni(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,whichsol_:: Soltype,sk_:: Stakey,x_:: Float64,sl_:: Float64,su_:: Float64,sn_:: Float64)

* `task :: MSKtask`. An optimization task.
* `accmode :: Accmode`. Defines whether solution information for a constraint or for a variable is modified.
* `i :: Int32`. Index of the constraint or variable.
* `whichsol :: Soltype`. Selects a solution.
* `sk :: Stakey`. Status key of the constraint or variable.
* `x :: Float64`. Solution value of the primal constraint or variable.
* `sl :: Float64`. Solution value of the dual variable associated with the lower bound.
* `su :: Float64`. Solution value of the dual variable associated with the upper bound.
* `sn :: Float64`. Solution value of the dual variable associated with the conic constraint.

Sets the primal and dual solution information for a single
constraint or variable.
"""
function putsolutioni end
putsolutioni(task:: MSKtask,accmode:: Accmode,i:: T2,whichsol:: Soltype,sk:: Stakey,x:: T5,sl:: T6,su:: T7,sn:: T8) where {T2,T5,T6,T7,T8} = putsolutioni(task,accmode,Int32(i),whichsol,sk,Float64(x),Float64(sl),Float64(su),Float64(sn))
function putsolutioni(task_:: MSKtask,accmode_:: Accmode,i_:: Int32,whichsol_:: Soltype,sk_:: Stakey,x_:: Float64,sl_:: Float64,su_:: Float64,sn_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putsolutioni",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int32,Float64,Float64,Float64,Float64,),task_.task,accmode_.value,i_-1,whichsol_.value,sk_.value,x_,sl_,su_,sn_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsolutionyi{T1,T3}(task:: MSKtask,i:: T1,whichsol:: Soltype,y:: T3)
    putsolutionyi(task_:: MSKtask,i_:: Int32,whichsol_:: Soltype,y_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the dual variable.
* `whichsol :: Soltype`. Selects a solution.
* `y :: Float64`. Solution value of the dual variable.

Inputs the dual variable of a solution.
"""
function putsolutionyi end
putsolutionyi(task:: MSKtask,i:: T1,whichsol:: Soltype,y:: T3) where {T1,T3} = putsolutionyi(task,Int32(i),whichsol,Float64(y))
function putsolutionyi(task_:: MSKtask,i_:: Int32,whichsol_:: Soltype,y_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putsolutionyi",Int32,(Ptr{Nothing},Int32,Int32,Float64,),task_.task,i_-1,whichsol_.value,y_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putstrparam(task_:: MSKtask,param_:: Sparam,parvalue_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `param :: Sparam`. Which parameter.
* `parvalue :: String`. Parameter value.

Sets the value of a string parameter.
"""
function putstrparam end
function putstrparam(task_:: MSKtask,param_:: Sparam,parvalue_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putstrparam",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,param_.value,string(parvalue_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsuc{T2}(task:: MSKtask,whichsol:: Soltype,suc:: Vector{T2})
    putsuc(task_:: MSKtask,whichsol_:: Soltype,suc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Sets the ``s_u^c`` vector for a solution.
"""
function putsuc end
putsuc(task:: MSKtask,whichsol:: Soltype,suc:: Vector{T2}) where {T2} = putsuc(task,whichsol,convert(Vector{Float64},suc))
function putsuc(task_:: MSKtask,whichsol_:: Soltype,suc_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(suc_) < __tmp_var_0
    println("Array argument suc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putsuc",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,suc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsucslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,suc:: Vector{T4})
    putsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,suc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Sets a slice of the ``s_u^c`` vector for a solution.
"""
function putsucslice end
putsucslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,suc:: Vector{T4}) where {T2,T3,T4} = putsucslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},suc))
function putsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,suc_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(suc_) < __tmp_var_0
    println("Array argument suc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putsucslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,suc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsux{T2}(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2})
    putsux(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Sets the ``s_u^x`` vector for a solution.
"""
function putsux end
putsux(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2}) where {T2} = putsux(task,whichsol,convert(Vector{Float64},sux))
function putsux(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(sux_) < __tmp_var_0
    println("Array argument sux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putsux",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,sux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsuxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,sux:: Vector{T4})
    putsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,sux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Sets a slice of the ``s_u^x`` vector for a solution.
"""
function putsuxslice end
putsuxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,sux:: Vector{T4}) where {T2,T3,T4} = putsuxslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},sux))
function putsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,sux_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(sux_) < __tmp_var_0
    println("Array argument sux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putsuxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,sux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    puttaskname(task_:: MSKtask,taskname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `taskname :: String`. Name assigned to the task.

Assigns a new name to the task.
"""
function puttaskname end
function puttaskname(task_:: MSKtask,taskname_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "puttaskname",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(taskname_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarbound{T1,T3,T4}(task:: MSKtask,j:: T1,bk:: Boundkey,bl:: T3,bu:: T4)
    putvarbound(task_:: MSKtask,j_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `bk :: Boundkey`. New bound key.
* `bl :: Float64`. New lower bound.
* `bu :: Float64`. New upper bound.

Changes the bounds for one variable.

If the bound value specified is numerically larger than
`MSK_DPAR_DATA_TOL_BOUND_INF`` it is considered infinite and the bound key is
changed accordingly. If a bound value is numerically larger than
`MSK_DPAR_DATA_TOL_BOUND_WRN``, a warning will be displayed, but the bound is
inputted as specified.
"""
function putvarbound end
putvarbound(task:: MSKtask,j:: T1,bk:: Boundkey,bl:: T3,bu:: T4) where {T1,T3,T4} = putvarbound(task,Int32(j),bk,Float64(bl),Float64(bu))
function putvarbound(task_:: MSKtask,j_:: Int32,bk_:: Boundkey,bl_:: Float64,bu_:: Float64)
  res = disable_sigint() do
    @msk_ccall( "putvarbound",Int32,(Ptr{Nothing},Int32,Int32,Float64,Float64,),task_.task,j_-1,bk_.value,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarboundlist{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bkx:: Vector{Boundkey},blx:: Vector{T3},bux:: Vector{T4})
    putvarboundlist(task_:: MSKtask,sub_:: Vector{Int32},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. List of variable indexes.
* `bkx :: Vector{Int32}`. Bound keys for the variables.
* `blx :: Vector{Float64}`. Lower bounds for the variables.
* `bux :: Vector{Float64}`. Upper bounds for the variables.

Changes the bounds for one or more variables. If multiple bound changes are specified for a variable, then only the last change takes effect. Data checks are performed as in `Mosek.putvarbound`.
"""
function putvarboundlist end
putvarboundlist(task:: MSKtask,sub:: Vector{T1},bkx:: Vector{Boundkey},blx:: Vector{T3},bux:: Vector{T4}) where {T1,T3,T4} = putvarboundlist(task,convert(Vector{Int32},sub),bkx,convert(Vector{Float64},blx),convert(Vector{Float64},bux))
function putvarboundlist(task_:: MSKtask,sub_:: Vector{Int32},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})
  bkx_i32 = Int32[item.value for item in bkx_]
  num_ = minimum([ length(sub_),length(bkx_),length(blx_),length(bux_) ])
  res = disable_sigint() do
    @msk_ccall( "putvarboundlist",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,num_,sub_ .- Int32(1),bkx_,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarboundslice{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5})
    putvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Int32}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Changes the bounds for a slice of the variables. Data checks are performed as in `Mosek.putvarbound`.
"""
function putvarboundslice end
putvarboundslice(task:: MSKtask,first:: T1,last:: T2,bk:: Vector{Boundkey},bl:: Vector{T4},bu:: Vector{T5}) where {T1,T2,T4,T5} = putvarboundslice(task,Int32(first),Int32(last),bk,convert(Vector{Float64},bl),convert(Vector{Float64},bu))
function putvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bk_:: Vector{Boundkey},bl_:: Vector{Float64},bu_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(bk_) < __tmp_var_0
    println("Array argument bk is not long enough")
    throw(BoundsError())
  end
  bk_i32 = Int32[item.value for item in bk_]
  __tmp_var_1 = ((last_) - (first_))
  if length(bl_) < __tmp_var_1
    println("Array argument bl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = ((last_) - (first_))
  if length(bu_) < __tmp_var_2
    println("Array argument bu is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putvarboundslice",Int32,(Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},),task_.task,first_-1,last_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarname{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
    putvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `name :: String`. The variable name.

Sets the name of a variable.
"""
function putvarname end
putvarname(task:: MSKtask,j:: T1,name:: AbstractString) where {T1} = putvarname(task,Int32(j),name)
function putvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putvarname",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,j_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvartype{T1}(task:: MSKtask,j:: T1,vartype:: Variabletype)
    putvartype(task_:: MSKtask,j_:: Int32,vartype_:: Variabletype)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `vartype :: Variabletype`. The new variable type.

Sets the variable type of one variable.
"""
function putvartype end
putvartype(task:: MSKtask,j:: T1,vartype:: Variabletype) where {T1} = putvartype(task,Int32(j),vartype)
function putvartype(task_:: MSKtask,j_:: Int32,vartype_:: Variabletype)
  res = disable_sigint() do
    @msk_ccall( "putvartype",Int32,(Ptr{Nothing},Int32,Int32,),task_.task,j_-1,vartype_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvartypelist{T1}(task:: MSKtask,subj:: Vector{T1},vartype:: Vector{Variabletype})
    putvartypelist(task_:: MSKtask,subj_:: Vector{Int32},vartype_:: Vector{Variabletype})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. A list of variable indexes for which the variable type should be changed.
* `vartype :: Vector{Int32}`. A list of variable types.

Sets the variable type for one or more variables. If the same index is specified multiple times in `subj` only the last entry
takes effect.
"""
function putvartypelist end
putvartypelist(task:: MSKtask,subj:: Vector{T1},vartype:: Vector{Variabletype}) where {T1} = putvartypelist(task,convert(Vector{Int32},subj),vartype)
function putvartypelist(task_:: MSKtask,subj_:: Vector{Int32},vartype_:: Vector{Variabletype})
  vartype_i32 = Int32[item.value for item in vartype_]
  num_ = minimum([ length(subj_),length(vartype_) ])
  res = disable_sigint() do
    @msk_ccall( "putvartypelist",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},),task_.task,num_,subj_ .- Int32(1),vartype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    xc = putxc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xc :: Vector{Float64}`. Primal constraint solution.

Sets the ``x^c`` vector for a solution.
"""
function putxc end
function putxc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xc_ = __tmp_var_1
  res = disable_sigint() do
    @msk_ccall( "putxc",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    putxcslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xc:: Vector{T4})
    putxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xc :: Vector{Float64}`. Primal constraint solution.

Sets a slice of the ``x^c`` vector for a solution.
"""
function putxcslice end
putxcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xc:: Vector{T4}) where {T2,T3,T4} = putxcslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},xc))
function putxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xc_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(xc_) < __tmp_var_0
    println("Array argument xc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putxcslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,xc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putxx{T2}(task:: MSKtask,whichsol:: Soltype,xx:: Vector{T2})
    putxx(task_:: MSKtask,whichsol_:: Soltype,xx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xx :: Vector{Float64}`. Primal variable solution.

Sets the ``x^x`` vector for a solution.
"""
function putxx end
putxx(task:: MSKtask,whichsol:: Soltype,xx:: Vector{T2}) where {T2} = putxx(task,whichsol,convert(Vector{Float64},xx))
function putxx(task_:: MSKtask,whichsol_:: Soltype,xx_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(xx_) < __tmp_var_0
    println("Array argument xx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putxx",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,xx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putxxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xx:: Vector{T4})
    putxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xx :: Vector{Float64}`. Primal variable solution.

Obtains a slice of the ``x^x`` vector for a solution.
"""
function putxxslice end
putxxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xx:: Vector{T4}) where {T2,T3,T4} = putxxslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},xx))
function putxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xx_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(xx_) < __tmp_var_0
    println("Array argument xx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putxxslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,xx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    puty{T2}(task:: MSKtask,whichsol:: Soltype,y:: Vector{T2})
    puty(task_:: MSKtask,whichsol_:: Soltype,y_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Sets the ``y`` vector for a solution.
"""
function puty end
puty(task:: MSKtask,whichsol:: Soltype,y:: Vector{T2}) where {T2} = puty(task,whichsol,convert(Vector{Float64},y))
function puty(task_:: MSKtask,whichsol_:: Soltype,y_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(y_) < __tmp_var_0
    println("Array argument y is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "puty",Int32,(Ptr{Nothing},Int32,Ptr{Float64},),task_.task,whichsol_.value,y_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putyslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,y:: Vector{T4})
    putyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,y_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Sets a slice of the ``y`` vector for a solution.
"""
function putyslice end
putyslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,y:: Vector{T4}) where {T2,T3,T4} = putyslice(task,whichsol,Int32(first),Int32(last),convert(Vector{Float64},y))
function putyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,y_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(y_) < __tmp_var_0
    println("Array argument y is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putyslice",Int32,(Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},),task_.task,whichsol_.value,first_-1,last_-1,y_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readdata(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Reads an optimization problem and associated data from a file.
"""
function readdata end
function readdata(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "readdataautoformat",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readdataformat(task_:: MSKtask,filename_:: AbstractString,format_:: Dataformat,compress_:: Compresstype)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.
* `format :: Dataformat`. File data format.
* `compress :: Compresstype`. File compression type.

Reads an optimization problem and associated data from a file.
"""
function readdataformat end
function readdataformat(task_:: MSKtask,filename_:: AbstractString,format_:: Dataformat,compress_:: Compresstype)
  res = disable_sigint() do
    @msk_ccall( "readdataformat",Int32,(Ptr{Nothing},Ptr{UInt8},Int32,Int32,),task_.task,string(filename_),format_.value,compress_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readparamfile(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Reads MOSEK parameters from a file. Data is read from the file `filename` if it is a nonempty string. Otherwise data is read from the file specified by :msk:sparam:`param_read_file_name`.
"""
function readparamfile end
function readparamfile(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "readparamfile",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readsolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `filename :: String`. A valid file name.

Reads a solution file and inserts it as a specified solution in the task. Data is read from the file `filename` if it is a nonempty string. Otherwise data is read from one of the files specified by :msk:sparam:`bas_sol_file_name`, :msk:sparam:`itr_sol_file_name` or :msk:sparam:`int_sol_file_name` depending on which solution is chosen.
"""
function readsolution end
function readsolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "readsolution",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,whichsol_.value,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readsummary(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Prints a short summary of last file that was read.
"""
function readsummary end
function readsummary(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @msk_ccall( "readsummary",Int32,(Ptr{Nothing},Int32,),task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readtask(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Load task data from a file, replacing any data that already exists in the task
object. All problem data, parameters and other settings are resorted, but if the file contains solutions, the
solution status after loading a file is set to unknown, even if it was optimal
or otherwise well-defined when the file was dumped.

See section :ref:`doc.shared.taskformat` for a description of the Task format.
"""
function readtask end
function readtask(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "readtask",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removebarvars{T1}(task:: MSKtask,subset:: Vector{T1})
    removebarvars(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of symmetric matrices which should be removed.

The function removes a subset of the symmetric matrices 
from the optimization task. This implies that the remaining
symmetric matrices are renumbered.
"""
function removebarvars end
removebarvars(task:: MSKtask,subset:: Vector{T1}) where {T1} = removebarvars(task,convert(Vector{Int32},subset))
function removebarvars(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @msk_ccall( "removebarvars",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,num_,subset_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removecones{T1}(task:: MSKtask,subset:: Vector{T1})
    removecones(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of cones which should be removed.

Removes a number of conic constraints from the problem. This implies that the remaining conic constraints are renumbered.
In general, it is much more efficient to remove a cone with a high index than a low index.
"""
function removecones end
removecones(task:: MSKtask,subset:: Vector{T1}) where {T1} = removecones(task,convert(Vector{Int32},subset))
function removecones(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @msk_ccall( "removecones",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,num_,subset_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removecons{T1}(task:: MSKtask,subset:: Vector{T1})
    removecons(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of constraints which should be removed.

The function removes a subset of the constraints 
from the optimization task. This implies that the remaining
constraints are renumbered.
"""
function removecons end
removecons(task:: MSKtask,subset:: Vector{T1}) where {T1} = removecons(task,convert(Vector{Int32},subset))
function removecons(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @msk_ccall( "removecons",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,num_,subset_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removevars{T1}(task:: MSKtask,subset:: Vector{T1})
    removevars(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of variables which should be removed.

The function removes a subset of the variables 
from the optimization task. This implies that the remaining
variables are renumbered.
"""
function removevars end
removevars(task:: MSKtask,subset:: Vector{T1}) where {T1} = removevars(task,convert(Vector{Int32},subset))
function removevars(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @msk_ccall( "removevars",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,num_,subset_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    resizetask{T1,T2,T3,T4,T5}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,maxnumcone:: T3,maxnumanz:: T4,maxnumqnz:: T5)
    resizetask(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,maxnumcone_:: Int32,maxnumanz_:: Int64,maxnumqnz_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. New maximum number of constraints.
* `maxnumvar :: Int32`. New maximum number of variables.
* `maxnumcone :: Int32`. New maximum number of cones.
* `maxnumanz :: Int64`. New maximum number of linear non-zero elements.
* `maxnumqnz :: Int64`. New maximum number of quadratic non-zeros elements.

Sets the amount of preallocated space assigned for each type of data in an
optimization task.

It is never mandatory to call this function, since it only gives 
a hint about the amount of data to preallocate for efficiency reasons.

Please note that the procedure is **destructive** in the sense that all
existing data stored in the task is destroyed.
"""
function resizetask end
resizetask(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,maxnumcone:: T3,maxnumanz:: T4,maxnumqnz:: T5) where {T1,T2,T3,T4,T5} = resizetask(task,Int32(maxnumcon),Int32(maxnumvar),Int32(maxnumcone),Int64(maxnumanz),Int64(maxnumqnz))
function resizetask(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,maxnumcone_:: Int32,maxnumanz_:: Int64,maxnumqnz_:: Int64)
  res = disable_sigint() do
    @msk_ccall( "resizetask",Int32,(Ptr{Nothing},Int32,Int32,Int32,Int64,Int64,),task_.task,maxnumcon_,maxnumvar_,maxnumcone_,maxnumanz_,maxnumqnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    sensitivityreport(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Reads a sensitivity format file from a location given by
:msk:sparam:`sensitivity_file_name` and writes the result to the stream
`whichstream`. If :msk:sparam:`sensitivity_res_file_name` is set to a non-empty
string, then the sensitivity report is also written to a file of this name.
"""
function sensitivityreport end
function sensitivityreport(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @msk_ccall( "sensitivityreport",Int32,(Ptr{Nothing},Int32,),task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    setdefaults(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.

Resets all the parameters to their default values.
"""
function setdefaults end
function setdefaults(task_:: MSKtask)
  res = disable_sigint() do
    @msk_ccall( "setdefaults",Int32,(Ptr{Nothing},),task_.task)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    isdef = solutiondef(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `isdef :: Bool`. Is non-zero if the requested solution is defined.

Checks whether a solution is defined.
"""
function solutiondef end
function solutiondef(task_:: MSKtask,whichsol_:: Soltype)
  isdef_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "solutiondef",Int32,(Ptr{Nothing},Int32,Ptr{Int32},),task_.task,whichsol_.value,isdef_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Bool,isdef_[1]))
end

"""
    solutionsummary(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Prints a short summary of the current solutions.
"""
function solutionsummary end
function solutionsummary(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @msk_ccall( "solutionsummary",Int32,(Ptr{Nothing},Int32,),task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    numnz = solvewithbasis{T1,T2,T3,T4}(task:: MSKtask,transp:: T1,numnz:: T2,sub:: Vector{T3},val:: Vector{T4})
    numnz = solvewithbasis(task_:: MSKtask,transp_:: Int32,numnz_:: Int32,sub_:: Vector{Int32},val_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `transp :: Int32`. Controls which problem formulation is solved.
* `numnz :: Int32`. Input (number of non-zeros in right-hand side) and output (number of non-zeros in solution vector).
* `sub :: Vector{Int32}`. Input (indexes of non-zeros in right-hand side) and output (indexes of non-zeros in solution vector).
* `val :: Vector{Float64}`. Input (right-hand side values) and output (solution vector values).

If a basic solution is available, then exactly ``numcon``
basis variables are defined.  These ``numcon`` basis
variables are denoted the basis.  Associated with the basis is a basis
matrix denoted ``B``.  This function solves either the linear
equation system

```math
:label: ais-eq-Bxb

B \\bar X = b                       
```
or the system

```math
:label: ais-eq-Btxb

B^T \\bar X = b
```
for the unknowns ``\\bar X``, with ``b`` being a user-defined  vector.                    
In order to make sense of the solution ``\\bar X`` it is important
to know the ordering of the variables in the basis because the
ordering specifies how ``B`` is constructed. When calling
`Mosek.initbasissolve` an ordering of the basis variables is
obtained, which can be used to deduce how MOSEK has constructed
``B``. Indeed if the ``k``-th basis variable is variable
``x_j`` it implies that


```math
 B_{i,k} = A_{i,j}, ~i=1,\\ldots,+1{numcon}.
```
Otherwise if the ``k``-th basis variable is variable ``x_j^c`` it implies that

```math
B_{i,k} = \\left\\{ \\begin{array}{ll}
                        -1, & i = j, \\\\
                        0 , & i \\neq j. \\\\
                    \\end{array} 
            \\right.
```
The function `Mosek.initbasissolve` must be called before a call to this function.
Please note that this function exploits the
sparsity in the vector ``b`` to speed up the computations.
"""
function solvewithbasis end
solvewithbasis(task:: MSKtask,transp:: T1,numnz:: T2,sub:: Vector{T3},val:: Vector{T4}) where {T1,T2,T3,T4} = solvewithbasis(task,Int32(transp),Int32(numnz),convert(Vector{Int32},sub),convert(Vector{Float64},val))
function solvewithbasis(task_:: MSKtask,transp_:: Int32,numnz_:: Int32,sub_:: Vector{Int32},val_:: Vector{Float64})
  __tmp_var_0 = Int32[ numnz_ ]
  __tmp_var_1 = getnumcon(task_)
  if length(sub_) < __tmp_var_1
    println("Array argument sub is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = getnumcon(task_)
  if length(val_) < __tmp_var_2
    println("Array argument val is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "solvewithbasis",Int32,(Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},),task_.task,transp_,__tmp_var_0,sub_ .- Int32(1),val_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_0[1])
end

"""
    conetype = strtoconetype(task_:: MSKtask,str_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `str :: String`. String corresponding to the cone type code.
* `conetype :: Conetype`. The cone type corresponding to str.

Obtains cone type code corresponding to a cone type string.
"""
function strtoconetype end
function strtoconetype(task_:: MSKtask,str_:: AbstractString)
  conetype_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "strtoconetype",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},),task_.task,string(str_),conetype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Conetype(conetype_[1]))
end

"""
    sk = strtosk(task_:: MSKtask,str_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `str :: String`. Status key string.
* `sk :: Int32`. Status key corresponding to the string.

Obtains the status key corresponding to an explanatory string.
"""
function strtosk end
function strtosk(task_:: MSKtask,str_:: AbstractString)
  sk_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "strtosk",Int32,(Ptr{Nothing},Ptr{UInt8},Ptr{Int32},),task_.task,string(str_),sk_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,sk_[1]))
end

"""
    updatesolutioninfo(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.

Update the information items related to the solution.
"""
function updatesolutioninfo end
function updatesolutioninfo(task_:: MSKtask,whichsol_:: Soltype)
  res = disable_sigint() do
    @msk_ccall( "updatesolutioninfo",Int32,(Ptr{Nothing},Int32,),task_.task,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writedata(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Writes problem data associated with the optimization task to a file in one of
the supported formats. See Section :ref:`doc.shared.file_formats` for the complete list.

By default the data file format is determined by the file name extension. This
behaviour can be overridden by setting the `MSK_IPAR_WRITE_DATA_FORMAT``
parameter. To write
in compressed format append the extension `.gz`.  E.g to write a gzip
compressed MPS file use the extension `mps.gz`.

Please note that MPS, LP and OPF files require all variables to have unique
names. If a task contains no names, it is possible to write the file with
automatically generated anonymous names by setting the
`MSK_IPAR_WRITE_GENERIC_NAMES`` parameter to `MSK_ON`.

Data is written to the file `filename`
if it is a nonempty string. Otherwise data is written
to the file specified by :msk:sparam:`data_file_name`.

Please note that if a general nonlinear function appears in the problem then
such function *cannot* be written to file and MOSEK will issue a warning.
"""
function writedata end
function writedata(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "writedata",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writejsonsol(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Saves the current solutions and solver information items in a JSON file.
"""
function writejsonsol end
function writejsonsol(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "writejsonsol",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writeparamfile(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Writes all the parameters to a parameter file.
"""
function writeparamfile end
function writeparamfile(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "writeparamfile",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writesolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `filename :: String`. A valid file name.

Saves the current basic, interior-point, or integer solution to a file.
"""
function writesolution end
function writesolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "writesolution",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},),task_.task,whichsol_.value,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writetask(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Write a binary dump of the task data. This format saves all problem data, coefficients and parameter settings but
does not save callback functions and general non-linear terms.

See section :ref:`doc.shared.taskformat` for a description of the Task format.
"""
function writetask end
function writetask(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "writetask",Int32,(Ptr{Nothing},Ptr{UInt8},),task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    checkinall(env_:: MSKenv)

* `env :: MSKenv`. The MOSEK environment.

Check in all unused license features to the license token server.
"""
function checkinall end
function checkinall(env_:: MSKenv)
  res = disable_sigint() do
    @msk_ccall( "checkinall",Int32,(Ptr{Nothing},),env_.env)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    checkinlicense(env_:: MSKenv,feature_:: Feature)

* `env :: MSKenv`. The MOSEK environment.
* `feature :: Feature`. Feature to check in to the license system.

Check in a license feature to the license server. By default all licenses
consumed by functions using a single environment are kept checked out for the
lifetime of the MOSEK environment. This function checks in a given license
feature back to the license server immediately.

If the given license feature is not checked out at all, or it is in use by a call to
`Mosek.optimize`, calling this function has no effect.

Please note that returning a license to the license server incurs a small
overhead, so frequent calls to this function should be avoided.
"""
function checkinlicense end
function checkinlicense(env_:: MSKenv,feature_:: Feature)
  res = disable_sigint() do
    @msk_ccall( "checkinlicense",Int32,(Ptr{Nothing},Int32,),env_.env,feature_.value)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    checkoutlicense(env_:: MSKenv,feature_:: Feature)

* `env :: MSKenv`. The MOSEK environment.
* `feature :: Feature`. Feature to check out from the license system.

Checks out a license feature from the license server. Normally the required
license features will be automatically checked out the first time they are needed
by the function `Mosek.optimize`. This function can be used to check out one
or more features ahead of time.

The feature will remain checked out until the environment is deleted or the function
`Mosek.checkinlicense` is called.

If a given feature is already checked out when this function is called, the call has no effect.
"""
function checkoutlicense end
function checkoutlicense(env_:: MSKenv,feature_:: Feature)
  res = disable_sigint() do
    @msk_ccall( "checkoutlicense",Int32,(Ptr{Nothing},Int32,),env_.env,feature_.value)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    echointro{T1}(env:: MSKenv,longver:: T1)
    echointro(env_:: MSKenv,longver_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `longver :: Int32`. If non-zero, then the intro is slightly longer.

Prints an intro to message stream.
"""
function echointro end
echointro(env:: MSKenv,longver:: T1) where {T1} = echointro(env,Int32(longver))
function echointro(env_:: MSKenv,longver_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "echointro",Int32,(Ptr{Nothing},Int32,),env_.env,longver_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    (symname,str) = getcodedesc(code_:: Rescode)

* `code :: Rescode`. A valid response code.
* `symname :: AbstractString`. Symbolic name corresponding to the code.
* `str :: AbstractString`. Obtains a short description of a response code.

Obtains a short description of the meaning of the response code given by `code`.
"""
function getcodedesc end
function getcodedesc(code_:: Rescode)
  str_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  symname_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @msk_ccall( "getcodedesc",Int32,(Int32,Ptr{UInt8},Ptr{UInt8},),code_.value,symname_,str_)
  end
  symname_str = convert(String,symname_)
  str_str = convert(String,str_)
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
  (symname_str[1:searchindex(symname_str,'\0')-1],str_str[1:searchindex(str_str,'\0')-1])
end

"""
    (major,minor,build,revision) = getversion()

* `major :: Int32`. Major version number.
* `minor :: Int32`. Minor version number.
* `build :: Int32`. Build number.
* `revision :: Int32`. Revision number.

Obtains MOSEK version information.
"""
function getversion end
function getversion()
  build_ = Vector{Int32}(undef,1)
  major_ = Vector{Int32}(undef,1)
  minor_ = Vector{Int32}(undef,1)
  revision_ = Vector{Int32}(undef,1)
  res = disable_sigint() do
    @msk_ccall( "getversion",Int32,(Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},),major_,minor_,build_,revision_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
  (convert(Int32,major_[1]),convert(Int32,minor_[1]),convert(Int32,build_[1]),convert(Int32,revision_[1]))
end

"""
    licensecleanup()


Stops all threads and deletes all handles used by the license system. If this
function is called, it must be called as the last MOSEK API call. No other
MOSEK API calls are valid after this.
"""
function licensecleanup end
function licensecleanup()
  res = disable_sigint() do
    @msk_ccall( "licensecleanup",Int32,())
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    linkfiletostream{T3}(env:: MSKenv,whichstream:: Streamtype,filename:: AbstractString,append:: T3)
    linkfiletostream(env_:: MSKenv,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `whichstream :: Streamtype`. Index of the stream.
* `filename :: String`. A valid file name.
* `append :: Int32`. If this argument is 0 the file will be overwritten, otherwise it will be appended to.

Sends all output from the stream defined by `whichstream` to the file given by `filename`.
"""
linkfiletostream(env:: MSKenv,whichstream:: Streamtype,filename:: AbstractString,append:: T3) where {T3} = linkfiletostream(env,whichstream,filename,Int32(append))
function linkfiletostream(env_:: MSKenv,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "linkfiletoenvstream",Int32,(Ptr{Nothing},Int32,Ptr{UInt8},Int32,),env_.env,whichstream_.value,string(filename_),append_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putlicensecode{T1}(env:: MSKenv,code:: Vector{T1})
    putlicensecode(env_:: MSKenv,code_:: Vector{Int32})

* `env :: MSKenv`. The MOSEK environment.
* `code :: Vector{Int32}`. A license key string.

Input a runtime license code.
"""
function putlicensecode end
putlicensecode(env:: MSKenv,code:: Vector{T1}) where {T1} = putlicensecode(env,convert(Vector{Int32},code))
function putlicensecode(env_:: MSKenv,code_:: Vector{Int32})
  __tmp_var_0 = MSK_LICENSE_BUFFER_LENGTH
  if length(code_) < __tmp_var_0
    println("Array argument code is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @msk_ccall( "putlicensecode",Int32,(Ptr{Nothing},Ptr{Int32},),env_.env,code_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putlicensedebug{T1}(env:: MSKenv,licdebug:: T1)
    putlicensedebug(env_:: MSKenv,licdebug_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `licdebug :: Int32`. Enable output of license check-out debug information.

Enables debug information for the license system. If `licdebug` is non-zero, then MOSEK will print debug info regarding the license checkout.
"""
function putlicensedebug end
putlicensedebug(env:: MSKenv,licdebug:: T1) where {T1} = putlicensedebug(env,Int32(licdebug))
function putlicensedebug(env_:: MSKenv,licdebug_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putlicensedebug",Int32,(Ptr{Nothing},Int32,),env_.env,licdebug_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putlicensepath(env_:: MSKenv,licensepath_:: AbstractString)

* `env :: MSKenv`. The MOSEK environment.
* `licensepath :: String`. A path specifying where to search for the license.

Set the path to the license file.
"""
function putlicensepath end
function putlicensepath(env_:: MSKenv,licensepath_:: AbstractString)
  res = disable_sigint() do
    @msk_ccall( "putlicensepath",Int32,(Ptr{Nothing},Ptr{UInt8},),env_.env,string(licensepath_))
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putlicensewait{T1}(env:: MSKenv,licwait:: T1)
    putlicensewait(env_:: MSKenv,licwait_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `licwait :: Int32`. Enable waiting for a license.

Control whether MOSEK should wait for an available license if no license is available. If `licwait` is non-zero, then MOSEK will wait for `licwait-1` milliseconds between each check for an available license.
"""
function putlicensewait end
putlicensewait(env:: MSKenv,licwait:: T1) where {T1} = putlicensewait(env,Int32(licwait))
function putlicensewait(env_:: MSKenv,licwait_:: Int32)
  res = disable_sigint() do
    @msk_ccall( "putlicensewait",Int32,(Ptr{Nothing},Int32,),env_.env,licwait_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

