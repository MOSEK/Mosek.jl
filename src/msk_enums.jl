# Contents of this file is generated. Do not edit by hand
# Target: Mosek 10.1.24
export
  Basindtype,
  MSK_BI_NEVER,
  MSK_BI_ALWAYS,
  MSK_BI_NO_ERROR,
  MSK_BI_IF_FEASIBLE,
  MSK_BI_RESERVERED,
  Boundkey,
  MSK_BK_LO,
  MSK_BK_UP,
  MSK_BK_FX,
  MSK_BK_FR,
  MSK_BK_RA,
  Mark,
  MSK_MARK_LO,
  MSK_MARK_UP,
  Simdegen,
  MSK_SIM_DEGEN_NONE,
  MSK_SIM_DEGEN_FREE,
  MSK_SIM_DEGEN_AGGRESSIVE,
  MSK_SIM_DEGEN_MODERATE,
  MSK_SIM_DEGEN_MINIMUM,
  Transpose,
  MSK_TRANSPOSE_NO,
  MSK_TRANSPOSE_YES,
  Uplo,
  MSK_UPLO_LO,
  MSK_UPLO_UP,
  Simreform,
  MSK_SIM_REFORMULATION_OFF,
  MSK_SIM_REFORMULATION_ON,
  MSK_SIM_REFORMULATION_FREE,
  MSK_SIM_REFORMULATION_AGGRESSIVE,
  Simdupvec,
  MSK_SIM_EXPLOIT_DUPVEC_OFF,
  MSK_SIM_EXPLOIT_DUPVEC_ON,
  MSK_SIM_EXPLOIT_DUPVEC_FREE,
  Simhotstart,
  MSK_SIM_HOTSTART_NONE,
  MSK_SIM_HOTSTART_FREE,
  MSK_SIM_HOTSTART_STATUS_KEYS,
  Intpnthotstart,
  MSK_INTPNT_HOTSTART_NONE,
  MSK_INTPNT_HOTSTART_PRIMAL,
  MSK_INTPNT_HOTSTART_DUAL,
  MSK_INTPNT_HOTSTART_PRIMAL_DUAL,
  Purify,
  MSK_PURIFY_NONE,
  MSK_PURIFY_PRIMAL,
  MSK_PURIFY_DUAL,
  MSK_PURIFY_PRIMAL_DUAL,
  MSK_PURIFY_AUTO,
  Callbackcode,
  MSK_CALLBACK_BEGIN_BI,
  MSK_CALLBACK_BEGIN_CONIC,
  MSK_CALLBACK_BEGIN_DUAL_BI,
  MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY,
  MSK_CALLBACK_BEGIN_DUAL_SETUP_BI,
  MSK_CALLBACK_BEGIN_DUAL_SIMPLEX,
  MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI,
  MSK_CALLBACK_BEGIN_INFEAS_ANA,
  MSK_CALLBACK_BEGIN_INTPNT,
  MSK_CALLBACK_BEGIN_LICENSE_WAIT,
  MSK_CALLBACK_BEGIN_MIO,
  MSK_CALLBACK_BEGIN_OPTIMIZER,
  MSK_CALLBACK_BEGIN_PRESOLVE,
  MSK_CALLBACK_BEGIN_PRIMAL_BI,
  MSK_CALLBACK_BEGIN_PRIMAL_REPAIR,
  MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY,
  MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI,
  MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX,
  MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI,
  MSK_CALLBACK_BEGIN_QCQO_REFORMULATE,
  MSK_CALLBACK_BEGIN_READ,
  MSK_CALLBACK_BEGIN_ROOT_CUTGEN,
  MSK_CALLBACK_BEGIN_SIMPLEX,
  MSK_CALLBACK_BEGIN_SIMPLEX_BI,
  MSK_CALLBACK_BEGIN_SOLVE_ROOT_RELAX,
  MSK_CALLBACK_BEGIN_TO_CONIC,
  MSK_CALLBACK_BEGIN_WRITE,
  MSK_CALLBACK_CONIC,
  MSK_CALLBACK_DUAL_SIMPLEX,
  MSK_CALLBACK_END_BI,
  MSK_CALLBACK_END_CONIC,
  MSK_CALLBACK_END_DUAL_BI,
  MSK_CALLBACK_END_DUAL_SENSITIVITY,
  MSK_CALLBACK_END_DUAL_SETUP_BI,
  MSK_CALLBACK_END_DUAL_SIMPLEX,
  MSK_CALLBACK_END_DUAL_SIMPLEX_BI,
  MSK_CALLBACK_END_INFEAS_ANA,
  MSK_CALLBACK_END_INTPNT,
  MSK_CALLBACK_END_LICENSE_WAIT,
  MSK_CALLBACK_END_MIO,
  MSK_CALLBACK_END_OPTIMIZER,
  MSK_CALLBACK_END_PRESOLVE,
  MSK_CALLBACK_END_PRIMAL_BI,
  MSK_CALLBACK_END_PRIMAL_REPAIR,
  MSK_CALLBACK_END_PRIMAL_SENSITIVITY,
  MSK_CALLBACK_END_PRIMAL_SETUP_BI,
  MSK_CALLBACK_END_PRIMAL_SIMPLEX,
  MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI,
  MSK_CALLBACK_END_QCQO_REFORMULATE,
  MSK_CALLBACK_END_READ,
  MSK_CALLBACK_END_ROOT_CUTGEN,
  MSK_CALLBACK_END_SIMPLEX,
  MSK_CALLBACK_END_SIMPLEX_BI,
  MSK_CALLBACK_END_SOLVE_ROOT_RELAX,
  MSK_CALLBACK_END_TO_CONIC,
  MSK_CALLBACK_END_WRITE,
  MSK_CALLBACK_IM_BI,
  MSK_CALLBACK_IM_CONIC,
  MSK_CALLBACK_IM_DUAL_BI,
  MSK_CALLBACK_IM_DUAL_SENSIVITY,
  MSK_CALLBACK_IM_DUAL_SIMPLEX,
  MSK_CALLBACK_IM_INTPNT,
  MSK_CALLBACK_IM_LICENSE_WAIT,
  MSK_CALLBACK_IM_LU,
  MSK_CALLBACK_IM_MIO,
  MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX,
  MSK_CALLBACK_IM_MIO_INTPNT,
  MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX,
  MSK_CALLBACK_IM_ORDER,
  MSK_CALLBACK_IM_PRESOLVE,
  MSK_CALLBACK_IM_PRIMAL_BI,
  MSK_CALLBACK_IM_PRIMAL_SENSIVITY,
  MSK_CALLBACK_IM_PRIMAL_SIMPLEX,
  MSK_CALLBACK_IM_QO_REFORMULATE,
  MSK_CALLBACK_IM_READ,
  MSK_CALLBACK_IM_ROOT_CUTGEN,
  MSK_CALLBACK_IM_SIMPLEX,
  MSK_CALLBACK_IM_SIMPLEX_BI,
  MSK_CALLBACK_INTPNT,
  MSK_CALLBACK_NEW_INT_MIO,
  MSK_CALLBACK_PRIMAL_SIMPLEX,
  MSK_CALLBACK_READ_OPF,
  MSK_CALLBACK_READ_OPF_SECTION,
  MSK_CALLBACK_RESTART_MIO,
  MSK_CALLBACK_SOLVING_REMOTE,
  MSK_CALLBACK_UPDATE_DUAL_BI,
  MSK_CALLBACK_UPDATE_DUAL_SIMPLEX,
  MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI,
  MSK_CALLBACK_UPDATE_PRESOLVE,
  MSK_CALLBACK_UPDATE_PRIMAL_BI,
  MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX,
  MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI,
  MSK_CALLBACK_UPDATE_SIMPLEX,
  MSK_CALLBACK_WRITE_OPF,
  Compresstype,
  MSK_COMPRESS_NONE,
  MSK_COMPRESS_FREE,
  MSK_COMPRESS_GZIP,
  MSK_COMPRESS_ZSTD,
  Conetype,
  MSK_CT_QUAD,
  MSK_CT_RQUAD,
  MSK_CT_PEXP,
  MSK_CT_DEXP,
  MSK_CT_PPOW,
  MSK_CT_DPOW,
  MSK_CT_ZERO,
  Domaintype,
  MSK_DOMAIN_R,
  MSK_DOMAIN_RZERO,
  MSK_DOMAIN_RPLUS,
  MSK_DOMAIN_RMINUS,
  MSK_DOMAIN_QUADRATIC_CONE,
  MSK_DOMAIN_RQUADRATIC_CONE,
  MSK_DOMAIN_PRIMAL_EXP_CONE,
  MSK_DOMAIN_DUAL_EXP_CONE,
  MSK_DOMAIN_PRIMAL_POWER_CONE,
  MSK_DOMAIN_DUAL_POWER_CONE,
  MSK_DOMAIN_PRIMAL_GEO_MEAN_CONE,
  MSK_DOMAIN_DUAL_GEO_MEAN_CONE,
  MSK_DOMAIN_SVEC_PSD_CONE,
  Nametype,
  MSK_NAME_TYPE_GEN,
  MSK_NAME_TYPE_MPS,
  MSK_NAME_TYPE_LP,
  Symmattype,
  MSK_SYMMAT_TYPE_SPARSE,
  Dataformat,
  MSK_DATA_FORMAT_EXTENSION,
  MSK_DATA_FORMAT_MPS,
  MSK_DATA_FORMAT_LP,
  MSK_DATA_FORMAT_OP,
  MSK_DATA_FORMAT_FREE_MPS,
  MSK_DATA_FORMAT_TASK,
  MSK_DATA_FORMAT_PTF,
  MSK_DATA_FORMAT_CB,
  MSK_DATA_FORMAT_JSON_TASK,
  Solformat,
  MSK_SOL_FORMAT_EXTENSION,
  MSK_SOL_FORMAT_B,
  MSK_SOL_FORMAT_TASK,
  MSK_SOL_FORMAT_JSON_TASK,
  Dinfitem,
  MSK_DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY,
  MSK_DINF_BI_CLEAN_DUAL_TIME,
  MSK_DINF_BI_CLEAN_PRIMAL_TIME,
  MSK_DINF_BI_CLEAN_TIME,
  MSK_DINF_BI_DUAL_TIME,
  MSK_DINF_BI_PRIMAL_TIME,
  MSK_DINF_BI_TIME,
  MSK_DINF_INTPNT_DUAL_FEAS,
  MSK_DINF_INTPNT_DUAL_OBJ,
  MSK_DINF_INTPNT_FACTOR_NUM_FLOPS,
  MSK_DINF_INTPNT_OPT_STATUS,
  MSK_DINF_INTPNT_ORDER_TIME,
  MSK_DINF_INTPNT_PRIMAL_FEAS,
  MSK_DINF_INTPNT_PRIMAL_OBJ,
  MSK_DINF_INTPNT_TIME,
  MSK_DINF_MIO_CLIQUE_SELECTION_TIME,
  MSK_DINF_MIO_CLIQUE_SEPARATION_TIME,
  MSK_DINF_MIO_CMIR_SELECTION_TIME,
  MSK_DINF_MIO_CMIR_SEPARATION_TIME,
  MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ,
  MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE,
  MSK_DINF_MIO_GMI_SELECTION_TIME,
  MSK_DINF_MIO_GMI_SEPARATION_TIME,
  MSK_DINF_MIO_IMPLIED_BOUND_SELECTION_TIME,
  MSK_DINF_MIO_IMPLIED_BOUND_SEPARATION_TIME,
  MSK_DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ,
  MSK_DINF_MIO_KNAPSACK_COVER_SELECTION_TIME,
  MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME,
  MSK_DINF_MIO_LIPRO_SELECTION_TIME,
  MSK_DINF_MIO_LIPRO_SEPARATION_TIME,
  MSK_DINF_MIO_OBJ_ABS_GAP,
  MSK_DINF_MIO_OBJ_BOUND,
  MSK_DINF_MIO_OBJ_INT,
  MSK_DINF_MIO_OBJ_REL_GAP,
  MSK_DINF_MIO_PROBING_TIME,
  MSK_DINF_MIO_ROOT_CUT_SELECTION_TIME,
  MSK_DINF_MIO_ROOT_CUT_SEPARATION_TIME,
  MSK_DINF_MIO_ROOT_OPTIMIZER_TIME,
  MSK_DINF_MIO_ROOT_PRESOLVE_TIME,
  MSK_DINF_MIO_ROOT_TIME,
  MSK_DINF_MIO_SYMMETRY_DETECTION_TIME,
  MSK_DINF_MIO_SYMMETRY_FACTOR,
  MSK_DINF_MIO_TIME,
  MSK_DINF_MIO_USER_OBJ_CUT,
  MSK_DINF_OPTIMIZER_TICKS,
  MSK_DINF_OPTIMIZER_TIME,
  MSK_DINF_PRESOLVE_ELI_TIME,
  MSK_DINF_PRESOLVE_LINDEP_TIME,
  MSK_DINF_PRESOLVE_TIME,
  MSK_DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION,
  MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ,
  MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION,
  MSK_DINF_QCQO_REFORMULATE_TIME,
  MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING,
  MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING,
  MSK_DINF_READ_DATA_TIME,
  MSK_DINF_REMOTE_TIME,
  MSK_DINF_SIM_DUAL_TIME,
  MSK_DINF_SIM_FEAS,
  MSK_DINF_SIM_OBJ,
  MSK_DINF_SIM_PRIMAL_TIME,
  MSK_DINF_SIM_TIME,
  MSK_DINF_SOL_BAS_DUAL_OBJ,
  MSK_DINF_SOL_BAS_DVIOLCON,
  MSK_DINF_SOL_BAS_DVIOLVAR,
  MSK_DINF_SOL_BAS_NRM_BARX,
  MSK_DINF_SOL_BAS_NRM_SLC,
  MSK_DINF_SOL_BAS_NRM_SLX,
  MSK_DINF_SOL_BAS_NRM_SUC,
  MSK_DINF_SOL_BAS_NRM_SUX,
  MSK_DINF_SOL_BAS_NRM_XC,
  MSK_DINF_SOL_BAS_NRM_XX,
  MSK_DINF_SOL_BAS_NRM_Y,
  MSK_DINF_SOL_BAS_PRIMAL_OBJ,
  MSK_DINF_SOL_BAS_PVIOLCON,
  MSK_DINF_SOL_BAS_PVIOLVAR,
  MSK_DINF_SOL_ITG_NRM_BARX,
  MSK_DINF_SOL_ITG_NRM_XC,
  MSK_DINF_SOL_ITG_NRM_XX,
  MSK_DINF_SOL_ITG_PRIMAL_OBJ,
  MSK_DINF_SOL_ITG_PVIOLACC,
  MSK_DINF_SOL_ITG_PVIOLBARVAR,
  MSK_DINF_SOL_ITG_PVIOLCON,
  MSK_DINF_SOL_ITG_PVIOLCONES,
  MSK_DINF_SOL_ITG_PVIOLDJC,
  MSK_DINF_SOL_ITG_PVIOLITG,
  MSK_DINF_SOL_ITG_PVIOLVAR,
  MSK_DINF_SOL_ITR_DUAL_OBJ,
  MSK_DINF_SOL_ITR_DVIOLACC,
  MSK_DINF_SOL_ITR_DVIOLBARVAR,
  MSK_DINF_SOL_ITR_DVIOLCON,
  MSK_DINF_SOL_ITR_DVIOLCONES,
  MSK_DINF_SOL_ITR_DVIOLVAR,
  MSK_DINF_SOL_ITR_NRM_BARS,
  MSK_DINF_SOL_ITR_NRM_BARX,
  MSK_DINF_SOL_ITR_NRM_SLC,
  MSK_DINF_SOL_ITR_NRM_SLX,
  MSK_DINF_SOL_ITR_NRM_SNX,
  MSK_DINF_SOL_ITR_NRM_SUC,
  MSK_DINF_SOL_ITR_NRM_SUX,
  MSK_DINF_SOL_ITR_NRM_XC,
  MSK_DINF_SOL_ITR_NRM_XX,
  MSK_DINF_SOL_ITR_NRM_Y,
  MSK_DINF_SOL_ITR_PRIMAL_OBJ,
  MSK_DINF_SOL_ITR_PVIOLACC,
  MSK_DINF_SOL_ITR_PVIOLBARVAR,
  MSK_DINF_SOL_ITR_PVIOLCON,
  MSK_DINF_SOL_ITR_PVIOLCONES,
  MSK_DINF_SOL_ITR_PVIOLVAR,
  MSK_DINF_TO_CONIC_TIME,
  MSK_DINF_WRITE_DATA_TIME,
  Feature,
  MSK_FEATURE_PTS,
  MSK_FEATURE_PTON,
  Dparam,
  MSK_DPAR_ANA_SOL_INFEAS_TOL,
  MSK_DPAR_BASIS_REL_TOL_S,
  MSK_DPAR_BASIS_TOL_S,
  MSK_DPAR_BASIS_TOL_X,
  MSK_DPAR_CHECK_CONVEXITY_REL_TOL,
  MSK_DPAR_DATA_SYM_MAT_TOL,
  MSK_DPAR_DATA_SYM_MAT_TOL_HUGE,
  MSK_DPAR_DATA_SYM_MAT_TOL_LARGE,
  MSK_DPAR_DATA_TOL_AIJ_HUGE,
  MSK_DPAR_DATA_TOL_AIJ_LARGE,
  MSK_DPAR_DATA_TOL_BOUND_INF,
  MSK_DPAR_DATA_TOL_BOUND_WRN,
  MSK_DPAR_DATA_TOL_C_HUGE,
  MSK_DPAR_DATA_TOL_CJ_LARGE,
  MSK_DPAR_DATA_TOL_QIJ,
  MSK_DPAR_DATA_TOL_X,
  MSK_DPAR_INTPNT_CO_TOL_DFEAS,
  MSK_DPAR_INTPNT_CO_TOL_INFEAS,
  MSK_DPAR_INTPNT_CO_TOL_MU_RED,
  MSK_DPAR_INTPNT_CO_TOL_NEAR_REL,
  MSK_DPAR_INTPNT_CO_TOL_PFEAS,
  MSK_DPAR_INTPNT_CO_TOL_REL_GAP,
  MSK_DPAR_INTPNT_QO_TOL_DFEAS,
  MSK_DPAR_INTPNT_QO_TOL_INFEAS,
  MSK_DPAR_INTPNT_QO_TOL_MU_RED,
  MSK_DPAR_INTPNT_QO_TOL_NEAR_REL,
  MSK_DPAR_INTPNT_QO_TOL_PFEAS,
  MSK_DPAR_INTPNT_QO_TOL_REL_GAP,
  MSK_DPAR_INTPNT_TOL_DFEAS,
  MSK_DPAR_INTPNT_TOL_DSAFE,
  MSK_DPAR_INTPNT_TOL_INFEAS,
  MSK_DPAR_INTPNT_TOL_MU_RED,
  MSK_DPAR_INTPNT_TOL_PATH,
  MSK_DPAR_INTPNT_TOL_PFEAS,
  MSK_DPAR_INTPNT_TOL_PSAFE,
  MSK_DPAR_INTPNT_TOL_REL_GAP,
  MSK_DPAR_INTPNT_TOL_REL_STEP,
  MSK_DPAR_INTPNT_TOL_STEP_SIZE,
  MSK_DPAR_LOWER_OBJ_CUT,
  MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH,
  MSK_DPAR_MIO_DJC_MAX_BIGM,
  MSK_DPAR_MIO_MAX_TIME,
  MSK_DPAR_MIO_REL_GAP_CONST,
  MSK_DPAR_MIO_TOL_ABS_GAP,
  MSK_DPAR_MIO_TOL_ABS_RELAX_INT,
  MSK_DPAR_MIO_TOL_FEAS,
  MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT,
  MSK_DPAR_MIO_TOL_REL_GAP,
  MSK_DPAR_OPTIMIZER_MAX_TICKS,
  MSK_DPAR_OPTIMIZER_MAX_TIME,
  MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP,
  MSK_DPAR_PRESOLVE_TOL_AIJ,
  MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION,
  MSK_DPAR_PRESOLVE_TOL_REL_LINDEP,
  MSK_DPAR_PRESOLVE_TOL_S,
  MSK_DPAR_PRESOLVE_TOL_X,
  MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL,
  MSK_DPAR_SEMIDEFINITE_TOL_APPROX,
  MSK_DPAR_SIM_LU_TOL_REL_PIV,
  MSK_DPAR_SIMPLEX_ABS_TOL_PIV,
  MSK_DPAR_UPPER_OBJ_CUT,
  MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH,
  Liinfitem,
  MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS,
  MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ,
  MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS,
  MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER,
  MSK_LIINF_BI_CLEAN_DUAL_ITER,
  MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER,
  MSK_LIINF_BI_CLEAN_PRIMAL_ITER,
  MSK_LIINF_BI_DUAL_ITER,
  MSK_LIINF_BI_PRIMAL_ITER,
  MSK_LIINF_INTPNT_FACTOR_NUM_NZ,
  MSK_LIINF_MIO_ANZ,
  MSK_LIINF_MIO_INTPNT_ITER,
  MSK_LIINF_MIO_NUM_DUAL_ILLPOSED_CER,
  MSK_LIINF_MIO_NUM_PRIM_ILLPOSED_CER,
  MSK_LIINF_MIO_PRESOLVED_ANZ,
  MSK_LIINF_MIO_SIMPLEX_ITER,
  MSK_LIINF_RD_NUMACC,
  MSK_LIINF_RD_NUMANZ,
  MSK_LIINF_RD_NUMDJC,
  MSK_LIINF_RD_NUMQNZ,
  MSK_LIINF_SIMPLEX_ITER,
  Iinfitem,
  MSK_IINF_ANA_PRO_NUM_CON,
  MSK_IINF_ANA_PRO_NUM_CON_EQ,
  MSK_IINF_ANA_PRO_NUM_CON_FR,
  MSK_IINF_ANA_PRO_NUM_CON_LO,
  MSK_IINF_ANA_PRO_NUM_CON_RA,
  MSK_IINF_ANA_PRO_NUM_CON_UP,
  MSK_IINF_ANA_PRO_NUM_VAR,
  MSK_IINF_ANA_PRO_NUM_VAR_BIN,
  MSK_IINF_ANA_PRO_NUM_VAR_CONT,
  MSK_IINF_ANA_PRO_NUM_VAR_EQ,
  MSK_IINF_ANA_PRO_NUM_VAR_FR,
  MSK_IINF_ANA_PRO_NUM_VAR_INT,
  MSK_IINF_ANA_PRO_NUM_VAR_LO,
  MSK_IINF_ANA_PRO_NUM_VAR_RA,
  MSK_IINF_ANA_PRO_NUM_VAR_UP,
  MSK_IINF_INTPNT_FACTOR_DIM_DENSE,
  MSK_IINF_INTPNT_ITER,
  MSK_IINF_INTPNT_NUM_THREADS,
  MSK_IINF_INTPNT_SOLVE_DUAL,
  MSK_IINF_MIO_ABSGAP_SATISFIED,
  MSK_IINF_MIO_CLIQUE_TABLE_SIZE,
  MSK_IINF_MIO_CONSTRUCT_SOLUTION,
  MSK_IINF_MIO_INITIAL_FEASIBLE_SOLUTION,
  MSK_IINF_MIO_NODE_DEPTH,
  MSK_IINF_MIO_NUM_ACTIVE_NODES,
  MSK_IINF_MIO_NUM_ACTIVE_ROOT_CUTS,
  MSK_IINF_MIO_NUM_BRANCH,
  MSK_IINF_MIO_NUM_INT_SOLUTIONS,
  MSK_IINF_MIO_NUM_RELAX,
  MSK_IINF_MIO_NUM_REPEATED_PRESOLVE,
  MSK_IINF_MIO_NUM_RESTARTS,
  MSK_IINF_MIO_NUM_ROOT_CUT_ROUNDS,
  MSK_IINF_MIO_NUM_SELECTED_CLIQUE_CUTS,
  MSK_IINF_MIO_NUM_SELECTED_CMIR_CUTS,
  MSK_IINF_MIO_NUM_SELECTED_GOMORY_CUTS,
  MSK_IINF_MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS,
  MSK_IINF_MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS,
  MSK_IINF_MIO_NUM_SELECTED_LIPRO_CUTS,
  MSK_IINF_MIO_NUM_SEPARATED_CLIQUE_CUTS,
  MSK_IINF_MIO_NUM_SEPARATED_CMIR_CUTS,
  MSK_IINF_MIO_NUM_SEPARATED_GOMORY_CUTS,
  MSK_IINF_MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS,
  MSK_IINF_MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS,
  MSK_IINF_MIO_NUM_SEPARATED_LIPRO_CUTS,
  MSK_IINF_MIO_NUM_SOLVED_NODES,
  MSK_IINF_MIO_NUMBIN,
  MSK_IINF_MIO_NUMBINCONEVAR,
  MSK_IINF_MIO_NUMCON,
  MSK_IINF_MIO_NUMCONE,
  MSK_IINF_MIO_NUMCONEVAR,
  MSK_IINF_MIO_NUMCONT,
  MSK_IINF_MIO_NUMCONTCONEVAR,
  MSK_IINF_MIO_NUMDEXPCONES,
  MSK_IINF_MIO_NUMDJC,
  MSK_IINF_MIO_NUMDPOWCONES,
  MSK_IINF_MIO_NUMINT,
  MSK_IINF_MIO_NUMINTCONEVAR,
  MSK_IINF_MIO_NUMPEXPCONES,
  MSK_IINF_MIO_NUMPPOWCONES,
  MSK_IINF_MIO_NUMQCONES,
  MSK_IINF_MIO_NUMRQCONES,
  MSK_IINF_MIO_NUMVAR,
  MSK_IINF_MIO_OBJ_BOUND_DEFINED,
  MSK_IINF_MIO_PRESOLVED_NUMBIN,
  MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR,
  MSK_IINF_MIO_PRESOLVED_NUMCON,
  MSK_IINF_MIO_PRESOLVED_NUMCONE,
  MSK_IINF_MIO_PRESOLVED_NUMCONEVAR,
  MSK_IINF_MIO_PRESOLVED_NUMCONT,
  MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR,
  MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES,
  MSK_IINF_MIO_PRESOLVED_NUMDJC,
  MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES,
  MSK_IINF_MIO_PRESOLVED_NUMINT,
  MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR,
  MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES,
  MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES,
  MSK_IINF_MIO_PRESOLVED_NUMQCONES,
  MSK_IINF_MIO_PRESOLVED_NUMRQCONES,
  MSK_IINF_MIO_PRESOLVED_NUMVAR,
  MSK_IINF_MIO_RELGAP_SATISFIED,
  MSK_IINF_MIO_TOTAL_NUM_SELECTED_CUTS,
  MSK_IINF_MIO_TOTAL_NUM_SEPARATED_CUTS,
  MSK_IINF_MIO_USER_OBJ_CUT,
  MSK_IINF_OPT_NUMCON,
  MSK_IINF_OPT_NUMVAR,
  MSK_IINF_OPTIMIZE_RESPONSE,
  MSK_IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS,
  MSK_IINF_PURIFY_DUAL_SUCCESS,
  MSK_IINF_PURIFY_PRIMAL_SUCCESS,
  MSK_IINF_RD_NUMBARVAR,
  MSK_IINF_RD_NUMCON,
  MSK_IINF_RD_NUMCONE,
  MSK_IINF_RD_NUMINTVAR,
  MSK_IINF_RD_NUMQ,
  MSK_IINF_RD_NUMVAR,
  MSK_IINF_RD_PROTYPE,
  MSK_IINF_SIM_DUAL_DEG_ITER,
  MSK_IINF_SIM_DUAL_HOTSTART,
  MSK_IINF_SIM_DUAL_HOTSTART_LU,
  MSK_IINF_SIM_DUAL_INF_ITER,
  MSK_IINF_SIM_DUAL_ITER,
  MSK_IINF_SIM_NUMCON,
  MSK_IINF_SIM_NUMVAR,
  MSK_IINF_SIM_PRIMAL_DEG_ITER,
  MSK_IINF_SIM_PRIMAL_HOTSTART,
  MSK_IINF_SIM_PRIMAL_HOTSTART_LU,
  MSK_IINF_SIM_PRIMAL_INF_ITER,
  MSK_IINF_SIM_PRIMAL_ITER,
  MSK_IINF_SIM_SOLVE_DUAL,
  MSK_IINF_SOL_BAS_PROSTA,
  MSK_IINF_SOL_BAS_SOLSTA,
  MSK_IINF_SOL_ITG_PROSTA,
  MSK_IINF_SOL_ITG_SOLSTA,
  MSK_IINF_SOL_ITR_PROSTA,
  MSK_IINF_SOL_ITR_SOLSTA,
  MSK_IINF_STO_NUM_A_REALLOC,
  Inftype,
  MSK_INF_DOU_TYPE,
  MSK_INF_INT_TYPE,
  MSK_INF_LINT_TYPE,
  Iomode,
  MSK_IOMODE_READ,
  MSK_IOMODE_WRITE,
  MSK_IOMODE_READWRITE,
  Iparam,
  MSK_IPAR_ANA_SOL_BASIS,
  MSK_IPAR_ANA_SOL_PRINT_VIOLATED,
  MSK_IPAR_AUTO_SORT_A_BEFORE_OPT,
  MSK_IPAR_AUTO_UPDATE_SOL_INFO,
  MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE,
  MSK_IPAR_BI_CLEAN_OPTIMIZER,
  MSK_IPAR_BI_IGNORE_MAX_ITER,
  MSK_IPAR_BI_IGNORE_NUM_ERROR,
  MSK_IPAR_BI_MAX_ITERATIONS,
  MSK_IPAR_CACHE_LICENSE,
  MSK_IPAR_COMPRESS_STATFILE,
  MSK_IPAR_INFEAS_GENERIC_NAMES,
  MSK_IPAR_INFEAS_PREFER_PRIMAL,
  MSK_IPAR_INFEAS_REPORT_AUTO,
  MSK_IPAR_INFEAS_REPORT_LEVEL,
  MSK_IPAR_INTPNT_BASIS,
  MSK_IPAR_INTPNT_DIFF_STEP,
  MSK_IPAR_INTPNT_HOTSTART,
  MSK_IPAR_INTPNT_MAX_ITERATIONS,
  MSK_IPAR_INTPNT_MAX_NUM_COR,
  MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS,
  MSK_IPAR_INTPNT_OFF_COL_TRH,
  MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS,
  MSK_IPAR_INTPNT_ORDER_METHOD,
  MSK_IPAR_INTPNT_PURIFY,
  MSK_IPAR_INTPNT_REGULARIZATION_USE,
  MSK_IPAR_INTPNT_SCALING,
  MSK_IPAR_INTPNT_SOLVE_FORM,
  MSK_IPAR_INTPNT_STARTING_POINT,
  MSK_IPAR_LICENSE_DEBUG,
  MSK_IPAR_LICENSE_PAUSE_TIME,
  MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS,
  MSK_IPAR_LICENSE_TRH_EXPIRY_WRN,
  MSK_IPAR_LICENSE_WAIT,
  MSK_IPAR_LOG,
  MSK_IPAR_LOG_ANA_PRO,
  MSK_IPAR_LOG_BI,
  MSK_IPAR_LOG_BI_FREQ,
  MSK_IPAR_LOG_CUT_SECOND_OPT,
  MSK_IPAR_LOG_EXPAND,
  MSK_IPAR_LOG_FEAS_REPAIR,
  MSK_IPAR_LOG_FILE,
  MSK_IPAR_LOG_INCLUDE_SUMMARY,
  MSK_IPAR_LOG_INFEAS_ANA,
  MSK_IPAR_LOG_INTPNT,
  MSK_IPAR_LOG_LOCAL_INFO,
  MSK_IPAR_LOG_MIO,
  MSK_IPAR_LOG_MIO_FREQ,
  MSK_IPAR_LOG_ORDER,
  MSK_IPAR_LOG_PRESOLVE,
  MSK_IPAR_LOG_RESPONSE,
  MSK_IPAR_LOG_SENSITIVITY,
  MSK_IPAR_LOG_SENSITIVITY_OPT,
  MSK_IPAR_LOG_SIM,
  MSK_IPAR_LOG_SIM_FREQ,
  MSK_IPAR_LOG_SIM_MINOR,
  MSK_IPAR_LOG_STORAGE,
  MSK_IPAR_MAX_NUM_WARNINGS,
  MSK_IPAR_MIO_BRANCH_DIR,
  MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION,
  MSK_IPAR_MIO_CONSTRUCT_SOL,
  MSK_IPAR_MIO_CUT_CLIQUE,
  MSK_IPAR_MIO_CUT_CMIR,
  MSK_IPAR_MIO_CUT_GMI,
  MSK_IPAR_MIO_CUT_IMPLIED_BOUND,
  MSK_IPAR_MIO_CUT_KNAPSACK_COVER,
  MSK_IPAR_MIO_CUT_LIPRO,
  MSK_IPAR_MIO_CUT_SELECTION_LEVEL,
  MSK_IPAR_MIO_DATA_PERMUTATION_METHOD,
  MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL,
  MSK_IPAR_MIO_FEASPUMP_LEVEL,
  MSK_IPAR_MIO_HEURISTIC_LEVEL,
  MSK_IPAR_MIO_MAX_NUM_BRANCHES,
  MSK_IPAR_MIO_MAX_NUM_RELAXS,
  MSK_IPAR_MIO_MAX_NUM_RESTARTS,
  MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS,
  MSK_IPAR_MIO_MAX_NUM_SOLUTIONS,
  MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL,
  MSK_IPAR_MIO_MIN_REL,
  MSK_IPAR_MIO_MODE,
  MSK_IPAR_MIO_NODE_OPTIMIZER,
  MSK_IPAR_MIO_NODE_SELECTION,
  MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL,
  MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE,
  MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE,
  MSK_IPAR_MIO_PROBING_LEVEL,
  MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT,
  MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD,
  MSK_IPAR_MIO_RINS_MAX_NODES,
  MSK_IPAR_MIO_ROOT_OPTIMIZER,
  MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL,
  MSK_IPAR_MIO_SEED,
  MSK_IPAR_MIO_SYMMETRY_LEVEL,
  MSK_IPAR_MIO_VAR_SELECTION,
  MSK_IPAR_MIO_VB_DETECTION_LEVEL,
  MSK_IPAR_MT_SPINCOUNT,
  MSK_IPAR_NG,
  MSK_IPAR_NUM_THREADS,
  MSK_IPAR_OPF_WRITE_HEADER,
  MSK_IPAR_OPF_WRITE_HINTS,
  MSK_IPAR_OPF_WRITE_LINE_LENGTH,
  MSK_IPAR_OPF_WRITE_PARAMETERS,
  MSK_IPAR_OPF_WRITE_PROBLEM,
  MSK_IPAR_OPF_WRITE_SOL_BAS,
  MSK_IPAR_OPF_WRITE_SOL_ITG,
  MSK_IPAR_OPF_WRITE_SOL_ITR,
  MSK_IPAR_OPF_WRITE_SOLUTIONS,
  MSK_IPAR_OPTIMIZER,
  MSK_IPAR_PARAM_READ_CASE_NAME,
  MSK_IPAR_PARAM_READ_IGN_ERROR,
  MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL,
  MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES,
  MSK_IPAR_PRESOLVE_LEVEL,
  MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH,
  MSK_IPAR_PRESOLVE_LINDEP_NEW,
  MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH,
  MSK_IPAR_PRESOLVE_LINDEP_USE,
  MSK_IPAR_PRESOLVE_MAX_NUM_PASS,
  MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS,
  MSK_IPAR_PRESOLVE_USE,
  MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER,
  MSK_IPAR_PTF_WRITE_PARAMETERS,
  MSK_IPAR_PTF_WRITE_SOLUTIONS,
  MSK_IPAR_PTF_WRITE_TRANSFORM,
  MSK_IPAR_READ_DEBUG,
  MSK_IPAR_READ_KEEP_FREE_CON,
  MSK_IPAR_READ_MPS_FORMAT,
  MSK_IPAR_READ_MPS_WIDTH,
  MSK_IPAR_READ_TASK_IGNORE_PARAM,
  MSK_IPAR_REMOTE_USE_COMPRESSION,
  MSK_IPAR_REMOVE_UNUSED_SOLUTIONS,
  MSK_IPAR_SENSITIVITY_ALL,
  MSK_IPAR_SENSITIVITY_OPTIMIZER,
  MSK_IPAR_SENSITIVITY_TYPE,
  MSK_IPAR_SIM_BASIS_FACTOR_USE,
  MSK_IPAR_SIM_DEGEN,
  MSK_IPAR_SIM_DETECT_PWL,
  MSK_IPAR_SIM_DUAL_CRASH,
  MSK_IPAR_SIM_DUAL_PHASEONE_METHOD,
  MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION,
  MSK_IPAR_SIM_DUAL_SELECTION,
  MSK_IPAR_SIM_EXPLOIT_DUPVEC,
  MSK_IPAR_SIM_HOTSTART,
  MSK_IPAR_SIM_HOTSTART_LU,
  MSK_IPAR_SIM_MAX_ITERATIONS,
  MSK_IPAR_SIM_MAX_NUM_SETBACKS,
  MSK_IPAR_SIM_NON_SINGULAR,
  MSK_IPAR_SIM_PRIMAL_CRASH,
  MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD,
  MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION,
  MSK_IPAR_SIM_PRIMAL_SELECTION,
  MSK_IPAR_SIM_REFACTOR_FREQ,
  MSK_IPAR_SIM_REFORMULATION,
  MSK_IPAR_SIM_SAVE_LU,
  MSK_IPAR_SIM_SCALING,
  MSK_IPAR_SIM_SCALING_METHOD,
  MSK_IPAR_SIM_SEED,
  MSK_IPAR_SIM_SOLVE_FORM,
  MSK_IPAR_SIM_STABILITY_PRIORITY,
  MSK_IPAR_SIM_SWITCH_OPTIMIZER,
  MSK_IPAR_SOL_FILTER_KEEP_BASIC,
  MSK_IPAR_SOL_FILTER_KEEP_RANGED,
  MSK_IPAR_SOL_READ_NAME_WIDTH,
  MSK_IPAR_SOL_READ_WIDTH,
  MSK_IPAR_SOLUTION_CALLBACK,
  MSK_IPAR_TIMING_LEVEL,
  MSK_IPAR_WRITE_BAS_CONSTRAINTS,
  MSK_IPAR_WRITE_BAS_HEAD,
  MSK_IPAR_WRITE_BAS_VARIABLES,
  MSK_IPAR_WRITE_COMPRESSION,
  MSK_IPAR_WRITE_DATA_PARAM,
  MSK_IPAR_WRITE_FREE_CON,
  MSK_IPAR_WRITE_GENERIC_NAMES,
  MSK_IPAR_WRITE_GENERIC_NAMES_IO,
  MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS,
  MSK_IPAR_WRITE_INT_CONSTRAINTS,
  MSK_IPAR_WRITE_INT_HEAD,
  MSK_IPAR_WRITE_INT_VARIABLES,
  MSK_IPAR_WRITE_JSON_INDENTATION,
  MSK_IPAR_WRITE_LP_FULL_OBJ,
  MSK_IPAR_WRITE_LP_LINE_WIDTH,
  MSK_IPAR_WRITE_MPS_FORMAT,
  MSK_IPAR_WRITE_MPS_INT,
  MSK_IPAR_WRITE_SOL_BARVARIABLES,
  MSK_IPAR_WRITE_SOL_CONSTRAINTS,
  MSK_IPAR_WRITE_SOL_HEAD,
  MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES,
  MSK_IPAR_WRITE_SOL_VARIABLES,
  MSK_IPAR_WRITE_TASK_INC_SOL,
  MSK_IPAR_WRITE_XML_MODE,
  Branchdir,
  MSK_BRANCH_DIR_FREE,
  MSK_BRANCH_DIR_UP,
  MSK_BRANCH_DIR_DOWN,
  MSK_BRANCH_DIR_NEAR,
  MSK_BRANCH_DIR_FAR,
  MSK_BRANCH_DIR_ROOT_LP,
  MSK_BRANCH_DIR_GUIDED,
  MSK_BRANCH_DIR_PSEUDOCOST,
  Miqcqoreformmethod,
  MSK_MIO_QCQO_REFORMULATION_METHOD_FREE,
  MSK_MIO_QCQO_REFORMULATION_METHOD_NONE,
  MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION,
  MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD,
  MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP,
  MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP,
  Miodatapermmethod,
  MSK_MIO_DATA_PERMUTATION_METHOD_NONE,
  MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT,
  MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM,
  Miocontsoltype,
  MSK_MIO_CONT_SOL_NONE,
  MSK_MIO_CONT_SOL_ROOT,
  MSK_MIO_CONT_SOL_ITG,
  MSK_MIO_CONT_SOL_ITG_REL,
  Miomode,
  MSK_MIO_MODE_IGNORED,
  MSK_MIO_MODE_SATISFIED,
  Mionodeseltype,
  MSK_MIO_NODE_SELECTION_FREE,
  MSK_MIO_NODE_SELECTION_FIRST,
  MSK_MIO_NODE_SELECTION_BEST,
  MSK_MIO_NODE_SELECTION_PSEUDO,
  Miovarseltype,
  MSK_MIO_VAR_SELECTION_FREE,
  MSK_MIO_VAR_SELECTION_PSEUDOCOST,
  MSK_MIO_VAR_SELECTION_STRONG,
  Mpsformat,
  MSK_MPS_FORMAT_STRICT,
  MSK_MPS_FORMAT_RELAXED,
  MSK_MPS_FORMAT_FREE,
  MSK_MPS_FORMAT_CPLEX,
  Objsense,
  MSK_OBJECTIVE_SENSE_MINIMIZE,
  MSK_OBJECTIVE_SENSE_MAXIMIZE,
  Onoffkey,
  MSK_OFF,
  MSK_ON,
  Optimizertype,
  MSK_OPTIMIZER_CONIC,
  MSK_OPTIMIZER_DUAL_SIMPLEX,
  MSK_OPTIMIZER_FREE,
  MSK_OPTIMIZER_FREE_SIMPLEX,
  MSK_OPTIMIZER_INTPNT,
  MSK_OPTIMIZER_MIXED_INT,
  MSK_OPTIMIZER_PRIMAL_SIMPLEX,
  Orderingtype,
  MSK_ORDER_METHOD_FREE,
  MSK_ORDER_METHOD_APPMINLOC,
  MSK_ORDER_METHOD_EXPERIMENTAL,
  MSK_ORDER_METHOD_TRY_GRAPHPAR,
  MSK_ORDER_METHOD_FORCE_GRAPHPAR,
  MSK_ORDER_METHOD_NONE,
  Presolvemode,
  MSK_PRESOLVE_MODE_OFF,
  MSK_PRESOLVE_MODE_ON,
  MSK_PRESOLVE_MODE_FREE,
  Parametertype,
  MSK_PAR_INVALID_TYPE,
  MSK_PAR_DOU_TYPE,
  MSK_PAR_INT_TYPE,
  MSK_PAR_STR_TYPE,
  Problemitem,
  MSK_PI_VAR,
  MSK_PI_CON,
  MSK_PI_CONE,
  Problemtype,
  MSK_PROBTYPE_LO,
  MSK_PROBTYPE_QO,
  MSK_PROBTYPE_QCQO,
  MSK_PROBTYPE_CONIC,
  MSK_PROBTYPE_MIXED,
  Prosta,
  MSK_PRO_STA_UNKNOWN,
  MSK_PRO_STA_PRIM_AND_DUAL_FEAS,
  MSK_PRO_STA_PRIM_FEAS,
  MSK_PRO_STA_DUAL_FEAS,
  MSK_PRO_STA_PRIM_INFEAS,
  MSK_PRO_STA_DUAL_INFEAS,
  MSK_PRO_STA_PRIM_AND_DUAL_INFEAS,
  MSK_PRO_STA_ILL_POSED,
  MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED,
  Xmlwriteroutputtype,
  MSK_WRITE_XML_MODE_ROW,
  MSK_WRITE_XML_MODE_COL,
  Rescode,
  MSK_RES_OK,
  MSK_RES_WRN_OPEN_PARAM_FILE,
  MSK_RES_WRN_LARGE_BOUND,
  MSK_RES_WRN_LARGE_LO_BOUND,
  MSK_RES_WRN_LARGE_UP_BOUND,
  MSK_RES_WRN_LARGE_CON_FX,
  MSK_RES_WRN_LARGE_CJ,
  MSK_RES_WRN_LARGE_AIJ,
  MSK_RES_WRN_ZERO_AIJ,
  MSK_RES_WRN_NAME_MAX_LEN,
  MSK_RES_WRN_SPAR_MAX_LEN,
  MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR,
  MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR,
  MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR,
  MSK_RES_WRN_LP_OLD_QUAD_FORMAT,
  MSK_RES_WRN_LP_DROP_VARIABLE,
  MSK_RES_WRN_NZ_IN_UPR_TRI,
  MSK_RES_WRN_DROPPED_NZ_QOBJ,
  MSK_RES_WRN_IGNORE_INTEGER,
  MSK_RES_WRN_NO_GLOBAL_OPTIMIZER,
  MSK_RES_WRN_MIO_INFEASIBLE_FINAL,
  MSK_RES_WRN_SOL_FILTER,
  MSK_RES_WRN_UNDEF_SOL_FILE_NAME,
  MSK_RES_WRN_SOL_FILE_IGNORED_CON,
  MSK_RES_WRN_SOL_FILE_IGNORED_VAR,
  MSK_RES_WRN_TOO_FEW_BASIS_VARS,
  MSK_RES_WRN_TOO_MANY_BASIS_VARS,
  MSK_RES_WRN_LICENSE_EXPIRE,
  MSK_RES_WRN_LICENSE_SERVER,
  MSK_RES_WRN_EMPTY_NAME,
  MSK_RES_WRN_USING_GENERIC_NAMES,
  MSK_RES_WRN_INVALID_MPS_NAME,
  MSK_RES_WRN_INVALID_MPS_OBJ_NAME,
  MSK_RES_WRN_LICENSE_FEATURE_EXPIRE,
  MSK_RES_WRN_PARAM_NAME_DOU,
  MSK_RES_WRN_PARAM_NAME_INT,
  MSK_RES_WRN_PARAM_NAME_STR,
  MSK_RES_WRN_PARAM_STR_VALUE,
  MSK_RES_WRN_PARAM_IGNORED_CMIO,
  MSK_RES_WRN_ZEROS_IN_SPARSE_ROW,
  MSK_RES_WRN_ZEROS_IN_SPARSE_COL,
  MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK,
  MSK_RES_WRN_ELIMINATOR_SPACE,
  MSK_RES_WRN_PRESOLVE_OUTOFSPACE,
  MSK_RES_WRN_PRESOLVE_PRIMAL_PERTUBATIONS,
  MSK_RES_WRN_WRITE_CHANGED_NAMES,
  MSK_RES_WRN_WRITE_DISCARDED_CFIX,
  MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES,
  MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES,
  MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES,
  MSK_RES_WRN_DUPLICATE_CONE_NAMES,
  MSK_RES_WRN_WRITE_LP_INVALID_VAR_NAMES,
  MSK_RES_WRN_WRITE_LP_DUPLICATE_VAR_NAMES,
  MSK_RES_WRN_WRITE_LP_INVALID_CON_NAMES,
  MSK_RES_WRN_WRITE_LP_DUPLICATE_CON_NAMES,
  MSK_RES_WRN_ANA_LARGE_BOUNDS,
  MSK_RES_WRN_ANA_C_ZERO,
  MSK_RES_WRN_ANA_EMPTY_COLS,
  MSK_RES_WRN_ANA_CLOSE_BOUNDS,
  MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS,
  MSK_RES_WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES,
  MSK_RES_WRN_NO_DUALIZER,
  MSK_RES_WRN_SYM_MAT_LARGE,
  MSK_RES_WRN_MODIFIED_DOUBLE_PARAMETER,
  MSK_RES_WRN_LARGE_FIJ,
  MSK_RES_ERR_LICENSE,
  MSK_RES_ERR_LICENSE_EXPIRED,
  MSK_RES_ERR_LICENSE_VERSION,
  MSK_RES_ERR_LICENSE_OLD_SERVER_VERSION,
  MSK_RES_ERR_SIZE_LICENSE,
  MSK_RES_ERR_PROB_LICENSE,
  MSK_RES_ERR_FILE_LICENSE,
  MSK_RES_ERR_MISSING_LICENSE_FILE,
  MSK_RES_ERR_SIZE_LICENSE_CON,
  MSK_RES_ERR_SIZE_LICENSE_VAR,
  MSK_RES_ERR_SIZE_LICENSE_INTVAR,
  MSK_RES_ERR_OPTIMIZER_LICENSE,
  MSK_RES_ERR_FLEXLM,
  MSK_RES_ERR_LICENSE_SERVER,
  MSK_RES_ERR_LICENSE_MAX,
  MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON,
  MSK_RES_ERR_LICENSE_FEATURE,
  MSK_RES_ERR_PLATFORM_NOT_LICENSED,
  MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE,
  MSK_RES_ERR_LICENSE_CANNOT_CONNECT,
  MSK_RES_ERR_LICENSE_INVALID_HOSTID,
  MSK_RES_ERR_LICENSE_SERVER_VERSION,
  MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT,
  MSK_RES_ERR_LICENSE_NO_SERVER_LINE,
  MSK_RES_ERR_OLDER_DLL,
  MSK_RES_ERR_NEWER_DLL,
  MSK_RES_ERR_LINK_FILE_DLL,
  MSK_RES_ERR_THREAD_MUTEX_INIT,
  MSK_RES_ERR_THREAD_MUTEX_LOCK,
  MSK_RES_ERR_THREAD_MUTEX_UNLOCK,
  MSK_RES_ERR_THREAD_CREATE,
  MSK_RES_ERR_THREAD_COND_INIT,
  MSK_RES_ERR_UNKNOWN,
  MSK_RES_ERR_SPACE,
  MSK_RES_ERR_FILE_OPEN,
  MSK_RES_ERR_FILE_READ,
  MSK_RES_ERR_FILE_WRITE,
  MSK_RES_ERR_DATA_FILE_EXT,
  MSK_RES_ERR_INVALID_FILE_NAME,
  MSK_RES_ERR_INVALID_SOL_FILE_NAME,
  MSK_RES_ERR_END_OF_FILE,
  MSK_RES_ERR_NULL_ENV,
  MSK_RES_ERR_NULL_TASK,
  MSK_RES_ERR_INVALID_STREAM,
  MSK_RES_ERR_NO_INIT_ENV,
  MSK_RES_ERR_INVALID_TASK,
  MSK_RES_ERR_NULL_POINTER,
  MSK_RES_ERR_LIVING_TASKS,
  MSK_RES_ERR_READ_GZIP,
  MSK_RES_ERR_READ_ZSTD,
  MSK_RES_ERR_BLANK_NAME,
  MSK_RES_ERR_DUP_NAME,
  MSK_RES_ERR_FORMAT_STRING,
  MSK_RES_ERR_SPARSITY_SPECIFICATION,
  MSK_RES_ERR_MISMATCHING_DIMENSION,
  MSK_RES_ERR_INVALID_OBJ_NAME,
  MSK_RES_ERR_INVALID_CON_NAME,
  MSK_RES_ERR_INVALID_VAR_NAME,
  MSK_RES_ERR_INVALID_CONE_NAME,
  MSK_RES_ERR_INVALID_BARVAR_NAME,
  MSK_RES_ERR_SPACE_LEAKING,
  MSK_RES_ERR_SPACE_NO_INFO,
  MSK_RES_ERR_DIMENSION_SPECIFICATION,
  MSK_RES_ERR_AXIS_NAME_SPECIFICATION,
  MSK_RES_ERR_READ_FORMAT,
  MSK_RES_ERR_MPS_FILE,
  MSK_RES_ERR_MPS_INV_FIELD,
  MSK_RES_ERR_MPS_INV_MARKER,
  MSK_RES_ERR_MPS_NULL_CON_NAME,
  MSK_RES_ERR_MPS_NULL_VAR_NAME,
  MSK_RES_ERR_MPS_UNDEF_CON_NAME,
  MSK_RES_ERR_MPS_UNDEF_VAR_NAME,
  MSK_RES_ERR_MPS_INVALID_CON_KEY,
  MSK_RES_ERR_MPS_INVALID_BOUND_KEY,
  MSK_RES_ERR_MPS_INVALID_SEC_NAME,
  MSK_RES_ERR_MPS_NO_OBJECTIVE,
  MSK_RES_ERR_MPS_SPLITTED_VAR,
  MSK_RES_ERR_MPS_MUL_CON_NAME,
  MSK_RES_ERR_MPS_MUL_QSEC,
  MSK_RES_ERR_MPS_MUL_QOBJ,
  MSK_RES_ERR_MPS_INV_SEC_ORDER,
  MSK_RES_ERR_MPS_MUL_CSEC,
  MSK_RES_ERR_MPS_CONE_TYPE,
  MSK_RES_ERR_MPS_CONE_OVERLAP,
  MSK_RES_ERR_MPS_CONE_REPEAT,
  MSK_RES_ERR_MPS_NON_SYMMETRIC_Q,
  MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT,
  MSK_RES_ERR_MPS_INVALID_OBJSENSE,
  MSK_RES_ERR_MPS_TAB_IN_FIELD2,
  MSK_RES_ERR_MPS_TAB_IN_FIELD3,
  MSK_RES_ERR_MPS_TAB_IN_FIELD5,
  MSK_RES_ERR_MPS_INVALID_OBJ_NAME,
  MSK_RES_ERR_MPS_INVALID_KEY,
  MSK_RES_ERR_MPS_INVALID_INDICATOR_CONSTRAINT,
  MSK_RES_ERR_MPS_INVALID_INDICATOR_VARIABLE,
  MSK_RES_ERR_MPS_INVALID_INDICATOR_VALUE,
  MSK_RES_ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT,
  MSK_RES_ERR_OPF_SYNTAX,
  MSK_RES_ERR_OPF_PREMATURE_EOF,
  MSK_RES_ERR_OPF_MISMATCHED_TAG,
  MSK_RES_ERR_OPF_DUPLICATE_BOUND,
  MSK_RES_ERR_OPF_DUPLICATE_CONSTRAINT_NAME,
  MSK_RES_ERR_OPF_INVALID_CONE_TYPE,
  MSK_RES_ERR_OPF_INCORRECT_TAG_PARAM,
  MSK_RES_ERR_OPF_INVALID_TAG,
  MSK_RES_ERR_OPF_DUPLICATE_CONE_ENTRY,
  MSK_RES_ERR_OPF_TOO_LARGE,
  MSK_RES_ERR_OPF_DUAL_INTEGER_SOLUTION,
  MSK_RES_ERR_LP_EMPTY,
  MSK_RES_ERR_WRITE_MPS_INVALID_NAME,
  MSK_RES_ERR_LP_INVALID_VAR_NAME,
  MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME,
  MSK_RES_ERR_LP_FILE_FORMAT,
  MSK_RES_ERR_LP_EXPECTED_NUMBER,
  MSK_RES_ERR_READ_LP_MISSING_END_TAG,
  MSK_RES_ERR_LP_INDICATOR_VAR,
  MSK_RES_ERR_LP_EXPECTED_OBJECTIVE,
  MSK_RES_ERR_LP_EXPECTED_CONSTRAINT_RELATION,
  MSK_RES_ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND,
  MSK_RES_ERR_LP_DUPLICATE_SECTION,
  MSK_RES_ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED,
  MSK_RES_ERR_WRITING_FILE,
  MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE,
  MSK_RES_ERR_JSON_SYNTAX,
  MSK_RES_ERR_JSON_STRING,
  MSK_RES_ERR_JSON_NUMBER_OVERFLOW,
  MSK_RES_ERR_JSON_FORMAT,
  MSK_RES_ERR_JSON_DATA,
  MSK_RES_ERR_JSON_MISSING_DATA,
  MSK_RES_ERR_PTF_INCOMPATIBILITY,
  MSK_RES_ERR_PTF_UNDEFINED_ITEM,
  MSK_RES_ERR_PTF_INCONSISTENCY,
  MSK_RES_ERR_PTF_FORMAT,
  MSK_RES_ERR_ARGUMENT_LENNEQ,
  MSK_RES_ERR_ARGUMENT_TYPE,
  MSK_RES_ERR_NUM_ARGUMENTS,
  MSK_RES_ERR_IN_ARGUMENT,
  MSK_RES_ERR_ARGUMENT_DIMENSION,
  MSK_RES_ERR_SHAPE_IS_TOO_LARGE,
  MSK_RES_ERR_INDEX_IS_TOO_SMALL,
  MSK_RES_ERR_INDEX_IS_TOO_LARGE,
  MSK_RES_ERR_INDEX_IS_NOT_UNIQUE,
  MSK_RES_ERR_PARAM_NAME,
  MSK_RES_ERR_PARAM_NAME_DOU,
  MSK_RES_ERR_PARAM_NAME_INT,
  MSK_RES_ERR_PARAM_NAME_STR,
  MSK_RES_ERR_PARAM_INDEX,
  MSK_RES_ERR_PARAM_IS_TOO_LARGE,
  MSK_RES_ERR_PARAM_IS_TOO_SMALL,
  MSK_RES_ERR_PARAM_VALUE_STR,
  MSK_RES_ERR_PARAM_TYPE,
  MSK_RES_ERR_INF_DOU_INDEX,
  MSK_RES_ERR_INF_INT_INDEX,
  MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL,
  MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE,
  MSK_RES_ERR_INF_LINT_INDEX,
  MSK_RES_ERR_ARG_IS_TOO_SMALL,
  MSK_RES_ERR_ARG_IS_TOO_LARGE,
  MSK_RES_ERR_INVALID_WHICHSOL,
  MSK_RES_ERR_INF_DOU_NAME,
  MSK_RES_ERR_INF_INT_NAME,
  MSK_RES_ERR_INF_TYPE,
  MSK_RES_ERR_INF_LINT_NAME,
  MSK_RES_ERR_INDEX,
  MSK_RES_ERR_WHICHSOL,
  MSK_RES_ERR_SOLITEM,
  MSK_RES_ERR_WHICHITEM_NOT_ALLOWED,
  MSK_RES_ERR_MAXNUMCON,
  MSK_RES_ERR_MAXNUMVAR,
  MSK_RES_ERR_MAXNUMBARVAR,
  MSK_RES_ERR_MAXNUMQNZ,
  MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ,
  MSK_RES_ERR_INVALID_IDX,
  MSK_RES_ERR_INVALID_MAX_NUM,
  MSK_RES_ERR_UNALLOWED_WHICHSOL,
  MSK_RES_ERR_NUMCONLIM,
  MSK_RES_ERR_NUMVARLIM,
  MSK_RES_ERR_TOO_SMALL_MAXNUMANZ,
  MSK_RES_ERR_INV_APTRE,
  MSK_RES_ERR_MUL_A_ELEMENT,
  MSK_RES_ERR_INV_BK,
  MSK_RES_ERR_INV_BKC,
  MSK_RES_ERR_INV_BKX,
  MSK_RES_ERR_INV_VAR_TYPE,
  MSK_RES_ERR_SOLVER_PROBTYPE,
  MSK_RES_ERR_OBJECTIVE_RANGE,
  MSK_RES_ERR_INV_RESCODE,
  MSK_RES_ERR_INV_IINF,
  MSK_RES_ERR_INV_LIINF,
  MSK_RES_ERR_INV_DINF,
  MSK_RES_ERR_BASIS,
  MSK_RES_ERR_INV_SKC,
  MSK_RES_ERR_INV_SKX,
  MSK_RES_ERR_INV_SK_STR,
  MSK_RES_ERR_INV_SK,
  MSK_RES_ERR_INV_CONE_TYPE_STR,
  MSK_RES_ERR_INV_CONE_TYPE,
  MSK_RES_ERR_INV_SKN,
  MSK_RES_ERR_INVALID_SURPLUS,
  MSK_RES_ERR_INV_NAME_ITEM,
  MSK_RES_ERR_PRO_ITEM,
  MSK_RES_ERR_INVALID_FORMAT_TYPE,
  MSK_RES_ERR_FIRSTI,
  MSK_RES_ERR_LASTI,
  MSK_RES_ERR_FIRSTJ,
  MSK_RES_ERR_LASTJ,
  MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL,
  MSK_RES_ERR_NONLINEAR_EQUALITY,
  MSK_RES_ERR_NONCONVEX,
  MSK_RES_ERR_NONLINEAR_RANGED,
  MSK_RES_ERR_CON_Q_NOT_PSD,
  MSK_RES_ERR_CON_Q_NOT_NSD,
  MSK_RES_ERR_OBJ_Q_NOT_PSD,
  MSK_RES_ERR_OBJ_Q_NOT_NSD,
  MSK_RES_ERR_ARGUMENT_PERM_ARRAY,
  MSK_RES_ERR_CONE_INDEX,
  MSK_RES_ERR_CONE_SIZE,
  MSK_RES_ERR_CONE_OVERLAP,
  MSK_RES_ERR_CONE_REP_VAR,
  MSK_RES_ERR_MAXNUMCONE,
  MSK_RES_ERR_CONE_TYPE,
  MSK_RES_ERR_CONE_TYPE_STR,
  MSK_RES_ERR_CONE_OVERLAP_APPEND,
  MSK_RES_ERR_REMOVE_CONE_VARIABLE,
  MSK_RES_ERR_APPENDING_TOO_BIG_CONE,
  MSK_RES_ERR_CONE_PARAMETER,
  MSK_RES_ERR_SOL_FILE_INVALID_NUMBER,
  MSK_RES_ERR_HUGE_C,
  MSK_RES_ERR_HUGE_AIJ,
  MSK_RES_ERR_DUPLICATE_AIJ,
  MSK_RES_ERR_LOWER_BOUND_IS_A_NAN,
  MSK_RES_ERR_UPPER_BOUND_IS_A_NAN,
  MSK_RES_ERR_INFINITE_BOUND,
  MSK_RES_ERR_INV_QOBJ_SUBI,
  MSK_RES_ERR_INV_QOBJ_SUBJ,
  MSK_RES_ERR_INV_QOBJ_VAL,
  MSK_RES_ERR_INV_QCON_SUBK,
  MSK_RES_ERR_INV_QCON_SUBI,
  MSK_RES_ERR_INV_QCON_SUBJ,
  MSK_RES_ERR_INV_QCON_VAL,
  MSK_RES_ERR_QCON_SUBI_TOO_SMALL,
  MSK_RES_ERR_QCON_SUBI_TOO_LARGE,
  MSK_RES_ERR_QOBJ_UPPER_TRIANGLE,
  MSK_RES_ERR_QCON_UPPER_TRIANGLE,
  MSK_RES_ERR_FIXED_BOUND_VALUES,
  MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE,
  MSK_RES_ERR_INVALID_OBJECTIVE_SENSE,
  MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE,
  MSK_RES_ERR_Y_IS_UNDEFINED,
  MSK_RES_ERR_NAN_IN_DOUBLE_DATA,
  MSK_RES_ERR_INF_IN_DOUBLE_DATA,
  MSK_RES_ERR_NAN_IN_BLC,
  MSK_RES_ERR_NAN_IN_BUC,
  MSK_RES_ERR_INVALID_CFIX,
  MSK_RES_ERR_NAN_IN_C,
  MSK_RES_ERR_NAN_IN_BLX,
  MSK_RES_ERR_NAN_IN_BUX,
  MSK_RES_ERR_INVALID_AIJ,
  MSK_RES_ERR_INVALID_CJ,
  MSK_RES_ERR_SYM_MAT_INVALID,
  MSK_RES_ERR_SYM_MAT_HUGE,
  MSK_RES_ERR_INV_PROBLEM,
  MSK_RES_ERR_MIXED_CONIC_AND_NL,
  MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM,
  MSK_RES_ERR_INV_OPTIMIZER,
  MSK_RES_ERR_MIO_NO_OPTIMIZER,
  MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE,
  MSK_RES_ERR_FINAL_SOLUTION,
  MSK_RES_ERR_FIRST,
  MSK_RES_ERR_LAST,
  MSK_RES_ERR_SLICE_SIZE,
  MSK_RES_ERR_NEGATIVE_SURPLUS,
  MSK_RES_ERR_NEGATIVE_APPEND,
  MSK_RES_ERR_POSTSOLVE,
  MSK_RES_ERR_OVERFLOW,
  MSK_RES_ERR_NO_BASIS_SOL,
  MSK_RES_ERR_BASIS_FACTOR,
  MSK_RES_ERR_BASIS_SINGULAR,
  MSK_RES_ERR_FACTOR,
  MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX,
  MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED,
  MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND,
  MSK_RES_ERR_REPAIR_INVALID_PROBLEM,
  MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED,
  MSK_RES_ERR_NAME_MAX_LEN,
  MSK_RES_ERR_NAME_IS_NULL,
  MSK_RES_ERR_INVALID_COMPRESSION,
  MSK_RES_ERR_INVALID_IOMODE,
  MSK_RES_ERR_NO_PRIMAL_INFEAS_CER,
  MSK_RES_ERR_NO_DUAL_INFEAS_CER,
  MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK,
  MSK_RES_ERR_INV_MARKI,
  MSK_RES_ERR_INV_MARKJ,
  MSK_RES_ERR_INV_NUMI,
  MSK_RES_ERR_INV_NUMJ,
  MSK_RES_ERR_TASK_INCOMPATIBLE,
  MSK_RES_ERR_TASK_INVALID,
  MSK_RES_ERR_TASK_WRITE,
  MSK_RES_ERR_LU_MAX_NUM_TRIES,
  MSK_RES_ERR_INVALID_UTF8,
  MSK_RES_ERR_INVALID_WCHAR,
  MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL,
  MSK_RES_ERR_NO_SNX_FOR_BAS_SOL,
  MSK_RES_ERR_INTERNAL,
  MSK_RES_ERR_API_ARRAY_TOO_SMALL,
  MSK_RES_ERR_API_CB_CONNECT,
  MSK_RES_ERR_API_FATAL_ERROR,
  MSK_RES_ERR_SEN_FORMAT,
  MSK_RES_ERR_SEN_UNDEF_NAME,
  MSK_RES_ERR_SEN_INDEX_RANGE,
  MSK_RES_ERR_SEN_BOUND_INVALID_UP,
  MSK_RES_ERR_SEN_BOUND_INVALID_LO,
  MSK_RES_ERR_SEN_INDEX_INVALID,
  MSK_RES_ERR_SEN_INVALID_REGEXP,
  MSK_RES_ERR_SEN_SOLUTION_STATUS,
  MSK_RES_ERR_SEN_NUMERICAL,
  MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE,
  MSK_RES_ERR_UNB_STEP_SIZE,
  MSK_RES_ERR_IDENTICAL_TASKS,
  MSK_RES_ERR_AD_INVALID_CODELIST,
  MSK_RES_ERR_INTERNAL_TEST_FAILED,
  MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE,
  MSK_RES_ERR_INVALID_AMPL_STUB,
  MSK_RES_ERR_INT64_TO_INT32_CAST,
  MSK_RES_ERR_SIZE_LICENSE_NUMCORES,
  MSK_RES_ERR_INFEAS_UNDEFINED,
  MSK_RES_ERR_NO_BARX_FOR_SOLUTION,
  MSK_RES_ERR_NO_BARS_FOR_SOLUTION,
  MSK_RES_ERR_BAR_VAR_DIM,
  MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX,
  MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX,
  MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR,
  MSK_RES_ERR_SYM_MAT_INVALID_VALUE,
  MSK_RES_ERR_SYM_MAT_DUPLICATE,
  MSK_RES_ERR_INVALID_SYM_MAT_DIM,
  MSK_RES_ERR_API_INTERNAL,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS,
  MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS,
  MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES,
  MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES,
  MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES,
  MSK_RES_ERR_DUPLICATE_CONE_NAMES,
  MSK_RES_ERR_DUPLICATE_DOMAIN_NAMES,
  MSK_RES_ERR_DUPLICATE_DJC_NAMES,
  MSK_RES_ERR_NON_UNIQUE_ARRAY,
  MSK_RES_ERR_ARGUMENT_IS_TOO_SMALL,
  MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE,
  MSK_RES_ERR_MIO_INTERNAL,
  MSK_RES_ERR_INVALID_PROBLEM_TYPE,
  MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS,
  MSK_RES_ERR_UPPER_TRIANGLE,
  MSK_RES_ERR_LAU_SINGULAR_MATRIX,
  MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE,
  MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX,
  MSK_RES_ERR_LAU_UNKNOWN,
  MSK_RES_ERR_LAU_ARG_M,
  MSK_RES_ERR_LAU_ARG_N,
  MSK_RES_ERR_LAU_ARG_K,
  MSK_RES_ERR_LAU_ARG_TRANSA,
  MSK_RES_ERR_LAU_ARG_TRANSB,
  MSK_RES_ERR_LAU_ARG_UPLO,
  MSK_RES_ERR_LAU_ARG_TRANS,
  MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX,
  MSK_RES_ERR_CBF_PARSE,
  MSK_RES_ERR_CBF_OBJ_SENSE,
  MSK_RES_ERR_CBF_NO_VARIABLES,
  MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS,
  MSK_RES_ERR_CBF_TOO_MANY_VARIABLES,
  MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED,
  MSK_RES_ERR_CBF_SYNTAX,
  MSK_RES_ERR_CBF_DUPLICATE_OBJ,
  MSK_RES_ERR_CBF_DUPLICATE_CON,
  MSK_RES_ERR_CBF_DUPLICATE_VAR,
  MSK_RES_ERR_CBF_DUPLICATE_INT,
  MSK_RES_ERR_CBF_INVALID_VAR_TYPE,
  MSK_RES_ERR_CBF_INVALID_CON_TYPE,
  MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION,
  MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD,
  MSK_RES_ERR_CBF_DUPLICATE_BCOORD,
  MSK_RES_ERR_CBF_DUPLICATE_ACOORD,
  MSK_RES_ERR_CBF_TOO_FEW_VARIABLES,
  MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS,
  MSK_RES_ERR_CBF_TOO_FEW_INTS,
  MSK_RES_ERR_CBF_TOO_MANY_INTS,
  MSK_RES_ERR_CBF_INVALID_INT_INDEX,
  MSK_RES_ERR_CBF_UNSUPPORTED,
  MSK_RES_ERR_CBF_DUPLICATE_PSDVAR,
  MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION,
  MSK_RES_ERR_CBF_TOO_FEW_PSDVAR,
  MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION,
  MSK_RES_ERR_CBF_DUPLICATE_POW_CONES,
  MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES,
  MSK_RES_ERR_CBF_INVALID_POWER,
  MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG,
  MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX,
  MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX,
  MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE,
  MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE,
  MSK_RES_ERR_CBF_POWER_CONE_MISMATCH,
  MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH,
  MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES,
  MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES,
  MSK_RES_ERR_CBF_INVALID_NUM_OBJACOORD,
  MSK_RES_ERR_CBF_INVALID_NUM_OBJFCOORD,
  MSK_RES_ERR_CBF_INVALID_NUM_ACOORD,
  MSK_RES_ERR_CBF_INVALID_NUM_BCOORD,
  MSK_RES_ERR_CBF_INVALID_NUM_FCOORD,
  MSK_RES_ERR_CBF_INVALID_NUM_HCOORD,
  MSK_RES_ERR_CBF_INVALID_NUM_DCOORD,
  MSK_RES_ERR_CBF_EXPECTED_A_KEYWORD,
  MSK_RES_ERR_CBF_INVALID_NUM_PSDCON,
  MSK_RES_ERR_CBF_DUPLICATE_PSDCON,
  MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_PSDCON,
  MSK_RES_ERR_CBF_INVALID_PSDCON_INDEX,
  MSK_RES_ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX,
  MSK_RES_ERR_CBF_INVALID_PSDCON_BLOCK_INDEX,
  MSK_RES_ERR_CBF_UNSUPPORTED_CHANGE,
  MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER,
  MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER,
  MSK_RES_ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE,
  MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD,
  MSK_RES_ERR_TOCONIC_CONSTRAINT_FX,
  MSK_RES_ERR_TOCONIC_CONSTRAINT_RA,
  MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC,
  MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD,
  MSK_RES_ERR_SERVER_CONNECT,
  MSK_RES_ERR_SERVER_PROTOCOL,
  MSK_RES_ERR_SERVER_STATUS,
  MSK_RES_ERR_SERVER_TOKEN,
  MSK_RES_ERR_SERVER_ADDRESS,
  MSK_RES_ERR_SERVER_CERTIFICATE,
  MSK_RES_ERR_SERVER_TLS_CLIENT,
  MSK_RES_ERR_SERVER_ACCESS_TOKEN,
  MSK_RES_ERR_SERVER_PROBLEM_SIZE,
  MSK_RES_ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX,
  MSK_RES_ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST,
  MSK_RES_ERR_DUPLICATE_FIJ,
  MSK_RES_ERR_INVALID_FIJ,
  MSK_RES_ERR_HUGE_FIJ,
  MSK_RES_ERR_INVALID_G,
  MSK_RES_ERR_INVALID_B,
  MSK_RES_ERR_DOMAIN_INVALID_INDEX,
  MSK_RES_ERR_DOMAIN_DIMENSION,
  MSK_RES_ERR_DOMAIN_DIMENSION_PSD,
  MSK_RES_ERR_NOT_POWER_DOMAIN,
  MSK_RES_ERR_DOMAIN_POWER_INVALID_ALPHA,
  MSK_RES_ERR_DOMAIN_POWER_NEGATIVE_ALPHA,
  MSK_RES_ERR_DOMAIN_POWER_NLEFT,
  MSK_RES_ERR_AFE_INVALID_INDEX,
  MSK_RES_ERR_ACC_INVALID_INDEX,
  MSK_RES_ERR_ACC_INVALID_ENTRY_INDEX,
  MSK_RES_ERR_ACC_AFE_DOMAIN_MISMATCH,
  MSK_RES_ERR_DJC_INVALID_INDEX,
  MSK_RES_ERR_DJC_UNSUPPORTED_DOMAIN_TYPE,
  MSK_RES_ERR_DJC_AFE_DOMAIN_MISMATCH,
  MSK_RES_ERR_DJC_INVALID_TERM_SIZE,
  MSK_RES_ERR_DJC_DOMAIN_TERMSIZE_MISMATCH,
  MSK_RES_ERR_DJC_TOTAL_NUM_TERMS_MISMATCH,
  MSK_RES_ERR_UNDEF_SOLUTION,
  MSK_RES_ERR_NO_DOTY,
  MSK_RES_TRM_MAX_ITERATIONS,
  MSK_RES_TRM_MAX_TIME,
  MSK_RES_TRM_OBJECTIVE_RANGE,
  MSK_RES_TRM_STALL,
  MSK_RES_TRM_USER_CALLBACK,
  MSK_RES_TRM_MIO_NUM_RELAXS,
  MSK_RES_TRM_MIO_NUM_BRANCHES,
  MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS,
  MSK_RES_TRM_MAX_NUM_SETBACKS,
  MSK_RES_TRM_NUMERICAL_PROBLEM,
  MSK_RES_TRM_LOST_RACE,
  MSK_RES_TRM_INTERNAL,
  MSK_RES_TRM_INTERNAL_STOP,
  Rescodetype,
  MSK_RESPONSE_OK,
  MSK_RESPONSE_WRN,
  MSK_RESPONSE_TRM,
  MSK_RESPONSE_ERR,
  MSK_RESPONSE_UNK,
  Scalingtype,
  MSK_SCALING_FREE,
  MSK_SCALING_NONE,
  Scalingmethod,
  MSK_SCALING_METHOD_POW2,
  MSK_SCALING_METHOD_FREE,
  Sensitivitytype,
  MSK_SENSITIVITY_TYPE_BASIS,
  Simseltype,
  MSK_SIM_SELECTION_FREE,
  MSK_SIM_SELECTION_FULL,
  MSK_SIM_SELECTION_ASE,
  MSK_SIM_SELECTION_DEVEX,
  MSK_SIM_SELECTION_SE,
  MSK_SIM_SELECTION_PARTIAL,
  Solitem,
  MSK_SOL_ITEM_XC,
  MSK_SOL_ITEM_XX,
  MSK_SOL_ITEM_Y,
  MSK_SOL_ITEM_SLC,
  MSK_SOL_ITEM_SUC,
  MSK_SOL_ITEM_SLX,
  MSK_SOL_ITEM_SUX,
  MSK_SOL_ITEM_SNX,
  Solsta,
  MSK_SOL_STA_UNKNOWN,
  MSK_SOL_STA_OPTIMAL,
  MSK_SOL_STA_PRIM_FEAS,
  MSK_SOL_STA_DUAL_FEAS,
  MSK_SOL_STA_PRIM_AND_DUAL_FEAS,
  MSK_SOL_STA_PRIM_INFEAS_CER,
  MSK_SOL_STA_DUAL_INFEAS_CER,
  MSK_SOL_STA_PRIM_ILLPOSED_CER,
  MSK_SOL_STA_DUAL_ILLPOSED_CER,
  MSK_SOL_STA_INTEGER_OPTIMAL,
  Soltype,
  MSK_SOL_ITR,
  MSK_SOL_BAS,
  MSK_SOL_ITG,
  Solveform,
  MSK_SOLVE_FREE,
  MSK_SOLVE_PRIMAL,
  MSK_SOLVE_DUAL,
  Sparam,
  MSK_SPAR_BAS_SOL_FILE_NAME,
  MSK_SPAR_DATA_FILE_NAME,
  MSK_SPAR_DEBUG_FILE_NAME,
  MSK_SPAR_INT_SOL_FILE_NAME,
  MSK_SPAR_ITR_SOL_FILE_NAME,
  MSK_SPAR_MIO_DEBUG_STRING,
  MSK_SPAR_PARAM_COMMENT_SIGN,
  MSK_SPAR_PARAM_READ_FILE_NAME,
  MSK_SPAR_PARAM_WRITE_FILE_NAME,
  MSK_SPAR_READ_MPS_BOU_NAME,
  MSK_SPAR_READ_MPS_OBJ_NAME,
  MSK_SPAR_READ_MPS_RAN_NAME,
  MSK_SPAR_READ_MPS_RHS_NAME,
  MSK_SPAR_REMOTE_OPTSERVER_HOST,
  MSK_SPAR_REMOTE_TLS_CERT,
  MSK_SPAR_REMOTE_TLS_CERT_PATH,
  MSK_SPAR_SENSITIVITY_FILE_NAME,
  MSK_SPAR_SENSITIVITY_RES_FILE_NAME,
  MSK_SPAR_SOL_FILTER_XC_LOW,
  MSK_SPAR_SOL_FILTER_XC_UPR,
  MSK_SPAR_SOL_FILTER_XX_LOW,
  MSK_SPAR_SOL_FILTER_XX_UPR,
  MSK_SPAR_STAT_KEY,
  MSK_SPAR_STAT_NAME,
  MSK_SPAR_WRITE_LP_GEN_VAR_NAME,
  Stakey,
  MSK_SK_UNK,
  MSK_SK_BAS,
  MSK_SK_SUPBAS,
  MSK_SK_LOW,
  MSK_SK_UPR,
  MSK_SK_FIX,
  MSK_SK_INF,
  Startpointtype,
  MSK_STARTING_POINT_FREE,
  MSK_STARTING_POINT_GUESS,
  MSK_STARTING_POINT_CONSTANT,
  Streamtype,
  MSK_STREAM_LOG,
  MSK_STREAM_MSG,
  MSK_STREAM_ERR,
  MSK_STREAM_WRN,
  Value,
  MSK_LICENSE_BUFFER_LENGTH,
  MSK_MAX_STR_LEN,
  Variabletype,
  MSK_VAR_TYPE_CONT,
  MSK_VAR_TYPE_INT

abstract type MosekEnum <: Integer end
Base.convert(::Type{Int32},c::T) where {T <: MosekEnum} = c.value
Base.broadcastable(c::T) where {T <: MosekEnum} = Ref(c)
Base.iterate(e::Type{T}) where {T <: MosekEnum} = (members(T)[1],2)
Base.iterate(e::Type{T},state::Int) where {T <: MosekEnum} = if state <= Base.length(T); (members(T)[state],state+1,state+1) else nothing end
Base.show(io::IO,v::T) where { T <: Mosek.MosekEnum } = print(io,tostr(v))

"""
    Basindtype

Basis identification

* `MSK_BI_NEVER`. Never do basis identification.
* `MSK_BI_ALWAYS`. Basis identification is always performed even if the interior-point optimizer terminates abnormally.
* `MSK_BI_NO_ERROR`. Basis identification is performed if the interior-point optimizer terminates without an error.
* `MSK_BI_IF_FEASIBLE`. Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible.
* `MSK_BI_RESERVERED`. Not currently in use.
"""
struct Basindtype <: MosekEnum
  value :: Int32
end # basindtype

"Never do basis identification."
const MSK_BI_NEVER = Basindtype(0)

"Basis identification is always performed even if the interior-point optimizer terminates abnormally."
const MSK_BI_ALWAYS = Basindtype(1)

"Basis identification is performed if the interior-point optimizer terminates without an error."
const MSK_BI_NO_ERROR = Basindtype(2)

"Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible."
const MSK_BI_IF_FEASIBLE = Basindtype(3)

"Not currently in use."
const MSK_BI_RESERVERED = Basindtype(4)
tostr(v::Basindtype) = if v.value == 0 "Mosek.MSK_BI_NEVER"
  elseif v.value == 1 "Mosek.MSK_BI_ALWAYS"
  elseif v.value == 2 "Mosek.MSK_BI_NO_ERROR"
  elseif v.value == 3 "Mosek.MSK_BI_IF_FEASIBLE"
  elseif v.value == 4 "Mosek.MSK_BI_RESERVERED"
  else "Mosek.Basindtype(?)"
  end
const Basindtype_members = Basindtype[
    MSK_BI_NEVER,
    MSK_BI_ALWAYS,
    MSK_BI_NO_ERROR,
    MSK_BI_IF_FEASIBLE,
    MSK_BI_RESERVERED ]
members(::Type{Basindtype}) = Basindtype_members
Base.length(::Type{Basindtype}) = 5
Base.convert(::Type{Int},x::Basindtype) = Int(x.value)
"""
    Boundkey

Bound keys

* `MSK_BK_LO`. The constraint or variable has a finite lower bound and an infinite upper bound.
* `MSK_BK_UP`. The constraint or variable has an infinite lower bound and an finite upper bound.
* `MSK_BK_FX`. The constraint or variable is fixed.
* `MSK_BK_FR`. The constraint or variable is free.
* `MSK_BK_RA`. The constraint or variable is ranged.
"""
struct Boundkey <: MosekEnum
  value :: Int32
end # boundkey

"The constraint or variable has a finite lower bound and an infinite upper bound."
const MSK_BK_LO = Boundkey(0)

"The constraint or variable has an infinite lower bound and an finite upper bound."
const MSK_BK_UP = Boundkey(1)

"The constraint or variable is fixed."
const MSK_BK_FX = Boundkey(2)

"The constraint or variable is free."
const MSK_BK_FR = Boundkey(3)

"The constraint or variable is ranged."
const MSK_BK_RA = Boundkey(4)
tostr(v::Boundkey) = if v.value == 0 "Mosek.MSK_BK_LO"
  elseif v.value == 1 "Mosek.MSK_BK_UP"
  elseif v.value == 2 "Mosek.MSK_BK_FX"
  elseif v.value == 3 "Mosek.MSK_BK_FR"
  elseif v.value == 4 "Mosek.MSK_BK_RA"
  else "Mosek.Boundkey(?)"
  end
const Boundkey_members = Boundkey[
    MSK_BK_LO,
    MSK_BK_UP,
    MSK_BK_FX,
    MSK_BK_FR,
    MSK_BK_RA ]
members(::Type{Boundkey}) = Boundkey_members
Base.length(::Type{Boundkey}) = 5
Base.convert(::Type{Int},x::Boundkey) = Int(x.value)
"""
    Mark

Mark

* `MSK_MARK_LO`. The lower bound is selected for sensitivity analysis.
* `MSK_MARK_UP`. The upper bound is selected for sensitivity analysis.
"""
struct Mark <: MosekEnum
  value :: Int32
end # mark

"The lower bound is selected for sensitivity analysis."
const MSK_MARK_LO = Mark(0)

"The upper bound is selected for sensitivity analysis."
const MSK_MARK_UP = Mark(1)
tostr(v::Mark) = if v.value == 0 "Mosek.MSK_MARK_LO"
  elseif v.value == 1 "Mosek.MSK_MARK_UP"
  else "Mosek.Mark(?)"
  end
const Mark_members = Mark[
    MSK_MARK_LO,
    MSK_MARK_UP ]
members(::Type{Mark}) = Mark_members
Base.length(::Type{Mark}) = 2
Base.convert(::Type{Int},x::Mark) = Int(x.value)
"""
    Simdegen

Degeneracy strategies

* `MSK_SIM_DEGEN_NONE`. The simplex optimizer should use no degeneration strategy.
* `MSK_SIM_DEGEN_FREE`. The simplex optimizer chooses the degeneration strategy.
* `MSK_SIM_DEGEN_AGGRESSIVE`. The simplex optimizer should use an aggressive degeneration strategy.
* `MSK_SIM_DEGEN_MODERATE`. The simplex optimizer should use a moderate degeneration strategy.
* `MSK_SIM_DEGEN_MINIMUM`. The simplex optimizer should use a minimum degeneration strategy.
"""
struct Simdegen <: MosekEnum
  value :: Int32
end # simdegen

"The simplex optimizer should use no degeneration strategy."
const MSK_SIM_DEGEN_NONE = Simdegen(0)

"The simplex optimizer chooses the degeneration strategy."
const MSK_SIM_DEGEN_FREE = Simdegen(1)

"The simplex optimizer should use an aggressive degeneration strategy."
const MSK_SIM_DEGEN_AGGRESSIVE = Simdegen(2)

"The simplex optimizer should use a moderate degeneration strategy."
const MSK_SIM_DEGEN_MODERATE = Simdegen(3)

"The simplex optimizer should use a minimum degeneration strategy."
const MSK_SIM_DEGEN_MINIMUM = Simdegen(4)
tostr(v::Simdegen) = if v.value == 0 "Mosek.MSK_SIM_DEGEN_NONE"
  elseif v.value == 1 "Mosek.MSK_SIM_DEGEN_FREE"
  elseif v.value == 2 "Mosek.MSK_SIM_DEGEN_AGGRESSIVE"
  elseif v.value == 3 "Mosek.MSK_SIM_DEGEN_MODERATE"
  elseif v.value == 4 "Mosek.MSK_SIM_DEGEN_MINIMUM"
  else "Mosek.Simdegen(?)"
  end
const Simdegen_members = Simdegen[
    MSK_SIM_DEGEN_NONE,
    MSK_SIM_DEGEN_FREE,
    MSK_SIM_DEGEN_AGGRESSIVE,
    MSK_SIM_DEGEN_MODERATE,
    MSK_SIM_DEGEN_MINIMUM ]
members(::Type{Simdegen}) = Simdegen_members
Base.length(::Type{Simdegen}) = 5
Base.convert(::Type{Int},x::Simdegen) = Int(x.value)
"""
    Transpose

Transposed matrix.

* `MSK_TRANSPOSE_NO`. No transpose is applied.
* `MSK_TRANSPOSE_YES`. A transpose is applied.
"""
struct Transpose <: MosekEnum
  value :: Int32
end # transpose

"No transpose is applied."
const MSK_TRANSPOSE_NO = Transpose(0)

"A transpose is applied."
const MSK_TRANSPOSE_YES = Transpose(1)
tostr(v::Transpose) = if v.value == 0 "Mosek.MSK_TRANSPOSE_NO"
  elseif v.value == 1 "Mosek.MSK_TRANSPOSE_YES"
  else "Mosek.Transpose(?)"
  end
const Transpose_members = Transpose[
    MSK_TRANSPOSE_NO,
    MSK_TRANSPOSE_YES ]
members(::Type{Transpose}) = Transpose_members
Base.length(::Type{Transpose}) = 2
Base.convert(::Type{Int},x::Transpose) = Int(x.value)
"""
    Uplo

Triangular part of a symmetric matrix.

* `MSK_UPLO_LO`. Lower part.
* `MSK_UPLO_UP`. Upper part.
"""
struct Uplo <: MosekEnum
  value :: Int32
end # uplo

"Lower part."
const MSK_UPLO_LO = Uplo(0)

"Upper part."
const MSK_UPLO_UP = Uplo(1)
tostr(v::Uplo) = if v.value == 0 "Mosek.MSK_UPLO_LO"
  elseif v.value == 1 "Mosek.MSK_UPLO_UP"
  else "Mosek.Uplo(?)"
  end
const Uplo_members = Uplo[
    MSK_UPLO_LO,
    MSK_UPLO_UP ]
members(::Type{Uplo}) = Uplo_members
Base.length(::Type{Uplo}) = 2
Base.convert(::Type{Int},x::Uplo) = Int(x.value)
"""
    Simreform

Problem reformulation.

* `MSK_SIM_REFORMULATION_OFF`. Disallow the simplex optimizer to reformulate the problem.
* `MSK_SIM_REFORMULATION_ON`. Allow the simplex optimizer to reformulate the problem.
* `MSK_SIM_REFORMULATION_FREE`. The simplex optimizer can choose freely.
* `MSK_SIM_REFORMULATION_AGGRESSIVE`. The simplex optimizer should use an aggressive reformulation strategy.
"""
struct Simreform <: MosekEnum
  value :: Int32
end # simreform

"Disallow the simplex optimizer to reformulate the problem."
const MSK_SIM_REFORMULATION_OFF = Simreform(0)

"Allow the simplex optimizer to reformulate the problem."
const MSK_SIM_REFORMULATION_ON = Simreform(1)

"The simplex optimizer can choose freely."
const MSK_SIM_REFORMULATION_FREE = Simreform(2)

"The simplex optimizer should use an aggressive reformulation strategy."
const MSK_SIM_REFORMULATION_AGGRESSIVE = Simreform(3)
tostr(v::Simreform) = if v.value == 0 "Mosek.MSK_SIM_REFORMULATION_OFF"
  elseif v.value == 1 "Mosek.MSK_SIM_REFORMULATION_ON"
  elseif v.value == 2 "Mosek.MSK_SIM_REFORMULATION_FREE"
  elseif v.value == 3 "Mosek.MSK_SIM_REFORMULATION_AGGRESSIVE"
  else "Mosek.Simreform(?)"
  end
const Simreform_members = Simreform[
    MSK_SIM_REFORMULATION_OFF,
    MSK_SIM_REFORMULATION_ON,
    MSK_SIM_REFORMULATION_FREE,
    MSK_SIM_REFORMULATION_AGGRESSIVE ]
members(::Type{Simreform}) = Simreform_members
Base.length(::Type{Simreform}) = 4
Base.convert(::Type{Int},x::Simreform) = Int(x.value)
"""
    Simdupvec

Exploit duplicate columns.

* `MSK_SIM_EXPLOIT_DUPVEC_OFF`. Disallow the simplex optimizer to exploit duplicated columns.
* `MSK_SIM_EXPLOIT_DUPVEC_ON`. Allow the simplex optimizer to exploit duplicated columns.
* `MSK_SIM_EXPLOIT_DUPVEC_FREE`. The simplex optimizer can choose freely.
"""
struct Simdupvec <: MosekEnum
  value :: Int32
end # simdupvec

"Disallow the simplex optimizer to exploit duplicated columns."
const MSK_SIM_EXPLOIT_DUPVEC_OFF = Simdupvec(0)

"Allow the simplex optimizer to exploit duplicated columns."
const MSK_SIM_EXPLOIT_DUPVEC_ON = Simdupvec(1)

"The simplex optimizer can choose freely."
const MSK_SIM_EXPLOIT_DUPVEC_FREE = Simdupvec(2)
tostr(v::Simdupvec) = if v.value == 0 "Mosek.MSK_SIM_EXPLOIT_DUPVEC_OFF"
  elseif v.value == 1 "Mosek.MSK_SIM_EXPLOIT_DUPVEC_ON"
  elseif v.value == 2 "Mosek.MSK_SIM_EXPLOIT_DUPVEC_FREE"
  else "Mosek.Simdupvec(?)"
  end
const Simdupvec_members = Simdupvec[
    MSK_SIM_EXPLOIT_DUPVEC_OFF,
    MSK_SIM_EXPLOIT_DUPVEC_ON,
    MSK_SIM_EXPLOIT_DUPVEC_FREE ]
members(::Type{Simdupvec}) = Simdupvec_members
Base.length(::Type{Simdupvec}) = 3
Base.convert(::Type{Int},x::Simdupvec) = Int(x.value)
"""
    Simhotstart

Hot-start type employed by the simplex optimizer

* `MSK_SIM_HOTSTART_NONE`. The simplex optimizer performs a coldstart.
* `MSK_SIM_HOTSTART_FREE`. The simplex optimize chooses the hot-start type.
* `MSK_SIM_HOTSTART_STATUS_KEYS`. Only the status keys of the constraints and variables are used to choose the type of hot-start.
"""
struct Simhotstart <: MosekEnum
  value :: Int32
end # simhotstart

"The simplex optimizer performs a coldstart."
const MSK_SIM_HOTSTART_NONE = Simhotstart(0)

"The simplex optimize chooses the hot-start type."
const MSK_SIM_HOTSTART_FREE = Simhotstart(1)

"Only the status keys of the constraints and variables are used to choose the type of hot-start."
const MSK_SIM_HOTSTART_STATUS_KEYS = Simhotstart(2)
tostr(v::Simhotstart) = if v.value == 0 "Mosek.MSK_SIM_HOTSTART_NONE"
  elseif v.value == 1 "Mosek.MSK_SIM_HOTSTART_FREE"
  elseif v.value == 2 "Mosek.MSK_SIM_HOTSTART_STATUS_KEYS"
  else "Mosek.Simhotstart(?)"
  end
const Simhotstart_members = Simhotstart[
    MSK_SIM_HOTSTART_NONE,
    MSK_SIM_HOTSTART_FREE,
    MSK_SIM_HOTSTART_STATUS_KEYS ]
members(::Type{Simhotstart}) = Simhotstart_members
Base.length(::Type{Simhotstart}) = 3
Base.convert(::Type{Int},x::Simhotstart) = Int(x.value)
"""
    Intpnthotstart

Hot-start type employed by the interior-point optimizers.

* `MSK_INTPNT_HOTSTART_NONE`. The interior-point optimizer performs a coldstart.
* `MSK_INTPNT_HOTSTART_PRIMAL`. The interior-point optimizer exploits the primal solution only.
* `MSK_INTPNT_HOTSTART_DUAL`. The interior-point optimizer exploits the dual solution only.
* `MSK_INTPNT_HOTSTART_PRIMAL_DUAL`. The interior-point optimizer exploits both the primal and dual solution.
"""
struct Intpnthotstart <: MosekEnum
  value :: Int32
end # intpnthotstart

"The interior-point optimizer performs a coldstart."
const MSK_INTPNT_HOTSTART_NONE = Intpnthotstart(0)

"The interior-point optimizer exploits the primal solution only."
const MSK_INTPNT_HOTSTART_PRIMAL = Intpnthotstart(1)

"The interior-point optimizer exploits the dual solution only."
const MSK_INTPNT_HOTSTART_DUAL = Intpnthotstart(2)

"The interior-point optimizer exploits both the primal and dual solution."
const MSK_INTPNT_HOTSTART_PRIMAL_DUAL = Intpnthotstart(3)
tostr(v::Intpnthotstart) = if v.value == 0 "Mosek.MSK_INTPNT_HOTSTART_NONE"
  elseif v.value == 1 "Mosek.MSK_INTPNT_HOTSTART_PRIMAL"
  elseif v.value == 2 "Mosek.MSK_INTPNT_HOTSTART_DUAL"
  elseif v.value == 3 "Mosek.MSK_INTPNT_HOTSTART_PRIMAL_DUAL"
  else "Mosek.Intpnthotstart(?)"
  end
const Intpnthotstart_members = Intpnthotstart[
    MSK_INTPNT_HOTSTART_NONE,
    MSK_INTPNT_HOTSTART_PRIMAL,
    MSK_INTPNT_HOTSTART_DUAL,
    MSK_INTPNT_HOTSTART_PRIMAL_DUAL ]
members(::Type{Intpnthotstart}) = Intpnthotstart_members
Base.length(::Type{Intpnthotstart}) = 4
Base.convert(::Type{Int},x::Intpnthotstart) = Int(x.value)
"""
    Purify

Solution purification employed optimizer.

* `MSK_PURIFY_NONE`. The optimizer performs no solution purification.
* `MSK_PURIFY_PRIMAL`. The optimizer purifies the primal solution.
* `MSK_PURIFY_DUAL`. The optimizer purifies the dual solution.
* `MSK_PURIFY_PRIMAL_DUAL`. The optimizer purifies both the primal and dual solution.
* `MSK_PURIFY_AUTO`. TBD
"""
struct Purify <: MosekEnum
  value :: Int32
end # purify

"The optimizer performs no solution purification."
const MSK_PURIFY_NONE = Purify(0)

"The optimizer purifies the primal solution."
const MSK_PURIFY_PRIMAL = Purify(1)

"The optimizer purifies the dual solution."
const MSK_PURIFY_DUAL = Purify(2)

"The optimizer purifies both the primal and dual solution."
const MSK_PURIFY_PRIMAL_DUAL = Purify(3)

"TBD"
const MSK_PURIFY_AUTO = Purify(4)
tostr(v::Purify) = if v.value == 0 "Mosek.MSK_PURIFY_NONE"
  elseif v.value == 1 "Mosek.MSK_PURIFY_PRIMAL"
  elseif v.value == 2 "Mosek.MSK_PURIFY_DUAL"
  elseif v.value == 3 "Mosek.MSK_PURIFY_PRIMAL_DUAL"
  elseif v.value == 4 "Mosek.MSK_PURIFY_AUTO"
  else "Mosek.Purify(?)"
  end
const Purify_members = Purify[
    MSK_PURIFY_NONE,
    MSK_PURIFY_PRIMAL,
    MSK_PURIFY_DUAL,
    MSK_PURIFY_PRIMAL_DUAL,
    MSK_PURIFY_AUTO ]
members(::Type{Purify}) = Purify_members
Base.length(::Type{Purify}) = 5
Base.convert(::Type{Int},x::Purify) = Int(x.value)
"""
    Callbackcode

Progress callback codes

* `MSK_CALLBACK_BEGIN_BI`. The basis identification procedure has been started.
* `MSK_CALLBACK_BEGIN_CONIC`. The callback function is called when the conic optimizer is started.
* `MSK_CALLBACK_BEGIN_DUAL_BI`. The callback function is called from within the basis identification procedure when the dual phase is started.
* `MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY`. Dual sensitivity analysis is started.
* `MSK_CALLBACK_BEGIN_DUAL_SETUP_BI`. The callback function is called when the dual BI phase is started.
* `MSK_CALLBACK_BEGIN_DUAL_SIMPLEX`. The callback function is called when the dual simplex optimizer started.
* `MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI`. The callback function is called from within the basis identification procedure when the dual simplex clean-up phase is started.
* `MSK_CALLBACK_BEGIN_INFEAS_ANA`. The callback function is called when the infeasibility analyzer is started.
* `MSK_CALLBACK_BEGIN_INTPNT`. The callback function is called when the interior-point optimizer is started.
* `MSK_CALLBACK_BEGIN_LICENSE_WAIT`. Begin waiting for license.
* `MSK_CALLBACK_BEGIN_MIO`. The callback function is called when the mixed-integer optimizer is started.
* `MSK_CALLBACK_BEGIN_OPTIMIZER`. The callback function is called when the optimizer is started.
* `MSK_CALLBACK_BEGIN_PRESOLVE`. The callback function is called when the presolve is started.
* `MSK_CALLBACK_BEGIN_PRIMAL_BI`. The callback function is called from within the basis identification procedure when the primal phase is started.
* `MSK_CALLBACK_BEGIN_PRIMAL_REPAIR`. Begin primal feasibility repair.
* `MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY`. Primal sensitivity analysis is started.
* `MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI`. The callback function is called when the primal BI setup is started.
* `MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX`. The callback function is called when the primal simplex optimizer is started.
* `MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI`. The callback function is called from within the basis identification procedure when the primal simplex clean-up phase is started.
* `MSK_CALLBACK_BEGIN_QCQO_REFORMULATE`. Begin QCQO reformulation.
* `MSK_CALLBACK_BEGIN_READ`. MOSEK has started reading a problem file.
* `MSK_CALLBACK_BEGIN_ROOT_CUTGEN`. The callback function is called when root cut generation is started.
* `MSK_CALLBACK_BEGIN_SIMPLEX`. The callback function is called when the simplex optimizer is started.
* `MSK_CALLBACK_BEGIN_SIMPLEX_BI`. The callback function is called from within the basis identification procedure when the simplex clean-up phase is started.
* `MSK_CALLBACK_BEGIN_SOLVE_ROOT_RELAX`. The callback function is called when solution of root relaxation is started.
* `MSK_CALLBACK_BEGIN_TO_CONIC`. Begin conic reformulation.
* `MSK_CALLBACK_BEGIN_WRITE`. MOSEK has started writing a problem file.
* `MSK_CALLBACK_CONIC`. The callback function is called from within the conic optimizer after the information database has been updated.
* `MSK_CALLBACK_DUAL_SIMPLEX`. The callback function is called from within the dual simplex optimizer.
* `MSK_CALLBACK_END_BI`. The callback function is called when the basis identification procedure is terminated.
* `MSK_CALLBACK_END_CONIC`. The callback function is called when the conic optimizer is terminated.
* `MSK_CALLBACK_END_DUAL_BI`. The callback function is called from within the basis identification procedure when the dual phase is terminated.
* `MSK_CALLBACK_END_DUAL_SENSITIVITY`. Dual sensitivity analysis is terminated.
* `MSK_CALLBACK_END_DUAL_SETUP_BI`. The callback function is called when the dual BI phase is terminated.
* `MSK_CALLBACK_END_DUAL_SIMPLEX`. The callback function is called when the dual simplex optimizer is terminated.
* `MSK_CALLBACK_END_DUAL_SIMPLEX_BI`. The callback function is called from within the basis identification procedure when the dual clean-up phase is terminated.
* `MSK_CALLBACK_END_INFEAS_ANA`. The callback function is called when the infeasibility analyzer is terminated.
* `MSK_CALLBACK_END_INTPNT`. The callback function is called when the interior-point optimizer is terminated.
* `MSK_CALLBACK_END_LICENSE_WAIT`. End waiting for license.
* `MSK_CALLBACK_END_MIO`. The callback function is called when the mixed-integer optimizer is terminated.
* `MSK_CALLBACK_END_OPTIMIZER`. The callback function is called when the optimizer is terminated.
* `MSK_CALLBACK_END_PRESOLVE`. The callback function is called when the presolve is completed.
* `MSK_CALLBACK_END_PRIMAL_BI`. The callback function is called from within the basis identification procedure when the primal phase is terminated.
* `MSK_CALLBACK_END_PRIMAL_REPAIR`. End primal feasibility repair.
* `MSK_CALLBACK_END_PRIMAL_SENSITIVITY`. Primal sensitivity analysis is terminated.
* `MSK_CALLBACK_END_PRIMAL_SETUP_BI`. The callback function is called when the primal BI setup is terminated.
* `MSK_CALLBACK_END_PRIMAL_SIMPLEX`. The callback function is called when the primal simplex optimizer is terminated.
* `MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI`. The callback function is called from within the basis identification procedure when the primal clean-up phase is terminated.
* `MSK_CALLBACK_END_QCQO_REFORMULATE`. End QCQO reformulation.
* `MSK_CALLBACK_END_READ`. MOSEK has finished reading a problem file.
* `MSK_CALLBACK_END_ROOT_CUTGEN`. The callback function is called when root cut generation is terminated.
* `MSK_CALLBACK_END_SIMPLEX`. The callback function is called when the simplex optimizer is terminated.
* `MSK_CALLBACK_END_SIMPLEX_BI`. The callback function is called from within the basis identification procedure when the simplex clean-up phase is terminated.
* `MSK_CALLBACK_END_SOLVE_ROOT_RELAX`. The callback function is called when solution of root relaxation is terminated.
* `MSK_CALLBACK_END_TO_CONIC`. End conic reformulation.
* `MSK_CALLBACK_END_WRITE`. MOSEK has finished writing a problem file.
* `MSK_CALLBACK_IM_BI`. The callback function is called from within the basis identification procedure at an intermediate point.
* `MSK_CALLBACK_IM_CONIC`. The callback function is called at an intermediate stage within the conic optimizer where the information database has not been updated.
* `MSK_CALLBACK_IM_DUAL_BI`. The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.
* `MSK_CALLBACK_IM_DUAL_SENSIVITY`. The callback function is called at an intermediate stage of the dual sensitivity analysis.
* `MSK_CALLBACK_IM_DUAL_SIMPLEX`. The callback function is called at an intermediate point in the dual simplex optimizer.
* `MSK_CALLBACK_IM_INTPNT`. The callback function is called at an intermediate stage within the interior-point optimizer where the information database has not been updated.
* `MSK_CALLBACK_IM_LICENSE_WAIT`. MOSEK is waiting for a license.
* `MSK_CALLBACK_IM_LU`. The callback function is called from within the LU factorization procedure at an intermediate point.
* `MSK_CALLBACK_IM_MIO`. The callback function is called at an intermediate point in the mixed-integer optimizer.
* `MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX`. The callback function is called at an intermediate point in the mixed-integer optimizer while running the dual simplex optimizer.
* `MSK_CALLBACK_IM_MIO_INTPNT`. The callback function is called at an intermediate point in the mixed-integer optimizer while running the interior-point optimizer.
* `MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX`. The callback function is called at an intermediate point in the mixed-integer optimizer while running the primal simplex optimizer.
* `MSK_CALLBACK_IM_ORDER`. The callback function is called from within the matrix ordering procedure at an intermediate point.
* `MSK_CALLBACK_IM_PRESOLVE`. The callback function is called from within the presolve procedure at an intermediate stage.
* `MSK_CALLBACK_IM_PRIMAL_BI`. The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.
* `MSK_CALLBACK_IM_PRIMAL_SENSIVITY`. The callback function is called at an intermediate stage of the primal sensitivity analysis.
* `MSK_CALLBACK_IM_PRIMAL_SIMPLEX`. The callback function is called at an intermediate point in the primal simplex optimizer.
* `MSK_CALLBACK_IM_QO_REFORMULATE`. The callback function is called at an intermediate stage of the conic quadratic reformulation.
* `MSK_CALLBACK_IM_READ`. Intermediate stage in reading.
* `MSK_CALLBACK_IM_ROOT_CUTGEN`. The callback is called from within root cut generation at an intermediate stage.
* `MSK_CALLBACK_IM_SIMPLEX`. The callback function is called from within the simplex optimizer at an intermediate point.
* `MSK_CALLBACK_IM_SIMPLEX_BI`. The callback function is called from within the basis identification procedure at an intermediate point in the simplex clean-up phase.
* `MSK_CALLBACK_INTPNT`. The callback function is called from within the interior-point optimizer after the information database has been updated.
* `MSK_CALLBACK_NEW_INT_MIO`. The callback function is called after a new integer solution has been located by the mixed-integer optimizer.
* `MSK_CALLBACK_PRIMAL_SIMPLEX`. The callback function is called from within the primal simplex optimizer.
* `MSK_CALLBACK_READ_OPF`. The callback function is called from the OPF reader.
* `MSK_CALLBACK_READ_OPF_SECTION`. A chunk of Q non-zeros has been read from a problem file.
* `MSK_CALLBACK_RESTART_MIO`. The callback function is called when the mixed-integer optimizer is restarted.
* `MSK_CALLBACK_SOLVING_REMOTE`. The callback function is called while the task is being solved on a remote server.
* `MSK_CALLBACK_UPDATE_DUAL_BI`. The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.
* `MSK_CALLBACK_UPDATE_DUAL_SIMPLEX`. The callback function is called in the dual simplex optimizer.
* `MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI`. The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase.
* `MSK_CALLBACK_UPDATE_PRESOLVE`. The callback function is called from within the presolve procedure.
* `MSK_CALLBACK_UPDATE_PRIMAL_BI`. The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.
* `MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX`. The callback function is called  in the primal simplex optimizer.
* `MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI`. The callback function is called from within the basis identification procedure at an intermediate point in the primal simplex clean-up phase.
* `MSK_CALLBACK_UPDATE_SIMPLEX`. The callback function is called from simplex optimizer.
* `MSK_CALLBACK_WRITE_OPF`. The callback function is called from the OPF writer.
"""
struct Callbackcode <: MosekEnum
  value :: Int32
end # callbackcode

"The basis identification procedure has been started."
const MSK_CALLBACK_BEGIN_BI = Callbackcode(0)

"The callback function is called when the conic optimizer is started."
const MSK_CALLBACK_BEGIN_CONIC = Callbackcode(1)

"The callback function is called from within the basis identification procedure when the dual phase is started."
const MSK_CALLBACK_BEGIN_DUAL_BI = Callbackcode(2)

"Dual sensitivity analysis is started."
const MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY = Callbackcode(3)

"The callback function is called when the dual BI phase is started."
const MSK_CALLBACK_BEGIN_DUAL_SETUP_BI = Callbackcode(4)

"The callback function is called when the dual simplex optimizer started."
const MSK_CALLBACK_BEGIN_DUAL_SIMPLEX = Callbackcode(5)

"The callback function is called from within the basis identification procedure when the dual simplex clean-up phase is started."
const MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI = Callbackcode(6)

"The callback function is called when the infeasibility analyzer is started."
const MSK_CALLBACK_BEGIN_INFEAS_ANA = Callbackcode(7)

"The callback function is called when the interior-point optimizer is started."
const MSK_CALLBACK_BEGIN_INTPNT = Callbackcode(8)

"Begin waiting for license."
const MSK_CALLBACK_BEGIN_LICENSE_WAIT = Callbackcode(9)

"The callback function is called when the mixed-integer optimizer is started."
const MSK_CALLBACK_BEGIN_MIO = Callbackcode(10)

"The callback function is called when the optimizer is started."
const MSK_CALLBACK_BEGIN_OPTIMIZER = Callbackcode(11)

"The callback function is called when the presolve is started."
const MSK_CALLBACK_BEGIN_PRESOLVE = Callbackcode(12)

"The callback function is called from within the basis identification procedure when the primal phase is started."
const MSK_CALLBACK_BEGIN_PRIMAL_BI = Callbackcode(13)

"Begin primal feasibility repair."
const MSK_CALLBACK_BEGIN_PRIMAL_REPAIR = Callbackcode(14)

"Primal sensitivity analysis is started."
const MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY = Callbackcode(15)

"The callback function is called when the primal BI setup is started."
const MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI = Callbackcode(16)

"The callback function is called when the primal simplex optimizer is started."
const MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX = Callbackcode(17)

"The callback function is called from within the basis identification procedure when the primal simplex clean-up phase is started."
const MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI = Callbackcode(18)

"Begin QCQO reformulation."
const MSK_CALLBACK_BEGIN_QCQO_REFORMULATE = Callbackcode(19)

"MOSEK has started reading a problem file."
const MSK_CALLBACK_BEGIN_READ = Callbackcode(20)

"The callback function is called when root cut generation is started."
const MSK_CALLBACK_BEGIN_ROOT_CUTGEN = Callbackcode(21)

"The callback function is called when the simplex optimizer is started."
const MSK_CALLBACK_BEGIN_SIMPLEX = Callbackcode(22)

"The callback function is called from within the basis identification procedure when the simplex clean-up phase is started."
const MSK_CALLBACK_BEGIN_SIMPLEX_BI = Callbackcode(23)

"The callback function is called when solution of root relaxation is started."
const MSK_CALLBACK_BEGIN_SOLVE_ROOT_RELAX = Callbackcode(24)

"Begin conic reformulation."
const MSK_CALLBACK_BEGIN_TO_CONIC = Callbackcode(25)

"MOSEK has started writing a problem file."
const MSK_CALLBACK_BEGIN_WRITE = Callbackcode(26)

"The callback function is called from within the conic optimizer after the information database has been updated."
const MSK_CALLBACK_CONIC = Callbackcode(27)

"The callback function is called from within the dual simplex optimizer."
const MSK_CALLBACK_DUAL_SIMPLEX = Callbackcode(28)

"The callback function is called when the basis identification procedure is terminated."
const MSK_CALLBACK_END_BI = Callbackcode(29)

"The callback function is called when the conic optimizer is terminated."
const MSK_CALLBACK_END_CONIC = Callbackcode(30)

"The callback function is called from within the basis identification procedure when the dual phase is terminated."
const MSK_CALLBACK_END_DUAL_BI = Callbackcode(31)

"Dual sensitivity analysis is terminated."
const MSK_CALLBACK_END_DUAL_SENSITIVITY = Callbackcode(32)

"The callback function is called when the dual BI phase is terminated."
const MSK_CALLBACK_END_DUAL_SETUP_BI = Callbackcode(33)

"The callback function is called when the dual simplex optimizer is terminated."
const MSK_CALLBACK_END_DUAL_SIMPLEX = Callbackcode(34)

"The callback function is called from within the basis identification procedure when the dual clean-up phase is terminated."
const MSK_CALLBACK_END_DUAL_SIMPLEX_BI = Callbackcode(35)

"The callback function is called when the infeasibility analyzer is terminated."
const MSK_CALLBACK_END_INFEAS_ANA = Callbackcode(36)

"The callback function is called when the interior-point optimizer is terminated."
const MSK_CALLBACK_END_INTPNT = Callbackcode(37)

"End waiting for license."
const MSK_CALLBACK_END_LICENSE_WAIT = Callbackcode(38)

"The callback function is called when the mixed-integer optimizer is terminated."
const MSK_CALLBACK_END_MIO = Callbackcode(39)

"The callback function is called when the optimizer is terminated."
const MSK_CALLBACK_END_OPTIMIZER = Callbackcode(40)

"The callback function is called when the presolve is completed."
const MSK_CALLBACK_END_PRESOLVE = Callbackcode(41)

"The callback function is called from within the basis identification procedure when the primal phase is terminated."
const MSK_CALLBACK_END_PRIMAL_BI = Callbackcode(42)

"End primal feasibility repair."
const MSK_CALLBACK_END_PRIMAL_REPAIR = Callbackcode(43)

"Primal sensitivity analysis is terminated."
const MSK_CALLBACK_END_PRIMAL_SENSITIVITY = Callbackcode(44)

"The callback function is called when the primal BI setup is terminated."
const MSK_CALLBACK_END_PRIMAL_SETUP_BI = Callbackcode(45)

"The callback function is called when the primal simplex optimizer is terminated."
const MSK_CALLBACK_END_PRIMAL_SIMPLEX = Callbackcode(46)

"The callback function is called from within the basis identification procedure when the primal clean-up phase is terminated."
const MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI = Callbackcode(47)

"End QCQO reformulation."
const MSK_CALLBACK_END_QCQO_REFORMULATE = Callbackcode(48)

"MOSEK has finished reading a problem file."
const MSK_CALLBACK_END_READ = Callbackcode(49)

"The callback function is called when root cut generation is terminated."
const MSK_CALLBACK_END_ROOT_CUTGEN = Callbackcode(50)

"The callback function is called when the simplex optimizer is terminated."
const MSK_CALLBACK_END_SIMPLEX = Callbackcode(51)

"The callback function is called from within the basis identification procedure when the simplex clean-up phase is terminated."
const MSK_CALLBACK_END_SIMPLEX_BI = Callbackcode(52)

"The callback function is called when solution of root relaxation is terminated."
const MSK_CALLBACK_END_SOLVE_ROOT_RELAX = Callbackcode(53)

"End conic reformulation."
const MSK_CALLBACK_END_TO_CONIC = Callbackcode(54)

"MOSEK has finished writing a problem file."
const MSK_CALLBACK_END_WRITE = Callbackcode(55)

"The callback function is called from within the basis identification procedure at an intermediate point."
const MSK_CALLBACK_IM_BI = Callbackcode(56)

"The callback function is called at an intermediate stage within the conic optimizer where the information database has not been updated."
const MSK_CALLBACK_IM_CONIC = Callbackcode(57)

"The callback function is called from within the basis identification procedure at an intermediate point in the dual phase."
const MSK_CALLBACK_IM_DUAL_BI = Callbackcode(58)

"The callback function is called at an intermediate stage of the dual sensitivity analysis."
const MSK_CALLBACK_IM_DUAL_SENSIVITY = Callbackcode(59)

"The callback function is called at an intermediate point in the dual simplex optimizer."
const MSK_CALLBACK_IM_DUAL_SIMPLEX = Callbackcode(60)

"The callback function is called at an intermediate stage within the interior-point optimizer where the information database has not been updated."
const MSK_CALLBACK_IM_INTPNT = Callbackcode(61)

"MOSEK is waiting for a license."
const MSK_CALLBACK_IM_LICENSE_WAIT = Callbackcode(62)

"The callback function is called from within the LU factorization procedure at an intermediate point."
const MSK_CALLBACK_IM_LU = Callbackcode(63)

"The callback function is called at an intermediate point in the mixed-integer optimizer."
const MSK_CALLBACK_IM_MIO = Callbackcode(64)

"The callback function is called at an intermediate point in the mixed-integer optimizer while running the dual simplex optimizer."
const MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX = Callbackcode(65)

"The callback function is called at an intermediate point in the mixed-integer optimizer while running the interior-point optimizer."
const MSK_CALLBACK_IM_MIO_INTPNT = Callbackcode(66)

"The callback function is called at an intermediate point in the mixed-integer optimizer while running the primal simplex optimizer."
const MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX = Callbackcode(67)

"The callback function is called from within the matrix ordering procedure at an intermediate point."
const MSK_CALLBACK_IM_ORDER = Callbackcode(68)

"The callback function is called from within the presolve procedure at an intermediate stage."
const MSK_CALLBACK_IM_PRESOLVE = Callbackcode(69)

"The callback function is called from within the basis identification procedure at an intermediate point in the primal phase."
const MSK_CALLBACK_IM_PRIMAL_BI = Callbackcode(70)

"The callback function is called at an intermediate stage of the primal sensitivity analysis."
const MSK_CALLBACK_IM_PRIMAL_SENSIVITY = Callbackcode(71)

"The callback function is called at an intermediate point in the primal simplex optimizer."
const MSK_CALLBACK_IM_PRIMAL_SIMPLEX = Callbackcode(72)

"The callback function is called at an intermediate stage of the conic quadratic reformulation."
const MSK_CALLBACK_IM_QO_REFORMULATE = Callbackcode(73)

"Intermediate stage in reading."
const MSK_CALLBACK_IM_READ = Callbackcode(74)

"The callback is called from within root cut generation at an intermediate stage."
const MSK_CALLBACK_IM_ROOT_CUTGEN = Callbackcode(75)

"The callback function is called from within the simplex optimizer at an intermediate point."
const MSK_CALLBACK_IM_SIMPLEX = Callbackcode(76)

"The callback function is called from within the basis identification procedure at an intermediate point in the simplex clean-up phase."
const MSK_CALLBACK_IM_SIMPLEX_BI = Callbackcode(77)

"The callback function is called from within the interior-point optimizer after the information database has been updated."
const MSK_CALLBACK_INTPNT = Callbackcode(78)

"The callback function is called after a new integer solution has been located by the mixed-integer optimizer."
const MSK_CALLBACK_NEW_INT_MIO = Callbackcode(79)

"The callback function is called from within the primal simplex optimizer."
const MSK_CALLBACK_PRIMAL_SIMPLEX = Callbackcode(80)

"The callback function is called from the OPF reader."
const MSK_CALLBACK_READ_OPF = Callbackcode(81)

"A chunk of Q non-zeros has been read from a problem file."
const MSK_CALLBACK_READ_OPF_SECTION = Callbackcode(82)

"The callback function is called when the mixed-integer optimizer is restarted."
const MSK_CALLBACK_RESTART_MIO = Callbackcode(83)

"The callback function is called while the task is being solved on a remote server."
const MSK_CALLBACK_SOLVING_REMOTE = Callbackcode(84)

"The callback function is called from within the basis identification procedure at an intermediate point in the dual phase."
const MSK_CALLBACK_UPDATE_DUAL_BI = Callbackcode(85)

"The callback function is called in the dual simplex optimizer."
const MSK_CALLBACK_UPDATE_DUAL_SIMPLEX = Callbackcode(86)

"The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase."
const MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI = Callbackcode(87)

"The callback function is called from within the presolve procedure."
const MSK_CALLBACK_UPDATE_PRESOLVE = Callbackcode(88)

"The callback function is called from within the basis identification procedure at an intermediate point in the primal phase."
const MSK_CALLBACK_UPDATE_PRIMAL_BI = Callbackcode(89)

"The callback function is called  in the primal simplex optimizer."
const MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX = Callbackcode(90)

"The callback function is called from within the basis identification procedure at an intermediate point in the primal simplex clean-up phase."
const MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI = Callbackcode(91)

"The callback function is called from simplex optimizer."
const MSK_CALLBACK_UPDATE_SIMPLEX = Callbackcode(92)

"The callback function is called from the OPF writer."
const MSK_CALLBACK_WRITE_OPF = Callbackcode(93)
tostr(v::Callbackcode) = if v.value == 0 "Mosek.MSK_CALLBACK_BEGIN_BI"
  elseif v.value == 1 "Mosek.MSK_CALLBACK_BEGIN_CONIC"
  elseif v.value == 2 "Mosek.MSK_CALLBACK_BEGIN_DUAL_BI"
  elseif v.value == 3 "Mosek.MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY"
  elseif v.value == 4 "Mosek.MSK_CALLBACK_BEGIN_DUAL_SETUP_BI"
  elseif v.value == 5 "Mosek.MSK_CALLBACK_BEGIN_DUAL_SIMPLEX"
  elseif v.value == 6 "Mosek.MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI"
  elseif v.value == 7 "Mosek.MSK_CALLBACK_BEGIN_INFEAS_ANA"
  elseif v.value == 8 "Mosek.MSK_CALLBACK_BEGIN_INTPNT"
  elseif v.value == 9 "Mosek.MSK_CALLBACK_BEGIN_LICENSE_WAIT"
  elseif v.value == 10 "Mosek.MSK_CALLBACK_BEGIN_MIO"
  elseif v.value == 11 "Mosek.MSK_CALLBACK_BEGIN_OPTIMIZER"
  elseif v.value == 12 "Mosek.MSK_CALLBACK_BEGIN_PRESOLVE"
  elseif v.value == 13 "Mosek.MSK_CALLBACK_BEGIN_PRIMAL_BI"
  elseif v.value == 14 "Mosek.MSK_CALLBACK_BEGIN_PRIMAL_REPAIR"
  elseif v.value == 15 "Mosek.MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY"
  elseif v.value == 16 "Mosek.MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI"
  elseif v.value == 17 "Mosek.MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX"
  elseif v.value == 18 "Mosek.MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI"
  elseif v.value == 19 "Mosek.MSK_CALLBACK_BEGIN_QCQO_REFORMULATE"
  elseif v.value == 20 "Mosek.MSK_CALLBACK_BEGIN_READ"
  elseif v.value == 21 "Mosek.MSK_CALLBACK_BEGIN_ROOT_CUTGEN"
  elseif v.value == 22 "Mosek.MSK_CALLBACK_BEGIN_SIMPLEX"
  elseif v.value == 23 "Mosek.MSK_CALLBACK_BEGIN_SIMPLEX_BI"
  elseif v.value == 24 "Mosek.MSK_CALLBACK_BEGIN_SOLVE_ROOT_RELAX"
  elseif v.value == 25 "Mosek.MSK_CALLBACK_BEGIN_TO_CONIC"
  elseif v.value == 26 "Mosek.MSK_CALLBACK_BEGIN_WRITE"
  elseif v.value == 27 "Mosek.MSK_CALLBACK_CONIC"
  elseif v.value == 28 "Mosek.MSK_CALLBACK_DUAL_SIMPLEX"
  elseif v.value == 29 "Mosek.MSK_CALLBACK_END_BI"
  elseif v.value == 30 "Mosek.MSK_CALLBACK_END_CONIC"
  elseif v.value == 31 "Mosek.MSK_CALLBACK_END_DUAL_BI"
  elseif v.value == 32 "Mosek.MSK_CALLBACK_END_DUAL_SENSITIVITY"
  elseif v.value == 33 "Mosek.MSK_CALLBACK_END_DUAL_SETUP_BI"
  elseif v.value == 34 "Mosek.MSK_CALLBACK_END_DUAL_SIMPLEX"
  elseif v.value == 35 "Mosek.MSK_CALLBACK_END_DUAL_SIMPLEX_BI"
  elseif v.value == 36 "Mosek.MSK_CALLBACK_END_INFEAS_ANA"
  elseif v.value == 37 "Mosek.MSK_CALLBACK_END_INTPNT"
  elseif v.value == 38 "Mosek.MSK_CALLBACK_END_LICENSE_WAIT"
  elseif v.value == 39 "Mosek.MSK_CALLBACK_END_MIO"
  elseif v.value == 40 "Mosek.MSK_CALLBACK_END_OPTIMIZER"
  elseif v.value == 41 "Mosek.MSK_CALLBACK_END_PRESOLVE"
  elseif v.value == 42 "Mosek.MSK_CALLBACK_END_PRIMAL_BI"
  elseif v.value == 43 "Mosek.MSK_CALLBACK_END_PRIMAL_REPAIR"
  elseif v.value == 44 "Mosek.MSK_CALLBACK_END_PRIMAL_SENSITIVITY"
  elseif v.value == 45 "Mosek.MSK_CALLBACK_END_PRIMAL_SETUP_BI"
  elseif v.value == 46 "Mosek.MSK_CALLBACK_END_PRIMAL_SIMPLEX"
  elseif v.value == 47 "Mosek.MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI"
  elseif v.value == 48 "Mosek.MSK_CALLBACK_END_QCQO_REFORMULATE"
  elseif v.value == 49 "Mosek.MSK_CALLBACK_END_READ"
  elseif v.value == 50 "Mosek.MSK_CALLBACK_END_ROOT_CUTGEN"
  elseif v.value == 51 "Mosek.MSK_CALLBACK_END_SIMPLEX"
  elseif v.value == 52 "Mosek.MSK_CALLBACK_END_SIMPLEX_BI"
  elseif v.value == 53 "Mosek.MSK_CALLBACK_END_SOLVE_ROOT_RELAX"
  elseif v.value == 54 "Mosek.MSK_CALLBACK_END_TO_CONIC"
  elseif v.value == 55 "Mosek.MSK_CALLBACK_END_WRITE"
  elseif v.value == 56 "Mosek.MSK_CALLBACK_IM_BI"
  elseif v.value == 57 "Mosek.MSK_CALLBACK_IM_CONIC"
  elseif v.value == 58 "Mosek.MSK_CALLBACK_IM_DUAL_BI"
  elseif v.value == 59 "Mosek.MSK_CALLBACK_IM_DUAL_SENSIVITY"
  elseif v.value == 60 "Mosek.MSK_CALLBACK_IM_DUAL_SIMPLEX"
  elseif v.value == 61 "Mosek.MSK_CALLBACK_IM_INTPNT"
  elseif v.value == 62 "Mosek.MSK_CALLBACK_IM_LICENSE_WAIT"
  elseif v.value == 63 "Mosek.MSK_CALLBACK_IM_LU"
  elseif v.value == 64 "Mosek.MSK_CALLBACK_IM_MIO"
  elseif v.value == 65 "Mosek.MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX"
  elseif v.value == 66 "Mosek.MSK_CALLBACK_IM_MIO_INTPNT"
  elseif v.value == 67 "Mosek.MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX"
  elseif v.value == 68 "Mosek.MSK_CALLBACK_IM_ORDER"
  elseif v.value == 69 "Mosek.MSK_CALLBACK_IM_PRESOLVE"
  elseif v.value == 70 "Mosek.MSK_CALLBACK_IM_PRIMAL_BI"
  elseif v.value == 71 "Mosek.MSK_CALLBACK_IM_PRIMAL_SENSIVITY"
  elseif v.value == 72 "Mosek.MSK_CALLBACK_IM_PRIMAL_SIMPLEX"
  elseif v.value == 73 "Mosek.MSK_CALLBACK_IM_QO_REFORMULATE"
  elseif v.value == 74 "Mosek.MSK_CALLBACK_IM_READ"
  elseif v.value == 75 "Mosek.MSK_CALLBACK_IM_ROOT_CUTGEN"
  elseif v.value == 76 "Mosek.MSK_CALLBACK_IM_SIMPLEX"
  elseif v.value == 77 "Mosek.MSK_CALLBACK_IM_SIMPLEX_BI"
  elseif v.value == 78 "Mosek.MSK_CALLBACK_INTPNT"
  elseif v.value == 79 "Mosek.MSK_CALLBACK_NEW_INT_MIO"
  elseif v.value == 80 "Mosek.MSK_CALLBACK_PRIMAL_SIMPLEX"
  elseif v.value == 81 "Mosek.MSK_CALLBACK_READ_OPF"
  elseif v.value == 82 "Mosek.MSK_CALLBACK_READ_OPF_SECTION"
  elseif v.value == 83 "Mosek.MSK_CALLBACK_RESTART_MIO"
  elseif v.value == 84 "Mosek.MSK_CALLBACK_SOLVING_REMOTE"
  elseif v.value == 85 "Mosek.MSK_CALLBACK_UPDATE_DUAL_BI"
  elseif v.value == 86 "Mosek.MSK_CALLBACK_UPDATE_DUAL_SIMPLEX"
  elseif v.value == 87 "Mosek.MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI"
  elseif v.value == 88 "Mosek.MSK_CALLBACK_UPDATE_PRESOLVE"
  elseif v.value == 89 "Mosek.MSK_CALLBACK_UPDATE_PRIMAL_BI"
  elseif v.value == 90 "Mosek.MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX"
  elseif v.value == 91 "Mosek.MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI"
  elseif v.value == 92 "Mosek.MSK_CALLBACK_UPDATE_SIMPLEX"
  elseif v.value == 93 "Mosek.MSK_CALLBACK_WRITE_OPF"
  else "Mosek.Callbackcode(?)"
  end
const Callbackcode_members = Callbackcode[
    MSK_CALLBACK_BEGIN_BI,
    MSK_CALLBACK_BEGIN_CONIC,
    MSK_CALLBACK_BEGIN_DUAL_BI,
    MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY,
    MSK_CALLBACK_BEGIN_DUAL_SETUP_BI,
    MSK_CALLBACK_BEGIN_DUAL_SIMPLEX,
    MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI,
    MSK_CALLBACK_BEGIN_INFEAS_ANA,
    MSK_CALLBACK_BEGIN_INTPNT,
    MSK_CALLBACK_BEGIN_LICENSE_WAIT,
    MSK_CALLBACK_BEGIN_MIO,
    MSK_CALLBACK_BEGIN_OPTIMIZER,
    MSK_CALLBACK_BEGIN_PRESOLVE,
    MSK_CALLBACK_BEGIN_PRIMAL_BI,
    MSK_CALLBACK_BEGIN_PRIMAL_REPAIR,
    MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY,
    MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI,
    MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX,
    MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI,
    MSK_CALLBACK_BEGIN_QCQO_REFORMULATE,
    MSK_CALLBACK_BEGIN_READ,
    MSK_CALLBACK_BEGIN_ROOT_CUTGEN,
    MSK_CALLBACK_BEGIN_SIMPLEX,
    MSK_CALLBACK_BEGIN_SIMPLEX_BI,
    MSK_CALLBACK_BEGIN_SOLVE_ROOT_RELAX,
    MSK_CALLBACK_BEGIN_TO_CONIC,
    MSK_CALLBACK_BEGIN_WRITE,
    MSK_CALLBACK_CONIC,
    MSK_CALLBACK_DUAL_SIMPLEX,
    MSK_CALLBACK_END_BI,
    MSK_CALLBACK_END_CONIC,
    MSK_CALLBACK_END_DUAL_BI,
    MSK_CALLBACK_END_DUAL_SENSITIVITY,
    MSK_CALLBACK_END_DUAL_SETUP_BI,
    MSK_CALLBACK_END_DUAL_SIMPLEX,
    MSK_CALLBACK_END_DUAL_SIMPLEX_BI,
    MSK_CALLBACK_END_INFEAS_ANA,
    MSK_CALLBACK_END_INTPNT,
    MSK_CALLBACK_END_LICENSE_WAIT,
    MSK_CALLBACK_END_MIO,
    MSK_CALLBACK_END_OPTIMIZER,
    MSK_CALLBACK_END_PRESOLVE,
    MSK_CALLBACK_END_PRIMAL_BI,
    MSK_CALLBACK_END_PRIMAL_REPAIR,
    MSK_CALLBACK_END_PRIMAL_SENSITIVITY,
    MSK_CALLBACK_END_PRIMAL_SETUP_BI,
    MSK_CALLBACK_END_PRIMAL_SIMPLEX,
    MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI,
    MSK_CALLBACK_END_QCQO_REFORMULATE,
    MSK_CALLBACK_END_READ,
    MSK_CALLBACK_END_ROOT_CUTGEN,
    MSK_CALLBACK_END_SIMPLEX,
    MSK_CALLBACK_END_SIMPLEX_BI,
    MSK_CALLBACK_END_SOLVE_ROOT_RELAX,
    MSK_CALLBACK_END_TO_CONIC,
    MSK_CALLBACK_END_WRITE,
    MSK_CALLBACK_IM_BI,
    MSK_CALLBACK_IM_CONIC,
    MSK_CALLBACK_IM_DUAL_BI,
    MSK_CALLBACK_IM_DUAL_SENSIVITY,
    MSK_CALLBACK_IM_DUAL_SIMPLEX,
    MSK_CALLBACK_IM_INTPNT,
    MSK_CALLBACK_IM_LICENSE_WAIT,
    MSK_CALLBACK_IM_LU,
    MSK_CALLBACK_IM_MIO,
    MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX,
    MSK_CALLBACK_IM_MIO_INTPNT,
    MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX,
    MSK_CALLBACK_IM_ORDER,
    MSK_CALLBACK_IM_PRESOLVE,
    MSK_CALLBACK_IM_PRIMAL_BI,
    MSK_CALLBACK_IM_PRIMAL_SENSIVITY,
    MSK_CALLBACK_IM_PRIMAL_SIMPLEX,
    MSK_CALLBACK_IM_QO_REFORMULATE,
    MSK_CALLBACK_IM_READ,
    MSK_CALLBACK_IM_ROOT_CUTGEN,
    MSK_CALLBACK_IM_SIMPLEX,
    MSK_CALLBACK_IM_SIMPLEX_BI,
    MSK_CALLBACK_INTPNT,
    MSK_CALLBACK_NEW_INT_MIO,
    MSK_CALLBACK_PRIMAL_SIMPLEX,
    MSK_CALLBACK_READ_OPF,
    MSK_CALLBACK_READ_OPF_SECTION,
    MSK_CALLBACK_RESTART_MIO,
    MSK_CALLBACK_SOLVING_REMOTE,
    MSK_CALLBACK_UPDATE_DUAL_BI,
    MSK_CALLBACK_UPDATE_DUAL_SIMPLEX,
    MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI,
    MSK_CALLBACK_UPDATE_PRESOLVE,
    MSK_CALLBACK_UPDATE_PRIMAL_BI,
    MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX,
    MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI,
    MSK_CALLBACK_UPDATE_SIMPLEX,
    MSK_CALLBACK_WRITE_OPF ]
members(::Type{Callbackcode}) = Callbackcode_members
Base.length(::Type{Callbackcode}) = 94
Base.convert(::Type{Int},x::Callbackcode) = Int(x.value)
"""
    Compresstype

Compression types

* `MSK_COMPRESS_NONE`. No compression is used.
* `MSK_COMPRESS_FREE`. The type of compression used is chosen automatically.
* `MSK_COMPRESS_GZIP`. The type of compression used is gzip compatible.
* `MSK_COMPRESS_ZSTD`. The type of compression used is zstd compatible.
"""
struct Compresstype <: MosekEnum
  value :: Int32
end # compresstype

"No compression is used."
const MSK_COMPRESS_NONE = Compresstype(0)

"The type of compression used is chosen automatically."
const MSK_COMPRESS_FREE = Compresstype(1)

"The type of compression used is gzip compatible."
const MSK_COMPRESS_GZIP = Compresstype(2)

"The type of compression used is zstd compatible."
const MSK_COMPRESS_ZSTD = Compresstype(3)
tostr(v::Compresstype) = if v.value == 0 "Mosek.MSK_COMPRESS_NONE"
  elseif v.value == 1 "Mosek.MSK_COMPRESS_FREE"
  elseif v.value == 2 "Mosek.MSK_COMPRESS_GZIP"
  elseif v.value == 3 "Mosek.MSK_COMPRESS_ZSTD"
  else "Mosek.Compresstype(?)"
  end
const Compresstype_members = Compresstype[
    MSK_COMPRESS_NONE,
    MSK_COMPRESS_FREE,
    MSK_COMPRESS_GZIP,
    MSK_COMPRESS_ZSTD ]
members(::Type{Compresstype}) = Compresstype_members
Base.length(::Type{Compresstype}) = 4
Base.convert(::Type{Int},x::Compresstype) = Int(x.value)
"""
    Conetype

Cone types

* `MSK_CT_QUAD`. The cone is a quadratic cone.
* `MSK_CT_RQUAD`. The cone is a rotated quadratic cone.
* `MSK_CT_PEXP`. A primal exponential cone.
* `MSK_CT_DEXP`. A dual exponential cone.
* `MSK_CT_PPOW`. A primal power cone.
* `MSK_CT_DPOW`. A dual power cone.
* `MSK_CT_ZERO`. The zero cone.
"""
struct Conetype <: MosekEnum
  value :: Int32
end # conetype

"The cone is a quadratic cone."
const MSK_CT_QUAD = Conetype(0)

"The cone is a rotated quadratic cone."
const MSK_CT_RQUAD = Conetype(1)

"A primal exponential cone."
const MSK_CT_PEXP = Conetype(2)

"A dual exponential cone."
const MSK_CT_DEXP = Conetype(3)

"A primal power cone."
const MSK_CT_PPOW = Conetype(4)

"A dual power cone."
const MSK_CT_DPOW = Conetype(5)

"The zero cone."
const MSK_CT_ZERO = Conetype(6)
tostr(v::Conetype) = if v.value == 0 "Mosek.MSK_CT_QUAD"
  elseif v.value == 1 "Mosek.MSK_CT_RQUAD"
  elseif v.value == 2 "Mosek.MSK_CT_PEXP"
  elseif v.value == 3 "Mosek.MSK_CT_DEXP"
  elseif v.value == 4 "Mosek.MSK_CT_PPOW"
  elseif v.value == 5 "Mosek.MSK_CT_DPOW"
  elseif v.value == 6 "Mosek.MSK_CT_ZERO"
  else "Mosek.Conetype(?)"
  end
const Conetype_members = Conetype[
    MSK_CT_QUAD,
    MSK_CT_RQUAD,
    MSK_CT_PEXP,
    MSK_CT_DEXP,
    MSK_CT_PPOW,
    MSK_CT_DPOW,
    MSK_CT_ZERO ]
members(::Type{Conetype}) = Conetype_members
Base.length(::Type{Conetype}) = 7
Base.convert(::Type{Int},x::Conetype) = Int(x.value)
"""
    Domaintype

Cone types

* `MSK_DOMAIN_R`. R.
* `MSK_DOMAIN_RZERO`. The zero vector.
* `MSK_DOMAIN_RPLUS`. The positive orthant.
* `MSK_DOMAIN_RMINUS`. The negative orthant.
* `MSK_DOMAIN_QUADRATIC_CONE`. The quadratic cone.
* `MSK_DOMAIN_RQUADRATIC_CONE`. The rotated quadratic cone.
* `MSK_DOMAIN_PRIMAL_EXP_CONE`. The primal exponential cone.
* `MSK_DOMAIN_DUAL_EXP_CONE`. The dual exponential cone.
* `MSK_DOMAIN_PRIMAL_POWER_CONE`. The primal power cone.
* `MSK_DOMAIN_DUAL_POWER_CONE`. The dual power cone.
* `MSK_DOMAIN_PRIMAL_GEO_MEAN_CONE`. The primal geometric mean cone.
* `MSK_DOMAIN_DUAL_GEO_MEAN_CONE`. The dual geometric mean cone.
* `MSK_DOMAIN_SVEC_PSD_CONE`. The vectorized positive semidefinite cone.
"""
struct Domaintype <: MosekEnum
  value :: Int32
end # domaintype

"R."
const MSK_DOMAIN_R = Domaintype(0)

"The zero vector."
const MSK_DOMAIN_RZERO = Domaintype(1)

"The positive orthant."
const MSK_DOMAIN_RPLUS = Domaintype(2)

"The negative orthant."
const MSK_DOMAIN_RMINUS = Domaintype(3)

"The quadratic cone."
const MSK_DOMAIN_QUADRATIC_CONE = Domaintype(4)

"The rotated quadratic cone."
const MSK_DOMAIN_RQUADRATIC_CONE = Domaintype(5)

"The primal exponential cone."
const MSK_DOMAIN_PRIMAL_EXP_CONE = Domaintype(6)

"The dual exponential cone."
const MSK_DOMAIN_DUAL_EXP_CONE = Domaintype(7)

"The primal power cone."
const MSK_DOMAIN_PRIMAL_POWER_CONE = Domaintype(8)

"The dual power cone."
const MSK_DOMAIN_DUAL_POWER_CONE = Domaintype(9)

"The primal geometric mean cone."
const MSK_DOMAIN_PRIMAL_GEO_MEAN_CONE = Domaintype(10)

"The dual geometric mean cone."
const MSK_DOMAIN_DUAL_GEO_MEAN_CONE = Domaintype(11)

"The vectorized positive semidefinite cone."
const MSK_DOMAIN_SVEC_PSD_CONE = Domaintype(12)
tostr(v::Domaintype) = if v.value == 0 "Mosek.MSK_DOMAIN_R"
  elseif v.value == 1 "Mosek.MSK_DOMAIN_RZERO"
  elseif v.value == 2 "Mosek.MSK_DOMAIN_RPLUS"
  elseif v.value == 3 "Mosek.MSK_DOMAIN_RMINUS"
  elseif v.value == 4 "Mosek.MSK_DOMAIN_QUADRATIC_CONE"
  elseif v.value == 5 "Mosek.MSK_DOMAIN_RQUADRATIC_CONE"
  elseif v.value == 6 "Mosek.MSK_DOMAIN_PRIMAL_EXP_CONE"
  elseif v.value == 7 "Mosek.MSK_DOMAIN_DUAL_EXP_CONE"
  elseif v.value == 8 "Mosek.MSK_DOMAIN_PRIMAL_POWER_CONE"
  elseif v.value == 9 "Mosek.MSK_DOMAIN_DUAL_POWER_CONE"
  elseif v.value == 10 "Mosek.MSK_DOMAIN_PRIMAL_GEO_MEAN_CONE"
  elseif v.value == 11 "Mosek.MSK_DOMAIN_DUAL_GEO_MEAN_CONE"
  elseif v.value == 12 "Mosek.MSK_DOMAIN_SVEC_PSD_CONE"
  else "Mosek.Domaintype(?)"
  end
const Domaintype_members = Domaintype[
    MSK_DOMAIN_R,
    MSK_DOMAIN_RZERO,
    MSK_DOMAIN_RPLUS,
    MSK_DOMAIN_RMINUS,
    MSK_DOMAIN_QUADRATIC_CONE,
    MSK_DOMAIN_RQUADRATIC_CONE,
    MSK_DOMAIN_PRIMAL_EXP_CONE,
    MSK_DOMAIN_DUAL_EXP_CONE,
    MSK_DOMAIN_PRIMAL_POWER_CONE,
    MSK_DOMAIN_DUAL_POWER_CONE,
    MSK_DOMAIN_PRIMAL_GEO_MEAN_CONE,
    MSK_DOMAIN_DUAL_GEO_MEAN_CONE,
    MSK_DOMAIN_SVEC_PSD_CONE ]
members(::Type{Domaintype}) = Domaintype_members
Base.length(::Type{Domaintype}) = 13
Base.convert(::Type{Int},x::Domaintype) = Int(x.value)
"""
    Nametype

Name types

* `MSK_NAME_TYPE_GEN`. General names. However, no duplicate and blank names are allowed.
* `MSK_NAME_TYPE_MPS`. MPS type names.
* `MSK_NAME_TYPE_LP`. LP type names.
"""
struct Nametype <: MosekEnum
  value :: Int32
end # nametype

"General names. However, no duplicate and blank names are allowed."
const MSK_NAME_TYPE_GEN = Nametype(0)

"MPS type names."
const MSK_NAME_TYPE_MPS = Nametype(1)

"LP type names."
const MSK_NAME_TYPE_LP = Nametype(2)
tostr(v::Nametype) = if v.value == 0 "Mosek.MSK_NAME_TYPE_GEN"
  elseif v.value == 1 "Mosek.MSK_NAME_TYPE_MPS"
  elseif v.value == 2 "Mosek.MSK_NAME_TYPE_LP"
  else "Mosek.Nametype(?)"
  end
const Nametype_members = Nametype[
    MSK_NAME_TYPE_GEN,
    MSK_NAME_TYPE_MPS,
    MSK_NAME_TYPE_LP ]
members(::Type{Nametype}) = Nametype_members
Base.length(::Type{Nametype}) = 3
Base.convert(::Type{Int},x::Nametype) = Int(x.value)
"""
    Symmattype

Cone types

* `MSK_SYMMAT_TYPE_SPARSE`. Sparse symmetric matrix.
"""
struct Symmattype <: MosekEnum
  value :: Int32
end # symmattype

"Sparse symmetric matrix."
const MSK_SYMMAT_TYPE_SPARSE = Symmattype(0)
tostr(v::Symmattype) = if v.value == 0 "Mosek.MSK_SYMMAT_TYPE_SPARSE"
  else "Mosek.Symmattype(?)"
  end
const Symmattype_members = Symmattype[
    MSK_SYMMAT_TYPE_SPARSE ]
members(::Type{Symmattype}) = Symmattype_members
Base.length(::Type{Symmattype}) = 1
Base.convert(::Type{Int},x::Symmattype) = Int(x.value)
"""
    Dataformat

Data format types

* `MSK_DATA_FORMAT_EXTENSION`. The file extension is used to determine the data file format.
* `MSK_DATA_FORMAT_MPS`. The data file is MPS formatted.
* `MSK_DATA_FORMAT_LP`. The data file is LP formatted.
* `MSK_DATA_FORMAT_OP`. The data file is an optimization problem formatted file.
* `MSK_DATA_FORMAT_FREE_MPS`. The data a free MPS formatted file.
* `MSK_DATA_FORMAT_TASK`. Generic task dump file.
* `MSK_DATA_FORMAT_PTF`. (P)retty (T)ext (F)format.
* `MSK_DATA_FORMAT_CB`. Conic benchmark format,
* `MSK_DATA_FORMAT_JSON_TASK`. JSON based task format.
"""
struct Dataformat <: MosekEnum
  value :: Int32
end # dataformat

"The file extension is used to determine the data file format."
const MSK_DATA_FORMAT_EXTENSION = Dataformat(0)

"The data file is MPS formatted."
const MSK_DATA_FORMAT_MPS = Dataformat(1)

"The data file is LP formatted."
const MSK_DATA_FORMAT_LP = Dataformat(2)

"The data file is an optimization problem formatted file."
const MSK_DATA_FORMAT_OP = Dataformat(3)

"The data a free MPS formatted file."
const MSK_DATA_FORMAT_FREE_MPS = Dataformat(4)

"Generic task dump file."
const MSK_DATA_FORMAT_TASK = Dataformat(5)

"(P)retty (T)ext (F)format."
const MSK_DATA_FORMAT_PTF = Dataformat(6)

"Conic benchmark format,"
const MSK_DATA_FORMAT_CB = Dataformat(7)

"JSON based task format."
const MSK_DATA_FORMAT_JSON_TASK = Dataformat(8)
tostr(v::Dataformat) = if v.value == 0 "Mosek.MSK_DATA_FORMAT_EXTENSION"
  elseif v.value == 1 "Mosek.MSK_DATA_FORMAT_MPS"
  elseif v.value == 2 "Mosek.MSK_DATA_FORMAT_LP"
  elseif v.value == 3 "Mosek.MSK_DATA_FORMAT_OP"
  elseif v.value == 4 "Mosek.MSK_DATA_FORMAT_FREE_MPS"
  elseif v.value == 5 "Mosek.MSK_DATA_FORMAT_TASK"
  elseif v.value == 6 "Mosek.MSK_DATA_FORMAT_PTF"
  elseif v.value == 7 "Mosek.MSK_DATA_FORMAT_CB"
  elseif v.value == 8 "Mosek.MSK_DATA_FORMAT_JSON_TASK"
  else "Mosek.Dataformat(?)"
  end
const Dataformat_members = Dataformat[
    MSK_DATA_FORMAT_EXTENSION,
    MSK_DATA_FORMAT_MPS,
    MSK_DATA_FORMAT_LP,
    MSK_DATA_FORMAT_OP,
    MSK_DATA_FORMAT_FREE_MPS,
    MSK_DATA_FORMAT_TASK,
    MSK_DATA_FORMAT_PTF,
    MSK_DATA_FORMAT_CB,
    MSK_DATA_FORMAT_JSON_TASK ]
members(::Type{Dataformat}) = Dataformat_members
Base.length(::Type{Dataformat}) = 9
Base.convert(::Type{Int},x::Dataformat) = Int(x.value)
"""
    Solformat

Data format types

* `MSK_SOL_FORMAT_EXTENSION`. The file extension is used to determine the data file format.
* `MSK_SOL_FORMAT_B`. Simple binary format
* `MSK_SOL_FORMAT_TASK`. Tar based format.
* `MSK_SOL_FORMAT_JSON_TASK`. JSON based format.
"""
struct Solformat <: MosekEnum
  value :: Int32
end # solformat

"The file extension is used to determine the data file format."
const MSK_SOL_FORMAT_EXTENSION = Solformat(0)

"Simple binary format"
const MSK_SOL_FORMAT_B = Solformat(1)

"Tar based format."
const MSK_SOL_FORMAT_TASK = Solformat(2)

"JSON based format."
const MSK_SOL_FORMAT_JSON_TASK = Solformat(3)
tostr(v::Solformat) = if v.value == 0 "Mosek.MSK_SOL_FORMAT_EXTENSION"
  elseif v.value == 1 "Mosek.MSK_SOL_FORMAT_B"
  elseif v.value == 2 "Mosek.MSK_SOL_FORMAT_TASK"
  elseif v.value == 3 "Mosek.MSK_SOL_FORMAT_JSON_TASK"
  else "Mosek.Solformat(?)"
  end
const Solformat_members = Solformat[
    MSK_SOL_FORMAT_EXTENSION,
    MSK_SOL_FORMAT_B,
    MSK_SOL_FORMAT_TASK,
    MSK_SOL_FORMAT_JSON_TASK ]
members(::Type{Solformat}) = Solformat_members
Base.length(::Type{Solformat}) = 4
Base.convert(::Type{Int},x::Solformat) = Int(x.value)
"""
    Dinfitem

Double information items

* `MSK_DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY`. Density percentage of the scalarized constraint matrix.
* `MSK_DINF_BI_CLEAN_DUAL_TIME`. Time  spent within the dual clean-up optimizer of the basis identification procedure since its invocation.
* `MSK_DINF_BI_CLEAN_PRIMAL_TIME`. Time spent within the primal clean-up optimizer of the basis identification procedure since its invocation.
* `MSK_DINF_BI_CLEAN_TIME`. Time spent within the clean-up phase of the basis identification procedure since its invocation.
* `MSK_DINF_BI_DUAL_TIME`. Time spent within the dual phase basis identification procedure since its invocation.
* `MSK_DINF_BI_PRIMAL_TIME`. Time  spent within the primal phase of the basis identification procedure since its invocation.
* `MSK_DINF_BI_TIME`. Time spent within the basis identification procedure since its invocation.
* `MSK_DINF_INTPNT_DUAL_FEAS`. Dual feasibility measure reported by the interior-point optimizer.
* `MSK_DINF_INTPNT_DUAL_OBJ`. Dual objective value reported by the interior-point optimizer.
* `MSK_DINF_INTPNT_FACTOR_NUM_FLOPS`. An estimate of the number of flops used in the factorization.
* `MSK_DINF_INTPNT_OPT_STATUS`. A measure of optimality of the solution.
* `MSK_DINF_INTPNT_ORDER_TIME`. Order time (in seconds).
* `MSK_DINF_INTPNT_PRIMAL_FEAS`. Primal feasibility measure reported by the interior-point optimizer.
* `MSK_DINF_INTPNT_PRIMAL_OBJ`. Primal objective value reported by the interior-point optimizer.
* `MSK_DINF_INTPNT_TIME`. Time spent within the interior-point optimizer since its invocation.
* `MSK_DINF_MIO_CLIQUE_SELECTION_TIME`. Selection time for clique cuts.
* `MSK_DINF_MIO_CLIQUE_SEPARATION_TIME`. Separation time for clique cuts.
* `MSK_DINF_MIO_CMIR_SELECTION_TIME`. Selection time for CMIR cuts.
* `MSK_DINF_MIO_CMIR_SEPARATION_TIME`. Separation time for CMIR cuts.
* `MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ`. Optimal objective value corresponding to the feasible solution.
* `MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE`. Value of the dual bound after presolve but before cut generation.
* `MSK_DINF_MIO_GMI_SELECTION_TIME`. Selection time for GMI cuts.
* `MSK_DINF_MIO_GMI_SEPARATION_TIME`. Separation time for GMI cuts.
* `MSK_DINF_MIO_IMPLIED_BOUND_SELECTION_TIME`. Selection time for implied bound cuts.
* `MSK_DINF_MIO_IMPLIED_BOUND_SEPARATION_TIME`. Separation time for implied bound cuts.
* `MSK_DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ`. Optimal objective value corresponding to the user provided initial solution.
* `MSK_DINF_MIO_KNAPSACK_COVER_SELECTION_TIME`. Selection time for knapsack cover.
* `MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME`. Separation time for knapsack cover.
* `MSK_DINF_MIO_LIPRO_SELECTION_TIME`. Selection time for lift-and-project cuts.
* `MSK_DINF_MIO_LIPRO_SEPARATION_TIME`. Separation time for lift-and-project cuts.
* `MSK_DINF_MIO_OBJ_ABS_GAP`. If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the absolute gap.
* `MSK_DINF_MIO_OBJ_BOUND`. The best bound on the objective value known.
* `MSK_DINF_MIO_OBJ_INT`. The primal objective value corresponding to the best integer feasible solution.
* `MSK_DINF_MIO_OBJ_REL_GAP`. If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the relative gap.
* `MSK_DINF_MIO_PROBING_TIME`. Total time for probing.
* `MSK_DINF_MIO_ROOT_CUT_SELECTION_TIME`. Total time for cut selection.
* `MSK_DINF_MIO_ROOT_CUT_SEPARATION_TIME`. Total time for cut separation.
* `MSK_DINF_MIO_ROOT_OPTIMIZER_TIME`. Time spent in the contiuous optimizer while processing the root node relaxation.
* `MSK_DINF_MIO_ROOT_PRESOLVE_TIME`. Time spent presolving the problem at the root node.
* `MSK_DINF_MIO_ROOT_TIME`. Time spent processing the root node.
* `MSK_DINF_MIO_SYMMETRY_DETECTION_TIME`. Total time for symmetry detection.
* `MSK_DINF_MIO_SYMMETRY_FACTOR`. Degree to which the problem is affected by detected symmetry.
* `MSK_DINF_MIO_TIME`. Time spent in the mixed-integer optimizer.
* `MSK_DINF_MIO_USER_OBJ_CUT`. If the objective cut is used, then this information item has the value of the cut.
* `MSK_DINF_OPTIMIZER_TICKS`. Total number of ticks spent in the optimizer since it was invoked. It is strictly negative if it is not available.
* `MSK_DINF_OPTIMIZER_TIME`. Total time spent in the optimizer since it was invoked.
* `MSK_DINF_PRESOLVE_ELI_TIME`. Total time spent in the eliminator since the presolve was invoked.
* `MSK_DINF_PRESOLVE_LINDEP_TIME`. Total time spent  in the linear dependency checker since the presolve was invoked.
* `MSK_DINF_PRESOLVE_TIME`. Total time (in seconds) spent in the presolve since it was invoked.
* `MSK_DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION`. Total perturbation of the bounds of the primal problem.
* `MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ`. The optimal objective value of the penalty function.
* `MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION`. Maximum absolute diagonal perturbation occurring during the QCQO reformulation.
* `MSK_DINF_QCQO_REFORMULATE_TIME`. Time spent with conic quadratic reformulation.
* `MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING`. Worst Cholesky column scaling.
* `MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING`. Worst Cholesky diagonal scaling.
* `MSK_DINF_READ_DATA_TIME`. Time spent reading the data file.
* `MSK_DINF_REMOTE_TIME`. The total real time in seconds spent when optimizing on a server by the process performing the optimization on the server
* `MSK_DINF_SIM_DUAL_TIME`. Time spent in the dual simplex optimizer since invoking it.
* `MSK_DINF_SIM_FEAS`. Feasibility measure reported by the simplex optimizer.
* `MSK_DINF_SIM_OBJ`. Objective value reported by the simplex optimizer.
* `MSK_DINF_SIM_PRIMAL_TIME`. Time spent in the primal simplex optimizer since invoking it.
* `MSK_DINF_SIM_TIME`. Time spent in the simplex optimizer since invoking it.
* `MSK_DINF_SOL_BAS_DUAL_OBJ`. Dual objective value of the basic solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_BAS_DVIOLCON`. Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_BAS_DVIOLVAR`. Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_BAS_NRM_BARX`. Infinity norm of barx in the basic solution.
* `MSK_DINF_SOL_BAS_NRM_SLC`. Infinity norm of slc in the basic solution.
* `MSK_DINF_SOL_BAS_NRM_SLX`. Infinity norm of slx in the basic solution.
* `MSK_DINF_SOL_BAS_NRM_SUC`. Infinity norm of suc in the basic solution.
* `MSK_DINF_SOL_BAS_NRM_SUX`. Infinity norm of sux in the basic solution.
* `MSK_DINF_SOL_BAS_NRM_XC`. Infinity norm of xc in the basic solution.
* `MSK_DINF_SOL_BAS_NRM_XX`. Infinity norm of xx in the basic solution.
* `MSK_DINF_SOL_BAS_NRM_Y`. Infinity norm of Y in the basic solution.
* `MSK_DINF_SOL_BAS_PRIMAL_OBJ`. Primal objective value of the basic solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_BAS_PVIOLCON`. Maximal primal bound violation for xc in the basic solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_BAS_PVIOLVAR`. Maximal primal bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_NRM_BARX`. Infinity norm of barx in the integer solution.
* `MSK_DINF_SOL_ITG_NRM_XC`. Infinity norm of xc in the integer solution.
* `MSK_DINF_SOL_ITG_NRM_XX`. Infinity norm of xx in the integer solution.
* `MSK_DINF_SOL_ITG_PRIMAL_OBJ`. Primal objective value of the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_PVIOLACC`. Maximal primal violation for affine conic constraints in the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_PVIOLBARVAR`. Maximal primal bound violation for barx in the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_PVIOLCON`. Maximal primal bound violation for xc in the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_PVIOLCONES`. Maximal primal violation for primal conic constraints in the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_PVIOLDJC`. Maximal primal violation for disjunctive constraints in the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_PVIOLITG`. Maximal violation for the integer constraints in the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITG_PVIOLVAR`. Maximal primal bound violation for xx in the integer solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_DUAL_OBJ`. Dual objective value of the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_DVIOLACC`. Maximal dual violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_DVIOLBARVAR`. Maximal dual bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_DVIOLCON`. Maximal dual bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_DVIOLCONES`. Maximal dual violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_DVIOLVAR`. Maximal dual bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_NRM_BARS`. Infinity norm of bars in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_BARX`. Infinity norm of barx in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_SLC`. Infinity norm of slc in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_SLX`. Infinity norm of slx in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_SNX`. Infinity norm of snx in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_SUC`. Infinity norm of suc in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_SUX`. Infinity norm of sux in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_XC`. Infinity norm of xc in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_XX`. Infinity norm of xx in the interior-point solution.
* `MSK_DINF_SOL_ITR_NRM_Y`. Infinity norm of Y in the interior-point solution.
* `MSK_DINF_SOL_ITR_PRIMAL_OBJ`. Primal objective value of the interior-point solution.
* `MSK_DINF_SOL_ITR_PVIOLACC`. Maximal primal violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_PVIOLBARVAR`. Maximal primal bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_PVIOLCON`. Maximal primal bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_PVIOLCONES`. Maximal primal violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_SOL_ITR_PVIOLVAR`. Maximal primal bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.
* `MSK_DINF_TO_CONIC_TIME`. Time spent in the last to conic reformulation.
* `MSK_DINF_WRITE_DATA_TIME`. Time spent writing the data file.
"""
struct Dinfitem <: MosekEnum
  value :: Int32
end # dinfitem

"Density percentage of the scalarized constraint matrix."
const MSK_DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY = Dinfitem(0)

"Time  spent within the dual clean-up optimizer of the basis identification procedure since its invocation."
const MSK_DINF_BI_CLEAN_DUAL_TIME = Dinfitem(1)

"Time spent within the primal clean-up optimizer of the basis identification procedure since its invocation."
const MSK_DINF_BI_CLEAN_PRIMAL_TIME = Dinfitem(2)

"Time spent within the clean-up phase of the basis identification procedure since its invocation."
const MSK_DINF_BI_CLEAN_TIME = Dinfitem(3)

"Time spent within the dual phase basis identification procedure since its invocation."
const MSK_DINF_BI_DUAL_TIME = Dinfitem(4)

"Time  spent within the primal phase of the basis identification procedure since its invocation."
const MSK_DINF_BI_PRIMAL_TIME = Dinfitem(5)

"Time spent within the basis identification procedure since its invocation."
const MSK_DINF_BI_TIME = Dinfitem(6)

"Dual feasibility measure reported by the interior-point optimizer."
const MSK_DINF_INTPNT_DUAL_FEAS = Dinfitem(7)

"Dual objective value reported by the interior-point optimizer."
const MSK_DINF_INTPNT_DUAL_OBJ = Dinfitem(8)

"An estimate of the number of flops used in the factorization."
const MSK_DINF_INTPNT_FACTOR_NUM_FLOPS = Dinfitem(9)

"A measure of optimality of the solution."
const MSK_DINF_INTPNT_OPT_STATUS = Dinfitem(10)

"Order time (in seconds)."
const MSK_DINF_INTPNT_ORDER_TIME = Dinfitem(11)

"Primal feasibility measure reported by the interior-point optimizer."
const MSK_DINF_INTPNT_PRIMAL_FEAS = Dinfitem(12)

"Primal objective value reported by the interior-point optimizer."
const MSK_DINF_INTPNT_PRIMAL_OBJ = Dinfitem(13)

"Time spent within the interior-point optimizer since its invocation."
const MSK_DINF_INTPNT_TIME = Dinfitem(14)

"Selection time for clique cuts."
const MSK_DINF_MIO_CLIQUE_SELECTION_TIME = Dinfitem(15)

"Separation time for clique cuts."
const MSK_DINF_MIO_CLIQUE_SEPARATION_TIME = Dinfitem(16)

"Selection time for CMIR cuts."
const MSK_DINF_MIO_CMIR_SELECTION_TIME = Dinfitem(17)

"Separation time for CMIR cuts."
const MSK_DINF_MIO_CMIR_SEPARATION_TIME = Dinfitem(18)

"Optimal objective value corresponding to the feasible solution."
const MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ = Dinfitem(19)

"Value of the dual bound after presolve but before cut generation."
const MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE = Dinfitem(20)

"Selection time for GMI cuts."
const MSK_DINF_MIO_GMI_SELECTION_TIME = Dinfitem(21)

"Separation time for GMI cuts."
const MSK_DINF_MIO_GMI_SEPARATION_TIME = Dinfitem(22)

"Selection time for implied bound cuts."
const MSK_DINF_MIO_IMPLIED_BOUND_SELECTION_TIME = Dinfitem(23)

"Separation time for implied bound cuts."
const MSK_DINF_MIO_IMPLIED_BOUND_SEPARATION_TIME = Dinfitem(24)

"Optimal objective value corresponding to the user provided initial solution."
const MSK_DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ = Dinfitem(25)

"Selection time for knapsack cover."
const MSK_DINF_MIO_KNAPSACK_COVER_SELECTION_TIME = Dinfitem(26)

"Separation time for knapsack cover."
const MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME = Dinfitem(27)

"Selection time for lift-and-project cuts."
const MSK_DINF_MIO_LIPRO_SELECTION_TIME = Dinfitem(28)

"Separation time for lift-and-project cuts."
const MSK_DINF_MIO_LIPRO_SEPARATION_TIME = Dinfitem(29)

"If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the absolute gap."
const MSK_DINF_MIO_OBJ_ABS_GAP = Dinfitem(30)

"The best bound on the objective value known."
const MSK_DINF_MIO_OBJ_BOUND = Dinfitem(31)

"The primal objective value corresponding to the best integer feasible solution."
const MSK_DINF_MIO_OBJ_INT = Dinfitem(32)

"If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the relative gap."
const MSK_DINF_MIO_OBJ_REL_GAP = Dinfitem(33)

"Total time for probing."
const MSK_DINF_MIO_PROBING_TIME = Dinfitem(34)

"Total time for cut selection."
const MSK_DINF_MIO_ROOT_CUT_SELECTION_TIME = Dinfitem(35)

"Total time for cut separation."
const MSK_DINF_MIO_ROOT_CUT_SEPARATION_TIME = Dinfitem(36)

"Time spent in the contiuous optimizer while processing the root node relaxation."
const MSK_DINF_MIO_ROOT_OPTIMIZER_TIME = Dinfitem(37)

"Time spent presolving the problem at the root node."
const MSK_DINF_MIO_ROOT_PRESOLVE_TIME = Dinfitem(38)

"Time spent processing the root node."
const MSK_DINF_MIO_ROOT_TIME = Dinfitem(39)

"Total time for symmetry detection."
const MSK_DINF_MIO_SYMMETRY_DETECTION_TIME = Dinfitem(40)

"Degree to which the problem is affected by detected symmetry."
const MSK_DINF_MIO_SYMMETRY_FACTOR = Dinfitem(41)

"Time spent in the mixed-integer optimizer."
const MSK_DINF_MIO_TIME = Dinfitem(42)

"If the objective cut is used, then this information item has the value of the cut."
const MSK_DINF_MIO_USER_OBJ_CUT = Dinfitem(43)

"Total number of ticks spent in the optimizer since it was invoked. It is strictly negative if it is not available."
const MSK_DINF_OPTIMIZER_TICKS = Dinfitem(44)

"Total time spent in the optimizer since it was invoked."
const MSK_DINF_OPTIMIZER_TIME = Dinfitem(45)

"Total time spent in the eliminator since the presolve was invoked."
const MSK_DINF_PRESOLVE_ELI_TIME = Dinfitem(46)

"Total time spent  in the linear dependency checker since the presolve was invoked."
const MSK_DINF_PRESOLVE_LINDEP_TIME = Dinfitem(47)

"Total time (in seconds) spent in the presolve since it was invoked."
const MSK_DINF_PRESOLVE_TIME = Dinfitem(48)

"Total perturbation of the bounds of the primal problem."
const MSK_DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION = Dinfitem(49)

"The optimal objective value of the penalty function."
const MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ = Dinfitem(50)

"Maximum absolute diagonal perturbation occurring during the QCQO reformulation."
const MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION = Dinfitem(51)

"Time spent with conic quadratic reformulation."
const MSK_DINF_QCQO_REFORMULATE_TIME = Dinfitem(52)

"Worst Cholesky column scaling."
const MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING = Dinfitem(53)

"Worst Cholesky diagonal scaling."
const MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING = Dinfitem(54)

"Time spent reading the data file."
const MSK_DINF_READ_DATA_TIME = Dinfitem(55)

"The total real time in seconds spent when optimizing on a server by the process performing the optimization on the server"
const MSK_DINF_REMOTE_TIME = Dinfitem(56)

"Time spent in the dual simplex optimizer since invoking it."
const MSK_DINF_SIM_DUAL_TIME = Dinfitem(57)

"Feasibility measure reported by the simplex optimizer."
const MSK_DINF_SIM_FEAS = Dinfitem(58)

"Objective value reported by the simplex optimizer."
const MSK_DINF_SIM_OBJ = Dinfitem(59)

"Time spent in the primal simplex optimizer since invoking it."
const MSK_DINF_SIM_PRIMAL_TIME = Dinfitem(60)

"Time spent in the simplex optimizer since invoking it."
const MSK_DINF_SIM_TIME = Dinfitem(61)

"Dual objective value of the basic solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_BAS_DUAL_OBJ = Dinfitem(62)

"Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_BAS_DVIOLCON = Dinfitem(63)

"Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_BAS_DVIOLVAR = Dinfitem(64)

"Infinity norm of barx in the basic solution."
const MSK_DINF_SOL_BAS_NRM_BARX = Dinfitem(65)

"Infinity norm of slc in the basic solution."
const MSK_DINF_SOL_BAS_NRM_SLC = Dinfitem(66)

"Infinity norm of slx in the basic solution."
const MSK_DINF_SOL_BAS_NRM_SLX = Dinfitem(67)

"Infinity norm of suc in the basic solution."
const MSK_DINF_SOL_BAS_NRM_SUC = Dinfitem(68)

"Infinity norm of sux in the basic solution."
const MSK_DINF_SOL_BAS_NRM_SUX = Dinfitem(69)

"Infinity norm of xc in the basic solution."
const MSK_DINF_SOL_BAS_NRM_XC = Dinfitem(70)

"Infinity norm of xx in the basic solution."
const MSK_DINF_SOL_BAS_NRM_XX = Dinfitem(71)

"Infinity norm of Y in the basic solution."
const MSK_DINF_SOL_BAS_NRM_Y = Dinfitem(72)

"Primal objective value of the basic solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_BAS_PRIMAL_OBJ = Dinfitem(73)

"Maximal primal bound violation for xc in the basic solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_BAS_PVIOLCON = Dinfitem(74)

"Maximal primal bound violation for xx in the basic solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_BAS_PVIOLVAR = Dinfitem(75)

"Infinity norm of barx in the integer solution."
const MSK_DINF_SOL_ITG_NRM_BARX = Dinfitem(76)

"Infinity norm of xc in the integer solution."
const MSK_DINF_SOL_ITG_NRM_XC = Dinfitem(77)

"Infinity norm of xx in the integer solution."
const MSK_DINF_SOL_ITG_NRM_XX = Dinfitem(78)

"Primal objective value of the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PRIMAL_OBJ = Dinfitem(79)

"Maximal primal violation for affine conic constraints in the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PVIOLACC = Dinfitem(80)

"Maximal primal bound violation for barx in the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PVIOLBARVAR = Dinfitem(81)

"Maximal primal bound violation for xc in the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PVIOLCON = Dinfitem(82)

"Maximal primal violation for primal conic constraints in the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PVIOLCONES = Dinfitem(83)

"Maximal primal violation for disjunctive constraints in the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PVIOLDJC = Dinfitem(84)

"Maximal violation for the integer constraints in the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PVIOLITG = Dinfitem(85)

"Maximal primal bound violation for xx in the integer solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITG_PVIOLVAR = Dinfitem(86)

"Dual objective value of the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_DUAL_OBJ = Dinfitem(87)

"Maximal dual violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_DVIOLACC = Dinfitem(88)

"Maximal dual bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_DVIOLBARVAR = Dinfitem(89)

"Maximal dual bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_DVIOLCON = Dinfitem(90)

"Maximal dual violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_DVIOLCONES = Dinfitem(91)

"Maximal dual bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_DVIOLVAR = Dinfitem(92)

"Infinity norm of bars in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_BARS = Dinfitem(93)

"Infinity norm of barx in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_BARX = Dinfitem(94)

"Infinity norm of slc in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_SLC = Dinfitem(95)

"Infinity norm of slx in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_SLX = Dinfitem(96)

"Infinity norm of snx in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_SNX = Dinfitem(97)

"Infinity norm of suc in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_SUC = Dinfitem(98)

"Infinity norm of sux in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_SUX = Dinfitem(99)

"Infinity norm of xc in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_XC = Dinfitem(100)

"Infinity norm of xx in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_XX = Dinfitem(101)

"Infinity norm of Y in the interior-point solution."
const MSK_DINF_SOL_ITR_NRM_Y = Dinfitem(102)

"Primal objective value of the interior-point solution."
const MSK_DINF_SOL_ITR_PRIMAL_OBJ = Dinfitem(103)

"Maximal primal violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_PVIOLACC = Dinfitem(104)

"Maximal primal bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_PVIOLBARVAR = Dinfitem(105)

"Maximal primal bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_PVIOLCON = Dinfitem(106)

"Maximal primal violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_PVIOLCONES = Dinfitem(107)

"Maximal primal bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo."
const MSK_DINF_SOL_ITR_PVIOLVAR = Dinfitem(108)

"Time spent in the last to conic reformulation."
const MSK_DINF_TO_CONIC_TIME = Dinfitem(109)

"Time spent writing the data file."
const MSK_DINF_WRITE_DATA_TIME = Dinfitem(110)
tostr(v::Dinfitem) = if v.value == 0 "Mosek.MSK_DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY"
  elseif v.value == 1 "Mosek.MSK_DINF_BI_CLEAN_DUAL_TIME"
  elseif v.value == 2 "Mosek.MSK_DINF_BI_CLEAN_PRIMAL_TIME"
  elseif v.value == 3 "Mosek.MSK_DINF_BI_CLEAN_TIME"
  elseif v.value == 4 "Mosek.MSK_DINF_BI_DUAL_TIME"
  elseif v.value == 5 "Mosek.MSK_DINF_BI_PRIMAL_TIME"
  elseif v.value == 6 "Mosek.MSK_DINF_BI_TIME"
  elseif v.value == 7 "Mosek.MSK_DINF_INTPNT_DUAL_FEAS"
  elseif v.value == 8 "Mosek.MSK_DINF_INTPNT_DUAL_OBJ"
  elseif v.value == 9 "Mosek.MSK_DINF_INTPNT_FACTOR_NUM_FLOPS"
  elseif v.value == 10 "Mosek.MSK_DINF_INTPNT_OPT_STATUS"
  elseif v.value == 11 "Mosek.MSK_DINF_INTPNT_ORDER_TIME"
  elseif v.value == 12 "Mosek.MSK_DINF_INTPNT_PRIMAL_FEAS"
  elseif v.value == 13 "Mosek.MSK_DINF_INTPNT_PRIMAL_OBJ"
  elseif v.value == 14 "Mosek.MSK_DINF_INTPNT_TIME"
  elseif v.value == 15 "Mosek.MSK_DINF_MIO_CLIQUE_SELECTION_TIME"
  elseif v.value == 16 "Mosek.MSK_DINF_MIO_CLIQUE_SEPARATION_TIME"
  elseif v.value == 17 "Mosek.MSK_DINF_MIO_CMIR_SELECTION_TIME"
  elseif v.value == 18 "Mosek.MSK_DINF_MIO_CMIR_SEPARATION_TIME"
  elseif v.value == 19 "Mosek.MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ"
  elseif v.value == 20 "Mosek.MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE"
  elseif v.value == 21 "Mosek.MSK_DINF_MIO_GMI_SELECTION_TIME"
  elseif v.value == 22 "Mosek.MSK_DINF_MIO_GMI_SEPARATION_TIME"
  elseif v.value == 23 "Mosek.MSK_DINF_MIO_IMPLIED_BOUND_SELECTION_TIME"
  elseif v.value == 24 "Mosek.MSK_DINF_MIO_IMPLIED_BOUND_SEPARATION_TIME"
  elseif v.value == 25 "Mosek.MSK_DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ"
  elseif v.value == 26 "Mosek.MSK_DINF_MIO_KNAPSACK_COVER_SELECTION_TIME"
  elseif v.value == 27 "Mosek.MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME"
  elseif v.value == 28 "Mosek.MSK_DINF_MIO_LIPRO_SELECTION_TIME"
  elseif v.value == 29 "Mosek.MSK_DINF_MIO_LIPRO_SEPARATION_TIME"
  elseif v.value == 30 "Mosek.MSK_DINF_MIO_OBJ_ABS_GAP"
  elseif v.value == 31 "Mosek.MSK_DINF_MIO_OBJ_BOUND"
  elseif v.value == 32 "Mosek.MSK_DINF_MIO_OBJ_INT"
  elseif v.value == 33 "Mosek.MSK_DINF_MIO_OBJ_REL_GAP"
  elseif v.value == 34 "Mosek.MSK_DINF_MIO_PROBING_TIME"
  elseif v.value == 35 "Mosek.MSK_DINF_MIO_ROOT_CUT_SELECTION_TIME"
  elseif v.value == 36 "Mosek.MSK_DINF_MIO_ROOT_CUT_SEPARATION_TIME"
  elseif v.value == 37 "Mosek.MSK_DINF_MIO_ROOT_OPTIMIZER_TIME"
  elseif v.value == 38 "Mosek.MSK_DINF_MIO_ROOT_PRESOLVE_TIME"
  elseif v.value == 39 "Mosek.MSK_DINF_MIO_ROOT_TIME"
  elseif v.value == 40 "Mosek.MSK_DINF_MIO_SYMMETRY_DETECTION_TIME"
  elseif v.value == 41 "Mosek.MSK_DINF_MIO_SYMMETRY_FACTOR"
  elseif v.value == 42 "Mosek.MSK_DINF_MIO_TIME"
  elseif v.value == 43 "Mosek.MSK_DINF_MIO_USER_OBJ_CUT"
  elseif v.value == 44 "Mosek.MSK_DINF_OPTIMIZER_TICKS"
  elseif v.value == 45 "Mosek.MSK_DINF_OPTIMIZER_TIME"
  elseif v.value == 46 "Mosek.MSK_DINF_PRESOLVE_ELI_TIME"
  elseif v.value == 47 "Mosek.MSK_DINF_PRESOLVE_LINDEP_TIME"
  elseif v.value == 48 "Mosek.MSK_DINF_PRESOLVE_TIME"
  elseif v.value == 49 "Mosek.MSK_DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION"
  elseif v.value == 50 "Mosek.MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ"
  elseif v.value == 51 "Mosek.MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION"
  elseif v.value == 52 "Mosek.MSK_DINF_QCQO_REFORMULATE_TIME"
  elseif v.value == 53 "Mosek.MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING"
  elseif v.value == 54 "Mosek.MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING"
  elseif v.value == 55 "Mosek.MSK_DINF_READ_DATA_TIME"
  elseif v.value == 56 "Mosek.MSK_DINF_REMOTE_TIME"
  elseif v.value == 57 "Mosek.MSK_DINF_SIM_DUAL_TIME"
  elseif v.value == 58 "Mosek.MSK_DINF_SIM_FEAS"
  elseif v.value == 59 "Mosek.MSK_DINF_SIM_OBJ"
  elseif v.value == 60 "Mosek.MSK_DINF_SIM_PRIMAL_TIME"
  elseif v.value == 61 "Mosek.MSK_DINF_SIM_TIME"
  elseif v.value == 62 "Mosek.MSK_DINF_SOL_BAS_DUAL_OBJ"
  elseif v.value == 63 "Mosek.MSK_DINF_SOL_BAS_DVIOLCON"
  elseif v.value == 64 "Mosek.MSK_DINF_SOL_BAS_DVIOLVAR"
  elseif v.value == 65 "Mosek.MSK_DINF_SOL_BAS_NRM_BARX"
  elseif v.value == 66 "Mosek.MSK_DINF_SOL_BAS_NRM_SLC"
  elseif v.value == 67 "Mosek.MSK_DINF_SOL_BAS_NRM_SLX"
  elseif v.value == 68 "Mosek.MSK_DINF_SOL_BAS_NRM_SUC"
  elseif v.value == 69 "Mosek.MSK_DINF_SOL_BAS_NRM_SUX"
  elseif v.value == 70 "Mosek.MSK_DINF_SOL_BAS_NRM_XC"
  elseif v.value == 71 "Mosek.MSK_DINF_SOL_BAS_NRM_XX"
  elseif v.value == 72 "Mosek.MSK_DINF_SOL_BAS_NRM_Y"
  elseif v.value == 73 "Mosek.MSK_DINF_SOL_BAS_PRIMAL_OBJ"
  elseif v.value == 74 "Mosek.MSK_DINF_SOL_BAS_PVIOLCON"
  elseif v.value == 75 "Mosek.MSK_DINF_SOL_BAS_PVIOLVAR"
  elseif v.value == 76 "Mosek.MSK_DINF_SOL_ITG_NRM_BARX"
  elseif v.value == 77 "Mosek.MSK_DINF_SOL_ITG_NRM_XC"
  elseif v.value == 78 "Mosek.MSK_DINF_SOL_ITG_NRM_XX"
  elseif v.value == 79 "Mosek.MSK_DINF_SOL_ITG_PRIMAL_OBJ"
  elseif v.value == 80 "Mosek.MSK_DINF_SOL_ITG_PVIOLACC"
  elseif v.value == 81 "Mosek.MSK_DINF_SOL_ITG_PVIOLBARVAR"
  elseif v.value == 82 "Mosek.MSK_DINF_SOL_ITG_PVIOLCON"
  elseif v.value == 83 "Mosek.MSK_DINF_SOL_ITG_PVIOLCONES"
  elseif v.value == 84 "Mosek.MSK_DINF_SOL_ITG_PVIOLDJC"
  elseif v.value == 85 "Mosek.MSK_DINF_SOL_ITG_PVIOLITG"
  elseif v.value == 86 "Mosek.MSK_DINF_SOL_ITG_PVIOLVAR"
  elseif v.value == 87 "Mosek.MSK_DINF_SOL_ITR_DUAL_OBJ"
  elseif v.value == 88 "Mosek.MSK_DINF_SOL_ITR_DVIOLACC"
  elseif v.value == 89 "Mosek.MSK_DINF_SOL_ITR_DVIOLBARVAR"
  elseif v.value == 90 "Mosek.MSK_DINF_SOL_ITR_DVIOLCON"
  elseif v.value == 91 "Mosek.MSK_DINF_SOL_ITR_DVIOLCONES"
  elseif v.value == 92 "Mosek.MSK_DINF_SOL_ITR_DVIOLVAR"
  elseif v.value == 93 "Mosek.MSK_DINF_SOL_ITR_NRM_BARS"
  elseif v.value == 94 "Mosek.MSK_DINF_SOL_ITR_NRM_BARX"
  elseif v.value == 95 "Mosek.MSK_DINF_SOL_ITR_NRM_SLC"
  elseif v.value == 96 "Mosek.MSK_DINF_SOL_ITR_NRM_SLX"
  elseif v.value == 97 "Mosek.MSK_DINF_SOL_ITR_NRM_SNX"
  elseif v.value == 98 "Mosek.MSK_DINF_SOL_ITR_NRM_SUC"
  elseif v.value == 99 "Mosek.MSK_DINF_SOL_ITR_NRM_SUX"
  elseif v.value == 100 "Mosek.MSK_DINF_SOL_ITR_NRM_XC"
  elseif v.value == 101 "Mosek.MSK_DINF_SOL_ITR_NRM_XX"
  elseif v.value == 102 "Mosek.MSK_DINF_SOL_ITR_NRM_Y"
  elseif v.value == 103 "Mosek.MSK_DINF_SOL_ITR_PRIMAL_OBJ"
  elseif v.value == 104 "Mosek.MSK_DINF_SOL_ITR_PVIOLACC"
  elseif v.value == 105 "Mosek.MSK_DINF_SOL_ITR_PVIOLBARVAR"
  elseif v.value == 106 "Mosek.MSK_DINF_SOL_ITR_PVIOLCON"
  elseif v.value == 107 "Mosek.MSK_DINF_SOL_ITR_PVIOLCONES"
  elseif v.value == 108 "Mosek.MSK_DINF_SOL_ITR_PVIOLVAR"
  elseif v.value == 109 "Mosek.MSK_DINF_TO_CONIC_TIME"
  elseif v.value == 110 "Mosek.MSK_DINF_WRITE_DATA_TIME"
  else "Mosek.Dinfitem(?)"
  end
const Dinfitem_members = Dinfitem[
    MSK_DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY,
    MSK_DINF_BI_CLEAN_DUAL_TIME,
    MSK_DINF_BI_CLEAN_PRIMAL_TIME,
    MSK_DINF_BI_CLEAN_TIME,
    MSK_DINF_BI_DUAL_TIME,
    MSK_DINF_BI_PRIMAL_TIME,
    MSK_DINF_BI_TIME,
    MSK_DINF_INTPNT_DUAL_FEAS,
    MSK_DINF_INTPNT_DUAL_OBJ,
    MSK_DINF_INTPNT_FACTOR_NUM_FLOPS,
    MSK_DINF_INTPNT_OPT_STATUS,
    MSK_DINF_INTPNT_ORDER_TIME,
    MSK_DINF_INTPNT_PRIMAL_FEAS,
    MSK_DINF_INTPNT_PRIMAL_OBJ,
    MSK_DINF_INTPNT_TIME,
    MSK_DINF_MIO_CLIQUE_SELECTION_TIME,
    MSK_DINF_MIO_CLIQUE_SEPARATION_TIME,
    MSK_DINF_MIO_CMIR_SELECTION_TIME,
    MSK_DINF_MIO_CMIR_SEPARATION_TIME,
    MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ,
    MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE,
    MSK_DINF_MIO_GMI_SELECTION_TIME,
    MSK_DINF_MIO_GMI_SEPARATION_TIME,
    MSK_DINF_MIO_IMPLIED_BOUND_SELECTION_TIME,
    MSK_DINF_MIO_IMPLIED_BOUND_SEPARATION_TIME,
    MSK_DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ,
    MSK_DINF_MIO_KNAPSACK_COVER_SELECTION_TIME,
    MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME,
    MSK_DINF_MIO_LIPRO_SELECTION_TIME,
    MSK_DINF_MIO_LIPRO_SEPARATION_TIME,
    MSK_DINF_MIO_OBJ_ABS_GAP,
    MSK_DINF_MIO_OBJ_BOUND,
    MSK_DINF_MIO_OBJ_INT,
    MSK_DINF_MIO_OBJ_REL_GAP,
    MSK_DINF_MIO_PROBING_TIME,
    MSK_DINF_MIO_ROOT_CUT_SELECTION_TIME,
    MSK_DINF_MIO_ROOT_CUT_SEPARATION_TIME,
    MSK_DINF_MIO_ROOT_OPTIMIZER_TIME,
    MSK_DINF_MIO_ROOT_PRESOLVE_TIME,
    MSK_DINF_MIO_ROOT_TIME,
    MSK_DINF_MIO_SYMMETRY_DETECTION_TIME,
    MSK_DINF_MIO_SYMMETRY_FACTOR,
    MSK_DINF_MIO_TIME,
    MSK_DINF_MIO_USER_OBJ_CUT,
    MSK_DINF_OPTIMIZER_TICKS,
    MSK_DINF_OPTIMIZER_TIME,
    MSK_DINF_PRESOLVE_ELI_TIME,
    MSK_DINF_PRESOLVE_LINDEP_TIME,
    MSK_DINF_PRESOLVE_TIME,
    MSK_DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION,
    MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ,
    MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION,
    MSK_DINF_QCQO_REFORMULATE_TIME,
    MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING,
    MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING,
    MSK_DINF_READ_DATA_TIME,
    MSK_DINF_REMOTE_TIME,
    MSK_DINF_SIM_DUAL_TIME,
    MSK_DINF_SIM_FEAS,
    MSK_DINF_SIM_OBJ,
    MSK_DINF_SIM_PRIMAL_TIME,
    MSK_DINF_SIM_TIME,
    MSK_DINF_SOL_BAS_DUAL_OBJ,
    MSK_DINF_SOL_BAS_DVIOLCON,
    MSK_DINF_SOL_BAS_DVIOLVAR,
    MSK_DINF_SOL_BAS_NRM_BARX,
    MSK_DINF_SOL_BAS_NRM_SLC,
    MSK_DINF_SOL_BAS_NRM_SLX,
    MSK_DINF_SOL_BAS_NRM_SUC,
    MSK_DINF_SOL_BAS_NRM_SUX,
    MSK_DINF_SOL_BAS_NRM_XC,
    MSK_DINF_SOL_BAS_NRM_XX,
    MSK_DINF_SOL_BAS_NRM_Y,
    MSK_DINF_SOL_BAS_PRIMAL_OBJ,
    MSK_DINF_SOL_BAS_PVIOLCON,
    MSK_DINF_SOL_BAS_PVIOLVAR,
    MSK_DINF_SOL_ITG_NRM_BARX,
    MSK_DINF_SOL_ITG_NRM_XC,
    MSK_DINF_SOL_ITG_NRM_XX,
    MSK_DINF_SOL_ITG_PRIMAL_OBJ,
    MSK_DINF_SOL_ITG_PVIOLACC,
    MSK_DINF_SOL_ITG_PVIOLBARVAR,
    MSK_DINF_SOL_ITG_PVIOLCON,
    MSK_DINF_SOL_ITG_PVIOLCONES,
    MSK_DINF_SOL_ITG_PVIOLDJC,
    MSK_DINF_SOL_ITG_PVIOLITG,
    MSK_DINF_SOL_ITG_PVIOLVAR,
    MSK_DINF_SOL_ITR_DUAL_OBJ,
    MSK_DINF_SOL_ITR_DVIOLACC,
    MSK_DINF_SOL_ITR_DVIOLBARVAR,
    MSK_DINF_SOL_ITR_DVIOLCON,
    MSK_DINF_SOL_ITR_DVIOLCONES,
    MSK_DINF_SOL_ITR_DVIOLVAR,
    MSK_DINF_SOL_ITR_NRM_BARS,
    MSK_DINF_SOL_ITR_NRM_BARX,
    MSK_DINF_SOL_ITR_NRM_SLC,
    MSK_DINF_SOL_ITR_NRM_SLX,
    MSK_DINF_SOL_ITR_NRM_SNX,
    MSK_DINF_SOL_ITR_NRM_SUC,
    MSK_DINF_SOL_ITR_NRM_SUX,
    MSK_DINF_SOL_ITR_NRM_XC,
    MSK_DINF_SOL_ITR_NRM_XX,
    MSK_DINF_SOL_ITR_NRM_Y,
    MSK_DINF_SOL_ITR_PRIMAL_OBJ,
    MSK_DINF_SOL_ITR_PVIOLACC,
    MSK_DINF_SOL_ITR_PVIOLBARVAR,
    MSK_DINF_SOL_ITR_PVIOLCON,
    MSK_DINF_SOL_ITR_PVIOLCONES,
    MSK_DINF_SOL_ITR_PVIOLVAR,
    MSK_DINF_TO_CONIC_TIME,
    MSK_DINF_WRITE_DATA_TIME ]
members(::Type{Dinfitem}) = Dinfitem_members
Base.length(::Type{Dinfitem}) = 111
Base.convert(::Type{Int},x::Dinfitem) = Int(x.value)
"""
    Feature

License feature

* `MSK_FEATURE_PTS`. Base system.
* `MSK_FEATURE_PTON`. Conic extension.
"""
struct Feature <: MosekEnum
  value :: Int32
end # feature

"Base system."
const MSK_FEATURE_PTS = Feature(0)

"Conic extension."
const MSK_FEATURE_PTON = Feature(1)
tostr(v::Feature) = if v.value == 0 "Mosek.MSK_FEATURE_PTS"
  elseif v.value == 1 "Mosek.MSK_FEATURE_PTON"
  else "Mosek.Feature(?)"
  end
const Feature_members = Feature[
    MSK_FEATURE_PTS,
    MSK_FEATURE_PTON ]
members(::Type{Feature}) = Feature_members
Base.length(::Type{Feature}) = 2
Base.convert(::Type{Int},x::Feature) = Int(x.value)
"""
    Dparam

The enumeration type containing all double parameters.

* `MSK_DPAR_ANA_SOL_INFEAS_TOL`. If a constraint violates its bound with an amount larger than this value, the constraint name, index and violation will be printed by the solution analyzer.
* `MSK_DPAR_BASIS_REL_TOL_S`. Maximum relative dual bound violation allowed in an optimal basic solution.
* `MSK_DPAR_BASIS_TOL_S`. Maximum absolute dual bound violation in an optimal basic solution.
* `MSK_DPAR_BASIS_TOL_X`. Maximum absolute primal bound violation allowed in an optimal basic solution.
* `MSK_DPAR_CHECK_CONVEXITY_REL_TOL`. Not in use.
* `MSK_DPAR_DATA_SYM_MAT_TOL`. Zero tolerance threshold for symmetric matrices.
* `MSK_DPAR_DATA_SYM_MAT_TOL_HUGE`. Data tolerance threshold.
* `MSK_DPAR_DATA_SYM_MAT_TOL_LARGE`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_AIJ_HUGE`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_AIJ_LARGE`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_BOUND_INF`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_BOUND_WRN`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_C_HUGE`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_CJ_LARGE`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_QIJ`. Data tolerance threshold.
* `MSK_DPAR_DATA_TOL_X`. Data tolerance threshold.
* `MSK_DPAR_INTPNT_CO_TOL_DFEAS`. Dual feasibility tolerance used by the interior-point optimizer for conic problems.
* `MSK_DPAR_INTPNT_CO_TOL_INFEAS`. Infeasibility tolerance used by the interior-point optimizer for conic problems.
* `MSK_DPAR_INTPNT_CO_TOL_MU_RED`. Relative complementarity gap tolerance used by the interior-point optimizer for conic problems.
* `MSK_DPAR_INTPNT_CO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for conic problems.
* `MSK_DPAR_INTPNT_CO_TOL_PFEAS`. Primal feasibility tolerance used by the interior-point optimizer for conic problems.
* `MSK_DPAR_INTPNT_CO_TOL_REL_GAP`. Relative gap termination tolerance used by the interior-point optimizer for conic problems.
* `MSK_DPAR_INTPNT_QO_TOL_DFEAS`. Dual feasibility tolerance used by the interior-point optimizer for quadratic problems.
* `MSK_DPAR_INTPNT_QO_TOL_INFEAS`. Infeasibility tolerance used by the interior-point optimizer for quadratic problems.
* `MSK_DPAR_INTPNT_QO_TOL_MU_RED`. Relative complementarity gap tolerance used by the interior-point optimizer for quadratic problems.
* `MSK_DPAR_INTPNT_QO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for quadratic problems.
* `MSK_DPAR_INTPNT_QO_TOL_PFEAS`. Primal feasibility tolerance used by the interior-point optimizer for quadratic problems.
* `MSK_DPAR_INTPNT_QO_TOL_REL_GAP`. Relative gap termination tolerance used by the interior-point optimizer for quadratic problems.
* `MSK_DPAR_INTPNT_TOL_DFEAS`. Dual feasibility tolerance used by the interior-point optimizer for linear problems.
* `MSK_DPAR_INTPNT_TOL_DSAFE`. Controls the interior-point dual starting point.
* `MSK_DPAR_INTPNT_TOL_INFEAS`. Infeasibility tolerance used by the interior-point optimizer for linear problems.
* `MSK_DPAR_INTPNT_TOL_MU_RED`. Relative complementarity gap tolerance used by the interior-point optimizer for linear problems.
* `MSK_DPAR_INTPNT_TOL_PATH`. Interior-point centering aggressiveness.
* `MSK_DPAR_INTPNT_TOL_PFEAS`. Primal feasibility tolerance used by the interior-point optimizer for linear problems.
* `MSK_DPAR_INTPNT_TOL_PSAFE`. Controls the interior-point primal starting point.
* `MSK_DPAR_INTPNT_TOL_REL_GAP`. Relative gap termination tolerance used by the interior-point optimizer for linear problems.
* `MSK_DPAR_INTPNT_TOL_REL_STEP`. Relative step size to the boundary for linear and quadratic optimization problems.
* `MSK_DPAR_INTPNT_TOL_STEP_SIZE`. Minimal step size tolerance for the interior-point optimizer.
* `MSK_DPAR_LOWER_OBJ_CUT`. Objective bound.
* `MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH`. Objective bound.
* `MSK_DPAR_MIO_DJC_MAX_BIGM`. Maximum allowed big-M value when reformulating disjunctive constraints to linear constraints.
* `MSK_DPAR_MIO_MAX_TIME`. Time limit for the mixed-integer optimizer.
* `MSK_DPAR_MIO_REL_GAP_CONST`. This value is used to compute the relative gap for the solution to an integer optimization problem.
* `MSK_DPAR_MIO_TOL_ABS_GAP`. Absolute optimality tolerance employed by the mixed-integer optimizer.
* `MSK_DPAR_MIO_TOL_ABS_RELAX_INT`. Integer feasibility tolerance.
* `MSK_DPAR_MIO_TOL_FEAS`. Feasibility tolerance for mixed integer solver.
* `MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT`. Controls cut generation for mixed-integer optimizer.
* `MSK_DPAR_MIO_TOL_REL_GAP`. Relative optimality tolerance employed by the mixed-integer optimizer.
* `MSK_DPAR_OPTIMIZER_MAX_TICKS`. Solver ticks limit.
* `MSK_DPAR_OPTIMIZER_MAX_TIME`. Solver time limit.
* `MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP`. Absolute tolerance employed by the linear dependency checker.
* `MSK_DPAR_PRESOLVE_TOL_AIJ`. Absolute zero tolerance employed for constraint coefficients in the presolve.
* `MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION`. The presolve is allowed to perturb a bound on a constraint or variable by this amount if it removes an infeasibility.
* `MSK_DPAR_PRESOLVE_TOL_REL_LINDEP`. Relative tolerance employed by the linear dependency checker.
* `MSK_DPAR_PRESOLVE_TOL_S`. Absolute zero tolerance employed for slack variables in the presolve.
* `MSK_DPAR_PRESOLVE_TOL_X`. Absolute zero tolerance employed for variables in the presolve.
* `MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL`. This parameter determines when columns are dropped in incomplete Cholesky factorization during reformulation of quadratic problems.
* `MSK_DPAR_SEMIDEFINITE_TOL_APPROX`. Tolerance to define a matrix to be positive semidefinite.
* `MSK_DPAR_SIM_LU_TOL_REL_PIV`. Relative pivot tolerance employed when computing the LU factorization of the basis matrix.
* `MSK_DPAR_SIMPLEX_ABS_TOL_PIV`. Absolute pivot tolerance employed by the simplex optimizers.
* `MSK_DPAR_UPPER_OBJ_CUT`. Objective bound.
* `MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH`. Objective bound.
"""
struct Dparam <: MosekEnum
  value :: Int32
end # dparam

"""
If a constraint violates its bound with an amount larger than this value, the constraint name, index and violation will be printed by the solution analyzer.

Default value: `1e-6`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_ANA_SOL_INFEAS_TOL = Dparam(0)

"""
Maximum relative dual bound violation allowed in an optimal basic solution.

Default value: `1.0e-12`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_BASIS_REL_TOL_S = Dparam(1)

"""
Maximum absolute dual bound violation in an optimal basic solution.

Default value: `1.0e-6`

Possible Values: Any number between 1.0e-9 and +inf.
"""
const MSK_DPAR_BASIS_TOL_S = Dparam(2)

"""
Maximum absolute primal bound violation allowed in an optimal basic solution.

Default value: `1.0e-6`

Possible Values: Any number between 1.0e-9 and +inf.
"""
const MSK_DPAR_BASIS_TOL_X = Dparam(3)

"""
Not in use.

Default value: `1e-10`

Possible Values: Any number between 0 and +inf.
"""
const MSK_DPAR_CHECK_CONVEXITY_REL_TOL = Dparam(4)

"""
Zero tolerance threshold for symmetric matrices.

Default value: `1.0e-12`

Possible Values: Any number between 1.0e-16 and 1.0e-6.
"""
const MSK_DPAR_DATA_SYM_MAT_TOL = Dparam(5)

"""
Data tolerance threshold.

Default value: `1.0e20`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_SYM_MAT_TOL_HUGE = Dparam(6)

"""
Data tolerance threshold.

Default value: `1.0e10`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_SYM_MAT_TOL_LARGE = Dparam(7)

"""
Data tolerance threshold.

Default value: `1.0e20`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_AIJ_HUGE = Dparam(8)

"""
Data tolerance threshold.

Default value: `1.0e10`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_AIJ_LARGE = Dparam(9)

"""
Data tolerance threshold.

Default value: `1.0e16`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_BOUND_INF = Dparam(10)

"""
Data tolerance threshold.

Default value: `1.0e8`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_BOUND_WRN = Dparam(11)

"""
Data tolerance threshold.

Default value: `1.0e16`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_C_HUGE = Dparam(12)

"""
Data tolerance threshold.

Default value: `1.0e8`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_CJ_LARGE = Dparam(13)

"""
Data tolerance threshold.

Default value: `1.0e-16`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_QIJ = Dparam(14)

"""
Data tolerance threshold.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_DATA_TOL_X = Dparam(15)

"""
Dual feasibility tolerance used by the interior-point optimizer for conic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.

See also:
* `MSK_DPAR_INTPNT_CO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for conic problems.
"""
const MSK_DPAR_INTPNT_CO_TOL_DFEAS = Dparam(16)

"""
Infeasibility tolerance used by the interior-point optimizer for conic problems.

Default value: `1.0e-12`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_CO_TOL_INFEAS = Dparam(17)

"""
Relative complementarity gap tolerance used by the interior-point optimizer for conic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_CO_TOL_MU_RED = Dparam(18)

"""
Optimality tolerance used by the interior-point optimizer for conic problems.

Default value: `1000`

Possible Values: Any number between 1.0 and +inf.
"""
const MSK_DPAR_INTPNT_CO_TOL_NEAR_REL = Dparam(19)

"""
Primal feasibility tolerance used by the interior-point optimizer for conic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.

See also:
* `MSK_DPAR_INTPNT_CO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for conic problems.
"""
const MSK_DPAR_INTPNT_CO_TOL_PFEAS = Dparam(20)

"""
Relative gap termination tolerance used by the interior-point optimizer for conic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.

See also:
* `MSK_DPAR_INTPNT_CO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for conic problems.
"""
const MSK_DPAR_INTPNT_CO_TOL_REL_GAP = Dparam(21)

"""
Dual feasibility tolerance used by the interior-point optimizer for quadratic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.

See also:
* `MSK_DPAR_INTPNT_QO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for quadratic problems.
"""
const MSK_DPAR_INTPNT_QO_TOL_DFEAS = Dparam(22)

"""
Infeasibility tolerance used by the interior-point optimizer for quadratic problems.

Default value: `1.0e-12`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_QO_TOL_INFEAS = Dparam(23)

"""
Relative complementarity gap tolerance used by the interior-point optimizer for quadratic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_QO_TOL_MU_RED = Dparam(24)

"""
Optimality tolerance used by the interior-point optimizer for quadratic problems.

Default value: `1000`

Possible Values: Any number between 1.0 and +inf.
"""
const MSK_DPAR_INTPNT_QO_TOL_NEAR_REL = Dparam(25)

"""
Primal feasibility tolerance used by the interior-point optimizer for quadratic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.

See also:
* `MSK_DPAR_INTPNT_QO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for quadratic problems.
"""
const MSK_DPAR_INTPNT_QO_TOL_PFEAS = Dparam(26)

"""
Relative gap termination tolerance used by the interior-point optimizer for quadratic problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.

See also:
* `MSK_DPAR_INTPNT_QO_TOL_NEAR_REL`. Optimality tolerance used by the interior-point optimizer for quadratic problems.
"""
const MSK_DPAR_INTPNT_QO_TOL_REL_GAP = Dparam(27)

"""
Dual feasibility tolerance used by the interior-point optimizer for linear problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_TOL_DFEAS = Dparam(28)

"""
Controls the interior-point dual starting point.

Default value: `1.0`

Possible Values: Any number between 1.0e-4 and +inf.
"""
const MSK_DPAR_INTPNT_TOL_DSAFE = Dparam(29)

"""
Infeasibility tolerance used by the interior-point optimizer for linear problems.

Default value: `1.0e-10`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_TOL_INFEAS = Dparam(30)

"""
Relative complementarity gap tolerance used by the interior-point optimizer for linear problems.

Default value: `1.0e-16`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_TOL_MU_RED = Dparam(31)

"""
Interior-point centering aggressiveness.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 0.9999.
"""
const MSK_DPAR_INTPNT_TOL_PATH = Dparam(32)

"""
Primal feasibility tolerance used by the interior-point optimizer for linear problems.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_TOL_PFEAS = Dparam(33)

"""
Controls the interior-point primal starting point.

Default value: `1.0`

Possible Values: Any number between 1.0e-4 and +inf.
"""
const MSK_DPAR_INTPNT_TOL_PSAFE = Dparam(34)

"""
Relative gap termination tolerance used by the interior-point optimizer for linear problems.

Default value: `1.0e-8`

Possible Values: Any number between 1.0e-14 and +inf.
"""
const MSK_DPAR_INTPNT_TOL_REL_GAP = Dparam(35)

"""
Relative step size to the boundary for linear and quadratic optimization problems.

Default value: `0.9999`

Possible Values: Any number between 1.0e-4 and 0.999999.
"""
const MSK_DPAR_INTPNT_TOL_REL_STEP = Dparam(36)

"""
Minimal step size tolerance for the interior-point optimizer.

Default value: `1.0e-6`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_INTPNT_TOL_STEP_SIZE = Dparam(37)

"""
Objective bound.

Default value: `-1.0e30`

Possible Values: Any number between -inf and +inf.

See also:
* `MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH`. Objective bound.
"""
const MSK_DPAR_LOWER_OBJ_CUT = Dparam(38)

"""
Objective bound.

Default value: `-0.5e30`

Possible Values: Any number between -inf and +inf.
"""
const MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH = Dparam(39)

"""
Maximum allowed big-M value when reformulating disjunctive constraints to linear constraints.

Default value: `1.0e6`

Possible Values: Any number between 0 and +inf.
"""
const MSK_DPAR_MIO_DJC_MAX_BIGM = Dparam(40)

"""
Time limit for the mixed-integer optimizer.

Default value: `-1.0`

Possible Values: Any number between -inf and +inf.
"""
const MSK_DPAR_MIO_MAX_TIME = Dparam(41)

"""
This value is used to compute the relative gap for the solution to an integer optimization problem.

Default value: `1.0e-10`

Possible Values: Any number between 1.0e-15 and +inf.
"""
const MSK_DPAR_MIO_REL_GAP_CONST = Dparam(42)

"""
Absolute optimality tolerance employed by the mixed-integer optimizer.

Default value: `0.0`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_MIO_TOL_ABS_GAP = Dparam(43)

"""
Integer feasibility tolerance.

Default value: `1.0e-5`

Possible Values: Any number between 1e-9 and +inf.
"""
const MSK_DPAR_MIO_TOL_ABS_RELAX_INT = Dparam(44)

"""
Feasibility tolerance for mixed integer solver.

Default value: `1.0e-6`

Possible Values: Any number between 1e-9 and 1e-3.
"""
const MSK_DPAR_MIO_TOL_FEAS = Dparam(45)

"""
Controls cut generation for mixed-integer optimizer.

Default value: `0.0`

Possible Values: Any number between 0.0 and 1.0.
"""
const MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT = Dparam(46)

"""
Relative optimality tolerance employed by the mixed-integer optimizer.

Default value: `1.0e-4`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_MIO_TOL_REL_GAP = Dparam(47)

"""
Solver ticks limit.

Default value: `-1.0`

Possible Values: Any number between -inf and +inf.
"""
const MSK_DPAR_OPTIMIZER_MAX_TICKS = Dparam(48)

"""
Solver time limit.

Default value: `-1.0`

Possible Values: Any number between -inf and +inf.
"""
const MSK_DPAR_OPTIMIZER_MAX_TIME = Dparam(49)

"""
Absolute tolerance employed by the linear dependency checker.

Default value: `1.0e-6`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP = Dparam(50)

"""
Absolute zero tolerance employed for constraint coefficients in the presolve.

Default value: `1.0e-12`

Possible Values: Any number between 1.0e-15 and +inf.
"""
const MSK_DPAR_PRESOLVE_TOL_AIJ = Dparam(51)

"""
The presolve is allowed to perturb a bound on a constraint or variable by this amount if it removes an infeasibility.

Default value: `1.0e-6`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION = Dparam(52)

"""
Relative tolerance employed by the linear dependency checker.

Default value: `1.0e-10`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_PRESOLVE_TOL_REL_LINDEP = Dparam(53)

"""
Absolute zero tolerance employed for slack variables in the presolve.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_PRESOLVE_TOL_S = Dparam(54)

"""
Absolute zero tolerance employed for variables in the presolve.

Default value: `1.0e-8`

Possible Values: Any number between 0.0 and +inf.
"""
const MSK_DPAR_PRESOLVE_TOL_X = Dparam(55)

"""
This parameter determines when columns are dropped in incomplete Cholesky factorization during reformulation of quadratic problems.

Default value: `1e-15`

Possible Values: Any number between 0 and +inf.
"""
const MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL = Dparam(56)

"""
Tolerance to define a matrix to be positive semidefinite.

Default value: `1.0e-10`

Possible Values: Any number between 1.0e-15 and +inf.
"""
const MSK_DPAR_SEMIDEFINITE_TOL_APPROX = Dparam(57)

"""
Relative pivot tolerance employed when computing the LU factorization of the basis matrix.

Default value: `0.01`

Possible Values: Any number between 1.0e-6 and 0.999999.
"""
const MSK_DPAR_SIM_LU_TOL_REL_PIV = Dparam(58)

"""
Absolute pivot tolerance employed by the simplex optimizers.

Default value: `1.0e-7`

Possible Values: Any number between 1.0e-12 and +inf.
"""
const MSK_DPAR_SIMPLEX_ABS_TOL_PIV = Dparam(59)

"""
Objective bound.

Default value: `1.0e30`

Possible Values: Any number between -inf and +inf.

See also:
* `MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH`. Objective bound.
"""
const MSK_DPAR_UPPER_OBJ_CUT = Dparam(60)

"""
Objective bound.

Default value: `0.5e30`

Possible Values: Any number between -inf and +inf.
"""
const MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH = Dparam(61)
tostr(v::Dparam) = if v.value == 0 "Mosek.MSK_DPAR_ANA_SOL_INFEAS_TOL"
  elseif v.value == 1 "Mosek.MSK_DPAR_BASIS_REL_TOL_S"
  elseif v.value == 2 "Mosek.MSK_DPAR_BASIS_TOL_S"
  elseif v.value == 3 "Mosek.MSK_DPAR_BASIS_TOL_X"
  elseif v.value == 4 "Mosek.MSK_DPAR_CHECK_CONVEXITY_REL_TOL"
  elseif v.value == 5 "Mosek.MSK_DPAR_DATA_SYM_MAT_TOL"
  elseif v.value == 6 "Mosek.MSK_DPAR_DATA_SYM_MAT_TOL_HUGE"
  elseif v.value == 7 "Mosek.MSK_DPAR_DATA_SYM_MAT_TOL_LARGE"
  elseif v.value == 8 "Mosek.MSK_DPAR_DATA_TOL_AIJ_HUGE"
  elseif v.value == 9 "Mosek.MSK_DPAR_DATA_TOL_AIJ_LARGE"
  elseif v.value == 10 "Mosek.MSK_DPAR_DATA_TOL_BOUND_INF"
  elseif v.value == 11 "Mosek.MSK_DPAR_DATA_TOL_BOUND_WRN"
  elseif v.value == 12 "Mosek.MSK_DPAR_DATA_TOL_C_HUGE"
  elseif v.value == 13 "Mosek.MSK_DPAR_DATA_TOL_CJ_LARGE"
  elseif v.value == 14 "Mosek.MSK_DPAR_DATA_TOL_QIJ"
  elseif v.value == 15 "Mosek.MSK_DPAR_DATA_TOL_X"
  elseif v.value == 16 "Mosek.MSK_DPAR_INTPNT_CO_TOL_DFEAS"
  elseif v.value == 17 "Mosek.MSK_DPAR_INTPNT_CO_TOL_INFEAS"
  elseif v.value == 18 "Mosek.MSK_DPAR_INTPNT_CO_TOL_MU_RED"
  elseif v.value == 19 "Mosek.MSK_DPAR_INTPNT_CO_TOL_NEAR_REL"
  elseif v.value == 20 "Mosek.MSK_DPAR_INTPNT_CO_TOL_PFEAS"
  elseif v.value == 21 "Mosek.MSK_DPAR_INTPNT_CO_TOL_REL_GAP"
  elseif v.value == 22 "Mosek.MSK_DPAR_INTPNT_QO_TOL_DFEAS"
  elseif v.value == 23 "Mosek.MSK_DPAR_INTPNT_QO_TOL_INFEAS"
  elseif v.value == 24 "Mosek.MSK_DPAR_INTPNT_QO_TOL_MU_RED"
  elseif v.value == 25 "Mosek.MSK_DPAR_INTPNT_QO_TOL_NEAR_REL"
  elseif v.value == 26 "Mosek.MSK_DPAR_INTPNT_QO_TOL_PFEAS"
  elseif v.value == 27 "Mosek.MSK_DPAR_INTPNT_QO_TOL_REL_GAP"
  elseif v.value == 28 "Mosek.MSK_DPAR_INTPNT_TOL_DFEAS"
  elseif v.value == 29 "Mosek.MSK_DPAR_INTPNT_TOL_DSAFE"
  elseif v.value == 30 "Mosek.MSK_DPAR_INTPNT_TOL_INFEAS"
  elseif v.value == 31 "Mosek.MSK_DPAR_INTPNT_TOL_MU_RED"
  elseif v.value == 32 "Mosek.MSK_DPAR_INTPNT_TOL_PATH"
  elseif v.value == 33 "Mosek.MSK_DPAR_INTPNT_TOL_PFEAS"
  elseif v.value == 34 "Mosek.MSK_DPAR_INTPNT_TOL_PSAFE"
  elseif v.value == 35 "Mosek.MSK_DPAR_INTPNT_TOL_REL_GAP"
  elseif v.value == 36 "Mosek.MSK_DPAR_INTPNT_TOL_REL_STEP"
  elseif v.value == 37 "Mosek.MSK_DPAR_INTPNT_TOL_STEP_SIZE"
  elseif v.value == 38 "Mosek.MSK_DPAR_LOWER_OBJ_CUT"
  elseif v.value == 39 "Mosek.MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH"
  elseif v.value == 40 "Mosek.MSK_DPAR_MIO_DJC_MAX_BIGM"
  elseif v.value == 41 "Mosek.MSK_DPAR_MIO_MAX_TIME"
  elseif v.value == 42 "Mosek.MSK_DPAR_MIO_REL_GAP_CONST"
  elseif v.value == 43 "Mosek.MSK_DPAR_MIO_TOL_ABS_GAP"
  elseif v.value == 44 "Mosek.MSK_DPAR_MIO_TOL_ABS_RELAX_INT"
  elseif v.value == 45 "Mosek.MSK_DPAR_MIO_TOL_FEAS"
  elseif v.value == 46 "Mosek.MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT"
  elseif v.value == 47 "Mosek.MSK_DPAR_MIO_TOL_REL_GAP"
  elseif v.value == 48 "Mosek.MSK_DPAR_OPTIMIZER_MAX_TICKS"
  elseif v.value == 49 "Mosek.MSK_DPAR_OPTIMIZER_MAX_TIME"
  elseif v.value == 50 "Mosek.MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP"
  elseif v.value == 51 "Mosek.MSK_DPAR_PRESOLVE_TOL_AIJ"
  elseif v.value == 52 "Mosek.MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION"
  elseif v.value == 53 "Mosek.MSK_DPAR_PRESOLVE_TOL_REL_LINDEP"
  elseif v.value == 54 "Mosek.MSK_DPAR_PRESOLVE_TOL_S"
  elseif v.value == 55 "Mosek.MSK_DPAR_PRESOLVE_TOL_X"
  elseif v.value == 56 "Mosek.MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL"
  elseif v.value == 57 "Mosek.MSK_DPAR_SEMIDEFINITE_TOL_APPROX"
  elseif v.value == 58 "Mosek.MSK_DPAR_SIM_LU_TOL_REL_PIV"
  elseif v.value == 59 "Mosek.MSK_DPAR_SIMPLEX_ABS_TOL_PIV"
  elseif v.value == 60 "Mosek.MSK_DPAR_UPPER_OBJ_CUT"
  elseif v.value == 61 "Mosek.MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH"
  else "Mosek.Dparam(?)"
  end
const Dparam_members = Dparam[
    MSK_DPAR_ANA_SOL_INFEAS_TOL,
    MSK_DPAR_BASIS_REL_TOL_S,
    MSK_DPAR_BASIS_TOL_S,
    MSK_DPAR_BASIS_TOL_X,
    MSK_DPAR_CHECK_CONVEXITY_REL_TOL,
    MSK_DPAR_DATA_SYM_MAT_TOL,
    MSK_DPAR_DATA_SYM_MAT_TOL_HUGE,
    MSK_DPAR_DATA_SYM_MAT_TOL_LARGE,
    MSK_DPAR_DATA_TOL_AIJ_HUGE,
    MSK_DPAR_DATA_TOL_AIJ_LARGE,
    MSK_DPAR_DATA_TOL_BOUND_INF,
    MSK_DPAR_DATA_TOL_BOUND_WRN,
    MSK_DPAR_DATA_TOL_C_HUGE,
    MSK_DPAR_DATA_TOL_CJ_LARGE,
    MSK_DPAR_DATA_TOL_QIJ,
    MSK_DPAR_DATA_TOL_X,
    MSK_DPAR_INTPNT_CO_TOL_DFEAS,
    MSK_DPAR_INTPNT_CO_TOL_INFEAS,
    MSK_DPAR_INTPNT_CO_TOL_MU_RED,
    MSK_DPAR_INTPNT_CO_TOL_NEAR_REL,
    MSK_DPAR_INTPNT_CO_TOL_PFEAS,
    MSK_DPAR_INTPNT_CO_TOL_REL_GAP,
    MSK_DPAR_INTPNT_QO_TOL_DFEAS,
    MSK_DPAR_INTPNT_QO_TOL_INFEAS,
    MSK_DPAR_INTPNT_QO_TOL_MU_RED,
    MSK_DPAR_INTPNT_QO_TOL_NEAR_REL,
    MSK_DPAR_INTPNT_QO_TOL_PFEAS,
    MSK_DPAR_INTPNT_QO_TOL_REL_GAP,
    MSK_DPAR_INTPNT_TOL_DFEAS,
    MSK_DPAR_INTPNT_TOL_DSAFE,
    MSK_DPAR_INTPNT_TOL_INFEAS,
    MSK_DPAR_INTPNT_TOL_MU_RED,
    MSK_DPAR_INTPNT_TOL_PATH,
    MSK_DPAR_INTPNT_TOL_PFEAS,
    MSK_DPAR_INTPNT_TOL_PSAFE,
    MSK_DPAR_INTPNT_TOL_REL_GAP,
    MSK_DPAR_INTPNT_TOL_REL_STEP,
    MSK_DPAR_INTPNT_TOL_STEP_SIZE,
    MSK_DPAR_LOWER_OBJ_CUT,
    MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH,
    MSK_DPAR_MIO_DJC_MAX_BIGM,
    MSK_DPAR_MIO_MAX_TIME,
    MSK_DPAR_MIO_REL_GAP_CONST,
    MSK_DPAR_MIO_TOL_ABS_GAP,
    MSK_DPAR_MIO_TOL_ABS_RELAX_INT,
    MSK_DPAR_MIO_TOL_FEAS,
    MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT,
    MSK_DPAR_MIO_TOL_REL_GAP,
    MSK_DPAR_OPTIMIZER_MAX_TICKS,
    MSK_DPAR_OPTIMIZER_MAX_TIME,
    MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP,
    MSK_DPAR_PRESOLVE_TOL_AIJ,
    MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION,
    MSK_DPAR_PRESOLVE_TOL_REL_LINDEP,
    MSK_DPAR_PRESOLVE_TOL_S,
    MSK_DPAR_PRESOLVE_TOL_X,
    MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL,
    MSK_DPAR_SEMIDEFINITE_TOL_APPROX,
    MSK_DPAR_SIM_LU_TOL_REL_PIV,
    MSK_DPAR_SIMPLEX_ABS_TOL_PIV,
    MSK_DPAR_UPPER_OBJ_CUT,
    MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH ]
members(::Type{Dparam}) = Dparam_members
Base.length(::Type{Dparam}) = 62
Base.convert(::Type{Int},x::Dparam) = Int(x.value)
"""
    Liinfitem

Long integer information items.

* `MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS`. Number of columns in the scalarized constraint matrix.
* `MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ`. Number of non-zero entries in the scalarized constraint matrix.
* `MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS`. Number of rows in the scalarized constraint matrix.
* `MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER`. Number of dual degenerate clean iterations performed in the basis identification.
* `MSK_LIINF_BI_CLEAN_DUAL_ITER`. Number of dual clean iterations performed in the basis identification.
* `MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER`. Number of primal degenerate clean iterations performed in the basis identification.
* `MSK_LIINF_BI_CLEAN_PRIMAL_ITER`. Number of primal clean iterations performed in the basis identification.
* `MSK_LIINF_BI_DUAL_ITER`. Number of dual pivots performed in the basis identification.
* `MSK_LIINF_BI_PRIMAL_ITER`. Number of primal pivots performed in the basis identification.
* `MSK_LIINF_INTPNT_FACTOR_NUM_NZ`. Number of non-zeros in factorization.
* `MSK_LIINF_MIO_ANZ`. Number of non-zero entries in the constraint matrix of the problem to be solved by the mixed-integer optimizer.
* `MSK_LIINF_MIO_INTPNT_ITER`. Number of interior-point iterations performed by the mixed-integer optimizer.
* `MSK_LIINF_MIO_NUM_DUAL_ILLPOSED_CER`. Number of dual illposed certificates encountered by the mixed-integer optimizer.
* `MSK_LIINF_MIO_NUM_PRIM_ILLPOSED_CER`. Number of primal illposed certificates encountered by the mixed-integer optimizer.
* `MSK_LIINF_MIO_PRESOLVED_ANZ`. Number of non-zero entries in the constraint matrix of the problem after the mixed-integer optimizer's presolve.
* `MSK_LIINF_MIO_SIMPLEX_ITER`. Number of simplex iterations performed by the mixed-integer optimizer.
* `MSK_LIINF_RD_NUMACC`. Number of affince conic constraints.
* `MSK_LIINF_RD_NUMANZ`. Number of non-zeros in A that is read.
* `MSK_LIINF_RD_NUMDJC`. Number of disjuncive constraints.
* `MSK_LIINF_RD_NUMQNZ`. Number of Q non-zeros.
* `MSK_LIINF_SIMPLEX_ITER`. Number of iterations performed by the simplex optimizer.
"""
struct Liinfitem <: MosekEnum
  value :: Int32
end # liinfitem

"Number of columns in the scalarized constraint matrix."
const MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS = Liinfitem(0)

"Number of non-zero entries in the scalarized constraint matrix."
const MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ = Liinfitem(1)

"Number of rows in the scalarized constraint matrix."
const MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS = Liinfitem(2)

"Number of dual degenerate clean iterations performed in the basis identification."
const MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER = Liinfitem(3)

"Number of dual clean iterations performed in the basis identification."
const MSK_LIINF_BI_CLEAN_DUAL_ITER = Liinfitem(4)

"Number of primal degenerate clean iterations performed in the basis identification."
const MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER = Liinfitem(5)

"Number of primal clean iterations performed in the basis identification."
const MSK_LIINF_BI_CLEAN_PRIMAL_ITER = Liinfitem(6)

"Number of dual pivots performed in the basis identification."
const MSK_LIINF_BI_DUAL_ITER = Liinfitem(7)

"Number of primal pivots performed in the basis identification."
const MSK_LIINF_BI_PRIMAL_ITER = Liinfitem(8)

"Number of non-zeros in factorization."
const MSK_LIINF_INTPNT_FACTOR_NUM_NZ = Liinfitem(9)

"Number of non-zero entries in the constraint matrix of the problem to be solved by the mixed-integer optimizer."
const MSK_LIINF_MIO_ANZ = Liinfitem(10)

"Number of interior-point iterations performed by the mixed-integer optimizer."
const MSK_LIINF_MIO_INTPNT_ITER = Liinfitem(11)

"Number of dual illposed certificates encountered by the mixed-integer optimizer."
const MSK_LIINF_MIO_NUM_DUAL_ILLPOSED_CER = Liinfitem(12)

"Number of primal illposed certificates encountered by the mixed-integer optimizer."
const MSK_LIINF_MIO_NUM_PRIM_ILLPOSED_CER = Liinfitem(13)

"Number of non-zero entries in the constraint matrix of the problem after the mixed-integer optimizer's presolve."
const MSK_LIINF_MIO_PRESOLVED_ANZ = Liinfitem(14)

"Number of simplex iterations performed by the mixed-integer optimizer."
const MSK_LIINF_MIO_SIMPLEX_ITER = Liinfitem(15)

"Number of affince conic constraints."
const MSK_LIINF_RD_NUMACC = Liinfitem(16)

"Number of non-zeros in A that is read."
const MSK_LIINF_RD_NUMANZ = Liinfitem(17)

"Number of disjuncive constraints."
const MSK_LIINF_RD_NUMDJC = Liinfitem(18)

"Number of Q non-zeros."
const MSK_LIINF_RD_NUMQNZ = Liinfitem(19)

"Number of iterations performed by the simplex optimizer."
const MSK_LIINF_SIMPLEX_ITER = Liinfitem(20)
tostr(v::Liinfitem) = if v.value == 0 "Mosek.MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS"
  elseif v.value == 1 "Mosek.MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ"
  elseif v.value == 2 "Mosek.MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS"
  elseif v.value == 3 "Mosek.MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER"
  elseif v.value == 4 "Mosek.MSK_LIINF_BI_CLEAN_DUAL_ITER"
  elseif v.value == 5 "Mosek.MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER"
  elseif v.value == 6 "Mosek.MSK_LIINF_BI_CLEAN_PRIMAL_ITER"
  elseif v.value == 7 "Mosek.MSK_LIINF_BI_DUAL_ITER"
  elseif v.value == 8 "Mosek.MSK_LIINF_BI_PRIMAL_ITER"
  elseif v.value == 9 "Mosek.MSK_LIINF_INTPNT_FACTOR_NUM_NZ"
  elseif v.value == 10 "Mosek.MSK_LIINF_MIO_ANZ"
  elseif v.value == 11 "Mosek.MSK_LIINF_MIO_INTPNT_ITER"
  elseif v.value == 12 "Mosek.MSK_LIINF_MIO_NUM_DUAL_ILLPOSED_CER"
  elseif v.value == 13 "Mosek.MSK_LIINF_MIO_NUM_PRIM_ILLPOSED_CER"
  elseif v.value == 14 "Mosek.MSK_LIINF_MIO_PRESOLVED_ANZ"
  elseif v.value == 15 "Mosek.MSK_LIINF_MIO_SIMPLEX_ITER"
  elseif v.value == 16 "Mosek.MSK_LIINF_RD_NUMACC"
  elseif v.value == 17 "Mosek.MSK_LIINF_RD_NUMANZ"
  elseif v.value == 18 "Mosek.MSK_LIINF_RD_NUMDJC"
  elseif v.value == 19 "Mosek.MSK_LIINF_RD_NUMQNZ"
  elseif v.value == 20 "Mosek.MSK_LIINF_SIMPLEX_ITER"
  else "Mosek.Liinfitem(?)"
  end
const Liinfitem_members = Liinfitem[
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS,
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ,
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS,
    MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER,
    MSK_LIINF_BI_CLEAN_DUAL_ITER,
    MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER,
    MSK_LIINF_BI_CLEAN_PRIMAL_ITER,
    MSK_LIINF_BI_DUAL_ITER,
    MSK_LIINF_BI_PRIMAL_ITER,
    MSK_LIINF_INTPNT_FACTOR_NUM_NZ,
    MSK_LIINF_MIO_ANZ,
    MSK_LIINF_MIO_INTPNT_ITER,
    MSK_LIINF_MIO_NUM_DUAL_ILLPOSED_CER,
    MSK_LIINF_MIO_NUM_PRIM_ILLPOSED_CER,
    MSK_LIINF_MIO_PRESOLVED_ANZ,
    MSK_LIINF_MIO_SIMPLEX_ITER,
    MSK_LIINF_RD_NUMACC,
    MSK_LIINF_RD_NUMANZ,
    MSK_LIINF_RD_NUMDJC,
    MSK_LIINF_RD_NUMQNZ,
    MSK_LIINF_SIMPLEX_ITER ]
members(::Type{Liinfitem}) = Liinfitem_members
Base.length(::Type{Liinfitem}) = 21
Base.convert(::Type{Int},x::Liinfitem) = Int(x.value)
"""
    Iinfitem

Integer information items.

* `MSK_IINF_ANA_PRO_NUM_CON`. Number of constraints in the problem.
* `MSK_IINF_ANA_PRO_NUM_CON_EQ`. Number of equality constraints.
* `MSK_IINF_ANA_PRO_NUM_CON_FR`. Number of unbounded constraints.
* `MSK_IINF_ANA_PRO_NUM_CON_LO`. Number of constraints with a lower bound and an infinite upper bound.
* `MSK_IINF_ANA_PRO_NUM_CON_RA`. Number of constraints with finite lower and upper bounds.
* `MSK_IINF_ANA_PRO_NUM_CON_UP`. Number of constraints with an upper bound and an infinite lower bound.
* `MSK_IINF_ANA_PRO_NUM_VAR`. Number of variables in the problem.
* `MSK_IINF_ANA_PRO_NUM_VAR_BIN`. Number of binary variables.
* `MSK_IINF_ANA_PRO_NUM_VAR_CONT`. Number of continuous variables.
* `MSK_IINF_ANA_PRO_NUM_VAR_EQ`. Number of fixed variables.
* `MSK_IINF_ANA_PRO_NUM_VAR_FR`. Number of unbounded constraints.
* `MSK_IINF_ANA_PRO_NUM_VAR_INT`. Number of general integer variables.
* `MSK_IINF_ANA_PRO_NUM_VAR_LO`. Number of variables with a lower bound and an infinite upper bound.
* `MSK_IINF_ANA_PRO_NUM_VAR_RA`. Number of variables with finite lower and upper bounds.
* `MSK_IINF_ANA_PRO_NUM_VAR_UP`. Number of variables with an upper bound and an infinite lower bound.
* `MSK_IINF_INTPNT_FACTOR_DIM_DENSE`. Dimension of the dense sub system in factorization.
* `MSK_IINF_INTPNT_ITER`. Number of interior-point iterations since invoking the interior-point optimizer.
* `MSK_IINF_INTPNT_NUM_THREADS`. Number of threads that the interior-point optimizer is using.
* `MSK_IINF_INTPNT_SOLVE_DUAL`. Non-zero if the interior-point optimizer is solving the dual problem.
* `MSK_IINF_MIO_ABSGAP_SATISFIED`. Non-zero if absolute gap is within tolerances.
* `MSK_IINF_MIO_CLIQUE_TABLE_SIZE`. Size of the clique table.
* `MSK_IINF_MIO_CONSTRUCT_SOLUTION`. Informs if MOSEK successfully constructed an initial integer feasible solution.
* `MSK_IINF_MIO_INITIAL_FEASIBLE_SOLUTION`. Informs if MOSEK found the solution provided by the user to be feasible
* `MSK_IINF_MIO_NODE_DEPTH`. Depth of the last node solved.
* `MSK_IINF_MIO_NUM_ACTIVE_NODES`. Number of active branch and bound nodes.
* `MSK_IINF_MIO_NUM_ACTIVE_ROOT_CUTS`. Number of active cuts in the final relaxation after the mixed-integer optimizer's root cut generation.
* `MSK_IINF_MIO_NUM_BRANCH`. Number of branches performed during the optimization.
* `MSK_IINF_MIO_NUM_INT_SOLUTIONS`. Number of integer feasible solutions that have been found.
* `MSK_IINF_MIO_NUM_RELAX`. Number of relaxations solved during the optimization.
* `MSK_IINF_MIO_NUM_REPEATED_PRESOLVE`. Number of times presolve was repeated at root.
* `MSK_IINF_MIO_NUM_RESTARTS`. Number of restarts performed during the optimization.
* `MSK_IINF_MIO_NUM_ROOT_CUT_ROUNDS`. Number of cut separation rounds at the root node of the mixed-integer optimizer.
* `MSK_IINF_MIO_NUM_SELECTED_CLIQUE_CUTS`. Number of clique cuts selected to be included in the relaxation.
* `MSK_IINF_MIO_NUM_SELECTED_CMIR_CUTS`. Number of Complemented Mixed Integer Rounding (CMIR) cuts selected to be included in the relaxation.
* `MSK_IINF_MIO_NUM_SELECTED_GOMORY_CUTS`. Number of Gomory cuts selected to be included in the relaxation.
* `MSK_IINF_MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS`. Number of implied bound cuts selected to be included in the relaxation.
* `MSK_IINF_MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS`. Number of clique cuts selected to be included in the relaxation.
* `MSK_IINF_MIO_NUM_SELECTED_LIPRO_CUTS`. Number of lift-and-project cuts selected to be included in the relaxation.
* `MSK_IINF_MIO_NUM_SEPARATED_CLIQUE_CUTS`. Number of separated clique cuts.
* `MSK_IINF_MIO_NUM_SEPARATED_CMIR_CUTS`. Number of separated Complemented Mixed Integer Rounding (CMIR) cuts.
* `MSK_IINF_MIO_NUM_SEPARATED_GOMORY_CUTS`. Number of separated Gomory cuts.
* `MSK_IINF_MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS`. Number of separated implied bound cuts.
* `MSK_IINF_MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS`. Number of separated clique cuts.
* `MSK_IINF_MIO_NUM_SEPARATED_LIPRO_CUTS`. Number of separated lift-and-project cuts.
* `MSK_IINF_MIO_NUM_SOLVED_NODES`. Number of branch and bounds nodes solved in the main branch and bound tree.
* `MSK_IINF_MIO_NUMBIN`. Number of binary variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMBINCONEVAR`. Number of binary cone variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMCON`. Number of constraints in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMCONE`. Number of cones in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMCONEVAR`. Number of cone variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMCONT`. Number of continuous variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMCONTCONEVAR`. Number of continuous cone variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMDEXPCONES`. Number of dual exponential cones in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMDJC`. Number of disjunctive constraints in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMDPOWCONES`. Number of dual power cones in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMINT`. Number of integer variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMINTCONEVAR`. Number of integer cone variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMPEXPCONES`. Number of primal exponential cones in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMPPOWCONES`. Number of primal power cones in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMQCONES`. Number of quadratic cones in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMRQCONES`. Number of rotated quadratic cones in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_NUMVAR`. Number of variables in the problem to be solved by the mixed-integer optimizer.
* `MSK_IINF_MIO_OBJ_BOUND_DEFINED`. Non-zero if a valid objective bound has been found, otherwise zero.
* `MSK_IINF_MIO_PRESOLVED_NUMBIN`. Number of binary variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR`. Number of binary cone variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMCON`. Number of constraints in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMCONE`. Number of cones in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMCONEVAR`. Number of cone variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMCONT`. Number of continuous variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR`. Number of continuous cone variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES`. Number of dual exponential cones in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMDJC`. Number of disjunctive constraints in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES`. Number of dual power cones in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMINT`. Number of integer variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR`. Number of integer cone variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES`. Number of primal exponential cones in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES`. Number of primal power cones in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMQCONES`. Number of quadratic cones in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMRQCONES`. Number of rotated quadratic cones in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_PRESOLVED_NUMVAR`. Number of variables in the problem after the mixed-integer optimizer's presolve.
* `MSK_IINF_MIO_RELGAP_SATISFIED`. Non-zero if relative gap is within tolerances.
* `MSK_IINF_MIO_TOTAL_NUM_SELECTED_CUTS`. Total number of cuts selected to be included in the relaxation by the mixed-integer optimizer.
* `MSK_IINF_MIO_TOTAL_NUM_SEPARATED_CUTS`. Total number of cuts separated by the mixed-integer optimizer.
* `MSK_IINF_MIO_USER_OBJ_CUT`. If it is non-zero, then the objective cut is used.
* `MSK_IINF_OPT_NUMCON`. Number of constraints in the problem solved when the optimizer is called.
* `MSK_IINF_OPT_NUMVAR`. Number of variables in the problem solved when the optimizer is called
* `MSK_IINF_OPTIMIZE_RESPONSE`. The response code returned by optimize.
* `MSK_IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS`. Number perturbations to thhe bounds of the primal problem.
* `MSK_IINF_PURIFY_DUAL_SUCCESS`. Is nonzero if the dual solution is purified.
* `MSK_IINF_PURIFY_PRIMAL_SUCCESS`. Is nonzero if the primal solution is purified.
* `MSK_IINF_RD_NUMBARVAR`. Number of symmetric variables read.
* `MSK_IINF_RD_NUMCON`. Number of constraints read.
* `MSK_IINF_RD_NUMCONE`. Number of conic constraints read.
* `MSK_IINF_RD_NUMINTVAR`. Number of integer-constrained variables read.
* `MSK_IINF_RD_NUMQ`. Number of nonempty Q matrices read.
* `MSK_IINF_RD_NUMVAR`. Number of variables read.
* `MSK_IINF_RD_PROTYPE`. Problem type.
* `MSK_IINF_SIM_DUAL_DEG_ITER`. The number of dual degenerate iterations.
* `MSK_IINF_SIM_DUAL_HOTSTART`. If 1 then the dual simplex algorithm is solving from an advanced basis.
* `MSK_IINF_SIM_DUAL_HOTSTART_LU`. If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm.
* `MSK_IINF_SIM_DUAL_INF_ITER`. The number of iterations taken with dual infeasibility.
* `MSK_IINF_SIM_DUAL_ITER`. Number of dual simplex iterations during the last optimization.
* `MSK_IINF_SIM_NUMCON`. Number of constraints in the problem solved by the simplex optimizer.
* `MSK_IINF_SIM_NUMVAR`. Number of variables in the problem solved by the simplex optimizer.
* `MSK_IINF_SIM_PRIMAL_DEG_ITER`. The number of primal degenerate iterations.
* `MSK_IINF_SIM_PRIMAL_HOTSTART`. If 1 then the primal simplex algorithm is solving from an advanced basis.
* `MSK_IINF_SIM_PRIMAL_HOTSTART_LU`. If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm.
* `MSK_IINF_SIM_PRIMAL_INF_ITER`. The number of iterations taken with primal infeasibility.
* `MSK_IINF_SIM_PRIMAL_ITER`. Number of primal simplex iterations during the last optimization.
* `MSK_IINF_SIM_SOLVE_DUAL`. Is non-zero if dual problem is solved.
* `MSK_IINF_SOL_BAS_PROSTA`. Problem status of the basic solution. Updated after each optimization.
* `MSK_IINF_SOL_BAS_SOLSTA`. Solution status of the basic solution. Updated after each optimization.
* `MSK_IINF_SOL_ITG_PROSTA`. Problem status of the integer solution. Updated after each optimization.
* `MSK_IINF_SOL_ITG_SOLSTA`. Solution status of the integer solution. Updated after each optimization.
* `MSK_IINF_SOL_ITR_PROSTA`. Problem status of the interior-point solution. Updated after each optimization.
* `MSK_IINF_SOL_ITR_SOLSTA`. Solution status of the interior-point solution. Updated after each optimization.
* `MSK_IINF_STO_NUM_A_REALLOC`. Number of times the storage for storing the linear coefficient matrix has been changed.
"""
struct Iinfitem <: MosekEnum
  value :: Int32
end # iinfitem

"Number of constraints in the problem."
const MSK_IINF_ANA_PRO_NUM_CON = Iinfitem(0)

"Number of equality constraints."
const MSK_IINF_ANA_PRO_NUM_CON_EQ = Iinfitem(1)

"Number of unbounded constraints."
const MSK_IINF_ANA_PRO_NUM_CON_FR = Iinfitem(2)

"Number of constraints with a lower bound and an infinite upper bound."
const MSK_IINF_ANA_PRO_NUM_CON_LO = Iinfitem(3)

"Number of constraints with finite lower and upper bounds."
const MSK_IINF_ANA_PRO_NUM_CON_RA = Iinfitem(4)

"Number of constraints with an upper bound and an infinite lower bound."
const MSK_IINF_ANA_PRO_NUM_CON_UP = Iinfitem(5)

"Number of variables in the problem."
const MSK_IINF_ANA_PRO_NUM_VAR = Iinfitem(6)

"Number of binary variables."
const MSK_IINF_ANA_PRO_NUM_VAR_BIN = Iinfitem(7)

"Number of continuous variables."
const MSK_IINF_ANA_PRO_NUM_VAR_CONT = Iinfitem(8)

"Number of fixed variables."
const MSK_IINF_ANA_PRO_NUM_VAR_EQ = Iinfitem(9)

"Number of unbounded constraints."
const MSK_IINF_ANA_PRO_NUM_VAR_FR = Iinfitem(10)

"Number of general integer variables."
const MSK_IINF_ANA_PRO_NUM_VAR_INT = Iinfitem(11)

"Number of variables with a lower bound and an infinite upper bound."
const MSK_IINF_ANA_PRO_NUM_VAR_LO = Iinfitem(12)

"Number of variables with finite lower and upper bounds."
const MSK_IINF_ANA_PRO_NUM_VAR_RA = Iinfitem(13)

"Number of variables with an upper bound and an infinite lower bound."
const MSK_IINF_ANA_PRO_NUM_VAR_UP = Iinfitem(14)

"Dimension of the dense sub system in factorization."
const MSK_IINF_INTPNT_FACTOR_DIM_DENSE = Iinfitem(15)

"Number of interior-point iterations since invoking the interior-point optimizer."
const MSK_IINF_INTPNT_ITER = Iinfitem(16)

"Number of threads that the interior-point optimizer is using."
const MSK_IINF_INTPNT_NUM_THREADS = Iinfitem(17)

"Non-zero if the interior-point optimizer is solving the dual problem."
const MSK_IINF_INTPNT_SOLVE_DUAL = Iinfitem(18)

"Non-zero if absolute gap is within tolerances."
const MSK_IINF_MIO_ABSGAP_SATISFIED = Iinfitem(19)

"Size of the clique table."
const MSK_IINF_MIO_CLIQUE_TABLE_SIZE = Iinfitem(20)

"Informs if MOSEK successfully constructed an initial integer feasible solution."
const MSK_IINF_MIO_CONSTRUCT_SOLUTION = Iinfitem(21)

"Informs if MOSEK found the solution provided by the user to be feasible"
const MSK_IINF_MIO_INITIAL_FEASIBLE_SOLUTION = Iinfitem(22)

"Depth of the last node solved."
const MSK_IINF_MIO_NODE_DEPTH = Iinfitem(23)

"Number of active branch and bound nodes."
const MSK_IINF_MIO_NUM_ACTIVE_NODES = Iinfitem(24)

"Number of active cuts in the final relaxation after the mixed-integer optimizer's root cut generation."
const MSK_IINF_MIO_NUM_ACTIVE_ROOT_CUTS = Iinfitem(25)

"Number of branches performed during the optimization."
const MSK_IINF_MIO_NUM_BRANCH = Iinfitem(26)

"Number of integer feasible solutions that have been found."
const MSK_IINF_MIO_NUM_INT_SOLUTIONS = Iinfitem(27)

"Number of relaxations solved during the optimization."
const MSK_IINF_MIO_NUM_RELAX = Iinfitem(28)

"Number of times presolve was repeated at root."
const MSK_IINF_MIO_NUM_REPEATED_PRESOLVE = Iinfitem(29)

"Number of restarts performed during the optimization."
const MSK_IINF_MIO_NUM_RESTARTS = Iinfitem(30)

"Number of cut separation rounds at the root node of the mixed-integer optimizer."
const MSK_IINF_MIO_NUM_ROOT_CUT_ROUNDS = Iinfitem(31)

"Number of clique cuts selected to be included in the relaxation."
const MSK_IINF_MIO_NUM_SELECTED_CLIQUE_CUTS = Iinfitem(32)

"Number of Complemented Mixed Integer Rounding (CMIR) cuts selected to be included in the relaxation."
const MSK_IINF_MIO_NUM_SELECTED_CMIR_CUTS = Iinfitem(33)

"Number of Gomory cuts selected to be included in the relaxation."
const MSK_IINF_MIO_NUM_SELECTED_GOMORY_CUTS = Iinfitem(34)

"Number of implied bound cuts selected to be included in the relaxation."
const MSK_IINF_MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS = Iinfitem(35)

"Number of clique cuts selected to be included in the relaxation."
const MSK_IINF_MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS = Iinfitem(36)

"Number of lift-and-project cuts selected to be included in the relaxation."
const MSK_IINF_MIO_NUM_SELECTED_LIPRO_CUTS = Iinfitem(37)

"Number of separated clique cuts."
const MSK_IINF_MIO_NUM_SEPARATED_CLIQUE_CUTS = Iinfitem(38)

"Number of separated Complemented Mixed Integer Rounding (CMIR) cuts."
const MSK_IINF_MIO_NUM_SEPARATED_CMIR_CUTS = Iinfitem(39)

"Number of separated Gomory cuts."
const MSK_IINF_MIO_NUM_SEPARATED_GOMORY_CUTS = Iinfitem(40)

"Number of separated implied bound cuts."
const MSK_IINF_MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS = Iinfitem(41)

"Number of separated clique cuts."
const MSK_IINF_MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS = Iinfitem(42)

"Number of separated lift-and-project cuts."
const MSK_IINF_MIO_NUM_SEPARATED_LIPRO_CUTS = Iinfitem(43)

"Number of branch and bounds nodes solved in the main branch and bound tree."
const MSK_IINF_MIO_NUM_SOLVED_NODES = Iinfitem(44)

"Number of binary variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMBIN = Iinfitem(45)

"Number of binary cone variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMBINCONEVAR = Iinfitem(46)

"Number of constraints in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMCON = Iinfitem(47)

"Number of cones in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMCONE = Iinfitem(48)

"Number of cone variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMCONEVAR = Iinfitem(49)

"Number of continuous variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMCONT = Iinfitem(50)

"Number of continuous cone variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMCONTCONEVAR = Iinfitem(51)

"Number of dual exponential cones in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMDEXPCONES = Iinfitem(52)

"Number of disjunctive constraints in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMDJC = Iinfitem(53)

"Number of dual power cones in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMDPOWCONES = Iinfitem(54)

"Number of integer variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMINT = Iinfitem(55)

"Number of integer cone variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMINTCONEVAR = Iinfitem(56)

"Number of primal exponential cones in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMPEXPCONES = Iinfitem(57)

"Number of primal power cones in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMPPOWCONES = Iinfitem(58)

"Number of quadratic cones in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMQCONES = Iinfitem(59)

"Number of rotated quadratic cones in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMRQCONES = Iinfitem(60)

"Number of variables in the problem to be solved by the mixed-integer optimizer."
const MSK_IINF_MIO_NUMVAR = Iinfitem(61)

"Non-zero if a valid objective bound has been found, otherwise zero."
const MSK_IINF_MIO_OBJ_BOUND_DEFINED = Iinfitem(62)

"Number of binary variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMBIN = Iinfitem(63)

"Number of binary cone variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR = Iinfitem(64)

"Number of constraints in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMCON = Iinfitem(65)

"Number of cones in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMCONE = Iinfitem(66)

"Number of cone variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMCONEVAR = Iinfitem(67)

"Number of continuous variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMCONT = Iinfitem(68)

"Number of continuous cone variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR = Iinfitem(69)

"Number of dual exponential cones in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES = Iinfitem(70)

"Number of disjunctive constraints in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMDJC = Iinfitem(71)

"Number of dual power cones in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES = Iinfitem(72)

"Number of integer variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMINT = Iinfitem(73)

"Number of integer cone variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR = Iinfitem(74)

"Number of primal exponential cones in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES = Iinfitem(75)

"Number of primal power cones in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES = Iinfitem(76)

"Number of quadratic cones in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMQCONES = Iinfitem(77)

"Number of rotated quadratic cones in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMRQCONES = Iinfitem(78)

"Number of variables in the problem after the mixed-integer optimizer's presolve."
const MSK_IINF_MIO_PRESOLVED_NUMVAR = Iinfitem(79)

"Non-zero if relative gap is within tolerances."
const MSK_IINF_MIO_RELGAP_SATISFIED = Iinfitem(80)

"Total number of cuts selected to be included in the relaxation by the mixed-integer optimizer."
const MSK_IINF_MIO_TOTAL_NUM_SELECTED_CUTS = Iinfitem(81)

"Total number of cuts separated by the mixed-integer optimizer."
const MSK_IINF_MIO_TOTAL_NUM_SEPARATED_CUTS = Iinfitem(82)

"If it is non-zero, then the objective cut is used."
const MSK_IINF_MIO_USER_OBJ_CUT = Iinfitem(83)

"Number of constraints in the problem solved when the optimizer is called."
const MSK_IINF_OPT_NUMCON = Iinfitem(84)

"Number of variables in the problem solved when the optimizer is called"
const MSK_IINF_OPT_NUMVAR = Iinfitem(85)

"The response code returned by optimize."
const MSK_IINF_OPTIMIZE_RESPONSE = Iinfitem(86)

"Number perturbations to thhe bounds of the primal problem."
const MSK_IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS = Iinfitem(87)

"Is nonzero if the dual solution is purified."
const MSK_IINF_PURIFY_DUAL_SUCCESS = Iinfitem(88)

"Is nonzero if the primal solution is purified."
const MSK_IINF_PURIFY_PRIMAL_SUCCESS = Iinfitem(89)

"Number of symmetric variables read."
const MSK_IINF_RD_NUMBARVAR = Iinfitem(90)

"Number of constraints read."
const MSK_IINF_RD_NUMCON = Iinfitem(91)

"Number of conic constraints read."
const MSK_IINF_RD_NUMCONE = Iinfitem(92)

"Number of integer-constrained variables read."
const MSK_IINF_RD_NUMINTVAR = Iinfitem(93)

"Number of nonempty Q matrices read."
const MSK_IINF_RD_NUMQ = Iinfitem(94)

"Number of variables read."
const MSK_IINF_RD_NUMVAR = Iinfitem(95)

"Problem type."
const MSK_IINF_RD_PROTYPE = Iinfitem(96)

"The number of dual degenerate iterations."
const MSK_IINF_SIM_DUAL_DEG_ITER = Iinfitem(97)

"If 1 then the dual simplex algorithm is solving from an advanced basis."
const MSK_IINF_SIM_DUAL_HOTSTART = Iinfitem(98)

"If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm."
const MSK_IINF_SIM_DUAL_HOTSTART_LU = Iinfitem(99)

"The number of iterations taken with dual infeasibility."
const MSK_IINF_SIM_DUAL_INF_ITER = Iinfitem(100)

"Number of dual simplex iterations during the last optimization."
const MSK_IINF_SIM_DUAL_ITER = Iinfitem(101)

"Number of constraints in the problem solved by the simplex optimizer."
const MSK_IINF_SIM_NUMCON = Iinfitem(102)

"Number of variables in the problem solved by the simplex optimizer."
const MSK_IINF_SIM_NUMVAR = Iinfitem(103)

"The number of primal degenerate iterations."
const MSK_IINF_SIM_PRIMAL_DEG_ITER = Iinfitem(104)

"If 1 then the primal simplex algorithm is solving from an advanced basis."
const MSK_IINF_SIM_PRIMAL_HOTSTART = Iinfitem(105)

"If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm."
const MSK_IINF_SIM_PRIMAL_HOTSTART_LU = Iinfitem(106)

"The number of iterations taken with primal infeasibility."
const MSK_IINF_SIM_PRIMAL_INF_ITER = Iinfitem(107)

"Number of primal simplex iterations during the last optimization."
const MSK_IINF_SIM_PRIMAL_ITER = Iinfitem(108)

"Is non-zero if dual problem is solved."
const MSK_IINF_SIM_SOLVE_DUAL = Iinfitem(109)

"Problem status of the basic solution. Updated after each optimization."
const MSK_IINF_SOL_BAS_PROSTA = Iinfitem(110)

"Solution status of the basic solution. Updated after each optimization."
const MSK_IINF_SOL_BAS_SOLSTA = Iinfitem(111)

"Problem status of the integer solution. Updated after each optimization."
const MSK_IINF_SOL_ITG_PROSTA = Iinfitem(112)

"Solution status of the integer solution. Updated after each optimization."
const MSK_IINF_SOL_ITG_SOLSTA = Iinfitem(113)

"Problem status of the interior-point solution. Updated after each optimization."
const MSK_IINF_SOL_ITR_PROSTA = Iinfitem(114)

"Solution status of the interior-point solution. Updated after each optimization."
const MSK_IINF_SOL_ITR_SOLSTA = Iinfitem(115)

"Number of times the storage for storing the linear coefficient matrix has been changed."
const MSK_IINF_STO_NUM_A_REALLOC = Iinfitem(116)
tostr(v::Iinfitem) = if v.value == 0 "Mosek.MSK_IINF_ANA_PRO_NUM_CON"
  elseif v.value == 1 "Mosek.MSK_IINF_ANA_PRO_NUM_CON_EQ"
  elseif v.value == 2 "Mosek.MSK_IINF_ANA_PRO_NUM_CON_FR"
  elseif v.value == 3 "Mosek.MSK_IINF_ANA_PRO_NUM_CON_LO"
  elseif v.value == 4 "Mosek.MSK_IINF_ANA_PRO_NUM_CON_RA"
  elseif v.value == 5 "Mosek.MSK_IINF_ANA_PRO_NUM_CON_UP"
  elseif v.value == 6 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR"
  elseif v.value == 7 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_BIN"
  elseif v.value == 8 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_CONT"
  elseif v.value == 9 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_EQ"
  elseif v.value == 10 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_FR"
  elseif v.value == 11 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_INT"
  elseif v.value == 12 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_LO"
  elseif v.value == 13 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_RA"
  elseif v.value == 14 "Mosek.MSK_IINF_ANA_PRO_NUM_VAR_UP"
  elseif v.value == 15 "Mosek.MSK_IINF_INTPNT_FACTOR_DIM_DENSE"
  elseif v.value == 16 "Mosek.MSK_IINF_INTPNT_ITER"
  elseif v.value == 17 "Mosek.MSK_IINF_INTPNT_NUM_THREADS"
  elseif v.value == 18 "Mosek.MSK_IINF_INTPNT_SOLVE_DUAL"
  elseif v.value == 19 "Mosek.MSK_IINF_MIO_ABSGAP_SATISFIED"
  elseif v.value == 20 "Mosek.MSK_IINF_MIO_CLIQUE_TABLE_SIZE"
  elseif v.value == 21 "Mosek.MSK_IINF_MIO_CONSTRUCT_SOLUTION"
  elseif v.value == 22 "Mosek.MSK_IINF_MIO_INITIAL_FEASIBLE_SOLUTION"
  elseif v.value == 23 "Mosek.MSK_IINF_MIO_NODE_DEPTH"
  elseif v.value == 24 "Mosek.MSK_IINF_MIO_NUM_ACTIVE_NODES"
  elseif v.value == 25 "Mosek.MSK_IINF_MIO_NUM_ACTIVE_ROOT_CUTS"
  elseif v.value == 26 "Mosek.MSK_IINF_MIO_NUM_BRANCH"
  elseif v.value == 27 "Mosek.MSK_IINF_MIO_NUM_INT_SOLUTIONS"
  elseif v.value == 28 "Mosek.MSK_IINF_MIO_NUM_RELAX"
  elseif v.value == 29 "Mosek.MSK_IINF_MIO_NUM_REPEATED_PRESOLVE"
  elseif v.value == 30 "Mosek.MSK_IINF_MIO_NUM_RESTARTS"
  elseif v.value == 31 "Mosek.MSK_IINF_MIO_NUM_ROOT_CUT_ROUNDS"
  elseif v.value == 32 "Mosek.MSK_IINF_MIO_NUM_SELECTED_CLIQUE_CUTS"
  elseif v.value == 33 "Mosek.MSK_IINF_MIO_NUM_SELECTED_CMIR_CUTS"
  elseif v.value == 34 "Mosek.MSK_IINF_MIO_NUM_SELECTED_GOMORY_CUTS"
  elseif v.value == 35 "Mosek.MSK_IINF_MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS"
  elseif v.value == 36 "Mosek.MSK_IINF_MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS"
  elseif v.value == 37 "Mosek.MSK_IINF_MIO_NUM_SELECTED_LIPRO_CUTS"
  elseif v.value == 38 "Mosek.MSK_IINF_MIO_NUM_SEPARATED_CLIQUE_CUTS"
  elseif v.value == 39 "Mosek.MSK_IINF_MIO_NUM_SEPARATED_CMIR_CUTS"
  elseif v.value == 40 "Mosek.MSK_IINF_MIO_NUM_SEPARATED_GOMORY_CUTS"
  elseif v.value == 41 "Mosek.MSK_IINF_MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS"
  elseif v.value == 42 "Mosek.MSK_IINF_MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS"
  elseif v.value == 43 "Mosek.MSK_IINF_MIO_NUM_SEPARATED_LIPRO_CUTS"
  elseif v.value == 44 "Mosek.MSK_IINF_MIO_NUM_SOLVED_NODES"
  elseif v.value == 45 "Mosek.MSK_IINF_MIO_NUMBIN"
  elseif v.value == 46 "Mosek.MSK_IINF_MIO_NUMBINCONEVAR"
  elseif v.value == 47 "Mosek.MSK_IINF_MIO_NUMCON"
  elseif v.value == 48 "Mosek.MSK_IINF_MIO_NUMCONE"
  elseif v.value == 49 "Mosek.MSK_IINF_MIO_NUMCONEVAR"
  elseif v.value == 50 "Mosek.MSK_IINF_MIO_NUMCONT"
  elseif v.value == 51 "Mosek.MSK_IINF_MIO_NUMCONTCONEVAR"
  elseif v.value == 52 "Mosek.MSK_IINF_MIO_NUMDEXPCONES"
  elseif v.value == 53 "Mosek.MSK_IINF_MIO_NUMDJC"
  elseif v.value == 54 "Mosek.MSK_IINF_MIO_NUMDPOWCONES"
  elseif v.value == 55 "Mosek.MSK_IINF_MIO_NUMINT"
  elseif v.value == 56 "Mosek.MSK_IINF_MIO_NUMINTCONEVAR"
  elseif v.value == 57 "Mosek.MSK_IINF_MIO_NUMPEXPCONES"
  elseif v.value == 58 "Mosek.MSK_IINF_MIO_NUMPPOWCONES"
  elseif v.value == 59 "Mosek.MSK_IINF_MIO_NUMQCONES"
  elseif v.value == 60 "Mosek.MSK_IINF_MIO_NUMRQCONES"
  elseif v.value == 61 "Mosek.MSK_IINF_MIO_NUMVAR"
  elseif v.value == 62 "Mosek.MSK_IINF_MIO_OBJ_BOUND_DEFINED"
  elseif v.value == 63 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMBIN"
  elseif v.value == 64 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR"
  elseif v.value == 65 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMCON"
  elseif v.value == 66 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMCONE"
  elseif v.value == 67 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMCONEVAR"
  elseif v.value == 68 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMCONT"
  elseif v.value == 69 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR"
  elseif v.value == 70 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES"
  elseif v.value == 71 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMDJC"
  elseif v.value == 72 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES"
  elseif v.value == 73 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMINT"
  elseif v.value == 74 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR"
  elseif v.value == 75 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES"
  elseif v.value == 76 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES"
  elseif v.value == 77 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMQCONES"
  elseif v.value == 78 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMRQCONES"
  elseif v.value == 79 "Mosek.MSK_IINF_MIO_PRESOLVED_NUMVAR"
  elseif v.value == 80 "Mosek.MSK_IINF_MIO_RELGAP_SATISFIED"
  elseif v.value == 81 "Mosek.MSK_IINF_MIO_TOTAL_NUM_SELECTED_CUTS"
  elseif v.value == 82 "Mosek.MSK_IINF_MIO_TOTAL_NUM_SEPARATED_CUTS"
  elseif v.value == 83 "Mosek.MSK_IINF_MIO_USER_OBJ_CUT"
  elseif v.value == 84 "Mosek.MSK_IINF_OPT_NUMCON"
  elseif v.value == 85 "Mosek.MSK_IINF_OPT_NUMVAR"
  elseif v.value == 86 "Mosek.MSK_IINF_OPTIMIZE_RESPONSE"
  elseif v.value == 87 "Mosek.MSK_IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS"
  elseif v.value == 88 "Mosek.MSK_IINF_PURIFY_DUAL_SUCCESS"
  elseif v.value == 89 "Mosek.MSK_IINF_PURIFY_PRIMAL_SUCCESS"
  elseif v.value == 90 "Mosek.MSK_IINF_RD_NUMBARVAR"
  elseif v.value == 91 "Mosek.MSK_IINF_RD_NUMCON"
  elseif v.value == 92 "Mosek.MSK_IINF_RD_NUMCONE"
  elseif v.value == 93 "Mosek.MSK_IINF_RD_NUMINTVAR"
  elseif v.value == 94 "Mosek.MSK_IINF_RD_NUMQ"
  elseif v.value == 95 "Mosek.MSK_IINF_RD_NUMVAR"
  elseif v.value == 96 "Mosek.MSK_IINF_RD_PROTYPE"
  elseif v.value == 97 "Mosek.MSK_IINF_SIM_DUAL_DEG_ITER"
  elseif v.value == 98 "Mosek.MSK_IINF_SIM_DUAL_HOTSTART"
  elseif v.value == 99 "Mosek.MSK_IINF_SIM_DUAL_HOTSTART_LU"
  elseif v.value == 100 "Mosek.MSK_IINF_SIM_DUAL_INF_ITER"
  elseif v.value == 101 "Mosek.MSK_IINF_SIM_DUAL_ITER"
  elseif v.value == 102 "Mosek.MSK_IINF_SIM_NUMCON"
  elseif v.value == 103 "Mosek.MSK_IINF_SIM_NUMVAR"
  elseif v.value == 104 "Mosek.MSK_IINF_SIM_PRIMAL_DEG_ITER"
  elseif v.value == 105 "Mosek.MSK_IINF_SIM_PRIMAL_HOTSTART"
  elseif v.value == 106 "Mosek.MSK_IINF_SIM_PRIMAL_HOTSTART_LU"
  elseif v.value == 107 "Mosek.MSK_IINF_SIM_PRIMAL_INF_ITER"
  elseif v.value == 108 "Mosek.MSK_IINF_SIM_PRIMAL_ITER"
  elseif v.value == 109 "Mosek.MSK_IINF_SIM_SOLVE_DUAL"
  elseif v.value == 110 "Mosek.MSK_IINF_SOL_BAS_PROSTA"
  elseif v.value == 111 "Mosek.MSK_IINF_SOL_BAS_SOLSTA"
  elseif v.value == 112 "Mosek.MSK_IINF_SOL_ITG_PROSTA"
  elseif v.value == 113 "Mosek.MSK_IINF_SOL_ITG_SOLSTA"
  elseif v.value == 114 "Mosek.MSK_IINF_SOL_ITR_PROSTA"
  elseif v.value == 115 "Mosek.MSK_IINF_SOL_ITR_SOLSTA"
  elseif v.value == 116 "Mosek.MSK_IINF_STO_NUM_A_REALLOC"
  else "Mosek.Iinfitem(?)"
  end
const Iinfitem_members = Iinfitem[
    MSK_IINF_ANA_PRO_NUM_CON,
    MSK_IINF_ANA_PRO_NUM_CON_EQ,
    MSK_IINF_ANA_PRO_NUM_CON_FR,
    MSK_IINF_ANA_PRO_NUM_CON_LO,
    MSK_IINF_ANA_PRO_NUM_CON_RA,
    MSK_IINF_ANA_PRO_NUM_CON_UP,
    MSK_IINF_ANA_PRO_NUM_VAR,
    MSK_IINF_ANA_PRO_NUM_VAR_BIN,
    MSK_IINF_ANA_PRO_NUM_VAR_CONT,
    MSK_IINF_ANA_PRO_NUM_VAR_EQ,
    MSK_IINF_ANA_PRO_NUM_VAR_FR,
    MSK_IINF_ANA_PRO_NUM_VAR_INT,
    MSK_IINF_ANA_PRO_NUM_VAR_LO,
    MSK_IINF_ANA_PRO_NUM_VAR_RA,
    MSK_IINF_ANA_PRO_NUM_VAR_UP,
    MSK_IINF_INTPNT_FACTOR_DIM_DENSE,
    MSK_IINF_INTPNT_ITER,
    MSK_IINF_INTPNT_NUM_THREADS,
    MSK_IINF_INTPNT_SOLVE_DUAL,
    MSK_IINF_MIO_ABSGAP_SATISFIED,
    MSK_IINF_MIO_CLIQUE_TABLE_SIZE,
    MSK_IINF_MIO_CONSTRUCT_SOLUTION,
    MSK_IINF_MIO_INITIAL_FEASIBLE_SOLUTION,
    MSK_IINF_MIO_NODE_DEPTH,
    MSK_IINF_MIO_NUM_ACTIVE_NODES,
    MSK_IINF_MIO_NUM_ACTIVE_ROOT_CUTS,
    MSK_IINF_MIO_NUM_BRANCH,
    MSK_IINF_MIO_NUM_INT_SOLUTIONS,
    MSK_IINF_MIO_NUM_RELAX,
    MSK_IINF_MIO_NUM_REPEATED_PRESOLVE,
    MSK_IINF_MIO_NUM_RESTARTS,
    MSK_IINF_MIO_NUM_ROOT_CUT_ROUNDS,
    MSK_IINF_MIO_NUM_SELECTED_CLIQUE_CUTS,
    MSK_IINF_MIO_NUM_SELECTED_CMIR_CUTS,
    MSK_IINF_MIO_NUM_SELECTED_GOMORY_CUTS,
    MSK_IINF_MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS,
    MSK_IINF_MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS,
    MSK_IINF_MIO_NUM_SELECTED_LIPRO_CUTS,
    MSK_IINF_MIO_NUM_SEPARATED_CLIQUE_CUTS,
    MSK_IINF_MIO_NUM_SEPARATED_CMIR_CUTS,
    MSK_IINF_MIO_NUM_SEPARATED_GOMORY_CUTS,
    MSK_IINF_MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS,
    MSK_IINF_MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS,
    MSK_IINF_MIO_NUM_SEPARATED_LIPRO_CUTS,
    MSK_IINF_MIO_NUM_SOLVED_NODES,
    MSK_IINF_MIO_NUMBIN,
    MSK_IINF_MIO_NUMBINCONEVAR,
    MSK_IINF_MIO_NUMCON,
    MSK_IINF_MIO_NUMCONE,
    MSK_IINF_MIO_NUMCONEVAR,
    MSK_IINF_MIO_NUMCONT,
    MSK_IINF_MIO_NUMCONTCONEVAR,
    MSK_IINF_MIO_NUMDEXPCONES,
    MSK_IINF_MIO_NUMDJC,
    MSK_IINF_MIO_NUMDPOWCONES,
    MSK_IINF_MIO_NUMINT,
    MSK_IINF_MIO_NUMINTCONEVAR,
    MSK_IINF_MIO_NUMPEXPCONES,
    MSK_IINF_MIO_NUMPPOWCONES,
    MSK_IINF_MIO_NUMQCONES,
    MSK_IINF_MIO_NUMRQCONES,
    MSK_IINF_MIO_NUMVAR,
    MSK_IINF_MIO_OBJ_BOUND_DEFINED,
    MSK_IINF_MIO_PRESOLVED_NUMBIN,
    MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR,
    MSK_IINF_MIO_PRESOLVED_NUMCON,
    MSK_IINF_MIO_PRESOLVED_NUMCONE,
    MSK_IINF_MIO_PRESOLVED_NUMCONEVAR,
    MSK_IINF_MIO_PRESOLVED_NUMCONT,
    MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR,
    MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES,
    MSK_IINF_MIO_PRESOLVED_NUMDJC,
    MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES,
    MSK_IINF_MIO_PRESOLVED_NUMINT,
    MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR,
    MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES,
    MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES,
    MSK_IINF_MIO_PRESOLVED_NUMQCONES,
    MSK_IINF_MIO_PRESOLVED_NUMRQCONES,
    MSK_IINF_MIO_PRESOLVED_NUMVAR,
    MSK_IINF_MIO_RELGAP_SATISFIED,
    MSK_IINF_MIO_TOTAL_NUM_SELECTED_CUTS,
    MSK_IINF_MIO_TOTAL_NUM_SEPARATED_CUTS,
    MSK_IINF_MIO_USER_OBJ_CUT,
    MSK_IINF_OPT_NUMCON,
    MSK_IINF_OPT_NUMVAR,
    MSK_IINF_OPTIMIZE_RESPONSE,
    MSK_IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS,
    MSK_IINF_PURIFY_DUAL_SUCCESS,
    MSK_IINF_PURIFY_PRIMAL_SUCCESS,
    MSK_IINF_RD_NUMBARVAR,
    MSK_IINF_RD_NUMCON,
    MSK_IINF_RD_NUMCONE,
    MSK_IINF_RD_NUMINTVAR,
    MSK_IINF_RD_NUMQ,
    MSK_IINF_RD_NUMVAR,
    MSK_IINF_RD_PROTYPE,
    MSK_IINF_SIM_DUAL_DEG_ITER,
    MSK_IINF_SIM_DUAL_HOTSTART,
    MSK_IINF_SIM_DUAL_HOTSTART_LU,
    MSK_IINF_SIM_DUAL_INF_ITER,
    MSK_IINF_SIM_DUAL_ITER,
    MSK_IINF_SIM_NUMCON,
    MSK_IINF_SIM_NUMVAR,
    MSK_IINF_SIM_PRIMAL_DEG_ITER,
    MSK_IINF_SIM_PRIMAL_HOTSTART,
    MSK_IINF_SIM_PRIMAL_HOTSTART_LU,
    MSK_IINF_SIM_PRIMAL_INF_ITER,
    MSK_IINF_SIM_PRIMAL_ITER,
    MSK_IINF_SIM_SOLVE_DUAL,
    MSK_IINF_SOL_BAS_PROSTA,
    MSK_IINF_SOL_BAS_SOLSTA,
    MSK_IINF_SOL_ITG_PROSTA,
    MSK_IINF_SOL_ITG_SOLSTA,
    MSK_IINF_SOL_ITR_PROSTA,
    MSK_IINF_SOL_ITR_SOLSTA,
    MSK_IINF_STO_NUM_A_REALLOC ]
members(::Type{Iinfitem}) = Iinfitem_members
Base.length(::Type{Iinfitem}) = 117
Base.convert(::Type{Int},x::Iinfitem) = Int(x.value)
"""
    Inftype

Information item types

* `MSK_INF_DOU_TYPE`. Is a double information type.
* `MSK_INF_INT_TYPE`. Is an integer.
* `MSK_INF_LINT_TYPE`. Is a long integer.
"""
struct Inftype <: MosekEnum
  value :: Int32
end # inftype

"Is a double information type."
const MSK_INF_DOU_TYPE = Inftype(0)

"Is an integer."
const MSK_INF_INT_TYPE = Inftype(1)

"Is a long integer."
const MSK_INF_LINT_TYPE = Inftype(2)
tostr(v::Inftype) = if v.value == 0 "Mosek.MSK_INF_DOU_TYPE"
  elseif v.value == 1 "Mosek.MSK_INF_INT_TYPE"
  elseif v.value == 2 "Mosek.MSK_INF_LINT_TYPE"
  else "Mosek.Inftype(?)"
  end
const Inftype_members = Inftype[
    MSK_INF_DOU_TYPE,
    MSK_INF_INT_TYPE,
    MSK_INF_LINT_TYPE ]
members(::Type{Inftype}) = Inftype_members
Base.length(::Type{Inftype}) = 3
Base.convert(::Type{Int},x::Inftype) = Int(x.value)
"""
    Iomode

Input/output modes

* `MSK_IOMODE_READ`. The file is read-only.
* `MSK_IOMODE_WRITE`. The file is write-only. If the file exists then it is truncated when it is opened. Otherwise it is created when it is opened.
* `MSK_IOMODE_READWRITE`. The file is to read and write.
"""
struct Iomode <: MosekEnum
  value :: Int32
end # iomode

"The file is read-only."
const MSK_IOMODE_READ = Iomode(0)

"The file is write-only. If the file exists then it is truncated when it is opened. Otherwise it is created when it is opened."
const MSK_IOMODE_WRITE = Iomode(1)

"The file is to read and write."
const MSK_IOMODE_READWRITE = Iomode(2)
tostr(v::Iomode) = if v.value == 0 "Mosek.MSK_IOMODE_READ"
  elseif v.value == 1 "Mosek.MSK_IOMODE_WRITE"
  elseif v.value == 2 "Mosek.MSK_IOMODE_READWRITE"
  else "Mosek.Iomode(?)"
  end
const Iomode_members = Iomode[
    MSK_IOMODE_READ,
    MSK_IOMODE_WRITE,
    MSK_IOMODE_READWRITE ]
members(::Type{Iomode}) = Iomode_members
Base.length(::Type{Iomode}) = 3
Base.convert(::Type{Int},x::Iomode) = Int(x.value)
"""
    Iparam

The enumeration type containing all integer parameters.

* `MSK_IPAR_ANA_SOL_BASIS`. Controls whether the basis matrix is analyzed in solution analyzer.
* `MSK_IPAR_ANA_SOL_PRINT_VIOLATED`. Controls whether a list of violated constraints is printed.
* `MSK_IPAR_AUTO_SORT_A_BEFORE_OPT`. Controls whether the elements in each column of A are sorted before an optimization is performed.
* `MSK_IPAR_AUTO_UPDATE_SOL_INFO`. Controls whether the solution information items are automatically updated after an optimization is performed.
* `MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE`. Controls the sign of the columns in the basis matrix corresponding to slack variables.
* `MSK_IPAR_BI_CLEAN_OPTIMIZER`. Controls which simplex optimizer is used in the clean-up phase.
* `MSK_IPAR_BI_IGNORE_MAX_ITER`. Turns on basis identification in case the interior-point optimizer is terminated due to maximum number of iterations.
* `MSK_IPAR_BI_IGNORE_NUM_ERROR`. Turns on basis identification in case the interior-point optimizer is terminated due to a numerical problem.
* `MSK_IPAR_BI_MAX_ITERATIONS`. Maximum number of iterations after basis identification.
* `MSK_IPAR_CACHE_LICENSE`. Control license caching.
* `MSK_IPAR_COMPRESS_STATFILE`. Control compression of stat files.
* `MSK_IPAR_INFEAS_GENERIC_NAMES`. Controls the contents of the infeasibility report.
* `MSK_IPAR_INFEAS_PREFER_PRIMAL`. Controls which certificate is used if both primal- and dual- certificate of infeasibility is available.
* `MSK_IPAR_INFEAS_REPORT_AUTO`. Turns the feasibility report on or off.
* `MSK_IPAR_INFEAS_REPORT_LEVEL`. Controls the contents of the infeasibility report.
* `MSK_IPAR_INTPNT_BASIS`. Controls whether basis identification is performed.
* `MSK_IPAR_INTPNT_DIFF_STEP`. Controls whether different step sizes are allowed in the primal and dual space.
* `MSK_IPAR_INTPNT_HOTSTART`. Currently not in use.
* `MSK_IPAR_INTPNT_MAX_ITERATIONS`. Controls the maximum number of iterations allowed in the interior-point optimizer.
* `MSK_IPAR_INTPNT_MAX_NUM_COR`. Maximum number of correction steps.
* `MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS`. Maximum number of steps to be used by the iterative search direction refinement.
* `MSK_IPAR_INTPNT_OFF_COL_TRH`. Controls the aggressiveness of the offending column detection.
* `MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS`. This parameter controls the number of random seeds tried.
* `MSK_IPAR_INTPNT_ORDER_METHOD`. Controls the ordering strategy.
* `MSK_IPAR_INTPNT_PURIFY`. Currently not in use.
* `MSK_IPAR_INTPNT_REGULARIZATION_USE`. Controls whether regularization is allowed.
* `MSK_IPAR_INTPNT_SCALING`. Controls how the problem is scaled before the interior-point optimizer is used.
* `MSK_IPAR_INTPNT_SOLVE_FORM`. Controls whether the primal or the dual problem is solved.
* `MSK_IPAR_INTPNT_STARTING_POINT`. Starting point used by the interior-point optimizer.
* `MSK_IPAR_LICENSE_DEBUG`. Controls the license manager client debugging behavior.
* `MSK_IPAR_LICENSE_PAUSE_TIME`. Controls license manager client behavior.
* `MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS`. Controls license manager client behavior.
* `MSK_IPAR_LICENSE_TRH_EXPIRY_WRN`. Controls when expiry warnings are issued.
* `MSK_IPAR_LICENSE_WAIT`. Controls if MOSEK should queue for a license if none is available.
* `MSK_IPAR_LOG`. Controls the amount of log information.
* `MSK_IPAR_LOG_ANA_PRO`. Controls amount of output from the problem analyzer.
* `MSK_IPAR_LOG_BI`. Controls the amount of output printed by the basis identification procedure. A higher level implies that more information is logged.
* `MSK_IPAR_LOG_BI_FREQ`. Controls the logging frequency.
* `MSK_IPAR_LOG_CUT_SECOND_OPT`. Controls the reduction in the log levels for the second and any subsequent optimizations.
* `MSK_IPAR_LOG_EXPAND`. Controls the amount of logging when a data item such as the maximum number constrains is expanded.
* `MSK_IPAR_LOG_FEAS_REPAIR`. Controls the amount of output printed when performing feasibility repair. A value higher than one means extensive logging.
* `MSK_IPAR_LOG_FILE`. If turned on, then some log info is printed when a file is written or read.
* `MSK_IPAR_LOG_INCLUDE_SUMMARY`. Controls whether solution summary should be printed by the optimizer.
* `MSK_IPAR_LOG_INFEAS_ANA`. Controls log level for the infeasibility analyzer.
* `MSK_IPAR_LOG_INTPNT`. Controls the amount of log information from the interior-point optimizers.
* `MSK_IPAR_LOG_LOCAL_INFO`. Control whether local identifying information is printed to the log.
* `MSK_IPAR_LOG_MIO`. Controls the amount of log information from the mixed-integer optimizers.
* `MSK_IPAR_LOG_MIO_FREQ`. The mixed-integer optimizer logging frequency.
* `MSK_IPAR_LOG_ORDER`. If turned on, then factor lines are added to the log.
* `MSK_IPAR_LOG_PRESOLVE`. Controls amount of output printed by the presolve procedure. A higher level implies that more information is logged.
* `MSK_IPAR_LOG_RESPONSE`. Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.
* `MSK_IPAR_LOG_SENSITIVITY`. Control logging in sensitivity analyzer.
* `MSK_IPAR_LOG_SENSITIVITY_OPT`. Control logging in sensitivity analyzer.
* `MSK_IPAR_LOG_SIM`. Controls the amount of log information from the simplex optimizers.
* `MSK_IPAR_LOG_SIM_FREQ`. Controls simplex logging frequency.
* `MSK_IPAR_LOG_SIM_MINOR`. Currently not in use.
* `MSK_IPAR_LOG_STORAGE`. Controls the memory related log information.
* `MSK_IPAR_MAX_NUM_WARNINGS`. Each warning is shown a limited number of times controlled by this parameter. A negative value is identical to infinite number of times.
* `MSK_IPAR_MIO_BRANCH_DIR`. Controls whether the mixed-integer optimizer is branching up or down by default.
* `MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION`. Toggles outer approximation for conic problems.
* `MSK_IPAR_MIO_CONSTRUCT_SOL`. Controls if an initial mixed integer solution should be constructed from the values of the integer variables.
* `MSK_IPAR_MIO_CUT_CLIQUE`. Controls whether clique cuts should be generated.
* `MSK_IPAR_MIO_CUT_CMIR`. Controls whether mixed integer rounding cuts should be generated.
* `MSK_IPAR_MIO_CUT_GMI`. Controls whether GMI cuts should be generated.
* `MSK_IPAR_MIO_CUT_IMPLIED_BOUND`. Controls whether implied bound cuts should be generated.
* `MSK_IPAR_MIO_CUT_KNAPSACK_COVER`. Controls whether knapsack cover cuts should be generated.
* `MSK_IPAR_MIO_CUT_LIPRO`. Controls whether lift-and-project cuts should be generated.
* `MSK_IPAR_MIO_CUT_SELECTION_LEVEL`. Controls how aggressively generated cuts are selected to be included in the relaxation.
* `MSK_IPAR_MIO_DATA_PERMUTATION_METHOD`. Controls what problem data permutation method is appplied to mixed-integer problems.
* `MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL`. Controls the amount of dual ray analysis employed by the mixed-integer optimizer in presolve.
* `MSK_IPAR_MIO_FEASPUMP_LEVEL`. Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.
* `MSK_IPAR_MIO_HEURISTIC_LEVEL`. Controls the heuristic employed by the mixed-integer optimizer to locate an initial integer feasible solution.
* `MSK_IPAR_MIO_MAX_NUM_BRANCHES`. Maximum number of branches allowed during the branch and bound search.
* `MSK_IPAR_MIO_MAX_NUM_RELAXS`. Maximum number of relaxations in branch and bound search.
* `MSK_IPAR_MIO_MAX_NUM_RESTARTS`. Maximum number of restarts allowed during the branch and bound search.
* `MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS`. Maximum number of cut separation rounds at the root node.
* `MSK_IPAR_MIO_MAX_NUM_SOLUTIONS`. Controls how many feasible solutions the mixed-integer optimizer investigates.
* `MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL`. Controls how much emphasis is put on reducing memory usage.
* `MSK_IPAR_MIO_MIN_REL`. Number of times a variable must have been branched on for its pseudocost to be considered reliable.
* `MSK_IPAR_MIO_MODE`. Turns on/off the mixed-integer mode.
* `MSK_IPAR_MIO_NODE_OPTIMIZER`. Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.
* `MSK_IPAR_MIO_NODE_SELECTION`. Controls the node selection strategy employed by the mixed-integer optimizer.
* `MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL`. Controls how much emphasis is put on reducing numerical problems
* `MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE`. Enables or disables perspective reformulation in presolve.
* `MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE`. Controls if the aggregator should be used.
* `MSK_IPAR_MIO_PROBING_LEVEL`. Controls the amount of probing employed by the mixed-integer optimizer in presolve.
* `MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT`. Use objective domain propagation.
* `MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD`. Controls what reformulation method is applied to mixed-integer quadratic problems.
* `MSK_IPAR_MIO_RINS_MAX_NODES`. Maximum number of nodes in each call to RINS.
* `MSK_IPAR_MIO_ROOT_OPTIMIZER`. Controls which optimizer is employed at the root node in the mixed-integer optimizer.
* `MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL`. Controls whether presolve can be repeated at root node.
* `MSK_IPAR_MIO_SEED`. Sets the random seed used for randomization in the mixed integer optimizer.
* `MSK_IPAR_MIO_SYMMETRY_LEVEL`. Controls the amount of symmetry detection and handling employed by the mixed-integer optimizer in presolve.
* `MSK_IPAR_MIO_VAR_SELECTION`. Controls the variable selection strategy employed by the mixed-integer optimizer.
* `MSK_IPAR_MIO_VB_DETECTION_LEVEL`. Controls how much effort is put into detecting variable bounds.
* `MSK_IPAR_MT_SPINCOUNT`. Set the number of iterations to spin before sleeping.
* `MSK_IPAR_NG`. Not in use
* `MSK_IPAR_NUM_THREADS`. The number of threads employed by the optimizer.
* `MSK_IPAR_OPF_WRITE_HEADER`. Write a text header with date and MOSEK version in an OPF file.
* `MSK_IPAR_OPF_WRITE_HINTS`. Write a hint section with problem dimensions in the beginning of an OPF file.
* `MSK_IPAR_OPF_WRITE_LINE_LENGTH`. Aim to keep lines in OPF files not much longer than this.
* `MSK_IPAR_OPF_WRITE_PARAMETERS`. Write a parameter section in an OPF file.
* `MSK_IPAR_OPF_WRITE_PROBLEM`. Write objective, constraints, bounds etc. to an OPF file.
* `MSK_IPAR_OPF_WRITE_SOL_BAS`. Controls what is written to the OPF files.
* `MSK_IPAR_OPF_WRITE_SOL_ITG`. Controls what is written to the OPF files.
* `MSK_IPAR_OPF_WRITE_SOL_ITR`. Controls what is written to the OPF files.
* `MSK_IPAR_OPF_WRITE_SOLUTIONS`. Enable inclusion of solutions in the OPF files.
* `MSK_IPAR_OPTIMIZER`. Controls which optimizer is used to optimize the task.
* `MSK_IPAR_PARAM_READ_CASE_NAME`. If turned on, then names in the parameter file are case sensitive.
* `MSK_IPAR_PARAM_READ_IGN_ERROR`. If turned on, then errors in parameter settings is ignored.
* `MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL`. Maximum amount of fill-in created in one pivot during the elimination phase.
* `MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES`. Control the maximum number of times the eliminator is tried.
* `MSK_IPAR_PRESOLVE_LEVEL`. Currently not used.
* `MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH`. Controls linear dependency check in presolve.
* `MSK_IPAR_PRESOLVE_LINDEP_NEW`. Controls whether whether a new experimental linear dependency checker is employed.
* `MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH`. Controls linear dependency check in presolve.
* `MSK_IPAR_PRESOLVE_LINDEP_USE`. Controls whether the linear constraints are checked for linear dependencies.
* `MSK_IPAR_PRESOLVE_MAX_NUM_PASS`. Control the maximum number of times presolve passes over the problem.
* `MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS`. Controls the maximum number of reductions performed by the presolve.
* `MSK_IPAR_PRESOLVE_USE`. Controls whether the presolve is applied to a problem before it is optimized.
* `MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER`. Controls which optimizer that is used to find the optimal repair.
* `MSK_IPAR_PTF_WRITE_PARAMETERS`. Controls whether parameters section is written in PTF files.
* `MSK_IPAR_PTF_WRITE_SOLUTIONS`. Controls whether solution section is written in PTF files.
* `MSK_IPAR_PTF_WRITE_TRANSFORM`. Controls if simple transformation are done when writing PTF files.
* `MSK_IPAR_READ_DEBUG`. Turns on additional debugging information when reading files.
* `MSK_IPAR_READ_KEEP_FREE_CON`. Controls whether the free constraints are included in the problem.
* `MSK_IPAR_READ_MPS_FORMAT`. Controls how strictly the MPS file reader interprets the MPS format.
* `MSK_IPAR_READ_MPS_WIDTH`. Controls the maximal number of characters allowed in one line of the MPS file.
* `MSK_IPAR_READ_TASK_IGNORE_PARAM`. Controls what information is used from the task files.
* `MSK_IPAR_REMOTE_USE_COMPRESSION`. Use compression when sending data to an optimization server
* `MSK_IPAR_REMOVE_UNUSED_SOLUTIONS`. Removes unused solutions before the optimization is performed.
* `MSK_IPAR_SENSITIVITY_ALL`. Controls sensitivity report behavior.
* `MSK_IPAR_SENSITIVITY_OPTIMIZER`. Controls which optimizer is used for optimal partition sensitivity analysis.
* `MSK_IPAR_SENSITIVITY_TYPE`. Controls which type of sensitivity analysis is to be performed.
* `MSK_IPAR_SIM_BASIS_FACTOR_USE`. Controls whether an LU factorization of the basis is used in a hot-start.
* `MSK_IPAR_SIM_DEGEN`. Controls how aggressively degeneration is handled.
* `MSK_IPAR_SIM_DETECT_PWL`. Not in use.
* `MSK_IPAR_SIM_DUAL_CRASH`. Controls whether crashing is performed in the dual simplex optimizer.
* `MSK_IPAR_SIM_DUAL_PHASEONE_METHOD`. An experimental feature.
* `MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION`. Controls how aggressively restricted selection is used.
* `MSK_IPAR_SIM_DUAL_SELECTION`. Controls the dual simplex strategy.
* `MSK_IPAR_SIM_EXPLOIT_DUPVEC`. Controls if the simplex optimizers are allowed to exploit duplicated columns.
* `MSK_IPAR_SIM_HOTSTART`. Controls the type of hot-start that the simplex optimizer perform.
* `MSK_IPAR_SIM_HOTSTART_LU`. Determines if the simplex optimizer should exploit the initial factorization.
* `MSK_IPAR_SIM_MAX_ITERATIONS`. Maximum number of iterations that can be used by a simplex optimizer.
* `MSK_IPAR_SIM_MAX_NUM_SETBACKS`. Controls how many set-backs that are allowed within a simplex optimizer.
* `MSK_IPAR_SIM_NON_SINGULAR`. Controls if the simplex optimizer ensures a non-singular basis, if possible.
* `MSK_IPAR_SIM_PRIMAL_CRASH`. Controls the simplex crash.
* `MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD`. An experimental feature.
* `MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION`. Controls how aggressively restricted selection is used.
* `MSK_IPAR_SIM_PRIMAL_SELECTION`. Controls the primal simplex strategy.
* `MSK_IPAR_SIM_REFACTOR_FREQ`. Controls the basis refactoring frequency.
* `MSK_IPAR_SIM_REFORMULATION`. Controls if the simplex optimizers are allowed to reformulate the problem.
* `MSK_IPAR_SIM_SAVE_LU`. Controls if the LU factorization stored should be replaced with the LU factorization corresponding to the initial basis.
* `MSK_IPAR_SIM_SCALING`. Controls how much effort is used in scaling the problem before a simplex optimizer is used.
* `MSK_IPAR_SIM_SCALING_METHOD`. Controls how the problem is scaled before a simplex optimizer is used.
* `MSK_IPAR_SIM_SEED`. Sets the random seed used for randomization in the simplex optimizers.
* `MSK_IPAR_SIM_SOLVE_FORM`. Controls whether the primal or the dual problem is solved by the primal-/dual-simplex optimizer.
* `MSK_IPAR_SIM_STABILITY_PRIORITY`. Controls how high priority the numerical stability should be given.
* `MSK_IPAR_SIM_SWITCH_OPTIMIZER`. Controls the simplex behavior.
* `MSK_IPAR_SOL_FILTER_KEEP_BASIC`. Control the contents of the solution files.
* `MSK_IPAR_SOL_FILTER_KEEP_RANGED`. Control the contents of the solution files.
* `MSK_IPAR_SOL_READ_NAME_WIDTH`. Controls the input solution file format.
* `MSK_IPAR_SOL_READ_WIDTH`. Controls the input solution file format.
* `MSK_IPAR_SOLUTION_CALLBACK`. Indicates whether solution callbacks will be performed during the optimization.
* `MSK_IPAR_TIMING_LEVEL`. Controls the amount of timing performed inside MOSEK.
* `MSK_IPAR_WRITE_BAS_CONSTRAINTS`. Controls the basic solution file format.
* `MSK_IPAR_WRITE_BAS_HEAD`. Controls the basic solution file format.
* `MSK_IPAR_WRITE_BAS_VARIABLES`. Controls the basic solution file format.
* `MSK_IPAR_WRITE_COMPRESSION`. Controls output file compression.
* `MSK_IPAR_WRITE_DATA_PARAM`. Controls output file data.
* `MSK_IPAR_WRITE_FREE_CON`. Controls the output file data.
* `MSK_IPAR_WRITE_GENERIC_NAMES`. Controls the output file data.
* `MSK_IPAR_WRITE_GENERIC_NAMES_IO`. Index origin used in  generic names.
* `MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS`. Controls if the writer ignores incompatible problem items when writing files.
* `MSK_IPAR_WRITE_INT_CONSTRAINTS`. Controls the integer solution file format.
* `MSK_IPAR_WRITE_INT_HEAD`. Controls the integer solution file format.
* `MSK_IPAR_WRITE_INT_VARIABLES`. Controls the integer solution file format.
* `MSK_IPAR_WRITE_JSON_INDENTATION`. When set, the JSON task and solution files are written with indentation for better readability.
* `MSK_IPAR_WRITE_LP_FULL_OBJ`. Write full linear objective
* `MSK_IPAR_WRITE_LP_LINE_WIDTH`. Controls the LP output file format.
* `MSK_IPAR_WRITE_MPS_FORMAT`. Controls in which format the MPS is written.
* `MSK_IPAR_WRITE_MPS_INT`. Controls the output file data.
* `MSK_IPAR_WRITE_SOL_BARVARIABLES`. Controls the solution file format.
* `MSK_IPAR_WRITE_SOL_CONSTRAINTS`. Controls the solution file format.
* `MSK_IPAR_WRITE_SOL_HEAD`. Controls solution file format.
* `MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES`. Controls whether the user specified names are employed even if they are invalid names.
* `MSK_IPAR_WRITE_SOL_VARIABLES`. Controls the solution file format.
* `MSK_IPAR_WRITE_TASK_INC_SOL`. Controls whether the solutions are stored in the task file too.
* `MSK_IPAR_WRITE_XML_MODE`. Controls if linear coefficients should be written by row or column when writing in the XML file format.
"""
struct Iparam <: MosekEnum
  value :: Int32
end # iparam

"""
Controls whether the basis matrix is analyzed in solution analyzer.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_ANA_SOL_BASIS = Iparam(0)

"""
Controls whether a list of violated constraints is printed.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_ANA_SOL_PRINT_VIOLATED = Iparam(1)

"""
Controls whether the elements in each column of A are sorted before an optimization is performed.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_AUTO_SORT_A_BEFORE_OPT = Iparam(2)

"""
Controls whether the solution information items are automatically updated after an optimization is performed.

Default value: `off`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_AUTO_UPDATE_SOL_INFO = Iparam(3)

"""
Controls the sign of the columns in the basis matrix corresponding to slack variables.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE = Iparam(4)

"""
Controls which simplex optimizer is used in the clean-up phase.

Default value: `FREE`

Possible values:

* `MSK_OPTIMIZER_FREE`. The optimizer is chosen automatically.
* `MSK_OPTIMIZER_INTPNT`. The interior-point optimizer is used.
* `MSK_OPTIMIZER_CONIC`. The optimizer for problems having conic constraints.
* `MSK_OPTIMIZER_PRIMAL_SIMPLEX`. The primal simplex optimizer is used.
* `MSK_OPTIMIZER_DUAL_SIMPLEX`. The dual simplex optimizer is used.
* `MSK_OPTIMIZER_FREE_SIMPLEX`. One of the simplex optimizers is used.
* `MSK_OPTIMIZER_MIXED_INT`. The mixed-integer optimizer.
"""
const MSK_IPAR_BI_CLEAN_OPTIMIZER = Iparam(5)

"""
Turns on basis identification in case the interior-point optimizer is terminated due to maximum number of iterations.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_BI_IGNORE_MAX_ITER = Iparam(6)

"""
Turns on basis identification in case the interior-point optimizer is terminated due to a numerical problem.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_BI_IGNORE_NUM_ERROR = Iparam(7)

"""
Maximum number of iterations after basis identification.

Default value: `1000000`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_BI_MAX_ITERATIONS = Iparam(8)

"""
Control license caching.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_CACHE_LICENSE = Iparam(9)

"""
Control compression of stat files.

Default value: `on`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_COMPRESS_STATFILE = Iparam(10)

"""
Controls the contents of the infeasibility report.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_INFEAS_GENERIC_NAMES = Iparam(11)

"""
Controls which certificate is used if both primal- and dual- certificate of infeasibility is available.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_INFEAS_PREFER_PRIMAL = Iparam(12)

"""
Turns the feasibility report on or off.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_INFEAS_REPORT_AUTO = Iparam(13)

"""
Controls the contents of the infeasibility report.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_INFEAS_REPORT_LEVEL = Iparam(14)

"""
Controls whether basis identification is performed.

Default value: `ALWAYS`

Possible values:

* `MSK_BI_NEVER`. Never do basis identification.
* `MSK_BI_ALWAYS`. Basis identification is always performed even if the interior-point optimizer terminates abnormally.
* `MSK_BI_NO_ERROR`. Basis identification is performed if the interior-point optimizer terminates without an error.
* `MSK_BI_IF_FEASIBLE`. Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible.
* `MSK_BI_RESERVERED`. Not currently in use.

See also:
* `MSK_IPAR_BI_IGNORE_MAX_ITER`. Turns on basis identification in case the interior-point optimizer is terminated due to maximum number of iterations.
* `MSK_IPAR_BI_IGNORE_NUM_ERROR`. Turns on basis identification in case the interior-point optimizer is terminated due to a numerical problem.
* `MSK_IPAR_BI_MAX_ITERATIONS`. Maximum number of iterations after basis identification.
* `MSK_IPAR_BI_CLEAN_OPTIMIZER`. Controls which simplex optimizer is used in the clean-up phase.
"""
const MSK_IPAR_INTPNT_BASIS = Iparam(15)

"""
Controls whether different step sizes are allowed in the primal and dual space.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_INTPNT_DIFF_STEP = Iparam(16)

"""
Currently not in use.

Default value: `none`

Possible values:

* `MSK_INTPNT_HOTSTART_NONE`. The interior-point optimizer performs a coldstart.
* `MSK_INTPNT_HOTSTART_PRIMAL`. The interior-point optimizer exploits the primal solution only.
* `MSK_INTPNT_HOTSTART_DUAL`. The interior-point optimizer exploits the dual solution only.
* `MSK_INTPNT_HOTSTART_PRIMAL_DUAL`. The interior-point optimizer exploits both the primal and dual solution.
"""
const MSK_IPAR_INTPNT_HOTSTART = Iparam(17)

"""
Controls the maximum number of iterations allowed in the interior-point optimizer.

Default value: `400`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_INTPNT_MAX_ITERATIONS = Iparam(18)

"""
Maximum number of correction steps.

Default value: `-1`

Possible Values: Any number between -1 and +inf.
"""
const MSK_IPAR_INTPNT_MAX_NUM_COR = Iparam(19)

"""
Maximum number of steps to be used by the iterative search direction refinement.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS = Iparam(20)

"""
Controls the aggressiveness of the offending column detection.

Default value: `40`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_INTPNT_OFF_COL_TRH = Iparam(21)

"""
This parameter controls the number of random seeds tried.

Default value: `0`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS = Iparam(22)

"""
Controls the ordering strategy.

Default value: `FREE`

Possible values:

* `MSK_ORDER_METHOD_FREE`. The ordering method is chosen automatically.
* `MSK_ORDER_METHOD_APPMINLOC`. Approximate minimum local fill-in ordering is employed.
* `MSK_ORDER_METHOD_EXPERIMENTAL`. This option should not be used.
* `MSK_ORDER_METHOD_TRY_GRAPHPAR`. Always try the graph partitioning based ordering.
* `MSK_ORDER_METHOD_FORCE_GRAPHPAR`. Always use the graph partitioning based ordering even if it is worse than the approximate minimum local fill ordering.
* `MSK_ORDER_METHOD_NONE`. No ordering is used. Note using this value almost always leads to a significantly slow down.
"""
const MSK_IPAR_INTPNT_ORDER_METHOD = Iparam(23)

"""
Currently not in use.

Default value: `none`

Possible values:

* `MSK_PURIFY_NONE`. The optimizer performs no solution purification.
* `MSK_PURIFY_PRIMAL`. The optimizer purifies the primal solution.
* `MSK_PURIFY_DUAL`. The optimizer purifies the dual solution.
* `MSK_PURIFY_PRIMAL_DUAL`. The optimizer purifies both the primal and dual solution.
* `MSK_PURIFY_AUTO`. TBD
"""
const MSK_IPAR_INTPNT_PURIFY = Iparam(24)

"""
Controls whether regularization is allowed.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_INTPNT_REGULARIZATION_USE = Iparam(25)

"""
Controls how the problem is scaled before the interior-point optimizer is used.

Default value: `FREE`

Possible values:

* `MSK_SCALING_FREE`. The optimizer chooses the scaling heuristic.
* `MSK_SCALING_NONE`. No scaling is performed.
"""
const MSK_IPAR_INTPNT_SCALING = Iparam(26)

"""
Controls whether the primal or the dual problem is solved.

Default value: `FREE`

Possible values:

* `MSK_SOLVE_FREE`. The optimizer is free to solve either the primal or the dual problem.
* `MSK_SOLVE_PRIMAL`. The optimizer should solve the primal problem.
* `MSK_SOLVE_DUAL`. The optimizer should solve the dual problem.
"""
const MSK_IPAR_INTPNT_SOLVE_FORM = Iparam(27)

"""
Starting point used by the interior-point optimizer.

Default value: `FREE`

Possible values:

* `MSK_STARTING_POINT_FREE`. The starting point is chosen automatically.
* `MSK_STARTING_POINT_GUESS`. The optimizer guesses a starting point.
* `MSK_STARTING_POINT_CONSTANT`. The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust.
"""
const MSK_IPAR_INTPNT_STARTING_POINT = Iparam(28)

"""
Controls the license manager client debugging behavior.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_LICENSE_DEBUG = Iparam(29)

"""
Controls license manager client behavior.

Default value: `100`

Possible Values: Any number between 0 and 1000000.
"""
const MSK_IPAR_LICENSE_PAUSE_TIME = Iparam(30)

"""
Controls license manager client behavior.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS = Iparam(31)

"""
Controls when expiry warnings are issued.

Default value: `7`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LICENSE_TRH_EXPIRY_WRN = Iparam(32)

"""
Controls if MOSEK should queue for a license if none is available.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_LICENSE_WAIT = Iparam(33)

"""
Controls the amount of log information.

Default value: `10`

Possible Values: Any number between 0 and +inf.

See also:
* `MSK_IPAR_LOG_CUT_SECOND_OPT`. Controls the reduction in the log levels for the second and any subsequent optimizations.
"""
const MSK_IPAR_LOG = Iparam(34)

"""
Controls amount of output from the problem analyzer.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_ANA_PRO = Iparam(35)

"""
Controls the amount of output printed by the basis identification procedure. A higher level implies that more information is logged.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_BI = Iparam(36)

"""
Controls the logging frequency.

Default value: `2500`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_BI_FREQ = Iparam(37)

"""
Controls the reduction in the log levels for the second and any subsequent optimizations.

Default value: `1`

Possible Values: Any number between 0 and +inf.

See also:
* `MSK_IPAR_LOG`. Controls the amount of log information.
* `MSK_IPAR_LOG_INTPNT`. Controls the amount of log information from the interior-point optimizers.
* `MSK_IPAR_LOG_MIO`. Controls the amount of log information from the mixed-integer optimizers.
* `MSK_IPAR_LOG_SIM`. Controls the amount of log information from the simplex optimizers.
"""
const MSK_IPAR_LOG_CUT_SECOND_OPT = Iparam(38)

"""
Controls the amount of logging when a data item such as the maximum number constrains is expanded.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_EXPAND = Iparam(39)

"""
Controls the amount of output printed when performing feasibility repair. A value higher than one means extensive logging.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_FEAS_REPAIR = Iparam(40)

"""
If turned on, then some log info is printed when a file is written or read.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_FILE = Iparam(41)

"""
Controls whether solution summary should be printed by the optimizer.

Default value: `off`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_LOG_INCLUDE_SUMMARY = Iparam(42)

"""
Controls log level for the infeasibility analyzer.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_INFEAS_ANA = Iparam(43)

"""
Controls the amount of log information from the interior-point optimizers.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_INTPNT = Iparam(44)

"""
Control whether local identifying information is printed to the log.

Default value: `on`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_LOG_LOCAL_INFO = Iparam(45)

"""
Controls the amount of log information from the mixed-integer optimizers.

Default value: `4`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_MIO = Iparam(46)

"""
The mixed-integer optimizer logging frequency.

Default value: `10`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_LOG_MIO_FREQ = Iparam(47)

"""
If turned on, then factor lines are added to the log.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_ORDER = Iparam(48)

"""
Controls amount of output printed by the presolve procedure. A higher level implies that more information is logged.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_PRESOLVE = Iparam(49)

"""
Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.

Default value: `0`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_RESPONSE = Iparam(50)

"""
Control logging in sensitivity analyzer.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_SENSITIVITY = Iparam(51)

"""
Control logging in sensitivity analyzer.

Default value: `0`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_SENSITIVITY_OPT = Iparam(52)

"""
Controls the amount of log information from the simplex optimizers.

Default value: `4`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_SIM = Iparam(53)

"""
Controls simplex logging frequency.

Default value: `1000`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_SIM_FREQ = Iparam(54)

"""
Currently not in use.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_SIM_MINOR = Iparam(55)

"""
Controls the memory related log information.

Default value: `0`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_LOG_STORAGE = Iparam(56)

"""
Each warning is shown a limited number of times controlled by this parameter. A negative value is identical to infinite number of times.

Default value: `10`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_MAX_NUM_WARNINGS = Iparam(57)

"""
Controls whether the mixed-integer optimizer is branching up or down by default.

Default value: `FREE`

Possible values:

* `MSK_BRANCH_DIR_FREE`. The mixed-integer optimizer decides which branch to choose.
* `MSK_BRANCH_DIR_UP`. The mixed-integer optimizer always chooses the up branch first.
* `MSK_BRANCH_DIR_DOWN`. The mixed-integer optimizer always chooses the down branch first.
* `MSK_BRANCH_DIR_NEAR`. Branch in direction nearest to selected fractional variable.
* `MSK_BRANCH_DIR_FAR`. Branch in direction farthest from selected fractional variable.
* `MSK_BRANCH_DIR_ROOT_LP`. Chose direction based on root lp value of selected variable.
* `MSK_BRANCH_DIR_GUIDED`. Branch in direction of current incumbent.
* `MSK_BRANCH_DIR_PSEUDOCOST`. Branch based on the pseudocost of the variable.
"""
const MSK_IPAR_MIO_BRANCH_DIR = Iparam(58)

"""
Toggles outer approximation for conic problems.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION = Iparam(59)

"""
Controls if an initial mixed integer solution should be constructed from the values of the integer variables.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CONSTRUCT_SOL = Iparam(60)

"""
Controls whether clique cuts should be generated.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CUT_CLIQUE = Iparam(61)

"""
Controls whether mixed integer rounding cuts should be generated.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CUT_CMIR = Iparam(62)

"""
Controls whether GMI cuts should be generated.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CUT_GMI = Iparam(63)

"""
Controls whether implied bound cuts should be generated.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CUT_IMPLIED_BOUND = Iparam(64)

"""
Controls whether knapsack cover cuts should be generated.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CUT_KNAPSACK_COVER = Iparam(65)

"""
Controls whether lift-and-project cuts should be generated.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_CUT_LIPRO = Iparam(66)

"""
Controls how aggressively generated cuts are selected to be included in the relaxation.

Default value: `-1`

Possible Values: Any number between -1 and +1.
"""
const MSK_IPAR_MIO_CUT_SELECTION_LEVEL = Iparam(67)

"""
Controls what problem data permutation method is appplied to mixed-integer problems.

Default value: `NONE`

Possible values:

* `MSK_MIO_DATA_PERMUTATION_METHOD_NONE`. No problem data permutation is applied.
* `MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT`. A random cyclic shift is applied to permute the problem data.
* `MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM`. A random permutation is applied to the problem data.
"""
const MSK_IPAR_MIO_DATA_PERMUTATION_METHOD = Iparam(68)

"""
Controls the amount of dual ray analysis employed by the mixed-integer optimizer in presolve.

Default value: `-1`

Possible Values: Any number between -1 and 2.
"""
const MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL = Iparam(69)

"""
Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.

Default value: `-1`

Possible Values: Any number between -1 and 2.
"""
const MSK_IPAR_MIO_FEASPUMP_LEVEL = Iparam(70)

"""
Controls the heuristic employed by the mixed-integer optimizer to locate an initial integer feasible solution.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_MIO_HEURISTIC_LEVEL = Iparam(71)

"""
Maximum number of branches allowed during the branch and bound search.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_MIO_MAX_NUM_BRANCHES = Iparam(72)

"""
Maximum number of relaxations in branch and bound search.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_MIO_MAX_NUM_RELAXS = Iparam(73)

"""
Maximum number of restarts allowed during the branch and bound search.

Default value: `0`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_MIO_MAX_NUM_RESTARTS = Iparam(74)

"""
Maximum number of cut separation rounds at the root node.

Default value: `100`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS = Iparam(75)

"""
Controls how many feasible solutions the mixed-integer optimizer investigates.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_MIO_MAX_NUM_SOLUTIONS = Iparam(76)

"""
Controls how much emphasis is put on reducing memory usage.

Default value: `0`

Possible Values: Any number between 0 and +1.
"""
const MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL = Iparam(77)

"""
Number of times a variable must have been branched on for its pseudocost to be considered reliable.

Default value: `5`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_MIO_MIN_REL = Iparam(78)

"""
Turns on/off the mixed-integer mode.

Default value: `SATISFIED`

Possible values:

* `MSK_MIO_MODE_IGNORED`. The integer constraints are ignored and the problem is solved as a continuous problem.
* `MSK_MIO_MODE_SATISFIED`. Integer restrictions should be satisfied.
"""
const MSK_IPAR_MIO_MODE = Iparam(79)

"""
Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.

Default value: `FREE`

Possible values:

* `MSK_OPTIMIZER_FREE`. The optimizer is chosen automatically.
* `MSK_OPTIMIZER_INTPNT`. The interior-point optimizer is used.
* `MSK_OPTIMIZER_CONIC`. The optimizer for problems having conic constraints.
* `MSK_OPTIMIZER_PRIMAL_SIMPLEX`. The primal simplex optimizer is used.
* `MSK_OPTIMIZER_DUAL_SIMPLEX`. The dual simplex optimizer is used.
* `MSK_OPTIMIZER_FREE_SIMPLEX`. One of the simplex optimizers is used.
* `MSK_OPTIMIZER_MIXED_INT`. The mixed-integer optimizer.
"""
const MSK_IPAR_MIO_NODE_OPTIMIZER = Iparam(80)

"""
Controls the node selection strategy employed by the mixed-integer optimizer.

Default value: `FREE`

Possible values:

* `MSK_MIO_NODE_SELECTION_FREE`. The optimizer decides the node selection strategy.
* `MSK_MIO_NODE_SELECTION_FIRST`. The optimizer employs a depth first node selection strategy.
* `MSK_MIO_NODE_SELECTION_BEST`. The optimizer employs a best bound node selection strategy.
* `MSK_MIO_NODE_SELECTION_PSEUDO`. The optimizer employs selects the node based on a pseudo cost estimate.
"""
const MSK_IPAR_MIO_NODE_SELECTION = Iparam(81)

"""
Controls how much emphasis is put on reducing numerical problems

Default value: `0`

Possible Values: Any number between 0 and +2.
"""
const MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL = Iparam(82)

"""
Enables or disables perspective reformulation in presolve.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE = Iparam(83)

"""
Controls if the aggregator should be used.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE = Iparam(84)

"""
Controls the amount of probing employed by the mixed-integer optimizer in presolve.

Default value: `-1`

Possible Values: Any number between -1 and 3.
"""
const MSK_IPAR_MIO_PROBING_LEVEL = Iparam(85)

"""
Use objective domain propagation.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT = Iparam(86)

"""
Controls what reformulation method is applied to mixed-integer quadratic problems.

Default value: `FREE`

Possible values:

* `MSK_MIO_QCQO_REFORMULATION_METHOD_FREE`. The mixed-integer optimizer decides which reformulation method to apply.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_NONE`. No reformulation method is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION`. A reformulation via linearization is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD`. The eigenvalue method is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP`. A perturbation of matrix diagonals via the solution of SDPs is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP`. A Reformulation based on the solution of an SDP-relaxation of the problem is applied.
"""
const MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD = Iparam(87)

"""
Maximum number of nodes in each call to RINS.

Default value: `-1`

Possible Values: Any number between -1 and +inf.
"""
const MSK_IPAR_MIO_RINS_MAX_NODES = Iparam(88)

"""
Controls which optimizer is employed at the root node in the mixed-integer optimizer.

Default value: `FREE`

Possible values:

* `MSK_OPTIMIZER_FREE`. The optimizer is chosen automatically.
* `MSK_OPTIMIZER_INTPNT`. The interior-point optimizer is used.
* `MSK_OPTIMIZER_CONIC`. The optimizer for problems having conic constraints.
* `MSK_OPTIMIZER_PRIMAL_SIMPLEX`. The primal simplex optimizer is used.
* `MSK_OPTIMIZER_DUAL_SIMPLEX`. The dual simplex optimizer is used.
* `MSK_OPTIMIZER_FREE_SIMPLEX`. One of the simplex optimizers is used.
* `MSK_OPTIMIZER_MIXED_INT`. The mixed-integer optimizer.
"""
const MSK_IPAR_MIO_ROOT_OPTIMIZER = Iparam(89)

"""
Controls whether presolve can be repeated at root node.

Default value: `-1`

Possible Values: Any number between -1 and 1.
"""
const MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL = Iparam(90)

"""
Sets the random seed used for randomization in the mixed integer optimizer.

Default value: `42`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_MIO_SEED = Iparam(91)

"""
Controls the amount of symmetry detection and handling employed by the mixed-integer optimizer in presolve.

Default value: `-1`

Possible Values: Any number between -1 and 4.
"""
const MSK_IPAR_MIO_SYMMETRY_LEVEL = Iparam(92)

"""
Controls the variable selection strategy employed by the mixed-integer optimizer.

Default value: `FREE`

Possible values:

* `MSK_MIO_VAR_SELECTION_FREE`. The optimizer decides the variable selection strategy.
* `MSK_MIO_VAR_SELECTION_PSEUDOCOST`. The optimizer employs pseudocost variable selection.
* `MSK_MIO_VAR_SELECTION_STRONG`. The optimizer employs strong branching variable selection.
"""
const MSK_IPAR_MIO_VAR_SELECTION = Iparam(93)

"""
Controls how much effort is put into detecting variable bounds.

Default value: `-1`

Possible Values: Any number between -1 and +2.
"""
const MSK_IPAR_MIO_VB_DETECTION_LEVEL = Iparam(94)

"""
Set the number of iterations to spin before sleeping.

Default value: `0`

Possible Values: Any number between 0 and 1000000000.
"""
const MSK_IPAR_MT_SPINCOUNT = Iparam(95)

"""
Not in use

Default value: `off`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_NG = Iparam(96)

"""
The number of threads employed by the optimizer.

Default value: `0`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_NUM_THREADS = Iparam(97)

"""
Write a text header with date and MOSEK version in an OPF file.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_HEADER = Iparam(98)

"""
Write a hint section with problem dimensions in the beginning of an OPF file.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_HINTS = Iparam(99)

"""
Aim to keep lines in OPF files not much longer than this.

Default value: `80`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_OPF_WRITE_LINE_LENGTH = Iparam(100)

"""
Write a parameter section in an OPF file.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_PARAMETERS = Iparam(101)

"""
Write objective, constraints, bounds etc. to an OPF file.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_PROBLEM = Iparam(102)

"""
Controls what is written to the OPF files.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_SOL_BAS = Iparam(103)

"""
Controls what is written to the OPF files.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_SOL_ITG = Iparam(104)

"""
Controls what is written to the OPF files.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_SOL_ITR = Iparam(105)

"""
Enable inclusion of solutions in the OPF files.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_OPF_WRITE_SOLUTIONS = Iparam(106)

"""
Controls which optimizer is used to optimize the task.

Default value: `FREE`

Possible values:

* `MSK_OPTIMIZER_FREE`. The optimizer is chosen automatically.
* `MSK_OPTIMIZER_INTPNT`. The interior-point optimizer is used.
* `MSK_OPTIMIZER_CONIC`. The optimizer for problems having conic constraints.
* `MSK_OPTIMIZER_PRIMAL_SIMPLEX`. The primal simplex optimizer is used.
* `MSK_OPTIMIZER_DUAL_SIMPLEX`. The dual simplex optimizer is used.
* `MSK_OPTIMIZER_FREE_SIMPLEX`. One of the simplex optimizers is used.
* `MSK_OPTIMIZER_MIXED_INT`. The mixed-integer optimizer.
"""
const MSK_IPAR_OPTIMIZER = Iparam(107)

"""
If turned on, then names in the parameter file are case sensitive.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_PARAM_READ_CASE_NAME = Iparam(108)

"""
If turned on, then errors in parameter settings is ignored.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_PARAM_READ_IGN_ERROR = Iparam(109)

"""
Maximum amount of fill-in created in one pivot during the elimination phase.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL = Iparam(110)

"""
Control the maximum number of times the eliminator is tried.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES = Iparam(111)

"""
Currently not used.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_PRESOLVE_LEVEL = Iparam(112)

"""
Controls linear dependency check in presolve.

Default value: `100`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH = Iparam(113)

"""
Controls whether whether a new experimental linear dependency checker is employed.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_PRESOLVE_LINDEP_NEW = Iparam(114)

"""
Controls linear dependency check in presolve.

Default value: `100`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH = Iparam(115)

"""
Controls whether the linear constraints are checked for linear dependencies.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_PRESOLVE_LINDEP_USE = Iparam(116)

"""
Control the maximum number of times presolve passes over the problem.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_PRESOLVE_MAX_NUM_PASS = Iparam(117)

"""
Controls the maximum number of reductions performed by the presolve.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS = Iparam(118)

"""
Controls whether the presolve is applied to a problem before it is optimized.

Default value: `FREE`

Possible values:

* `MSK_PRESOLVE_MODE_OFF`. The problem is not presolved before it is optimized.
* `MSK_PRESOLVE_MODE_ON`. The problem is presolved before it is optimized.
* `MSK_PRESOLVE_MODE_FREE`. It is decided automatically whether to presolve before the problem is optimized.
"""
const MSK_IPAR_PRESOLVE_USE = Iparam(119)

"""
Controls which optimizer that is used to find the optimal repair.

Default value: `FREE`

Possible values:

* `MSK_OPTIMIZER_FREE`. The optimizer is chosen automatically.
* `MSK_OPTIMIZER_INTPNT`. The interior-point optimizer is used.
* `MSK_OPTIMIZER_CONIC`. The optimizer for problems having conic constraints.
* `MSK_OPTIMIZER_PRIMAL_SIMPLEX`. The primal simplex optimizer is used.
* `MSK_OPTIMIZER_DUAL_SIMPLEX`. The dual simplex optimizer is used.
* `MSK_OPTIMIZER_FREE_SIMPLEX`. One of the simplex optimizers is used.
* `MSK_OPTIMIZER_MIXED_INT`. The mixed-integer optimizer.
"""
const MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER = Iparam(120)

"""
Controls whether parameters section is written in PTF files.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_PTF_WRITE_PARAMETERS = Iparam(121)

"""
Controls whether solution section is written in PTF files.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_PTF_WRITE_SOLUTIONS = Iparam(122)

"""
Controls if simple transformation are done when writing PTF files.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_PTF_WRITE_TRANSFORM = Iparam(123)

"""
Turns on additional debugging information when reading files.

Default value: `off`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_READ_DEBUG = Iparam(124)

"""
Controls whether the free constraints are included in the problem.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_READ_KEEP_FREE_CON = Iparam(125)

"""
Controls how strictly the MPS file reader interprets the MPS format.

Default value: `FREE`

Possible values:

* `MSK_MPS_FORMAT_STRICT`. It is assumed that the input file satisfies the MPS format strictly.
* `MSK_MPS_FORMAT_RELAXED`. It is assumed that the input file satisfies a slightly relaxed version of the MPS format.
* `MSK_MPS_FORMAT_FREE`. It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free.
* `MSK_MPS_FORMAT_CPLEX`. The CPLEX compatible version of the MPS format is employed.
"""
const MSK_IPAR_READ_MPS_FORMAT = Iparam(126)

"""
Controls the maximal number of characters allowed in one line of the MPS file.

Default value: `1024`

Possible Values: Any number between 80 and +inf.
"""
const MSK_IPAR_READ_MPS_WIDTH = Iparam(127)

"""
Controls what information is used from the task files.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_READ_TASK_IGNORE_PARAM = Iparam(128)

"""
Use compression when sending data to an optimization server

Default value: `zstd`

Possible values:

* `MSK_COMPRESS_NONE`. No compression is used.
* `MSK_COMPRESS_FREE`. The type of compression used is chosen automatically.
* `MSK_COMPRESS_GZIP`. The type of compression used is gzip compatible.
* `MSK_COMPRESS_ZSTD`. The type of compression used is zstd compatible.
"""
const MSK_IPAR_REMOTE_USE_COMPRESSION = Iparam(129)

"""
Removes unused solutions before the optimization is performed.

Default value: `off`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_REMOVE_UNUSED_SOLUTIONS = Iparam(130)

"""
Controls sensitivity report behavior.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SENSITIVITY_ALL = Iparam(131)

"""
Controls which optimizer is used for optimal partition sensitivity analysis.

Default value: `FREE_SIMPLEX`

Possible values:

* `MSK_OPTIMIZER_FREE`. The optimizer is chosen automatically.
* `MSK_OPTIMIZER_INTPNT`. The interior-point optimizer is used.
* `MSK_OPTIMIZER_CONIC`. The optimizer for problems having conic constraints.
* `MSK_OPTIMIZER_PRIMAL_SIMPLEX`. The primal simplex optimizer is used.
* `MSK_OPTIMIZER_DUAL_SIMPLEX`. The dual simplex optimizer is used.
* `MSK_OPTIMIZER_FREE_SIMPLEX`. One of the simplex optimizers is used.
* `MSK_OPTIMIZER_MIXED_INT`. The mixed-integer optimizer.
"""
const MSK_IPAR_SENSITIVITY_OPTIMIZER = Iparam(132)

"""
Controls which type of sensitivity analysis is to be performed.

Default value: `BASIS`

Possible values:

* `MSK_SENSITIVITY_TYPE_BASIS`. Basis sensitivity analysis is performed.
"""
const MSK_IPAR_SENSITIVITY_TYPE = Iparam(133)

"""
Controls whether an LU factorization of the basis is used in a hot-start.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SIM_BASIS_FACTOR_USE = Iparam(134)

"""
Controls how aggressively degeneration is handled.

Default value: `FREE`

Possible values:

* `MSK_SIM_DEGEN_NONE`. The simplex optimizer should use no degeneration strategy.
* `MSK_SIM_DEGEN_FREE`. The simplex optimizer chooses the degeneration strategy.
* `MSK_SIM_DEGEN_AGGRESSIVE`. The simplex optimizer should use an aggressive degeneration strategy.
* `MSK_SIM_DEGEN_MODERATE`. The simplex optimizer should use a moderate degeneration strategy.
* `MSK_SIM_DEGEN_MINIMUM`. The simplex optimizer should use a minimum degeneration strategy.
"""
const MSK_IPAR_SIM_DEGEN = Iparam(135)

"""
Not in use.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SIM_DETECT_PWL = Iparam(136)

"""
Controls whether crashing is performed in the dual simplex optimizer.

Default value: `90`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_SIM_DUAL_CRASH = Iparam(137)

"""
An experimental feature.

Default value: `0`

Possible Values: Any number between 0 and 10.
"""
const MSK_IPAR_SIM_DUAL_PHASEONE_METHOD = Iparam(138)

"""
Controls how aggressively restricted selection is used.

Default value: `50`

Possible Values: Any number between 0 and 100.
"""
const MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION = Iparam(139)

"""
Controls the dual simplex strategy.

Default value: `FREE`

Possible values:

* `MSK_SIM_SELECTION_FREE`. The optimizer chooses the pricing strategy.
* `MSK_SIM_SELECTION_FULL`. The optimizer uses full pricing.
* `MSK_SIM_SELECTION_ASE`. The optimizer uses approximate steepest-edge pricing.
* `MSK_SIM_SELECTION_DEVEX`. The optimizer uses devex steepest-edge pricing.
* `MSK_SIM_SELECTION_SE`. The optimizer uses steepest-edge selection.
* `MSK_SIM_SELECTION_PARTIAL`. The optimizer uses a partial selection approach.
"""
const MSK_IPAR_SIM_DUAL_SELECTION = Iparam(140)

"""
Controls if the simplex optimizers are allowed to exploit duplicated columns.

Default value: `OFF`

Possible values:

* `MSK_SIM_EXPLOIT_DUPVEC_ON`. Allow the simplex optimizer to exploit duplicated columns.
* `MSK_SIM_EXPLOIT_DUPVEC_OFF`. Disallow the simplex optimizer to exploit duplicated columns.
* `MSK_SIM_EXPLOIT_DUPVEC_FREE`. The simplex optimizer can choose freely.
"""
const MSK_IPAR_SIM_EXPLOIT_DUPVEC = Iparam(141)

"""
Controls the type of hot-start that the simplex optimizer perform.

Default value: `FREE`

Possible values:

* `MSK_SIM_HOTSTART_NONE`. The simplex optimizer performs a coldstart.
* `MSK_SIM_HOTSTART_FREE`. The simplex optimize chooses the hot-start type.
* `MSK_SIM_HOTSTART_STATUS_KEYS`. Only the status keys of the constraints and variables are used to choose the type of hot-start.
"""
const MSK_IPAR_SIM_HOTSTART = Iparam(142)

"""
Determines if the simplex optimizer should exploit the initial factorization.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SIM_HOTSTART_LU = Iparam(143)

"""
Maximum number of iterations that can be used by a simplex optimizer.

Default value: `10000000`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_SIM_MAX_ITERATIONS = Iparam(144)

"""
Controls how many set-backs that are allowed within a simplex optimizer.

Default value: `250`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_SIM_MAX_NUM_SETBACKS = Iparam(145)

"""
Controls if the simplex optimizer ensures a non-singular basis, if possible.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SIM_NON_SINGULAR = Iparam(146)

"""
Controls the simplex crash.

Default value: `90`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_SIM_PRIMAL_CRASH = Iparam(147)

"""
An experimental feature.

Default value: `0`

Possible Values: Any number between 0 and 10.
"""
const MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD = Iparam(148)

"""
Controls how aggressively restricted selection is used.

Default value: `50`

Possible Values: Any number between 0 and 100.
"""
const MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION = Iparam(149)

"""
Controls the primal simplex strategy.

Default value: `FREE`

Possible values:

* `MSK_SIM_SELECTION_FREE`. The optimizer chooses the pricing strategy.
* `MSK_SIM_SELECTION_FULL`. The optimizer uses full pricing.
* `MSK_SIM_SELECTION_ASE`. The optimizer uses approximate steepest-edge pricing.
* `MSK_SIM_SELECTION_DEVEX`. The optimizer uses devex steepest-edge pricing.
* `MSK_SIM_SELECTION_SE`. The optimizer uses steepest-edge selection.
* `MSK_SIM_SELECTION_PARTIAL`. The optimizer uses a partial selection approach.
"""
const MSK_IPAR_SIM_PRIMAL_SELECTION = Iparam(150)

"""
Controls the basis refactoring frequency.

Default value: `0`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_SIM_REFACTOR_FREQ = Iparam(151)

"""
Controls if the simplex optimizers are allowed to reformulate the problem.

Default value: `OFF`

Possible values:

* `MSK_SIM_REFORMULATION_ON`. Allow the simplex optimizer to reformulate the problem.
* `MSK_SIM_REFORMULATION_OFF`. Disallow the simplex optimizer to reformulate the problem.
* `MSK_SIM_REFORMULATION_FREE`. The simplex optimizer can choose freely.
* `MSK_SIM_REFORMULATION_AGGRESSIVE`. The simplex optimizer should use an aggressive reformulation strategy.
"""
const MSK_IPAR_SIM_REFORMULATION = Iparam(152)

"""
Controls if the LU factorization stored should be replaced with the LU factorization corresponding to the initial basis.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SIM_SAVE_LU = Iparam(153)

"""
Controls how much effort is used in scaling the problem before a simplex optimizer is used.

Default value: `FREE`

Possible values:

* `MSK_SCALING_FREE`. The optimizer chooses the scaling heuristic.
* `MSK_SCALING_NONE`. No scaling is performed.
"""
const MSK_IPAR_SIM_SCALING = Iparam(154)

"""
Controls how the problem is scaled before a simplex optimizer is used.

Default value: `POW2`

Possible values:

* `MSK_SCALING_METHOD_POW2`. Scales only with power of 2 leaving the mantissa untouched.
* `MSK_SCALING_METHOD_FREE`. The optimizer chooses the scaling heuristic.
"""
const MSK_IPAR_SIM_SCALING_METHOD = Iparam(155)

"""
Sets the random seed used for randomization in the simplex optimizers.

Default value: `23456`

Possible Values: Any number between 0 and 32749.
"""
const MSK_IPAR_SIM_SEED = Iparam(156)

"""
Controls whether the primal or the dual problem is solved by the primal-/dual-simplex optimizer.

Default value: `FREE`

Possible values:

* `MSK_SOLVE_FREE`. The optimizer is free to solve either the primal or the dual problem.
* `MSK_SOLVE_PRIMAL`. The optimizer should solve the primal problem.
* `MSK_SOLVE_DUAL`. The optimizer should solve the dual problem.
"""
const MSK_IPAR_SIM_SOLVE_FORM = Iparam(157)

"""
Controls how high priority the numerical stability should be given.

Default value: `50`

Possible Values: Any number between 0 and 100.
"""
const MSK_IPAR_SIM_STABILITY_PRIORITY = Iparam(158)

"""
Controls the simplex behavior.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SIM_SWITCH_OPTIMIZER = Iparam(159)

"""
Control the contents of the solution files.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SOL_FILTER_KEEP_BASIC = Iparam(160)

"""
Control the contents of the solution files.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SOL_FILTER_KEEP_RANGED = Iparam(161)

"""
Controls the input solution file format.

Default value: `-1`

Possible Values: Any number between -inf and +inf.
"""
const MSK_IPAR_SOL_READ_NAME_WIDTH = Iparam(162)

"""
Controls the input solution file format.

Default value: `1024`

Possible Values: Any number between 80 and +inf.
"""
const MSK_IPAR_SOL_READ_WIDTH = Iparam(163)

"""
Indicates whether solution callbacks will be performed during the optimization.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_SOLUTION_CALLBACK = Iparam(164)

"""
Controls the amount of timing performed inside MOSEK.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_TIMING_LEVEL = Iparam(165)

"""
Controls the basic solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_BAS_CONSTRAINTS = Iparam(166)

"""
Controls the basic solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_BAS_HEAD = Iparam(167)

"""
Controls the basic solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_BAS_VARIABLES = Iparam(168)

"""
Controls output file compression.

Default value: `9`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_WRITE_COMPRESSION = Iparam(169)

"""
Controls output file data.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_DATA_PARAM = Iparam(170)

"""
Controls the output file data.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_FREE_CON = Iparam(171)

"""
Controls the output file data.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_GENERIC_NAMES = Iparam(172)

"""
Index origin used in  generic names.

Default value: `1`

Possible Values: Any number between 0 and +inf.
"""
const MSK_IPAR_WRITE_GENERIC_NAMES_IO = Iparam(173)

"""
Controls if the writer ignores incompatible problem items when writing files.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS = Iparam(174)

"""
Controls the integer solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_INT_CONSTRAINTS = Iparam(175)

"""
Controls the integer solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_INT_HEAD = Iparam(176)

"""
Controls the integer solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_INT_VARIABLES = Iparam(177)

"""
When set, the JSON task and solution files are written with indentation for better readability.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_JSON_INDENTATION = Iparam(178)

"""
Write full linear objective

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_LP_FULL_OBJ = Iparam(179)

"""
Controls the LP output file format.

Default value: `80`

Possible Values: Any number between 40 and +inf.
"""
const MSK_IPAR_WRITE_LP_LINE_WIDTH = Iparam(180)

"""
Controls in which format the MPS is written.

Default value: `FREE`

Possible values:

* `MSK_MPS_FORMAT_STRICT`. It is assumed that the input file satisfies the MPS format strictly.
* `MSK_MPS_FORMAT_RELAXED`. It is assumed that the input file satisfies a slightly relaxed version of the MPS format.
* `MSK_MPS_FORMAT_FREE`. It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free.
* `MSK_MPS_FORMAT_CPLEX`. The CPLEX compatible version of the MPS format is employed.
"""
const MSK_IPAR_WRITE_MPS_FORMAT = Iparam(181)

"""
Controls the output file data.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_MPS_INT = Iparam(182)

"""
Controls the solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_SOL_BARVARIABLES = Iparam(183)

"""
Controls the solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_SOL_CONSTRAINTS = Iparam(184)

"""
Controls solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_SOL_HEAD = Iparam(185)

"""
Controls whether the user specified names are employed even if they are invalid names.

Default value: `OFF`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES = Iparam(186)

"""
Controls the solution file format.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_SOL_VARIABLES = Iparam(187)

"""
Controls whether the solutions are stored in the task file too.

Default value: `ON`

Possible values:

* `MSK_ON`. Switch the option on.
* `MSK_OFF`. Switch the option off.
"""
const MSK_IPAR_WRITE_TASK_INC_SOL = Iparam(188)

"""
Controls if linear coefficients should be written by row or column when writing in the XML file format.

Default value: `ROW`

Possible values:

* `MSK_WRITE_XML_MODE_ROW`. Write in row order.
* `MSK_WRITE_XML_MODE_COL`. Write in column order.
"""
const MSK_IPAR_WRITE_XML_MODE = Iparam(189)
tostr(v::Iparam) = if v.value == 0 "Mosek.MSK_IPAR_ANA_SOL_BASIS"
  elseif v.value == 1 "Mosek.MSK_IPAR_ANA_SOL_PRINT_VIOLATED"
  elseif v.value == 2 "Mosek.MSK_IPAR_AUTO_SORT_A_BEFORE_OPT"
  elseif v.value == 3 "Mosek.MSK_IPAR_AUTO_UPDATE_SOL_INFO"
  elseif v.value == 4 "Mosek.MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE"
  elseif v.value == 5 "Mosek.MSK_IPAR_BI_CLEAN_OPTIMIZER"
  elseif v.value == 6 "Mosek.MSK_IPAR_BI_IGNORE_MAX_ITER"
  elseif v.value == 7 "Mosek.MSK_IPAR_BI_IGNORE_NUM_ERROR"
  elseif v.value == 8 "Mosek.MSK_IPAR_BI_MAX_ITERATIONS"
  elseif v.value == 9 "Mosek.MSK_IPAR_CACHE_LICENSE"
  elseif v.value == 10 "Mosek.MSK_IPAR_COMPRESS_STATFILE"
  elseif v.value == 11 "Mosek.MSK_IPAR_INFEAS_GENERIC_NAMES"
  elseif v.value == 12 "Mosek.MSK_IPAR_INFEAS_PREFER_PRIMAL"
  elseif v.value == 13 "Mosek.MSK_IPAR_INFEAS_REPORT_AUTO"
  elseif v.value == 14 "Mosek.MSK_IPAR_INFEAS_REPORT_LEVEL"
  elseif v.value == 15 "Mosek.MSK_IPAR_INTPNT_BASIS"
  elseif v.value == 16 "Mosek.MSK_IPAR_INTPNT_DIFF_STEP"
  elseif v.value == 17 "Mosek.MSK_IPAR_INTPNT_HOTSTART"
  elseif v.value == 18 "Mosek.MSK_IPAR_INTPNT_MAX_ITERATIONS"
  elseif v.value == 19 "Mosek.MSK_IPAR_INTPNT_MAX_NUM_COR"
  elseif v.value == 20 "Mosek.MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS"
  elseif v.value == 21 "Mosek.MSK_IPAR_INTPNT_OFF_COL_TRH"
  elseif v.value == 22 "Mosek.MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS"
  elseif v.value == 23 "Mosek.MSK_IPAR_INTPNT_ORDER_METHOD"
  elseif v.value == 24 "Mosek.MSK_IPAR_INTPNT_PURIFY"
  elseif v.value == 25 "Mosek.MSK_IPAR_INTPNT_REGULARIZATION_USE"
  elseif v.value == 26 "Mosek.MSK_IPAR_INTPNT_SCALING"
  elseif v.value == 27 "Mosek.MSK_IPAR_INTPNT_SOLVE_FORM"
  elseif v.value == 28 "Mosek.MSK_IPAR_INTPNT_STARTING_POINT"
  elseif v.value == 29 "Mosek.MSK_IPAR_LICENSE_DEBUG"
  elseif v.value == 30 "Mosek.MSK_IPAR_LICENSE_PAUSE_TIME"
  elseif v.value == 31 "Mosek.MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS"
  elseif v.value == 32 "Mosek.MSK_IPAR_LICENSE_TRH_EXPIRY_WRN"
  elseif v.value == 33 "Mosek.MSK_IPAR_LICENSE_WAIT"
  elseif v.value == 34 "Mosek.MSK_IPAR_LOG"
  elseif v.value == 35 "Mosek.MSK_IPAR_LOG_ANA_PRO"
  elseif v.value == 36 "Mosek.MSK_IPAR_LOG_BI"
  elseif v.value == 37 "Mosek.MSK_IPAR_LOG_BI_FREQ"
  elseif v.value == 38 "Mosek.MSK_IPAR_LOG_CUT_SECOND_OPT"
  elseif v.value == 39 "Mosek.MSK_IPAR_LOG_EXPAND"
  elseif v.value == 40 "Mosek.MSK_IPAR_LOG_FEAS_REPAIR"
  elseif v.value == 41 "Mosek.MSK_IPAR_LOG_FILE"
  elseif v.value == 42 "Mosek.MSK_IPAR_LOG_INCLUDE_SUMMARY"
  elseif v.value == 43 "Mosek.MSK_IPAR_LOG_INFEAS_ANA"
  elseif v.value == 44 "Mosek.MSK_IPAR_LOG_INTPNT"
  elseif v.value == 45 "Mosek.MSK_IPAR_LOG_LOCAL_INFO"
  elseif v.value == 46 "Mosek.MSK_IPAR_LOG_MIO"
  elseif v.value == 47 "Mosek.MSK_IPAR_LOG_MIO_FREQ"
  elseif v.value == 48 "Mosek.MSK_IPAR_LOG_ORDER"
  elseif v.value == 49 "Mosek.MSK_IPAR_LOG_PRESOLVE"
  elseif v.value == 50 "Mosek.MSK_IPAR_LOG_RESPONSE"
  elseif v.value == 51 "Mosek.MSK_IPAR_LOG_SENSITIVITY"
  elseif v.value == 52 "Mosek.MSK_IPAR_LOG_SENSITIVITY_OPT"
  elseif v.value == 53 "Mosek.MSK_IPAR_LOG_SIM"
  elseif v.value == 54 "Mosek.MSK_IPAR_LOG_SIM_FREQ"
  elseif v.value == 55 "Mosek.MSK_IPAR_LOG_SIM_MINOR"
  elseif v.value == 56 "Mosek.MSK_IPAR_LOG_STORAGE"
  elseif v.value == 57 "Mosek.MSK_IPAR_MAX_NUM_WARNINGS"
  elseif v.value == 58 "Mosek.MSK_IPAR_MIO_BRANCH_DIR"
  elseif v.value == 59 "Mosek.MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION"
  elseif v.value == 60 "Mosek.MSK_IPAR_MIO_CONSTRUCT_SOL"
  elseif v.value == 61 "Mosek.MSK_IPAR_MIO_CUT_CLIQUE"
  elseif v.value == 62 "Mosek.MSK_IPAR_MIO_CUT_CMIR"
  elseif v.value == 63 "Mosek.MSK_IPAR_MIO_CUT_GMI"
  elseif v.value == 64 "Mosek.MSK_IPAR_MIO_CUT_IMPLIED_BOUND"
  elseif v.value == 65 "Mosek.MSK_IPAR_MIO_CUT_KNAPSACK_COVER"
  elseif v.value == 66 "Mosek.MSK_IPAR_MIO_CUT_LIPRO"
  elseif v.value == 67 "Mosek.MSK_IPAR_MIO_CUT_SELECTION_LEVEL"
  elseif v.value == 68 "Mosek.MSK_IPAR_MIO_DATA_PERMUTATION_METHOD"
  elseif v.value == 69 "Mosek.MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL"
  elseif v.value == 70 "Mosek.MSK_IPAR_MIO_FEASPUMP_LEVEL"
  elseif v.value == 71 "Mosek.MSK_IPAR_MIO_HEURISTIC_LEVEL"
  elseif v.value == 72 "Mosek.MSK_IPAR_MIO_MAX_NUM_BRANCHES"
  elseif v.value == 73 "Mosek.MSK_IPAR_MIO_MAX_NUM_RELAXS"
  elseif v.value == 74 "Mosek.MSK_IPAR_MIO_MAX_NUM_RESTARTS"
  elseif v.value == 75 "Mosek.MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS"
  elseif v.value == 76 "Mosek.MSK_IPAR_MIO_MAX_NUM_SOLUTIONS"
  elseif v.value == 77 "Mosek.MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL"
  elseif v.value == 78 "Mosek.MSK_IPAR_MIO_MIN_REL"
  elseif v.value == 79 "Mosek.MSK_IPAR_MIO_MODE"
  elseif v.value == 80 "Mosek.MSK_IPAR_MIO_NODE_OPTIMIZER"
  elseif v.value == 81 "Mosek.MSK_IPAR_MIO_NODE_SELECTION"
  elseif v.value == 82 "Mosek.MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL"
  elseif v.value == 83 "Mosek.MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE"
  elseif v.value == 84 "Mosek.MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE"
  elseif v.value == 85 "Mosek.MSK_IPAR_MIO_PROBING_LEVEL"
  elseif v.value == 86 "Mosek.MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT"
  elseif v.value == 87 "Mosek.MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD"
  elseif v.value == 88 "Mosek.MSK_IPAR_MIO_RINS_MAX_NODES"
  elseif v.value == 89 "Mosek.MSK_IPAR_MIO_ROOT_OPTIMIZER"
  elseif v.value == 90 "Mosek.MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL"
  elseif v.value == 91 "Mosek.MSK_IPAR_MIO_SEED"
  elseif v.value == 92 "Mosek.MSK_IPAR_MIO_SYMMETRY_LEVEL"
  elseif v.value == 93 "Mosek.MSK_IPAR_MIO_VAR_SELECTION"
  elseif v.value == 94 "Mosek.MSK_IPAR_MIO_VB_DETECTION_LEVEL"
  elseif v.value == 95 "Mosek.MSK_IPAR_MT_SPINCOUNT"
  elseif v.value == 96 "Mosek.MSK_IPAR_NG"
  elseif v.value == 97 "Mosek.MSK_IPAR_NUM_THREADS"
  elseif v.value == 98 "Mosek.MSK_IPAR_OPF_WRITE_HEADER"
  elseif v.value == 99 "Mosek.MSK_IPAR_OPF_WRITE_HINTS"
  elseif v.value == 100 "Mosek.MSK_IPAR_OPF_WRITE_LINE_LENGTH"
  elseif v.value == 101 "Mosek.MSK_IPAR_OPF_WRITE_PARAMETERS"
  elseif v.value == 102 "Mosek.MSK_IPAR_OPF_WRITE_PROBLEM"
  elseif v.value == 103 "Mosek.MSK_IPAR_OPF_WRITE_SOL_BAS"
  elseif v.value == 104 "Mosek.MSK_IPAR_OPF_WRITE_SOL_ITG"
  elseif v.value == 105 "Mosek.MSK_IPAR_OPF_WRITE_SOL_ITR"
  elseif v.value == 106 "Mosek.MSK_IPAR_OPF_WRITE_SOLUTIONS"
  elseif v.value == 107 "Mosek.MSK_IPAR_OPTIMIZER"
  elseif v.value == 108 "Mosek.MSK_IPAR_PARAM_READ_CASE_NAME"
  elseif v.value == 109 "Mosek.MSK_IPAR_PARAM_READ_IGN_ERROR"
  elseif v.value == 110 "Mosek.MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL"
  elseif v.value == 111 "Mosek.MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES"
  elseif v.value == 112 "Mosek.MSK_IPAR_PRESOLVE_LEVEL"
  elseif v.value == 113 "Mosek.MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH"
  elseif v.value == 114 "Mosek.MSK_IPAR_PRESOLVE_LINDEP_NEW"
  elseif v.value == 115 "Mosek.MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH"
  elseif v.value == 116 "Mosek.MSK_IPAR_PRESOLVE_LINDEP_USE"
  elseif v.value == 117 "Mosek.MSK_IPAR_PRESOLVE_MAX_NUM_PASS"
  elseif v.value == 118 "Mosek.MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS"
  elseif v.value == 119 "Mosek.MSK_IPAR_PRESOLVE_USE"
  elseif v.value == 120 "Mosek.MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER"
  elseif v.value == 121 "Mosek.MSK_IPAR_PTF_WRITE_PARAMETERS"
  elseif v.value == 122 "Mosek.MSK_IPAR_PTF_WRITE_SOLUTIONS"
  elseif v.value == 123 "Mosek.MSK_IPAR_PTF_WRITE_TRANSFORM"
  elseif v.value == 124 "Mosek.MSK_IPAR_READ_DEBUG"
  elseif v.value == 125 "Mosek.MSK_IPAR_READ_KEEP_FREE_CON"
  elseif v.value == 126 "Mosek.MSK_IPAR_READ_MPS_FORMAT"
  elseif v.value == 127 "Mosek.MSK_IPAR_READ_MPS_WIDTH"
  elseif v.value == 128 "Mosek.MSK_IPAR_READ_TASK_IGNORE_PARAM"
  elseif v.value == 129 "Mosek.MSK_IPAR_REMOTE_USE_COMPRESSION"
  elseif v.value == 130 "Mosek.MSK_IPAR_REMOVE_UNUSED_SOLUTIONS"
  elseif v.value == 131 "Mosek.MSK_IPAR_SENSITIVITY_ALL"
  elseif v.value == 132 "Mosek.MSK_IPAR_SENSITIVITY_OPTIMIZER"
  elseif v.value == 133 "Mosek.MSK_IPAR_SENSITIVITY_TYPE"
  elseif v.value == 134 "Mosek.MSK_IPAR_SIM_BASIS_FACTOR_USE"
  elseif v.value == 135 "Mosek.MSK_IPAR_SIM_DEGEN"
  elseif v.value == 136 "Mosek.MSK_IPAR_SIM_DETECT_PWL"
  elseif v.value == 137 "Mosek.MSK_IPAR_SIM_DUAL_CRASH"
  elseif v.value == 138 "Mosek.MSK_IPAR_SIM_DUAL_PHASEONE_METHOD"
  elseif v.value == 139 "Mosek.MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION"
  elseif v.value == 140 "Mosek.MSK_IPAR_SIM_DUAL_SELECTION"
  elseif v.value == 141 "Mosek.MSK_IPAR_SIM_EXPLOIT_DUPVEC"
  elseif v.value == 142 "Mosek.MSK_IPAR_SIM_HOTSTART"
  elseif v.value == 143 "Mosek.MSK_IPAR_SIM_HOTSTART_LU"
  elseif v.value == 144 "Mosek.MSK_IPAR_SIM_MAX_ITERATIONS"
  elseif v.value == 145 "Mosek.MSK_IPAR_SIM_MAX_NUM_SETBACKS"
  elseif v.value == 146 "Mosek.MSK_IPAR_SIM_NON_SINGULAR"
  elseif v.value == 147 "Mosek.MSK_IPAR_SIM_PRIMAL_CRASH"
  elseif v.value == 148 "Mosek.MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD"
  elseif v.value == 149 "Mosek.MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION"
  elseif v.value == 150 "Mosek.MSK_IPAR_SIM_PRIMAL_SELECTION"
  elseif v.value == 151 "Mosek.MSK_IPAR_SIM_REFACTOR_FREQ"
  elseif v.value == 152 "Mosek.MSK_IPAR_SIM_REFORMULATION"
  elseif v.value == 153 "Mosek.MSK_IPAR_SIM_SAVE_LU"
  elseif v.value == 154 "Mosek.MSK_IPAR_SIM_SCALING"
  elseif v.value == 155 "Mosek.MSK_IPAR_SIM_SCALING_METHOD"
  elseif v.value == 156 "Mosek.MSK_IPAR_SIM_SEED"
  elseif v.value == 157 "Mosek.MSK_IPAR_SIM_SOLVE_FORM"
  elseif v.value == 158 "Mosek.MSK_IPAR_SIM_STABILITY_PRIORITY"
  elseif v.value == 159 "Mosek.MSK_IPAR_SIM_SWITCH_OPTIMIZER"
  elseif v.value == 160 "Mosek.MSK_IPAR_SOL_FILTER_KEEP_BASIC"
  elseif v.value == 161 "Mosek.MSK_IPAR_SOL_FILTER_KEEP_RANGED"
  elseif v.value == 162 "Mosek.MSK_IPAR_SOL_READ_NAME_WIDTH"
  elseif v.value == 163 "Mosek.MSK_IPAR_SOL_READ_WIDTH"
  elseif v.value == 164 "Mosek.MSK_IPAR_SOLUTION_CALLBACK"
  elseif v.value == 165 "Mosek.MSK_IPAR_TIMING_LEVEL"
  elseif v.value == 166 "Mosek.MSK_IPAR_WRITE_BAS_CONSTRAINTS"
  elseif v.value == 167 "Mosek.MSK_IPAR_WRITE_BAS_HEAD"
  elseif v.value == 168 "Mosek.MSK_IPAR_WRITE_BAS_VARIABLES"
  elseif v.value == 169 "Mosek.MSK_IPAR_WRITE_COMPRESSION"
  elseif v.value == 170 "Mosek.MSK_IPAR_WRITE_DATA_PARAM"
  elseif v.value == 171 "Mosek.MSK_IPAR_WRITE_FREE_CON"
  elseif v.value == 172 "Mosek.MSK_IPAR_WRITE_GENERIC_NAMES"
  elseif v.value == 173 "Mosek.MSK_IPAR_WRITE_GENERIC_NAMES_IO"
  elseif v.value == 174 "Mosek.MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS"
  elseif v.value == 175 "Mosek.MSK_IPAR_WRITE_INT_CONSTRAINTS"
  elseif v.value == 176 "Mosek.MSK_IPAR_WRITE_INT_HEAD"
  elseif v.value == 177 "Mosek.MSK_IPAR_WRITE_INT_VARIABLES"
  elseif v.value == 178 "Mosek.MSK_IPAR_WRITE_JSON_INDENTATION"
  elseif v.value == 179 "Mosek.MSK_IPAR_WRITE_LP_FULL_OBJ"
  elseif v.value == 180 "Mosek.MSK_IPAR_WRITE_LP_LINE_WIDTH"
  elseif v.value == 181 "Mosek.MSK_IPAR_WRITE_MPS_FORMAT"
  elseif v.value == 182 "Mosek.MSK_IPAR_WRITE_MPS_INT"
  elseif v.value == 183 "Mosek.MSK_IPAR_WRITE_SOL_BARVARIABLES"
  elseif v.value == 184 "Mosek.MSK_IPAR_WRITE_SOL_CONSTRAINTS"
  elseif v.value == 185 "Mosek.MSK_IPAR_WRITE_SOL_HEAD"
  elseif v.value == 186 "Mosek.MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES"
  elseif v.value == 187 "Mosek.MSK_IPAR_WRITE_SOL_VARIABLES"
  elseif v.value == 188 "Mosek.MSK_IPAR_WRITE_TASK_INC_SOL"
  elseif v.value == 189 "Mosek.MSK_IPAR_WRITE_XML_MODE"
  else "Mosek.Iparam(?)"
  end
const Iparam_members = Iparam[
    MSK_IPAR_ANA_SOL_BASIS,
    MSK_IPAR_ANA_SOL_PRINT_VIOLATED,
    MSK_IPAR_AUTO_SORT_A_BEFORE_OPT,
    MSK_IPAR_AUTO_UPDATE_SOL_INFO,
    MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE,
    MSK_IPAR_BI_CLEAN_OPTIMIZER,
    MSK_IPAR_BI_IGNORE_MAX_ITER,
    MSK_IPAR_BI_IGNORE_NUM_ERROR,
    MSK_IPAR_BI_MAX_ITERATIONS,
    MSK_IPAR_CACHE_LICENSE,
    MSK_IPAR_COMPRESS_STATFILE,
    MSK_IPAR_INFEAS_GENERIC_NAMES,
    MSK_IPAR_INFEAS_PREFER_PRIMAL,
    MSK_IPAR_INFEAS_REPORT_AUTO,
    MSK_IPAR_INFEAS_REPORT_LEVEL,
    MSK_IPAR_INTPNT_BASIS,
    MSK_IPAR_INTPNT_DIFF_STEP,
    MSK_IPAR_INTPNT_HOTSTART,
    MSK_IPAR_INTPNT_MAX_ITERATIONS,
    MSK_IPAR_INTPNT_MAX_NUM_COR,
    MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS,
    MSK_IPAR_INTPNT_OFF_COL_TRH,
    MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS,
    MSK_IPAR_INTPNT_ORDER_METHOD,
    MSK_IPAR_INTPNT_PURIFY,
    MSK_IPAR_INTPNT_REGULARIZATION_USE,
    MSK_IPAR_INTPNT_SCALING,
    MSK_IPAR_INTPNT_SOLVE_FORM,
    MSK_IPAR_INTPNT_STARTING_POINT,
    MSK_IPAR_LICENSE_DEBUG,
    MSK_IPAR_LICENSE_PAUSE_TIME,
    MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS,
    MSK_IPAR_LICENSE_TRH_EXPIRY_WRN,
    MSK_IPAR_LICENSE_WAIT,
    MSK_IPAR_LOG,
    MSK_IPAR_LOG_ANA_PRO,
    MSK_IPAR_LOG_BI,
    MSK_IPAR_LOG_BI_FREQ,
    MSK_IPAR_LOG_CUT_SECOND_OPT,
    MSK_IPAR_LOG_EXPAND,
    MSK_IPAR_LOG_FEAS_REPAIR,
    MSK_IPAR_LOG_FILE,
    MSK_IPAR_LOG_INCLUDE_SUMMARY,
    MSK_IPAR_LOG_INFEAS_ANA,
    MSK_IPAR_LOG_INTPNT,
    MSK_IPAR_LOG_LOCAL_INFO,
    MSK_IPAR_LOG_MIO,
    MSK_IPAR_LOG_MIO_FREQ,
    MSK_IPAR_LOG_ORDER,
    MSK_IPAR_LOG_PRESOLVE,
    MSK_IPAR_LOG_RESPONSE,
    MSK_IPAR_LOG_SENSITIVITY,
    MSK_IPAR_LOG_SENSITIVITY_OPT,
    MSK_IPAR_LOG_SIM,
    MSK_IPAR_LOG_SIM_FREQ,
    MSK_IPAR_LOG_SIM_MINOR,
    MSK_IPAR_LOG_STORAGE,
    MSK_IPAR_MAX_NUM_WARNINGS,
    MSK_IPAR_MIO_BRANCH_DIR,
    MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION,
    MSK_IPAR_MIO_CONSTRUCT_SOL,
    MSK_IPAR_MIO_CUT_CLIQUE,
    MSK_IPAR_MIO_CUT_CMIR,
    MSK_IPAR_MIO_CUT_GMI,
    MSK_IPAR_MIO_CUT_IMPLIED_BOUND,
    MSK_IPAR_MIO_CUT_KNAPSACK_COVER,
    MSK_IPAR_MIO_CUT_LIPRO,
    MSK_IPAR_MIO_CUT_SELECTION_LEVEL,
    MSK_IPAR_MIO_DATA_PERMUTATION_METHOD,
    MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL,
    MSK_IPAR_MIO_FEASPUMP_LEVEL,
    MSK_IPAR_MIO_HEURISTIC_LEVEL,
    MSK_IPAR_MIO_MAX_NUM_BRANCHES,
    MSK_IPAR_MIO_MAX_NUM_RELAXS,
    MSK_IPAR_MIO_MAX_NUM_RESTARTS,
    MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS,
    MSK_IPAR_MIO_MAX_NUM_SOLUTIONS,
    MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL,
    MSK_IPAR_MIO_MIN_REL,
    MSK_IPAR_MIO_MODE,
    MSK_IPAR_MIO_NODE_OPTIMIZER,
    MSK_IPAR_MIO_NODE_SELECTION,
    MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL,
    MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE,
    MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE,
    MSK_IPAR_MIO_PROBING_LEVEL,
    MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT,
    MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD,
    MSK_IPAR_MIO_RINS_MAX_NODES,
    MSK_IPAR_MIO_ROOT_OPTIMIZER,
    MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL,
    MSK_IPAR_MIO_SEED,
    MSK_IPAR_MIO_SYMMETRY_LEVEL,
    MSK_IPAR_MIO_VAR_SELECTION,
    MSK_IPAR_MIO_VB_DETECTION_LEVEL,
    MSK_IPAR_MT_SPINCOUNT,
    MSK_IPAR_NG,
    MSK_IPAR_NUM_THREADS,
    MSK_IPAR_OPF_WRITE_HEADER,
    MSK_IPAR_OPF_WRITE_HINTS,
    MSK_IPAR_OPF_WRITE_LINE_LENGTH,
    MSK_IPAR_OPF_WRITE_PARAMETERS,
    MSK_IPAR_OPF_WRITE_PROBLEM,
    MSK_IPAR_OPF_WRITE_SOL_BAS,
    MSK_IPAR_OPF_WRITE_SOL_ITG,
    MSK_IPAR_OPF_WRITE_SOL_ITR,
    MSK_IPAR_OPF_WRITE_SOLUTIONS,
    MSK_IPAR_OPTIMIZER,
    MSK_IPAR_PARAM_READ_CASE_NAME,
    MSK_IPAR_PARAM_READ_IGN_ERROR,
    MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL,
    MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES,
    MSK_IPAR_PRESOLVE_LEVEL,
    MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH,
    MSK_IPAR_PRESOLVE_LINDEP_NEW,
    MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH,
    MSK_IPAR_PRESOLVE_LINDEP_USE,
    MSK_IPAR_PRESOLVE_MAX_NUM_PASS,
    MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS,
    MSK_IPAR_PRESOLVE_USE,
    MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER,
    MSK_IPAR_PTF_WRITE_PARAMETERS,
    MSK_IPAR_PTF_WRITE_SOLUTIONS,
    MSK_IPAR_PTF_WRITE_TRANSFORM,
    MSK_IPAR_READ_DEBUG,
    MSK_IPAR_READ_KEEP_FREE_CON,
    MSK_IPAR_READ_MPS_FORMAT,
    MSK_IPAR_READ_MPS_WIDTH,
    MSK_IPAR_READ_TASK_IGNORE_PARAM,
    MSK_IPAR_REMOTE_USE_COMPRESSION,
    MSK_IPAR_REMOVE_UNUSED_SOLUTIONS,
    MSK_IPAR_SENSITIVITY_ALL,
    MSK_IPAR_SENSITIVITY_OPTIMIZER,
    MSK_IPAR_SENSITIVITY_TYPE,
    MSK_IPAR_SIM_BASIS_FACTOR_USE,
    MSK_IPAR_SIM_DEGEN,
    MSK_IPAR_SIM_DETECT_PWL,
    MSK_IPAR_SIM_DUAL_CRASH,
    MSK_IPAR_SIM_DUAL_PHASEONE_METHOD,
    MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION,
    MSK_IPAR_SIM_DUAL_SELECTION,
    MSK_IPAR_SIM_EXPLOIT_DUPVEC,
    MSK_IPAR_SIM_HOTSTART,
    MSK_IPAR_SIM_HOTSTART_LU,
    MSK_IPAR_SIM_MAX_ITERATIONS,
    MSK_IPAR_SIM_MAX_NUM_SETBACKS,
    MSK_IPAR_SIM_NON_SINGULAR,
    MSK_IPAR_SIM_PRIMAL_CRASH,
    MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD,
    MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION,
    MSK_IPAR_SIM_PRIMAL_SELECTION,
    MSK_IPAR_SIM_REFACTOR_FREQ,
    MSK_IPAR_SIM_REFORMULATION,
    MSK_IPAR_SIM_SAVE_LU,
    MSK_IPAR_SIM_SCALING,
    MSK_IPAR_SIM_SCALING_METHOD,
    MSK_IPAR_SIM_SEED,
    MSK_IPAR_SIM_SOLVE_FORM,
    MSK_IPAR_SIM_STABILITY_PRIORITY,
    MSK_IPAR_SIM_SWITCH_OPTIMIZER,
    MSK_IPAR_SOL_FILTER_KEEP_BASIC,
    MSK_IPAR_SOL_FILTER_KEEP_RANGED,
    MSK_IPAR_SOL_READ_NAME_WIDTH,
    MSK_IPAR_SOL_READ_WIDTH,
    MSK_IPAR_SOLUTION_CALLBACK,
    MSK_IPAR_TIMING_LEVEL,
    MSK_IPAR_WRITE_BAS_CONSTRAINTS,
    MSK_IPAR_WRITE_BAS_HEAD,
    MSK_IPAR_WRITE_BAS_VARIABLES,
    MSK_IPAR_WRITE_COMPRESSION,
    MSK_IPAR_WRITE_DATA_PARAM,
    MSK_IPAR_WRITE_FREE_CON,
    MSK_IPAR_WRITE_GENERIC_NAMES,
    MSK_IPAR_WRITE_GENERIC_NAMES_IO,
    MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS,
    MSK_IPAR_WRITE_INT_CONSTRAINTS,
    MSK_IPAR_WRITE_INT_HEAD,
    MSK_IPAR_WRITE_INT_VARIABLES,
    MSK_IPAR_WRITE_JSON_INDENTATION,
    MSK_IPAR_WRITE_LP_FULL_OBJ,
    MSK_IPAR_WRITE_LP_LINE_WIDTH,
    MSK_IPAR_WRITE_MPS_FORMAT,
    MSK_IPAR_WRITE_MPS_INT,
    MSK_IPAR_WRITE_SOL_BARVARIABLES,
    MSK_IPAR_WRITE_SOL_CONSTRAINTS,
    MSK_IPAR_WRITE_SOL_HEAD,
    MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES,
    MSK_IPAR_WRITE_SOL_VARIABLES,
    MSK_IPAR_WRITE_TASK_INC_SOL,
    MSK_IPAR_WRITE_XML_MODE ]
members(::Type{Iparam}) = Iparam_members
Base.length(::Type{Iparam}) = 190
Base.convert(::Type{Int},x::Iparam) = Int(x.value)
"""
    Branchdir

Specifies the branching direction.

* `MSK_BRANCH_DIR_FREE`. The mixed-integer optimizer decides which branch to choose.
* `MSK_BRANCH_DIR_UP`. The mixed-integer optimizer always chooses the up branch first.
* `MSK_BRANCH_DIR_DOWN`. The mixed-integer optimizer always chooses the down branch first.
* `MSK_BRANCH_DIR_NEAR`. Branch in direction nearest to selected fractional variable.
* `MSK_BRANCH_DIR_FAR`. Branch in direction farthest from selected fractional variable.
* `MSK_BRANCH_DIR_ROOT_LP`. Chose direction based on root lp value of selected variable.
* `MSK_BRANCH_DIR_GUIDED`. Branch in direction of current incumbent.
* `MSK_BRANCH_DIR_PSEUDOCOST`. Branch based on the pseudocost of the variable.
"""
struct Branchdir <: MosekEnum
  value :: Int32
end # branchdir

"The mixed-integer optimizer decides which branch to choose."
const MSK_BRANCH_DIR_FREE = Branchdir(0)

"The mixed-integer optimizer always chooses the up branch first."
const MSK_BRANCH_DIR_UP = Branchdir(1)

"The mixed-integer optimizer always chooses the down branch first."
const MSK_BRANCH_DIR_DOWN = Branchdir(2)

"Branch in direction nearest to selected fractional variable."
const MSK_BRANCH_DIR_NEAR = Branchdir(3)

"Branch in direction farthest from selected fractional variable."
const MSK_BRANCH_DIR_FAR = Branchdir(4)

"Chose direction based on root lp value of selected variable."
const MSK_BRANCH_DIR_ROOT_LP = Branchdir(5)

"Branch in direction of current incumbent."
const MSK_BRANCH_DIR_GUIDED = Branchdir(6)

"Branch based on the pseudocost of the variable."
const MSK_BRANCH_DIR_PSEUDOCOST = Branchdir(7)
tostr(v::Branchdir) = if v.value == 0 "Mosek.MSK_BRANCH_DIR_FREE"
  elseif v.value == 1 "Mosek.MSK_BRANCH_DIR_UP"
  elseif v.value == 2 "Mosek.MSK_BRANCH_DIR_DOWN"
  elseif v.value == 3 "Mosek.MSK_BRANCH_DIR_NEAR"
  elseif v.value == 4 "Mosek.MSK_BRANCH_DIR_FAR"
  elseif v.value == 5 "Mosek.MSK_BRANCH_DIR_ROOT_LP"
  elseif v.value == 6 "Mosek.MSK_BRANCH_DIR_GUIDED"
  elseif v.value == 7 "Mosek.MSK_BRANCH_DIR_PSEUDOCOST"
  else "Mosek.Branchdir(?)"
  end
const Branchdir_members = Branchdir[
    MSK_BRANCH_DIR_FREE,
    MSK_BRANCH_DIR_UP,
    MSK_BRANCH_DIR_DOWN,
    MSK_BRANCH_DIR_NEAR,
    MSK_BRANCH_DIR_FAR,
    MSK_BRANCH_DIR_ROOT_LP,
    MSK_BRANCH_DIR_GUIDED,
    MSK_BRANCH_DIR_PSEUDOCOST ]
members(::Type{Branchdir}) = Branchdir_members
Base.length(::Type{Branchdir}) = 8
Base.convert(::Type{Int},x::Branchdir) = Int(x.value)
"""
    Miqcqoreformmethod

Specifies the reformulation method for mixed-integer quadratic problems.

* `MSK_MIO_QCQO_REFORMULATION_METHOD_FREE`. The mixed-integer optimizer decides which reformulation method to apply.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_NONE`. No reformulation method is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION`. A reformulation via linearization is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD`. The eigenvalue method is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP`. A perturbation of matrix diagonals via the solution of SDPs is applied.
* `MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP`. A Reformulation based on the solution of an SDP-relaxation of the problem is applied.
"""
struct Miqcqoreformmethod <: MosekEnum
  value :: Int32
end # miqcqoreformmethod

"The mixed-integer optimizer decides which reformulation method to apply."
const MSK_MIO_QCQO_REFORMULATION_METHOD_FREE = Miqcqoreformmethod(0)

"No reformulation method is applied."
const MSK_MIO_QCQO_REFORMULATION_METHOD_NONE = Miqcqoreformmethod(1)

"A reformulation via linearization is applied."
const MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION = Miqcqoreformmethod(2)

"The eigenvalue method is applied."
const MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD = Miqcqoreformmethod(3)

"A perturbation of matrix diagonals via the solution of SDPs is applied."
const MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP = Miqcqoreformmethod(4)

"A Reformulation based on the solution of an SDP-relaxation of the problem is applied."
const MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP = Miqcqoreformmethod(5)
tostr(v::Miqcqoreformmethod) = if v.value == 0 "Mosek.MSK_MIO_QCQO_REFORMULATION_METHOD_FREE"
  elseif v.value == 1 "Mosek.MSK_MIO_QCQO_REFORMULATION_METHOD_NONE"
  elseif v.value == 2 "Mosek.MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION"
  elseif v.value == 3 "Mosek.MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD"
  elseif v.value == 4 "Mosek.MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP"
  elseif v.value == 5 "Mosek.MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP"
  else "Mosek.Miqcqoreformmethod(?)"
  end
const Miqcqoreformmethod_members = Miqcqoreformmethod[
    MSK_MIO_QCQO_REFORMULATION_METHOD_FREE,
    MSK_MIO_QCQO_REFORMULATION_METHOD_NONE,
    MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION,
    MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD,
    MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP,
    MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP ]
members(::Type{Miqcqoreformmethod}) = Miqcqoreformmethod_members
Base.length(::Type{Miqcqoreformmethod}) = 6
Base.convert(::Type{Int},x::Miqcqoreformmethod) = Int(x.value)
"""
    Miodatapermmethod

Specifies the problem data permutation method for mixed-integer problems.

* `MSK_MIO_DATA_PERMUTATION_METHOD_NONE`. No problem data permutation is applied.
* `MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT`. A random cyclic shift is applied to permute the problem data.
* `MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM`. A random permutation is applied to the problem data.
"""
struct Miodatapermmethod <: MosekEnum
  value :: Int32
end # miodatapermmethod

"No problem data permutation is applied."
const MSK_MIO_DATA_PERMUTATION_METHOD_NONE = Miodatapermmethod(0)

"A random cyclic shift is applied to permute the problem data."
const MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT = Miodatapermmethod(1)

"A random permutation is applied to the problem data."
const MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM = Miodatapermmethod(2)
tostr(v::Miodatapermmethod) = if v.value == 0 "Mosek.MSK_MIO_DATA_PERMUTATION_METHOD_NONE"
  elseif v.value == 1 "Mosek.MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT"
  elseif v.value == 2 "Mosek.MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM"
  else "Mosek.Miodatapermmethod(?)"
  end
const Miodatapermmethod_members = Miodatapermmethod[
    MSK_MIO_DATA_PERMUTATION_METHOD_NONE,
    MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT,
    MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM ]
members(::Type{Miodatapermmethod}) = Miodatapermmethod_members
Base.length(::Type{Miodatapermmethod}) = 3
Base.convert(::Type{Int},x::Miodatapermmethod) = Int(x.value)
"""
    Miocontsoltype

Continuous mixed-integer solution type

* `MSK_MIO_CONT_SOL_NONE`. No interior-point or basic solution.
* `MSK_MIO_CONT_SOL_ROOT`. Solutions to the root node problem.
* `MSK_MIO_CONT_SOL_ITG`. A feasible primal solution.
* `MSK_MIO_CONT_SOL_ITG_REL`. A feasible primal solution or a root node solution if the problem is infeasible.
"""
struct Miocontsoltype <: MosekEnum
  value :: Int32
end # miocontsoltype

"No interior-point or basic solution."
const MSK_MIO_CONT_SOL_NONE = Miocontsoltype(0)

"Solutions to the root node problem."
const MSK_MIO_CONT_SOL_ROOT = Miocontsoltype(1)

"A feasible primal solution."
const MSK_MIO_CONT_SOL_ITG = Miocontsoltype(2)

"A feasible primal solution or a root node solution if the problem is infeasible."
const MSK_MIO_CONT_SOL_ITG_REL = Miocontsoltype(3)
tostr(v::Miocontsoltype) = if v.value == 0 "Mosek.MSK_MIO_CONT_SOL_NONE"
  elseif v.value == 1 "Mosek.MSK_MIO_CONT_SOL_ROOT"
  elseif v.value == 2 "Mosek.MSK_MIO_CONT_SOL_ITG"
  elseif v.value == 3 "Mosek.MSK_MIO_CONT_SOL_ITG_REL"
  else "Mosek.Miocontsoltype(?)"
  end
const Miocontsoltype_members = Miocontsoltype[
    MSK_MIO_CONT_SOL_NONE,
    MSK_MIO_CONT_SOL_ROOT,
    MSK_MIO_CONT_SOL_ITG,
    MSK_MIO_CONT_SOL_ITG_REL ]
members(::Type{Miocontsoltype}) = Miocontsoltype_members
Base.length(::Type{Miocontsoltype}) = 4
Base.convert(::Type{Int},x::Miocontsoltype) = Int(x.value)
"""
    Miomode

Integer restrictions

* `MSK_MIO_MODE_IGNORED`. The integer constraints are ignored and the problem is solved as a continuous problem.
* `MSK_MIO_MODE_SATISFIED`. Integer restrictions should be satisfied.
"""
struct Miomode <: MosekEnum
  value :: Int32
end # miomode

"The integer constraints are ignored and the problem is solved as a continuous problem."
const MSK_MIO_MODE_IGNORED = Miomode(0)

"Integer restrictions should be satisfied."
const MSK_MIO_MODE_SATISFIED = Miomode(1)
tostr(v::Miomode) = if v.value == 0 "Mosek.MSK_MIO_MODE_IGNORED"
  elseif v.value == 1 "Mosek.MSK_MIO_MODE_SATISFIED"
  else "Mosek.Miomode(?)"
  end
const Miomode_members = Miomode[
    MSK_MIO_MODE_IGNORED,
    MSK_MIO_MODE_SATISFIED ]
members(::Type{Miomode}) = Miomode_members
Base.length(::Type{Miomode}) = 2
Base.convert(::Type{Int},x::Miomode) = Int(x.value)
"""
    Mionodeseltype

Mixed-integer node selection types

* `MSK_MIO_NODE_SELECTION_FREE`. The optimizer decides the node selection strategy.
* `MSK_MIO_NODE_SELECTION_FIRST`. The optimizer employs a depth first node selection strategy.
* `MSK_MIO_NODE_SELECTION_BEST`. The optimizer employs a best bound node selection strategy.
* `MSK_MIO_NODE_SELECTION_PSEUDO`. The optimizer employs selects the node based on a pseudo cost estimate.
"""
struct Mionodeseltype <: MosekEnum
  value :: Int32
end # mionodeseltype

"The optimizer decides the node selection strategy."
const MSK_MIO_NODE_SELECTION_FREE = Mionodeseltype(0)

"The optimizer employs a depth first node selection strategy."
const MSK_MIO_NODE_SELECTION_FIRST = Mionodeseltype(1)

"The optimizer employs a best bound node selection strategy."
const MSK_MIO_NODE_SELECTION_BEST = Mionodeseltype(2)

"The optimizer employs selects the node based on a pseudo cost estimate."
const MSK_MIO_NODE_SELECTION_PSEUDO = Mionodeseltype(3)
tostr(v::Mionodeseltype) = if v.value == 0 "Mosek.MSK_MIO_NODE_SELECTION_FREE"
  elseif v.value == 1 "Mosek.MSK_MIO_NODE_SELECTION_FIRST"
  elseif v.value == 2 "Mosek.MSK_MIO_NODE_SELECTION_BEST"
  elseif v.value == 3 "Mosek.MSK_MIO_NODE_SELECTION_PSEUDO"
  else "Mosek.Mionodeseltype(?)"
  end
const Mionodeseltype_members = Mionodeseltype[
    MSK_MIO_NODE_SELECTION_FREE,
    MSK_MIO_NODE_SELECTION_FIRST,
    MSK_MIO_NODE_SELECTION_BEST,
    MSK_MIO_NODE_SELECTION_PSEUDO ]
members(::Type{Mionodeseltype}) = Mionodeseltype_members
Base.length(::Type{Mionodeseltype}) = 4
Base.convert(::Type{Int},x::Mionodeseltype) = Int(x.value)
"""
    Miovarseltype

Mixed-integer variable selection types

* `MSK_MIO_VAR_SELECTION_FREE`. The optimizer decides the variable selection strategy.
* `MSK_MIO_VAR_SELECTION_PSEUDOCOST`. The optimizer employs pseudocost variable selection.
* `MSK_MIO_VAR_SELECTION_STRONG`. The optimizer employs strong branching variable selection.
"""
struct Miovarseltype <: MosekEnum
  value :: Int32
end # miovarseltype

"The optimizer decides the variable selection strategy."
const MSK_MIO_VAR_SELECTION_FREE = Miovarseltype(0)

"The optimizer employs pseudocost variable selection."
const MSK_MIO_VAR_SELECTION_PSEUDOCOST = Miovarseltype(1)

"The optimizer employs strong branching variable selection."
const MSK_MIO_VAR_SELECTION_STRONG = Miovarseltype(2)
tostr(v::Miovarseltype) = if v.value == 0 "Mosek.MSK_MIO_VAR_SELECTION_FREE"
  elseif v.value == 1 "Mosek.MSK_MIO_VAR_SELECTION_PSEUDOCOST"
  elseif v.value == 2 "Mosek.MSK_MIO_VAR_SELECTION_STRONG"
  else "Mosek.Miovarseltype(?)"
  end
const Miovarseltype_members = Miovarseltype[
    MSK_MIO_VAR_SELECTION_FREE,
    MSK_MIO_VAR_SELECTION_PSEUDOCOST,
    MSK_MIO_VAR_SELECTION_STRONG ]
members(::Type{Miovarseltype}) = Miovarseltype_members
Base.length(::Type{Miovarseltype}) = 3
Base.convert(::Type{Int},x::Miovarseltype) = Int(x.value)
"""
    Mpsformat

MPS file format type

* `MSK_MPS_FORMAT_STRICT`. It is assumed that the input file satisfies the MPS format strictly.
* `MSK_MPS_FORMAT_RELAXED`. It is assumed that the input file satisfies a slightly relaxed version of the MPS format.
* `MSK_MPS_FORMAT_FREE`. It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free.
* `MSK_MPS_FORMAT_CPLEX`. The CPLEX compatible version of the MPS format is employed.
"""
struct Mpsformat <: MosekEnum
  value :: Int32
end # mpsformat

"It is assumed that the input file satisfies the MPS format strictly."
const MSK_MPS_FORMAT_STRICT = Mpsformat(0)

"It is assumed that the input file satisfies a slightly relaxed version of the MPS format."
const MSK_MPS_FORMAT_RELAXED = Mpsformat(1)

"It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free."
const MSK_MPS_FORMAT_FREE = Mpsformat(2)

"The CPLEX compatible version of the MPS format is employed."
const MSK_MPS_FORMAT_CPLEX = Mpsformat(3)
tostr(v::Mpsformat) = if v.value == 0 "Mosek.MSK_MPS_FORMAT_STRICT"
  elseif v.value == 1 "Mosek.MSK_MPS_FORMAT_RELAXED"
  elseif v.value == 2 "Mosek.MSK_MPS_FORMAT_FREE"
  elseif v.value == 3 "Mosek.MSK_MPS_FORMAT_CPLEX"
  else "Mosek.Mpsformat(?)"
  end
const Mpsformat_members = Mpsformat[
    MSK_MPS_FORMAT_STRICT,
    MSK_MPS_FORMAT_RELAXED,
    MSK_MPS_FORMAT_FREE,
    MSK_MPS_FORMAT_CPLEX ]
members(::Type{Mpsformat}) = Mpsformat_members
Base.length(::Type{Mpsformat}) = 4
Base.convert(::Type{Int},x::Mpsformat) = Int(x.value)
"""
    Objsense

Objective sense types

* `MSK_OBJECTIVE_SENSE_MINIMIZE`. The problem should be minimized.
* `MSK_OBJECTIVE_SENSE_MAXIMIZE`. The problem should be maximized.
"""
struct Objsense <: MosekEnum
  value :: Int32
end # objsense

"The problem should be minimized."
const MSK_OBJECTIVE_SENSE_MINIMIZE = Objsense(0)

"The problem should be maximized."
const MSK_OBJECTIVE_SENSE_MAXIMIZE = Objsense(1)
tostr(v::Objsense) = if v.value == 0 "Mosek.MSK_OBJECTIVE_SENSE_MINIMIZE"
  elseif v.value == 1 "Mosek.MSK_OBJECTIVE_SENSE_MAXIMIZE"
  else "Mosek.Objsense(?)"
  end
const Objsense_members = Objsense[
    MSK_OBJECTIVE_SENSE_MINIMIZE,
    MSK_OBJECTIVE_SENSE_MAXIMIZE ]
members(::Type{Objsense}) = Objsense_members
Base.length(::Type{Objsense}) = 2
Base.convert(::Type{Int},x::Objsense) = Int(x.value)
"""
    Onoffkey

On/off

* `MSK_OFF`. Switch the option off.
* `MSK_ON`. Switch the option on.
"""
struct Onoffkey <: MosekEnum
  value :: Int32
end # onoffkey

"Switch the option off."
const MSK_OFF = Onoffkey(0)

"Switch the option on."
const MSK_ON = Onoffkey(1)
tostr(v::Onoffkey) = if v.value == 0 "Mosek.MSK_OFF"
  elseif v.value == 1 "Mosek.MSK_ON"
  else "Mosek.Onoffkey(?)"
  end
const Onoffkey_members = Onoffkey[
    MSK_OFF,
    MSK_ON ]
members(::Type{Onoffkey}) = Onoffkey_members
Base.length(::Type{Onoffkey}) = 2
Base.convert(::Type{Int},x::Onoffkey) = Int(x.value)
"""
    Optimizertype

Optimizer types

* `MSK_OPTIMIZER_CONIC`. The optimizer for problems having conic constraints.
* `MSK_OPTIMIZER_DUAL_SIMPLEX`. The dual simplex optimizer is used.
* `MSK_OPTIMIZER_FREE`. The optimizer is chosen automatically.
* `MSK_OPTIMIZER_FREE_SIMPLEX`. One of the simplex optimizers is used.
* `MSK_OPTIMIZER_INTPNT`. The interior-point optimizer is used.
* `MSK_OPTIMIZER_MIXED_INT`. The mixed-integer optimizer.
* `MSK_OPTIMIZER_PRIMAL_SIMPLEX`. The primal simplex optimizer is used.
"""
struct Optimizertype <: MosekEnum
  value :: Int32
end # optimizertype

"The optimizer for problems having conic constraints."
const MSK_OPTIMIZER_CONIC = Optimizertype(0)

"The dual simplex optimizer is used."
const MSK_OPTIMIZER_DUAL_SIMPLEX = Optimizertype(1)

"The optimizer is chosen automatically."
const MSK_OPTIMIZER_FREE = Optimizertype(2)

"One of the simplex optimizers is used."
const MSK_OPTIMIZER_FREE_SIMPLEX = Optimizertype(3)

"The interior-point optimizer is used."
const MSK_OPTIMIZER_INTPNT = Optimizertype(4)

"The mixed-integer optimizer."
const MSK_OPTIMIZER_MIXED_INT = Optimizertype(5)

"The primal simplex optimizer is used."
const MSK_OPTIMIZER_PRIMAL_SIMPLEX = Optimizertype(6)
tostr(v::Optimizertype) = if v.value == 0 "Mosek.MSK_OPTIMIZER_CONIC"
  elseif v.value == 1 "Mosek.MSK_OPTIMIZER_DUAL_SIMPLEX"
  elseif v.value == 2 "Mosek.MSK_OPTIMIZER_FREE"
  elseif v.value == 3 "Mosek.MSK_OPTIMIZER_FREE_SIMPLEX"
  elseif v.value == 4 "Mosek.MSK_OPTIMIZER_INTPNT"
  elseif v.value == 5 "Mosek.MSK_OPTIMIZER_MIXED_INT"
  elseif v.value == 6 "Mosek.MSK_OPTIMIZER_PRIMAL_SIMPLEX"
  else "Mosek.Optimizertype(?)"
  end
const Optimizertype_members = Optimizertype[
    MSK_OPTIMIZER_CONIC,
    MSK_OPTIMIZER_DUAL_SIMPLEX,
    MSK_OPTIMIZER_FREE,
    MSK_OPTIMIZER_FREE_SIMPLEX,
    MSK_OPTIMIZER_INTPNT,
    MSK_OPTIMIZER_MIXED_INT,
    MSK_OPTIMIZER_PRIMAL_SIMPLEX ]
members(::Type{Optimizertype}) = Optimizertype_members
Base.length(::Type{Optimizertype}) = 7
Base.convert(::Type{Int},x::Optimizertype) = Int(x.value)
"""
    Orderingtype

Ordering strategies

* `MSK_ORDER_METHOD_FREE`. The ordering method is chosen automatically.
* `MSK_ORDER_METHOD_APPMINLOC`. Approximate minimum local fill-in ordering is employed.
* `MSK_ORDER_METHOD_EXPERIMENTAL`. This option should not be used.
* `MSK_ORDER_METHOD_TRY_GRAPHPAR`. Always try the graph partitioning based ordering.
* `MSK_ORDER_METHOD_FORCE_GRAPHPAR`. Always use the graph partitioning based ordering even if it is worse than the approximate minimum local fill ordering.
* `MSK_ORDER_METHOD_NONE`. No ordering is used. Note using this value almost always leads to a significantly slow down.
"""
struct Orderingtype <: MosekEnum
  value :: Int32
end # orderingtype

"The ordering method is chosen automatically."
const MSK_ORDER_METHOD_FREE = Orderingtype(0)

"Approximate minimum local fill-in ordering is employed."
const MSK_ORDER_METHOD_APPMINLOC = Orderingtype(1)

"This option should not be used."
const MSK_ORDER_METHOD_EXPERIMENTAL = Orderingtype(2)

"Always try the graph partitioning based ordering."
const MSK_ORDER_METHOD_TRY_GRAPHPAR = Orderingtype(3)

"Always use the graph partitioning based ordering even if it is worse than the approximate minimum local fill ordering."
const MSK_ORDER_METHOD_FORCE_GRAPHPAR = Orderingtype(4)

"No ordering is used. Note using this value almost always leads to a significantly slow down."
const MSK_ORDER_METHOD_NONE = Orderingtype(5)
tostr(v::Orderingtype) = if v.value == 0 "Mosek.MSK_ORDER_METHOD_FREE"
  elseif v.value == 1 "Mosek.MSK_ORDER_METHOD_APPMINLOC"
  elseif v.value == 2 "Mosek.MSK_ORDER_METHOD_EXPERIMENTAL"
  elseif v.value == 3 "Mosek.MSK_ORDER_METHOD_TRY_GRAPHPAR"
  elseif v.value == 4 "Mosek.MSK_ORDER_METHOD_FORCE_GRAPHPAR"
  elseif v.value == 5 "Mosek.MSK_ORDER_METHOD_NONE"
  else "Mosek.Orderingtype(?)"
  end
const Orderingtype_members = Orderingtype[
    MSK_ORDER_METHOD_FREE,
    MSK_ORDER_METHOD_APPMINLOC,
    MSK_ORDER_METHOD_EXPERIMENTAL,
    MSK_ORDER_METHOD_TRY_GRAPHPAR,
    MSK_ORDER_METHOD_FORCE_GRAPHPAR,
    MSK_ORDER_METHOD_NONE ]
members(::Type{Orderingtype}) = Orderingtype_members
Base.length(::Type{Orderingtype}) = 6
Base.convert(::Type{Int},x::Orderingtype) = Int(x.value)
"""
    Presolvemode

Presolve method.

* `MSK_PRESOLVE_MODE_OFF`. The problem is not presolved before it is optimized.
* `MSK_PRESOLVE_MODE_ON`. The problem is presolved before it is optimized.
* `MSK_PRESOLVE_MODE_FREE`. It is decided automatically whether to presolve before the problem is optimized.
"""
struct Presolvemode <: MosekEnum
  value :: Int32
end # presolvemode

"The problem is not presolved before it is optimized."
const MSK_PRESOLVE_MODE_OFF = Presolvemode(0)

"The problem is presolved before it is optimized."
const MSK_PRESOLVE_MODE_ON = Presolvemode(1)

"It is decided automatically whether to presolve before the problem is optimized."
const MSK_PRESOLVE_MODE_FREE = Presolvemode(2)
tostr(v::Presolvemode) = if v.value == 0 "Mosek.MSK_PRESOLVE_MODE_OFF"
  elseif v.value == 1 "Mosek.MSK_PRESOLVE_MODE_ON"
  elseif v.value == 2 "Mosek.MSK_PRESOLVE_MODE_FREE"
  else "Mosek.Presolvemode(?)"
  end
const Presolvemode_members = Presolvemode[
    MSK_PRESOLVE_MODE_OFF,
    MSK_PRESOLVE_MODE_ON,
    MSK_PRESOLVE_MODE_FREE ]
members(::Type{Presolvemode}) = Presolvemode_members
Base.length(::Type{Presolvemode}) = 3
Base.convert(::Type{Int},x::Presolvemode) = Int(x.value)
"""
    Parametertype

Parameter type

* `MSK_PAR_INVALID_TYPE`. Not a valid parameter.
* `MSK_PAR_DOU_TYPE`. Is a double parameter.
* `MSK_PAR_INT_TYPE`. Is an integer parameter.
* `MSK_PAR_STR_TYPE`. Is a string parameter.
"""
struct Parametertype <: MosekEnum
  value :: Int32
end # parametertype

"Not a valid parameter."
const MSK_PAR_INVALID_TYPE = Parametertype(0)

"Is a double parameter."
const MSK_PAR_DOU_TYPE = Parametertype(1)

"Is an integer parameter."
const MSK_PAR_INT_TYPE = Parametertype(2)

"Is a string parameter."
const MSK_PAR_STR_TYPE = Parametertype(3)
tostr(v::Parametertype) = if v.value == 0 "Mosek.MSK_PAR_INVALID_TYPE"
  elseif v.value == 1 "Mosek.MSK_PAR_DOU_TYPE"
  elseif v.value == 2 "Mosek.MSK_PAR_INT_TYPE"
  elseif v.value == 3 "Mosek.MSK_PAR_STR_TYPE"
  else "Mosek.Parametertype(?)"
  end
const Parametertype_members = Parametertype[
    MSK_PAR_INVALID_TYPE,
    MSK_PAR_DOU_TYPE,
    MSK_PAR_INT_TYPE,
    MSK_PAR_STR_TYPE ]
members(::Type{Parametertype}) = Parametertype_members
Base.length(::Type{Parametertype}) = 4
Base.convert(::Type{Int},x::Parametertype) = Int(x.value)
"""
    Problemitem

Problem data items

* `MSK_PI_VAR`. Item is a variable.
* `MSK_PI_CON`. Item is a constraint.
* `MSK_PI_CONE`. Item is a cone.
"""
struct Problemitem <: MosekEnum
  value :: Int32
end # problemitem

"Item is a variable."
const MSK_PI_VAR = Problemitem(0)

"Item is a constraint."
const MSK_PI_CON = Problemitem(1)

"Item is a cone."
const MSK_PI_CONE = Problemitem(2)
tostr(v::Problemitem) = if v.value == 0 "Mosek.MSK_PI_VAR"
  elseif v.value == 1 "Mosek.MSK_PI_CON"
  elseif v.value == 2 "Mosek.MSK_PI_CONE"
  else "Mosek.Problemitem(?)"
  end
const Problemitem_members = Problemitem[
    MSK_PI_VAR,
    MSK_PI_CON,
    MSK_PI_CONE ]
members(::Type{Problemitem}) = Problemitem_members
Base.length(::Type{Problemitem}) = 3
Base.convert(::Type{Int},x::Problemitem) = Int(x.value)
"""
    Problemtype

Problem types

* `MSK_PROBTYPE_LO`. The problem is a linear optimization problem.
* `MSK_PROBTYPE_QO`. The problem is a quadratic optimization problem.
* `MSK_PROBTYPE_QCQO`. The problem is a quadratically constrained optimization problem.
* `MSK_PROBTYPE_CONIC`. A conic optimization.
* `MSK_PROBTYPE_MIXED`. General nonlinear constraints and conic constraints. This combination can not be solved by MOSEK.
"""
struct Problemtype <: MosekEnum
  value :: Int32
end # problemtype

"The problem is a linear optimization problem."
const MSK_PROBTYPE_LO = Problemtype(0)

"The problem is a quadratic optimization problem."
const MSK_PROBTYPE_QO = Problemtype(1)

"The problem is a quadratically constrained optimization problem."
const MSK_PROBTYPE_QCQO = Problemtype(2)

"A conic optimization."
const MSK_PROBTYPE_CONIC = Problemtype(3)

"General nonlinear constraints and conic constraints. This combination can not be solved by MOSEK."
const MSK_PROBTYPE_MIXED = Problemtype(4)
tostr(v::Problemtype) = if v.value == 0 "Mosek.MSK_PROBTYPE_LO"
  elseif v.value == 1 "Mosek.MSK_PROBTYPE_QO"
  elseif v.value == 2 "Mosek.MSK_PROBTYPE_QCQO"
  elseif v.value == 3 "Mosek.MSK_PROBTYPE_CONIC"
  elseif v.value == 4 "Mosek.MSK_PROBTYPE_MIXED"
  else "Mosek.Problemtype(?)"
  end
const Problemtype_members = Problemtype[
    MSK_PROBTYPE_LO,
    MSK_PROBTYPE_QO,
    MSK_PROBTYPE_QCQO,
    MSK_PROBTYPE_CONIC,
    MSK_PROBTYPE_MIXED ]
members(::Type{Problemtype}) = Problemtype_members
Base.length(::Type{Problemtype}) = 5
Base.convert(::Type{Int},x::Problemtype) = Int(x.value)
"""
    Prosta

Problem status keys

* `MSK_PRO_STA_UNKNOWN`. Unknown problem status.
* `MSK_PRO_STA_PRIM_AND_DUAL_FEAS`. The problem is primal and dual feasible.
* `MSK_PRO_STA_PRIM_FEAS`. The problem is primal feasible.
* `MSK_PRO_STA_DUAL_FEAS`. The problem is dual feasible.
* `MSK_PRO_STA_PRIM_INFEAS`. The problem is primal infeasible.
* `MSK_PRO_STA_DUAL_INFEAS`. The problem is dual infeasible.
* `MSK_PRO_STA_PRIM_AND_DUAL_INFEAS`. The problem is primal and dual infeasible.
* `MSK_PRO_STA_ILL_POSED`. The problem is ill-posed. For example, it may be primal and dual feasible but have a positive duality gap.
* `MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED`. The problem is either primal infeasible or unbounded. This may occur for mixed-integer problems.
"""
struct Prosta <: MosekEnum
  value :: Int32
end # prosta

"Unknown problem status."
const MSK_PRO_STA_UNKNOWN = Prosta(0)

"The problem is primal and dual feasible."
const MSK_PRO_STA_PRIM_AND_DUAL_FEAS = Prosta(1)

"The problem is primal feasible."
const MSK_PRO_STA_PRIM_FEAS = Prosta(2)

"The problem is dual feasible."
const MSK_PRO_STA_DUAL_FEAS = Prosta(3)

"The problem is primal infeasible."
const MSK_PRO_STA_PRIM_INFEAS = Prosta(4)

"The problem is dual infeasible."
const MSK_PRO_STA_DUAL_INFEAS = Prosta(5)

"The problem is primal and dual infeasible."
const MSK_PRO_STA_PRIM_AND_DUAL_INFEAS = Prosta(6)

"The problem is ill-posed. For example, it may be primal and dual feasible but have a positive duality gap."
const MSK_PRO_STA_ILL_POSED = Prosta(7)

"The problem is either primal infeasible or unbounded. This may occur for mixed-integer problems."
const MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED = Prosta(8)
tostr(v::Prosta) = if v.value == 0 "Mosek.MSK_PRO_STA_UNKNOWN"
  elseif v.value == 1 "Mosek.MSK_PRO_STA_PRIM_AND_DUAL_FEAS"
  elseif v.value == 2 "Mosek.MSK_PRO_STA_PRIM_FEAS"
  elseif v.value == 3 "Mosek.MSK_PRO_STA_DUAL_FEAS"
  elseif v.value == 4 "Mosek.MSK_PRO_STA_PRIM_INFEAS"
  elseif v.value == 5 "Mosek.MSK_PRO_STA_DUAL_INFEAS"
  elseif v.value == 6 "Mosek.MSK_PRO_STA_PRIM_AND_DUAL_INFEAS"
  elseif v.value == 7 "Mosek.MSK_PRO_STA_ILL_POSED"
  elseif v.value == 8 "Mosek.MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED"
  else "Mosek.Prosta(?)"
  end
const Prosta_members = Prosta[
    MSK_PRO_STA_UNKNOWN,
    MSK_PRO_STA_PRIM_AND_DUAL_FEAS,
    MSK_PRO_STA_PRIM_FEAS,
    MSK_PRO_STA_DUAL_FEAS,
    MSK_PRO_STA_PRIM_INFEAS,
    MSK_PRO_STA_DUAL_INFEAS,
    MSK_PRO_STA_PRIM_AND_DUAL_INFEAS,
    MSK_PRO_STA_ILL_POSED,
    MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED ]
members(::Type{Prosta}) = Prosta_members
Base.length(::Type{Prosta}) = 9
Base.convert(::Type{Int},x::Prosta) = Int(x.value)
"""
    Xmlwriteroutputtype

XML writer output mode

* `MSK_WRITE_XML_MODE_ROW`. Write in row order.
* `MSK_WRITE_XML_MODE_COL`. Write in column order.
"""
struct Xmlwriteroutputtype <: MosekEnum
  value :: Int32
end # xmlwriteroutputtype

"Write in row order."
const MSK_WRITE_XML_MODE_ROW = Xmlwriteroutputtype(0)

"Write in column order."
const MSK_WRITE_XML_MODE_COL = Xmlwriteroutputtype(1)
tostr(v::Xmlwriteroutputtype) = if v.value == 0 "Mosek.MSK_WRITE_XML_MODE_ROW"
  elseif v.value == 1 "Mosek.MSK_WRITE_XML_MODE_COL"
  else "Mosek.Xmlwriteroutputtype(?)"
  end
const Xmlwriteroutputtype_members = Xmlwriteroutputtype[
    MSK_WRITE_XML_MODE_ROW,
    MSK_WRITE_XML_MODE_COL ]
members(::Type{Xmlwriteroutputtype}) = Xmlwriteroutputtype_members
Base.length(::Type{Xmlwriteroutputtype}) = 2
Base.convert(::Type{Int},x::Xmlwriteroutputtype) = Int(x.value)
"""
    Rescode

The enumeration type containing all response codes.

* `MSK_RES_OK`. No error occurred.
* `MSK_RES_WRN_OPEN_PARAM_FILE`. The parameter file could not be opened.
* `MSK_RES_WRN_LARGE_BOUND`. A numerically large bound value is specified.
* `MSK_RES_WRN_LARGE_LO_BOUND`. A numerically large lower bound value is specified.
* `MSK_RES_WRN_LARGE_UP_BOUND`. A numerically large upper bound value is specified.
* `MSK_RES_WRN_LARGE_CON_FX`. A equality constraint is fixed to numerically large value.
* `MSK_RES_WRN_LARGE_CJ`. A numerically large value is specified for one element in c.
* `MSK_RES_WRN_LARGE_AIJ`. A numerically large value is specified for an element in A.
* `MSK_RES_WRN_ZERO_AIJ`. One or more zero elements are specified in A.
* `MSK_RES_WRN_NAME_MAX_LEN`. A name is longer than the buffer that is supposed to hold it.
* `MSK_RES_WRN_SPAR_MAX_LEN`. A value for a string parameter is longer than the buffer that is supposed to hold it.
* `MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR`. An RHS vector is split into several nonadjacent parts.
* `MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR`. A RANGE vector is split into several nonadjacent parts in an MPS file.
* `MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR`. A BOUNDS vector is split into several nonadjacent parts in an MPS file.
* `MSK_RES_WRN_LP_OLD_QUAD_FORMAT`. Missing '/2' after quadratic expressions in bound or objective.
* `MSK_RES_WRN_LP_DROP_VARIABLE`. Ignore a variable because the variable was not previously defined.
* `MSK_RES_WRN_NZ_IN_UPR_TRI`. Non-zero elements specified in the upper triangle of a matrix were ignored.
* `MSK_RES_WRN_DROPPED_NZ_QOBJ`. One or more non-zero elements were dropped in the Q matrix in the objective.
* `MSK_RES_WRN_IGNORE_INTEGER`. Ignored integer constraints.
* `MSK_RES_WRN_NO_GLOBAL_OPTIMIZER`. No global optimizer is available.
* `MSK_RES_WRN_MIO_INFEASIBLE_FINAL`. The final mixed-integer problem with all the integer variables fixed at their optimal values is infeasible.
* `MSK_RES_WRN_SOL_FILTER`. Invalid solution filter is specified.
* `MSK_RES_WRN_UNDEF_SOL_FILE_NAME`. Undefined name occurred in a solution.
* `MSK_RES_WRN_SOL_FILE_IGNORED_CON`. One or more lines in the constraint section were ignored when reading a solution file.
* `MSK_RES_WRN_SOL_FILE_IGNORED_VAR`. One or more lines in the variable section were ignored when reading a solution file.
* `MSK_RES_WRN_TOO_FEW_BASIS_VARS`. An incomplete basis is specified.
* `MSK_RES_WRN_TOO_MANY_BASIS_VARS`. A basis with too many variables is specified.
* `MSK_RES_WRN_LICENSE_EXPIRE`. The license expires.
* `MSK_RES_WRN_LICENSE_SERVER`. The license server is not responding.
* `MSK_RES_WRN_EMPTY_NAME`. A variable or constraint name is empty. The output file may be invalid.
* `MSK_RES_WRN_USING_GENERIC_NAMES`. Generic names are used because a name is invalid for requested format.
* `MSK_RES_WRN_INVALID_MPS_NAME`. A name e.g. a row name is not a valid MPS name.
* `MSK_RES_WRN_INVALID_MPS_OBJ_NAME`. The objective name is not a valid MPS name.
* `MSK_RES_WRN_LICENSE_FEATURE_EXPIRE`. The license expires.
* `MSK_RES_WRN_PARAM_NAME_DOU`. Parameter name not recognized.
* `MSK_RES_WRN_PARAM_NAME_INT`. Parameter name not recognized.
* `MSK_RES_WRN_PARAM_NAME_STR`. Parameter name not recognized.
* `MSK_RES_WRN_PARAM_STR_VALUE`. A parameter value is not correct.
* `MSK_RES_WRN_PARAM_IGNORED_CMIO`. A parameter was ignored by the conic mixed integer optimizer.
* `MSK_RES_WRN_ZEROS_IN_SPARSE_ROW`. One or more (near) zero elements are specified in a sparse row of a matrix.
* `MSK_RES_WRN_ZEROS_IN_SPARSE_COL`. One or more (near) zero elements are specified in a sparse column of a matrix.
* `MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK`. The linear dependency check(s) is incomplete.
* `MSK_RES_WRN_ELIMINATOR_SPACE`. The eliminator is skipped at least once due to lack of space.
* `MSK_RES_WRN_PRESOLVE_OUTOFSPACE`. The presolve is incomplete due to lack of space.
* `MSK_RES_WRN_PRESOLVE_PRIMAL_PERTUBATIONS`. The presolve perturbed the bounds of the primal problem. This is an indication that the problem is nearly infeasible.
* `MSK_RES_WRN_WRITE_CHANGED_NAMES`. Some names were changed because they were invalid for the output file format.
* `MSK_RES_WRN_WRITE_DISCARDED_CFIX`. The fixed objective term was discarded in the output file.
* `MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES`. Two constraint names are identical.
* `MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES`. Two variable names are identical.
* `MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES`. Two barvariable names are identical.
* `MSK_RES_WRN_DUPLICATE_CONE_NAMES`. Two cone names are identical.
* `MSK_RES_WRN_WRITE_LP_INVALID_VAR_NAMES`. LP file will be written with generic variable names.
* `MSK_RES_WRN_WRITE_LP_DUPLICATE_VAR_NAMES`. LP file will be written with generic variable names.
* `MSK_RES_WRN_WRITE_LP_INVALID_CON_NAMES`. LP file will be written with generic constraint names.
* `MSK_RES_WRN_WRITE_LP_DUPLICATE_CON_NAMES`. LP file will be written with generic constraint names.
* `MSK_RES_WRN_ANA_LARGE_BOUNDS`. Warn against very large bounds.
* `MSK_RES_WRN_ANA_C_ZERO`. Warn against all objective coefficients being zero.
* `MSK_RES_WRN_ANA_EMPTY_COLS`. Warn against empty columns.
* `MSK_RES_WRN_ANA_CLOSE_BOUNDS`. Warn against close bounds.
* `MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS`. Warn against almost integral bounds.
* `MSK_RES_WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES`. An infeasibility report is not available when the problem contains matrix variables.
* `MSK_RES_WRN_NO_DUALIZER`. No automatic dualizer is available for the specified problem.
* `MSK_RES_WRN_SYM_MAT_LARGE`. A numerically large value is specified for an element in E.
* `MSK_RES_WRN_MODIFIED_DOUBLE_PARAMETER`. A double parameter related to solver tolerances has a non-default value.
* `MSK_RES_WRN_LARGE_FIJ`. A numerically large value is specified for an element in F.
* `MSK_RES_ERR_LICENSE`. Invalid license.
* `MSK_RES_ERR_LICENSE_EXPIRED`. The license has expired.
* `MSK_RES_ERR_LICENSE_VERSION`. Invalid license version.
* `MSK_RES_ERR_LICENSE_OLD_SERVER_VERSION`. The license server version is too old.
* `MSK_RES_ERR_SIZE_LICENSE`. The problem is bigger than the license.
* `MSK_RES_ERR_PROB_LICENSE`. The software is not licensed to solve the problem.
* `MSK_RES_ERR_FILE_LICENSE`. Invalid license file.
* `MSK_RES_ERR_MISSING_LICENSE_FILE`. A license cannot be located.
* `MSK_RES_ERR_SIZE_LICENSE_CON`. The problem has too many constraints.
* `MSK_RES_ERR_SIZE_LICENSE_VAR`. The problem has too many variables.
* `MSK_RES_ERR_SIZE_LICENSE_INTVAR`. The problem contains too many integer variables.
* `MSK_RES_ERR_OPTIMIZER_LICENSE`. The optimizer required is not licensed.
* `MSK_RES_ERR_FLEXLM`. The license manager reported an error.
* `MSK_RES_ERR_LICENSE_SERVER`. The license server is not responding.
* `MSK_RES_ERR_LICENSE_MAX`. Maximum number of licenses is reached.
* `MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON`. The MOSEKLM license manager daemon is not up and running.
* `MSK_RES_ERR_LICENSE_FEATURE`. A requested feature is not available in the license file(s).
* `MSK_RES_ERR_PLATFORM_NOT_LICENSED`. A requested license feature is not available for the required platform.
* `MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE`. The license system cannot allocate the memory required.
* `MSK_RES_ERR_LICENSE_CANNOT_CONNECT`. MOSEK cannot connect to the license server.
* `MSK_RES_ERR_LICENSE_INVALID_HOSTID`. The host ID specified in the license file does not match the host ID of the computer.
* `MSK_RES_ERR_LICENSE_SERVER_VERSION`. The version specified in the checkout request is greater than the highest version number the daemon supports.
* `MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT`. The license server does not support the requested feature.
* `MSK_RES_ERR_LICENSE_NO_SERVER_LINE`. No SERVER lines in license file.
* `MSK_RES_ERR_OLDER_DLL`. The dynamic link library is older than the specified version.
* `MSK_RES_ERR_NEWER_DLL`. The dynamic link library is newer than the specified version.
* `MSK_RES_ERR_LINK_FILE_DLL`. A file cannot be linked to a stream in the DLL version.
* `MSK_RES_ERR_THREAD_MUTEX_INIT`. Could not initialize a mutex.
* `MSK_RES_ERR_THREAD_MUTEX_LOCK`. Could not lock a mutex.
* `MSK_RES_ERR_THREAD_MUTEX_UNLOCK`. Could not unlock a mutex.
* `MSK_RES_ERR_THREAD_CREATE`. Could not create a thread.
* `MSK_RES_ERR_THREAD_COND_INIT`. Could not initialize a condition.
* `MSK_RES_ERR_UNKNOWN`. Unknown error.
* `MSK_RES_ERR_SPACE`. Out of space.
* `MSK_RES_ERR_FILE_OPEN`. An error occurred while opening a file.
* `MSK_RES_ERR_FILE_READ`. An error occurred while reading file.
* `MSK_RES_ERR_FILE_WRITE`. An error occurred while writing to a file.
* `MSK_RES_ERR_DATA_FILE_EXT`. The data file format cannot be determined from the file name.
* `MSK_RES_ERR_INVALID_FILE_NAME`. An invalid file name has been specified.
* `MSK_RES_ERR_INVALID_SOL_FILE_NAME`. An invalid file name has been specified.
* `MSK_RES_ERR_END_OF_FILE`. End of file reached.
* `MSK_RES_ERR_NULL_ENV`. env is a null pointer.
* `MSK_RES_ERR_NULL_TASK`. task is a null pointer.
* `MSK_RES_ERR_INVALID_STREAM`. An invalid stream is referenced.
* `MSK_RES_ERR_NO_INIT_ENV`. Environment is not initialized.
* `MSK_RES_ERR_INVALID_TASK`. The task is invalid.
* `MSK_RES_ERR_NULL_POINTER`. An argument to a function is unexpectedly a null pointer.
* `MSK_RES_ERR_LIVING_TASKS`. Not all tasks associated with the environment have been deleted.
* `MSK_RES_ERR_READ_GZIP`. Error encountered in GZIP stream.
* `MSK_RES_ERR_READ_ZSTD`. Error encountered in ZSTD stream.
* `MSK_RES_ERR_BLANK_NAME`. An all blank name has been specified.
* `MSK_RES_ERR_DUP_NAME`. Duplicate names specified.
* `MSK_RES_ERR_FORMAT_STRING`. The name format string is invalid.
* `MSK_RES_ERR_SPARSITY_SPECIFICATION`. The sparsity included an index that was out of bounds of the shape.
* `MSK_RES_ERR_MISMATCHING_DIMENSION`. Mismatching dimensions specified in arguments
* `MSK_RES_ERR_INVALID_OBJ_NAME`. An invalid objective name is specified.
* `MSK_RES_ERR_INVALID_CON_NAME`. An invalid constraint name is used.
* `MSK_RES_ERR_INVALID_VAR_NAME`. An invalid variable name is used.
* `MSK_RES_ERR_INVALID_CONE_NAME`. An invalid cone name is used.
* `MSK_RES_ERR_INVALID_BARVAR_NAME`. An invalid symmetric matrix variable name is used.
* `MSK_RES_ERR_SPACE_LEAKING`. MOSEK is leaking memory.
* `MSK_RES_ERR_SPACE_NO_INFO`. No available information about the space usage.
* `MSK_RES_ERR_DIMENSION_SPECIFICATION`. Invalid dimension specification
* `MSK_RES_ERR_AXIS_NAME_SPECIFICATION`. Invalid axis names specification
* `MSK_RES_ERR_READ_FORMAT`. The specified format cannot be read.
* `MSK_RES_ERR_MPS_FILE`. An error occurred while reading an MPS file.
* `MSK_RES_ERR_MPS_INV_FIELD`. Invalid field occurred while reading an MPS file.
* `MSK_RES_ERR_MPS_INV_MARKER`. An invalid marker has been specified in the MPS file.
* `MSK_RES_ERR_MPS_NULL_CON_NAME`. An empty constraint name is used in an MPS file.
* `MSK_RES_ERR_MPS_NULL_VAR_NAME`. An empty variable name is used in an MPS file.
* `MSK_RES_ERR_MPS_UNDEF_CON_NAME`. An undefined constraint name occurred in an MPS file.
* `MSK_RES_ERR_MPS_UNDEF_VAR_NAME`. An undefined variable name occurred in an MPS file.
* `MSK_RES_ERR_MPS_INVALID_CON_KEY`. An invalid constraint key occurred in an MPS file.
* `MSK_RES_ERR_MPS_INVALID_BOUND_KEY`. An invalid bound key occurred in an MPS file.
* `MSK_RES_ERR_MPS_INVALID_SEC_NAME`. An invalid section name occurred in an MPS file.
* `MSK_RES_ERR_MPS_NO_OBJECTIVE`. No objective is defined in an MPS file.
* `MSK_RES_ERR_MPS_SPLITTED_VAR`. The non-zero elements in A corresponding to a variable in an MPS file must be specified consecutively.
* `MSK_RES_ERR_MPS_MUL_CON_NAME`. A constraint name is specified multiple times in the ROWS section in an MPS file.
* `MSK_RES_ERR_MPS_MUL_QSEC`. Multiple QSECTIONs are specified for a constraint.
* `MSK_RES_ERR_MPS_MUL_QOBJ`. The Q term in the objective is specified multiple times.
* `MSK_RES_ERR_MPS_INV_SEC_ORDER`. The sections in an MPS file is not in the correct order.
* `MSK_RES_ERR_MPS_MUL_CSEC`. Multiple CSECTIONs are given the same name.
* `MSK_RES_ERR_MPS_CONE_TYPE`. Invalid cone type specified in a  CSECTION.
* `MSK_RES_ERR_MPS_CONE_OVERLAP`. A variable is specified to be a member of several cones.
* `MSK_RES_ERR_MPS_CONE_REPEAT`. A variable is repeated within the CSECTION.
* `MSK_RES_ERR_MPS_NON_SYMMETRIC_Q`. A non symmetric matrix has been speciefied.
* `MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT`. Duplicate elements is specified in a Q matrix.
* `MSK_RES_ERR_MPS_INVALID_OBJSENSE`. An invalid objective sense is specified.
* `MSK_RES_ERR_MPS_TAB_IN_FIELD2`. A tab char occurred in field 2.
* `MSK_RES_ERR_MPS_TAB_IN_FIELD3`. A tab char occurred in field 3.
* `MSK_RES_ERR_MPS_TAB_IN_FIELD5`. A tab char occurred in field 5.
* `MSK_RES_ERR_MPS_INVALID_OBJ_NAME`. An invalid objective name is specified.
* `MSK_RES_ERR_MPS_INVALID_KEY`. An invalid indicator key occurred in an MPS file.
* `MSK_RES_ERR_MPS_INVALID_INDICATOR_CONSTRAINT`. An invalid indicator constraint is used. It must not be a ranged constraint.
* `MSK_RES_ERR_MPS_INVALID_INDICATOR_VARIABLE`. An invalid indicator variable is specfied. It must be a binary variable.
* `MSK_RES_ERR_MPS_INVALID_INDICATOR_VALUE`. An invalid indicator value is specfied. It must be either 0 or 1.
* `MSK_RES_ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT`. A quadratic constraint can be be an indicator constraint.
* `MSK_RES_ERR_OPF_SYNTAX`. Syntax error in an OPF file
* `MSK_RES_ERR_OPF_PREMATURE_EOF`. Premature end of file in an OPF file.
* `MSK_RES_ERR_OPF_MISMATCHED_TAG`. Mismatched end-tag in OPF file
* `MSK_RES_ERR_OPF_DUPLICATE_BOUND`. Either upper or lower bound was specified twice in OPF file
* `MSK_RES_ERR_OPF_DUPLICATE_CONSTRAINT_NAME`. Duplicate constraint name in OPF File
* `MSK_RES_ERR_OPF_INVALID_CONE_TYPE`. Invalid cone type in OPF File
* `MSK_RES_ERR_OPF_INCORRECT_TAG_PARAM`. Invalid number of parameters in start-tag in OPF File
* `MSK_RES_ERR_OPF_INVALID_TAG`. Invalid start-tag in OPF File
* `MSK_RES_ERR_OPF_DUPLICATE_CONE_ENTRY`. Same variable appears in multiple cones in OPF File
* `MSK_RES_ERR_OPF_TOO_LARGE`. The problem is too large to be correctly loaded
* `MSK_RES_ERR_OPF_DUAL_INTEGER_SOLUTION`. Dual solution values are not allowed in OPF File
* `MSK_RES_ERR_LP_EMPTY`. The problem cannot be written to an LP formatted file.
* `MSK_RES_ERR_WRITE_MPS_INVALID_NAME`. An invalid name is created while writing an MPS file.
* `MSK_RES_ERR_LP_INVALID_VAR_NAME`. A variable name is invalid when used in an LP formatted file.
* `MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME`. Empty variable names cannot be written to OPF files.
* `MSK_RES_ERR_LP_FILE_FORMAT`. Syntax error in an LP file.
* `MSK_RES_ERR_LP_EXPECTED_NUMBER`. Expected a number in LP file
* `MSK_RES_ERR_READ_LP_MISSING_END_TAG`. Syntax error in LP fil. Possibly missing End tag.
* `MSK_RES_ERR_LP_INDICATOR_VAR`. An indicator variable was not declared binary
* `MSK_RES_ERR_LP_EXPECTED_OBJECTIVE`. Expected an objective section in LP file
* `MSK_RES_ERR_LP_EXPECTED_CONSTRAINT_RELATION`. Expected constraint relation
* `MSK_RES_ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND`. Constraint has ambiguous or invalid bound
* `MSK_RES_ERR_LP_DUPLICATE_SECTION`. Duplicate section
* `MSK_RES_ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED`. Duplicate section
* `MSK_RES_ERR_WRITING_FILE`. An error occurred while writing file
* `MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE`. An invalid name occurred in a solution file.
* `MSK_RES_ERR_JSON_SYNTAX`. Syntax error in an JSON data
* `MSK_RES_ERR_JSON_STRING`. Error in JSON string.
* `MSK_RES_ERR_JSON_NUMBER_OVERFLOW`. Invalid number entry - wrong type or value overflow.
* `MSK_RES_ERR_JSON_FORMAT`. Error in an JSON Task file
* `MSK_RES_ERR_JSON_DATA`. Inconsistent data in JSON Task file
* `MSK_RES_ERR_JSON_MISSING_DATA`. Missing data section in JSON task file.
* `MSK_RES_ERR_PTF_INCOMPATIBILITY`. Incompatible item
* `MSK_RES_ERR_PTF_UNDEFINED_ITEM`. Undefined symbol referenced
* `MSK_RES_ERR_PTF_INCONSISTENCY`. Inconsistent size of item
* `MSK_RES_ERR_PTF_FORMAT`. Syntax error in an PTF file
* `MSK_RES_ERR_ARGUMENT_LENNEQ`. Incorrect length of arguments.
* `MSK_RES_ERR_ARGUMENT_TYPE`. Incorrect argument type.
* `MSK_RES_ERR_NUM_ARGUMENTS`. Incorrect number of function arguments.
* `MSK_RES_ERR_IN_ARGUMENT`. A function argument is incorrect.
* `MSK_RES_ERR_ARGUMENT_DIMENSION`. A function argument is of incorrect dimension.
* `MSK_RES_ERR_SHAPE_IS_TOO_LARGE`. The size of the n-dimensional shape is too large.
* `MSK_RES_ERR_INDEX_IS_TOO_SMALL`. An index in an argument is too small.
* `MSK_RES_ERR_INDEX_IS_TOO_LARGE`. An index in an argument is too large.
* `MSK_RES_ERR_INDEX_IS_NOT_UNIQUE`. An index in an argument is is unique.
* `MSK_RES_ERR_PARAM_NAME`. A parameter name is not correct.
* `MSK_RES_ERR_PARAM_NAME_DOU`. A parameter name is not correct.
* `MSK_RES_ERR_PARAM_NAME_INT`. A parameter name is not correct.
* `MSK_RES_ERR_PARAM_NAME_STR`. A parameter name is not correct.
* `MSK_RES_ERR_PARAM_INDEX`. Parameter index is out of range.
* `MSK_RES_ERR_PARAM_IS_TOO_LARGE`. A parameter value is too large.
* `MSK_RES_ERR_PARAM_IS_TOO_SMALL`. A parameter value is too small.
* `MSK_RES_ERR_PARAM_VALUE_STR`. A parameter value string is incorrect.
* `MSK_RES_ERR_PARAM_TYPE`. A parameter type is invalid.
* `MSK_RES_ERR_INF_DOU_INDEX`. A double information index is out of range for the specified type.
* `MSK_RES_ERR_INF_INT_INDEX`. An integer information index is out of range for the specified type.
* `MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL`. An index in an array argument is too small.
* `MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE`. An index in an array argument is too large.
* `MSK_RES_ERR_INF_LINT_INDEX`. A long integer information index is out of range for the specified type.
* `MSK_RES_ERR_ARG_IS_TOO_SMALL`. The value of a argument is too small.
* `MSK_RES_ERR_ARG_IS_TOO_LARGE`. The value of a argument is too large.
* `MSK_RES_ERR_INVALID_WHICHSOL`. whichsol is invalid.
* `MSK_RES_ERR_INF_DOU_NAME`. A double information name is invalid.
* `MSK_RES_ERR_INF_INT_NAME`. An integer information name is invalid.
* `MSK_RES_ERR_INF_TYPE`. The information type is invalid.
* `MSK_RES_ERR_INF_LINT_NAME`. A long integer information name is invalid.
* `MSK_RES_ERR_INDEX`. An index is out of range.
* `MSK_RES_ERR_WHICHSOL`. The solution defined by whichsol does not exists.
* `MSK_RES_ERR_SOLITEM`. The solution number  solemn does not exists.
* `MSK_RES_ERR_WHICHITEM_NOT_ALLOWED`. whichitem is unacceptable.
* `MSK_RES_ERR_MAXNUMCON`. Invalid maximum number of constraints specified.
* `MSK_RES_ERR_MAXNUMVAR`. The maximum number of variables limit is too small.
* `MSK_RES_ERR_MAXNUMBARVAR`. The maximum number of semidefinite variables limit is too small.
* `MSK_RES_ERR_MAXNUMQNZ`. Too small maximum number of non-zeros for the Q matrices is specified.
* `MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ`. The maximum number of non-zeros specified is too small.
* `MSK_RES_ERR_INVALID_IDX`. A specified index is invalid.
* `MSK_RES_ERR_INVALID_MAX_NUM`. A specified index is invalid.
* `MSK_RES_ERR_UNALLOWED_WHICHSOL`. The value of whichsol is not allowed.
* `MSK_RES_ERR_NUMCONLIM`. Maximum number of constraints limit is exceeded.
* `MSK_RES_ERR_NUMVARLIM`. Maximum number of variables limit is exceeded.
* `MSK_RES_ERR_TOO_SMALL_MAXNUMANZ`. Too small maximum number of non-zeros in A specified.
* `MSK_RES_ERR_INV_APTRE`. aptre[j] is strictly smaller than aptrb[j] for some j.
* `MSK_RES_ERR_MUL_A_ELEMENT`. An element in A is defined multiple times.
* `MSK_RES_ERR_INV_BK`. Invalid bound key.
* `MSK_RES_ERR_INV_BKC`. Invalid bound key is specified for a constraint.
* `MSK_RES_ERR_INV_BKX`. An invalid bound key is specified for a variable.
* `MSK_RES_ERR_INV_VAR_TYPE`. An invalid variable type is specified for a variable.
* `MSK_RES_ERR_SOLVER_PROBTYPE`. Problem type does not match the chosen optimizer.
* `MSK_RES_ERR_OBJECTIVE_RANGE`. Empty objective range.
* `MSK_RES_ERR_INV_RESCODE`. Invalid response code.
* `MSK_RES_ERR_INV_IINF`. Invalid integer information item.
* `MSK_RES_ERR_INV_LIINF`. Invalid long integer information item.
* `MSK_RES_ERR_INV_DINF`. Invalid double information item.
* `MSK_RES_ERR_BASIS`. Invalid basis is specified.
* `MSK_RES_ERR_INV_SKC`. Invalid value in skc encountered.
* `MSK_RES_ERR_INV_SKX`. Invalid value in skx encountered.
* `MSK_RES_ERR_INV_SK_STR`. Invalid status key string encountered.
* `MSK_RES_ERR_INV_SK`. Invalid status key code encountered.
* `MSK_RES_ERR_INV_CONE_TYPE_STR`. Invalid cone type string encountered.
* `MSK_RES_ERR_INV_CONE_TYPE`. Invalid cone type code encountered.
* `MSK_RES_ERR_INV_SKN`. Invalid value in skn encountered.
* `MSK_RES_ERR_INVALID_SURPLUS`. Invalid surplus.
* `MSK_RES_ERR_INV_NAME_ITEM`. An invalid name item code is used.
* `MSK_RES_ERR_PRO_ITEM`. An invalid problem item is used.
* `MSK_RES_ERR_INVALID_FORMAT_TYPE`. Invalid format type.
* `MSK_RES_ERR_FIRSTI`. Invalid firsti.
* `MSK_RES_ERR_LASTI`. Invalid lasti.
* `MSK_RES_ERR_FIRSTJ`. Invalid firstj.
* `MSK_RES_ERR_LASTJ`. Invalid lastj.
* `MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL`. A maximum length that is too small has been specified.
* `MSK_RES_ERR_NONLINEAR_EQUALITY`. The model contains a nonlinear equality.
* `MSK_RES_ERR_NONCONVEX`. The optimization problem is nonconvex.
* `MSK_RES_ERR_NONLINEAR_RANGED`. The problem contains a nonlinear constraint with inite lower and upper bound.
* `MSK_RES_ERR_CON_Q_NOT_PSD`. The quadratic constraint matrix is not PSD.
* `MSK_RES_ERR_CON_Q_NOT_NSD`. The quadratic constraint matrix is not NSD.
* `MSK_RES_ERR_OBJ_Q_NOT_PSD`. The quadratic coefficient matrix in the objective is not PSD.
* `MSK_RES_ERR_OBJ_Q_NOT_NSD`. The quadratic coefficient matrix in the objective is not NSD.
* `MSK_RES_ERR_ARGUMENT_PERM_ARRAY`. An invalid permutation array is specified.
* `MSK_RES_ERR_CONE_INDEX`. An index of a non-existing cone has been specified.
* `MSK_RES_ERR_CONE_SIZE`. A cone with incorrect number of members is specified.
* `MSK_RES_ERR_CONE_OVERLAP`. One or more of variables in the cone to be added is already member of another cone.
* `MSK_RES_ERR_CONE_REP_VAR`. A variable is included multiple times in the cone.
* `MSK_RES_ERR_MAXNUMCONE`. The value specified for maxnumcone is too small.
* `MSK_RES_ERR_CONE_TYPE`. Invalid cone type specified.
* `MSK_RES_ERR_CONE_TYPE_STR`. Invalid cone type specified.
* `MSK_RES_ERR_CONE_OVERLAP_APPEND`. The cone to be appended has one variable which is already member of another cone.
* `MSK_RES_ERR_REMOVE_CONE_VARIABLE`. A variable cannot be removed because it will make a cone invalid.
* `MSK_RES_ERR_APPENDING_TOO_BIG_CONE`. Trying to append a too big cone.
* `MSK_RES_ERR_CONE_PARAMETER`. An invalid cone parameter.
* `MSK_RES_ERR_SOL_FILE_INVALID_NUMBER`. An invalid number is specified in a solution file.
* `MSK_RES_ERR_HUGE_C`. A huge value in absolute size is specified for an objective coefficient.
* `MSK_RES_ERR_HUGE_AIJ`. A numerically huge value is specified for an element in A.
* `MSK_RES_ERR_DUPLICATE_AIJ`. An element in the A matrix is specified twice.
* `MSK_RES_ERR_LOWER_BOUND_IS_A_NAN`. The lower bound specified is not a number (nan).
* `MSK_RES_ERR_UPPER_BOUND_IS_A_NAN`. The upper bound specified is not a number (nan).
* `MSK_RES_ERR_INFINITE_BOUND`. A numerically huge bound value is specified.
* `MSK_RES_ERR_INV_QOBJ_SUBI`. Invalid value %d at qosubi.
* `MSK_RES_ERR_INV_QOBJ_SUBJ`. Invalid value in qosubj.
* `MSK_RES_ERR_INV_QOBJ_VAL`. Invalid value in qoval.
* `MSK_RES_ERR_INV_QCON_SUBK`. Invalid value in qcsubk.
* `MSK_RES_ERR_INV_QCON_SUBI`. Invalid value in qcsubi.
* `MSK_RES_ERR_INV_QCON_SUBJ`. Invalid value in qcsubj.
* `MSK_RES_ERR_INV_QCON_VAL`. Invalid value in qcval.
* `MSK_RES_ERR_QCON_SUBI_TOO_SMALL`. Invalid value in qcsubi.
* `MSK_RES_ERR_QCON_SUBI_TOO_LARGE`. Invalid value in qcsubi.
* `MSK_RES_ERR_QOBJ_UPPER_TRIANGLE`. An element in the upper triangle of the quadratic term in the objective is specified.
* `MSK_RES_ERR_QCON_UPPER_TRIANGLE`. An element in the upper triangle of the quadratic term in a constraint.
* `MSK_RES_ERR_FIXED_BOUND_VALUES`. A fixed constraint/variable has been specified using the bound keys but the numerical bounds are different.
* `MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE`. A too small value for the A trucation value is specified.
* `MSK_RES_ERR_INVALID_OBJECTIVE_SENSE`. An invalid objective sense is specified.
* `MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE`. The objective sense has not been specified before the optimization.
* `MSK_RES_ERR_Y_IS_UNDEFINED`. The solution item y is undefined.
* `MSK_RES_ERR_NAN_IN_DOUBLE_DATA`. An invalid floating value was used in some double data.
* `MSK_RES_ERR_INF_IN_DOUBLE_DATA`. An infinite floating value was used in some double data.
* `MSK_RES_ERR_NAN_IN_BLC`. blc contains an invalid floating point value, i.e. a NaN.
* `MSK_RES_ERR_NAN_IN_BUC`. buc contains an invalid floating point value, i.e. a NaN.
* `MSK_RES_ERR_INVALID_CFIX`. An invalid fixed term in the objective is speficied.
* `MSK_RES_ERR_NAN_IN_C`. c contains an invalid floating point value, i.e. a NaN.
* `MSK_RES_ERR_NAN_IN_BLX`. blx contains an invalid floating point value, i.e. a NaN.
* `MSK_RES_ERR_NAN_IN_BUX`. bux contains an invalid floating point value, i.e. a NaN.
* `MSK_RES_ERR_INVALID_AIJ`. a[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value.
* `MSK_RES_ERR_INVALID_CJ`. c[j] contains an invalid floating point value, i.e. a NaN or an infinite value.
* `MSK_RES_ERR_SYM_MAT_INVALID`. A symmetric matrix contains an invalid floating point value, i.e. a NaN or an infinite value.
* `MSK_RES_ERR_SYM_MAT_HUGE`. A numerically huge value is specified for an element in E.
* `MSK_RES_ERR_INV_PROBLEM`. Invalid problem type.
* `MSK_RES_ERR_MIXED_CONIC_AND_NL`. The problem contains both conic and nonlinear constraints.
* `MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM`. The global optimizer can only be applied to problems without semidefinite variables.
* `MSK_RES_ERR_INV_OPTIMIZER`. An invalid optimizer has been chosen for the problem.
* `MSK_RES_ERR_MIO_NO_OPTIMIZER`. No optimizer is available for the current class of integer optimization problems.
* `MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE`. No optimizer is available for this class of optimization problems.
* `MSK_RES_ERR_FINAL_SOLUTION`. An error occurred during the solution finalization.
* `MSK_RES_ERR_FIRST`. Invalid first.
* `MSK_RES_ERR_LAST`. Invalid last.
* `MSK_RES_ERR_SLICE_SIZE`. Invalid slice size specified.
* `MSK_RES_ERR_NEGATIVE_SURPLUS`. Negative surplus.
* `MSK_RES_ERR_NEGATIVE_APPEND`. Cannot append a negative number.
* `MSK_RES_ERR_POSTSOLVE`. An error occurred during the postsolve.
* `MSK_RES_ERR_OVERFLOW`. A computation produced an overflow.
* `MSK_RES_ERR_NO_BASIS_SOL`. No basic solution is defined.
* `MSK_RES_ERR_BASIS_FACTOR`. The factorization of the basis is invalid.
* `MSK_RES_ERR_BASIS_SINGULAR`. The basis is singular.
* `MSK_RES_ERR_FACTOR`. An error occurred while factorizing a matrix.
* `MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX`. An optimization problem cannot be relaxed.
* `MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED`. The relaxed problem could not be solved to optimality.
* `MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND`. The upper bound is less than the lower bound for a variable or a constraint.
* `MSK_RES_ERR_REPAIR_INVALID_PROBLEM`. The feasibility repair does not support the specified problem type.
* `MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED`. Computation the optimal relaxation failed.
* `MSK_RES_ERR_NAME_MAX_LEN`. A name is longer than the buffer that is supposed to hold it.
* `MSK_RES_ERR_NAME_IS_NULL`. The name buffer is a null pointer.
* `MSK_RES_ERR_INVALID_COMPRESSION`. Invalid compression type.
* `MSK_RES_ERR_INVALID_IOMODE`. Invalid io mode.
* `MSK_RES_ERR_NO_PRIMAL_INFEAS_CER`. A certificate of primal infeasibility is not available.
* `MSK_RES_ERR_NO_DUAL_INFEAS_CER`. A certificate of dual infeasibility is not available.
* `MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK`. The required solution is not available.
* `MSK_RES_ERR_INV_MARKI`. Invalid value in marki.
* `MSK_RES_ERR_INV_MARKJ`. Invalid value in markj.
* `MSK_RES_ERR_INV_NUMI`. Invalid numi.
* `MSK_RES_ERR_INV_NUMJ`. Invalid numj.
* `MSK_RES_ERR_TASK_INCOMPATIBLE`. The Task file is incompatible with this platform.
* `MSK_RES_ERR_TASK_INVALID`. The Task file is invalid.
* `MSK_RES_ERR_TASK_WRITE`. Failed to write the task file.
* `MSK_RES_ERR_LU_MAX_NUM_TRIES`. Could not compute the LU factors of the matrix within the maximum number of allowed tries.
* `MSK_RES_ERR_INVALID_UTF8`. An invalid UTF8 string is encountered.
* `MSK_RES_ERR_INVALID_WCHAR`. An invalid wchar string is encountered.
* `MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL`. No dual information is available for the integer solution.
* `MSK_RES_ERR_NO_SNX_FOR_BAS_SOL`. snx is not available for the basis solution.
* `MSK_RES_ERR_INTERNAL`. An internal error occurred.
* `MSK_RES_ERR_API_ARRAY_TOO_SMALL`. An input array was too short.
* `MSK_RES_ERR_API_CB_CONNECT`. Failed to connect a callback object.
* `MSK_RES_ERR_API_FATAL_ERROR`. An internal error occurred in the API. Please report this problem.
* `MSK_RES_ERR_SEN_FORMAT`. Syntax error in sensitivity analysis file.
* `MSK_RES_ERR_SEN_UNDEF_NAME`. An undefined name was encountered in the sensitivity analysis file.
* `MSK_RES_ERR_SEN_INDEX_RANGE`. Index out of range in the sensitivity analysis file.
* `MSK_RES_ERR_SEN_BOUND_INVALID_UP`. Analysis of upper bound requested for an index, where no upper bound exists.
* `MSK_RES_ERR_SEN_BOUND_INVALID_LO`. Analysis of lower bound requested for an index, where no lower bound exists.
* `MSK_RES_ERR_SEN_INDEX_INVALID`. Invalid range given in the sensitivity file.
* `MSK_RES_ERR_SEN_INVALID_REGEXP`. Syntax error in regexp or regexp longer than 1024.
* `MSK_RES_ERR_SEN_SOLUTION_STATUS`. No optimal solution found to the original problem given for sensitivity analysis.
* `MSK_RES_ERR_SEN_NUMERICAL`. Numerical difficulties encountered performing the sensitivity analysis.
* `MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE`. Sensitivity analysis cannot be performed for the specified problem.
* `MSK_RES_ERR_UNB_STEP_SIZE`. A step-size in an optimizer was unexpectedly unbounded.
* `MSK_RES_ERR_IDENTICAL_TASKS`. Some tasks related to this function call were identical. Unique tasks were expected.
* `MSK_RES_ERR_AD_INVALID_CODELIST`. The code list data was invalid.
* `MSK_RES_ERR_INTERNAL_TEST_FAILED`. An internal unit test function failed.
* `MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE`. The problem type is not supported by the XML format.
* `MSK_RES_ERR_INVALID_AMPL_STUB`. Invalid AMPL stub.
* `MSK_RES_ERR_INT64_TO_INT32_CAST`. A 64 bit integer could not be cast to a 32 bit integer.
* `MSK_RES_ERR_SIZE_LICENSE_NUMCORES`. The computer contains more cpu cores than the license allows for.
* `MSK_RES_ERR_INFEAS_UNDEFINED`. The requested value is not defined for this solution type.
* `MSK_RES_ERR_NO_BARX_FOR_SOLUTION`. There is no barx available for the solution specified.
* `MSK_RES_ERR_NO_BARS_FOR_SOLUTION`. There is no bars available for the solution specified.
* `MSK_RES_ERR_BAR_VAR_DIM`. The dimension of a symmetric matrix variable has to be greater than 0.
* `MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX`. A row index specified for sparse symmetric matrix is invalid.
* `MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX`. A column index specified for sparse symmetric matrix is invalid.
* `MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR`. Only the lower triangular part of sparse symmetric matrix should be specified.
* `MSK_RES_ERR_SYM_MAT_INVALID_VALUE`. The numerical value specified in a sparse symmetric matrix is not a floating point value.
* `MSK_RES_ERR_SYM_MAT_DUPLICATE`. A value in a symmetric matric as been specified more than once.
* `MSK_RES_ERR_INVALID_SYM_MAT_DIM`. A sparse symmetric matrix of invalid dimension is specified.
* `MSK_RES_ERR_API_INTERNAL`. An internal fatal error occurred in an interface function.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT`. The file format does not support a problem with symmetric matrix variables.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX`. The file format does not support a problem with nonzero fixed term in c.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS`. The file format does not support a problem with ranged constraints.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS`. The file format does not support a problem with free constraints.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES`. The file format does not support a problem with the simple cones (deprecated).
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS`. The file format does not support a problem with quadratic terms.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR`. The file format does not support a problem with nonlinear terms.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS`. The file format does not support a problem with disjunctive constraints.
* `MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS`. The file format does not support a problem with affine conic constraints.
* `MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES`. Two constraint names are identical.
* `MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES`. Two variable names are identical.
* `MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES`. Two barvariable names are identical.
* `MSK_RES_ERR_DUPLICATE_CONE_NAMES`. Two cone names are identical.
* `MSK_RES_ERR_DUPLICATE_DOMAIN_NAMES`. Two domain names are identical.
* `MSK_RES_ERR_DUPLICATE_DJC_NAMES`. Two disjunctive constraint names are identical.
* `MSK_RES_ERR_NON_UNIQUE_ARRAY`. An array does not contain unique elements.
* `MSK_RES_ERR_ARGUMENT_IS_TOO_SMALL`. The value of a function argument is too small.
* `MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE`. The value of a function argument is too large.
* `MSK_RES_ERR_MIO_INTERNAL`. A fatal error occurred in the mixed integer optimizer.  Please contact MOSEK support.
* `MSK_RES_ERR_INVALID_PROBLEM_TYPE`. An invalid problem type.
* `MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS`. Unhandled solution status.
* `MSK_RES_ERR_UPPER_TRIANGLE`. An element in the upper triangle of a lower triangular matrix is specified.
* `MSK_RES_ERR_LAU_SINGULAR_MATRIX`. A matrix is singular.
* `MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE`. A matrix is not positive definite.
* `MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX`. An invalid lower triangular matrix.
* `MSK_RES_ERR_LAU_UNKNOWN`. An unknown error.
* `MSK_RES_ERR_LAU_ARG_M`. Invalid argument m.
* `MSK_RES_ERR_LAU_ARG_N`. Invalid argument n.
* `MSK_RES_ERR_LAU_ARG_K`. Invalid argument k.
* `MSK_RES_ERR_LAU_ARG_TRANSA`. Invalid argument transa.
* `MSK_RES_ERR_LAU_ARG_TRANSB`. Invalid argument transb.
* `MSK_RES_ERR_LAU_ARG_UPLO`. Invalid argument uplo.
* `MSK_RES_ERR_LAU_ARG_TRANS`. Invalid argument trans.
* `MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX`. An invalid sparse symmetric matrix is specfified.
* `MSK_RES_ERR_CBF_PARSE`. An error occurred while parsing an CBF file.
* `MSK_RES_ERR_CBF_OBJ_SENSE`. An invalid objective sense is specified.
* `MSK_RES_ERR_CBF_NO_VARIABLES`. An invalid objective sense is specified.
* `MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS`. Too many constraints specified.
* `MSK_RES_ERR_CBF_TOO_MANY_VARIABLES`. Too many variables specified.
* `MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED`. No version specified.
* `MSK_RES_ERR_CBF_SYNTAX`. Invalid syntax.
* `MSK_RES_ERR_CBF_DUPLICATE_OBJ`. Duplicate OBJ keyword.
* `MSK_RES_ERR_CBF_DUPLICATE_CON`. Duplicate CON keyword.
* `MSK_RES_ERR_CBF_DUPLICATE_VAR`. Duplicate VAR keyword.
* `MSK_RES_ERR_CBF_DUPLICATE_INT`. Duplicate INT keyword.
* `MSK_RES_ERR_CBF_INVALID_VAR_TYPE`. Invalid variable type.
* `MSK_RES_ERR_CBF_INVALID_CON_TYPE`. Invalid constraint type.
* `MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION`. Invalid domain dimension.
* `MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD`. Duplicate index in OBJCOORD.
* `MSK_RES_ERR_CBF_DUPLICATE_BCOORD`. Duplicate index in BCOORD.
* `MSK_RES_ERR_CBF_DUPLICATE_ACOORD`. Duplicate index in ACOORD.
* `MSK_RES_ERR_CBF_TOO_FEW_VARIABLES`. Too few variables defined.
* `MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS`. Too few constraints defined.
* `MSK_RES_ERR_CBF_TOO_FEW_INTS`. Too ints specified.
* `MSK_RES_ERR_CBF_TOO_MANY_INTS`. Too ints specified.
* `MSK_RES_ERR_CBF_INVALID_INT_INDEX`. Invalid INT index.
* `MSK_RES_ERR_CBF_UNSUPPORTED`. Unsupported feature is present.
* `MSK_RES_ERR_CBF_DUPLICATE_PSDVAR`. Duplicate PSDVAR keyword.
* `MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION`. Invalid PSDVAR dimension.
* `MSK_RES_ERR_CBF_TOO_FEW_PSDVAR`. Too few variables defined.
* `MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION`. Invalid dimension of a exponential cone.
* `MSK_RES_ERR_CBF_DUPLICATE_POW_CONES`. Multiple POWCONES specified.
* `MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES`. Multiple POW*CONES specified.
* `MSK_RES_ERR_CBF_INVALID_POWER`. Invalid power specified.
* `MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG`. Power cone is too long.
* `MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX`. Invalid power cone index.
* `MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX`. Invalid power star cone index.
* `MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE`. An unhandled power cone type.
* `MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE`. An unhandled power star cone type.
* `MSK_RES_ERR_CBF_POWER_CONE_MISMATCH`. The power cone does not match with it definition.
* `MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH`. The power star cone does not match with it definition.
* `MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES`. Invalid number of cones.
* `MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES`. Invalid number of cones.
* `MSK_RES_ERR_CBF_INVALID_NUM_OBJACOORD`. Invalid number of OBJACOORD.
* `MSK_RES_ERR_CBF_INVALID_NUM_OBJFCOORD`. Invalid number of OBJFCOORD.
* `MSK_RES_ERR_CBF_INVALID_NUM_ACOORD`. Invalid number of ACOORD.
* `MSK_RES_ERR_CBF_INVALID_NUM_BCOORD`. Invalid number of BCOORD.
* `MSK_RES_ERR_CBF_INVALID_NUM_FCOORD`. Invalid number of FCOORD.
* `MSK_RES_ERR_CBF_INVALID_NUM_HCOORD`. Invalid number of HCOORD.
* `MSK_RES_ERR_CBF_INVALID_NUM_DCOORD`. Invalid number of DCOORD.
* `MSK_RES_ERR_CBF_EXPECTED_A_KEYWORD`. Expected a key word.
* `MSK_RES_ERR_CBF_INVALID_NUM_PSDCON`. Invalid number of PSDCON.
* `MSK_RES_ERR_CBF_DUPLICATE_PSDCON`. Duplicate CON keyword.
* `MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_PSDCON`. Invalid PSDCON dimension.
* `MSK_RES_ERR_CBF_INVALID_PSDCON_INDEX`. Invalid PSDCON index.
* `MSK_RES_ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX`. Invalid PSDCON index.
* `MSK_RES_ERR_CBF_INVALID_PSDCON_BLOCK_INDEX`. Invalid PSDCON index.
* `MSK_RES_ERR_CBF_UNSUPPORTED_CHANGE`. The CHANGE section is not supported.
* `MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER`. An invalid root optimizer was selected for the problem type.
* `MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER`. An invalid node optimizer was selected for the problem type.
* `MSK_RES_ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE`. An invalid cone type occurs when writing a CPLEX formatted MPS file.
* `MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD`. The matrix defining the quadratric part of constraint is not positive semidefinite.
* `MSK_RES_ERR_TOCONIC_CONSTRAINT_FX`. The quadratic constraint is an equality, thus not convex.
* `MSK_RES_ERR_TOCONIC_CONSTRAINT_RA`. The quadratic constraint has finite lower and upper bound, and therefore it is not convex.
* `MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC`. The constraint is not conic representable.
* `MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD`. The matrix defining the quadratric part of the objective function is not positive semidefinite.
* `MSK_RES_ERR_SERVER_CONNECT`. Failed to connect to remote solver server.
* `MSK_RES_ERR_SERVER_PROTOCOL`. Unexpected message or data from solver server.
* `MSK_RES_ERR_SERVER_STATUS`. Server returned non-ok status code
* `MSK_RES_ERR_SERVER_TOKEN`. Invalid job ID
* `MSK_RES_ERR_SERVER_ADDRESS`. Invalid address
* `MSK_RES_ERR_SERVER_CERTIFICATE`. Invalid TLS certificate format or path
* `MSK_RES_ERR_SERVER_TLS_CLIENT`. Failed to create TLS client
* `MSK_RES_ERR_SERVER_ACCESS_TOKEN`. Invalid access token
* `MSK_RES_ERR_SERVER_PROBLEM_SIZE`. The problem is too large.
* `MSK_RES_ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX`. An element in a sparse matrix is specified twice.
* `MSK_RES_ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST`. An index is specified twice in an affine expression list.
* `MSK_RES_ERR_DUPLICATE_FIJ`. An element in the F matrix is specified twice.
* `MSK_RES_ERR_INVALID_FIJ`. f[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value.
* `MSK_RES_ERR_HUGE_FIJ`. A numerically huge value is specified for an element in F.
* `MSK_RES_ERR_INVALID_G`. g contains an invalid floating point value, i.e. a NaN or an infinite value.
* `MSK_RES_ERR_INVALID_B`. b contains an invalid floating point value, i.e. a NaN or an infinite value.
* `MSK_RES_ERR_DOMAIN_INVALID_INDEX`. A domain index is invalid.
* `MSK_RES_ERR_DOMAIN_DIMENSION`. A domain dimension is invalid.
* `MSK_RES_ERR_DOMAIN_DIMENSION_PSD`. A PSD domain dimension is invalid.
* `MSK_RES_ERR_NOT_POWER_DOMAIN`. The function is only applicable to primal and dual power cone domains.
* `MSK_RES_ERR_DOMAIN_POWER_INVALID_ALPHA`. Alpha contains an invalid floating point value, i.e. a NaN or an infinite value.
* `MSK_RES_ERR_DOMAIN_POWER_NEGATIVE_ALPHA`. Alpha contains a negative value or zero.
* `MSK_RES_ERR_DOMAIN_POWER_NLEFT`. The value of nleft is too small or too large.
* `MSK_RES_ERR_AFE_INVALID_INDEX`. An affine expression index is invalid.
* `MSK_RES_ERR_ACC_INVALID_INDEX`. A affine conic constraint index is invalid.
* `MSK_RES_ERR_ACC_INVALID_ENTRY_INDEX`. The index of an element in an affine conic constraint is invalid.
* `MSK_RES_ERR_ACC_AFE_DOMAIN_MISMATCH`. There is a mismatch between between the number of affine expressions and total dimension of the domain(s).
* `MSK_RES_ERR_DJC_INVALID_INDEX`. A disjunctive constraint index is invalid.
* `MSK_RES_ERR_DJC_UNSUPPORTED_DOMAIN_TYPE`. An unsupported domain type has been used in a disjunctive constraint.
* `MSK_RES_ERR_DJC_AFE_DOMAIN_MISMATCH`. There is a mismatch between the number of affine expressions and total dimension of the domain(s).
* `MSK_RES_ERR_DJC_INVALID_TERM_SIZE`. A termize is invalid.
* `MSK_RES_ERR_DJC_DOMAIN_TERMSIZE_MISMATCH`. There is a mismatch between the number of domains and the term sizes.
* `MSK_RES_ERR_DJC_TOTAL_NUM_TERMS_MISMATCH`. There total number of terms in all domains does not match.
* `MSK_RES_ERR_UNDEF_SOLUTION`. The required solution is not defined.
* `MSK_RES_ERR_NO_DOTY`. No doty is available.
* `MSK_RES_TRM_MAX_ITERATIONS`. The optimizer terminated at the maximum number of iterations.
* `MSK_RES_TRM_MAX_TIME`. The optimizer terminated at the maximum amount of time.
* `MSK_RES_TRM_OBJECTIVE_RANGE`. The optimizer terminated with an objective value outside the objective range.
* `MSK_RES_TRM_STALL`. The optimizer is terminated due to slow progress.
* `MSK_RES_TRM_USER_CALLBACK`. The user-defined progress callback function terminated the optimization.
* `MSK_RES_TRM_MIO_NUM_RELAXS`. The mixed-integer optimizer terminated as the maximum number of relaxations was reached.
* `MSK_RES_TRM_MIO_NUM_BRANCHES`. The mixed-integer optimizer terminated as the maximum number of branches was reached.
* `MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS`. The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.
* `MSK_RES_TRM_MAX_NUM_SETBACKS`. The optimizer terminated as the maximum number of set-backs was reached.
* `MSK_RES_TRM_NUMERICAL_PROBLEM`. The optimizer terminated due to a numerical problem.
* `MSK_RES_TRM_LOST_RACE`. Lost a race.
* `MSK_RES_TRM_INTERNAL`. The optimizer terminated due to some internal reason.
* `MSK_RES_TRM_INTERNAL_STOP`. The optimizer terminated for internal reasons.
"""
struct Rescode <: MosekEnum
  value :: Int32
end # rescode

"No error occurred."
const MSK_RES_OK = Rescode(0)

"The parameter file could not be opened."
const MSK_RES_WRN_OPEN_PARAM_FILE = Rescode(50)

"A numerically large bound value is specified."
const MSK_RES_WRN_LARGE_BOUND = Rescode(51)

"A numerically large lower bound value is specified."
const MSK_RES_WRN_LARGE_LO_BOUND = Rescode(52)

"A numerically large upper bound value is specified."
const MSK_RES_WRN_LARGE_UP_BOUND = Rescode(53)

"A equality constraint is fixed to numerically large value."
const MSK_RES_WRN_LARGE_CON_FX = Rescode(54)

"A numerically large value is specified for one element in c."
const MSK_RES_WRN_LARGE_CJ = Rescode(57)

"A numerically large value is specified for an element in A."
const MSK_RES_WRN_LARGE_AIJ = Rescode(62)

"One or more zero elements are specified in A."
const MSK_RES_WRN_ZERO_AIJ = Rescode(63)

"A name is longer than the buffer that is supposed to hold it."
const MSK_RES_WRN_NAME_MAX_LEN = Rescode(65)

"A value for a string parameter is longer than the buffer that is supposed to hold it."
const MSK_RES_WRN_SPAR_MAX_LEN = Rescode(66)

"An RHS vector is split into several nonadjacent parts."
const MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR = Rescode(70)

"A RANGE vector is split into several nonadjacent parts in an MPS file."
const MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR = Rescode(71)

"A BOUNDS vector is split into several nonadjacent parts in an MPS file."
const MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR = Rescode(72)

"Missing '/2' after quadratic expressions in bound or objective."
const MSK_RES_WRN_LP_OLD_QUAD_FORMAT = Rescode(80)

"Ignore a variable because the variable was not previously defined."
const MSK_RES_WRN_LP_DROP_VARIABLE = Rescode(85)

"Non-zero elements specified in the upper triangle of a matrix were ignored."
const MSK_RES_WRN_NZ_IN_UPR_TRI = Rescode(200)

"One or more non-zero elements were dropped in the Q matrix in the objective."
const MSK_RES_WRN_DROPPED_NZ_QOBJ = Rescode(201)

"Ignored integer constraints."
const MSK_RES_WRN_IGNORE_INTEGER = Rescode(250)

"No global optimizer is available."
const MSK_RES_WRN_NO_GLOBAL_OPTIMIZER = Rescode(251)

"The final mixed-integer problem with all the integer variables fixed at their optimal values is infeasible."
const MSK_RES_WRN_MIO_INFEASIBLE_FINAL = Rescode(270)

"Invalid solution filter is specified."
const MSK_RES_WRN_SOL_FILTER = Rescode(300)

"Undefined name occurred in a solution."
const MSK_RES_WRN_UNDEF_SOL_FILE_NAME = Rescode(350)

"One or more lines in the constraint section were ignored when reading a solution file."
const MSK_RES_WRN_SOL_FILE_IGNORED_CON = Rescode(351)

"One or more lines in the variable section were ignored when reading a solution file."
const MSK_RES_WRN_SOL_FILE_IGNORED_VAR = Rescode(352)

"An incomplete basis is specified."
const MSK_RES_WRN_TOO_FEW_BASIS_VARS = Rescode(400)

"A basis with too many variables is specified."
const MSK_RES_WRN_TOO_MANY_BASIS_VARS = Rescode(405)

"The license expires."
const MSK_RES_WRN_LICENSE_EXPIRE = Rescode(500)

"The license server is not responding."
const MSK_RES_WRN_LICENSE_SERVER = Rescode(501)

"A variable or constraint name is empty. The output file may be invalid."
const MSK_RES_WRN_EMPTY_NAME = Rescode(502)

"Generic names are used because a name is invalid for requested format."
const MSK_RES_WRN_USING_GENERIC_NAMES = Rescode(503)

"A name e.g. a row name is not a valid MPS name."
const MSK_RES_WRN_INVALID_MPS_NAME = Rescode(504)

"The objective name is not a valid MPS name."
const MSK_RES_WRN_INVALID_MPS_OBJ_NAME = Rescode(505)

"The license expires."
const MSK_RES_WRN_LICENSE_FEATURE_EXPIRE = Rescode(509)

"Parameter name not recognized."
const MSK_RES_WRN_PARAM_NAME_DOU = Rescode(510)

"Parameter name not recognized."
const MSK_RES_WRN_PARAM_NAME_INT = Rescode(511)

"Parameter name not recognized."
const MSK_RES_WRN_PARAM_NAME_STR = Rescode(512)

"A parameter value is not correct."
const MSK_RES_WRN_PARAM_STR_VALUE = Rescode(515)

"A parameter was ignored by the conic mixed integer optimizer."
const MSK_RES_WRN_PARAM_IGNORED_CMIO = Rescode(516)

"One or more (near) zero elements are specified in a sparse row of a matrix."
const MSK_RES_WRN_ZEROS_IN_SPARSE_ROW = Rescode(705)

"One or more (near) zero elements are specified in a sparse column of a matrix."
const MSK_RES_WRN_ZEROS_IN_SPARSE_COL = Rescode(710)

"The linear dependency check(s) is incomplete."
const MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK = Rescode(800)

"The eliminator is skipped at least once due to lack of space."
const MSK_RES_WRN_ELIMINATOR_SPACE = Rescode(801)

"The presolve is incomplete due to lack of space."
const MSK_RES_WRN_PRESOLVE_OUTOFSPACE = Rescode(802)

"The presolve perturbed the bounds of the primal problem. This is an indication that the problem is nearly infeasible."
const MSK_RES_WRN_PRESOLVE_PRIMAL_PERTUBATIONS = Rescode(803)

"Some names were changed because they were invalid for the output file format."
const MSK_RES_WRN_WRITE_CHANGED_NAMES = Rescode(830)

"The fixed objective term was discarded in the output file."
const MSK_RES_WRN_WRITE_DISCARDED_CFIX = Rescode(831)

"Two constraint names are identical."
const MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES = Rescode(850)

"Two variable names are identical."
const MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES = Rescode(851)

"Two barvariable names are identical."
const MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES = Rescode(852)

"Two cone names are identical."
const MSK_RES_WRN_DUPLICATE_CONE_NAMES = Rescode(853)

"LP file will be written with generic variable names."
const MSK_RES_WRN_WRITE_LP_INVALID_VAR_NAMES = Rescode(854)

"LP file will be written with generic variable names."
const MSK_RES_WRN_WRITE_LP_DUPLICATE_VAR_NAMES = Rescode(855)

"LP file will be written with generic constraint names."
const MSK_RES_WRN_WRITE_LP_INVALID_CON_NAMES = Rescode(856)

"LP file will be written with generic constraint names."
const MSK_RES_WRN_WRITE_LP_DUPLICATE_CON_NAMES = Rescode(857)

"Warn against very large bounds."
const MSK_RES_WRN_ANA_LARGE_BOUNDS = Rescode(900)

"Warn against all objective coefficients being zero."
const MSK_RES_WRN_ANA_C_ZERO = Rescode(901)

"Warn against empty columns."
const MSK_RES_WRN_ANA_EMPTY_COLS = Rescode(902)

"Warn against close bounds."
const MSK_RES_WRN_ANA_CLOSE_BOUNDS = Rescode(903)

"Warn against almost integral bounds."
const MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS = Rescode(904)

"An infeasibility report is not available when the problem contains matrix variables."
const MSK_RES_WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES = Rescode(930)

"No automatic dualizer is available for the specified problem."
const MSK_RES_WRN_NO_DUALIZER = Rescode(950)

"A numerically large value is specified for an element in E."
const MSK_RES_WRN_SYM_MAT_LARGE = Rescode(960)

"A double parameter related to solver tolerances has a non-default value."
const MSK_RES_WRN_MODIFIED_DOUBLE_PARAMETER = Rescode(970)

"A numerically large value is specified for an element in F."
const MSK_RES_WRN_LARGE_FIJ = Rescode(980)

"Invalid license."
const MSK_RES_ERR_LICENSE = Rescode(1000)

"The license has expired."
const MSK_RES_ERR_LICENSE_EXPIRED = Rescode(1001)

"Invalid license version."
const MSK_RES_ERR_LICENSE_VERSION = Rescode(1002)

"The license server version is too old."
const MSK_RES_ERR_LICENSE_OLD_SERVER_VERSION = Rescode(1003)

"The problem is bigger than the license."
const MSK_RES_ERR_SIZE_LICENSE = Rescode(1005)

"The software is not licensed to solve the problem."
const MSK_RES_ERR_PROB_LICENSE = Rescode(1006)

"Invalid license file."
const MSK_RES_ERR_FILE_LICENSE = Rescode(1007)

"A license cannot be located."
const MSK_RES_ERR_MISSING_LICENSE_FILE = Rescode(1008)

"The problem has too many constraints."
const MSK_RES_ERR_SIZE_LICENSE_CON = Rescode(1010)

"The problem has too many variables."
const MSK_RES_ERR_SIZE_LICENSE_VAR = Rescode(1011)

"The problem contains too many integer variables."
const MSK_RES_ERR_SIZE_LICENSE_INTVAR = Rescode(1012)

"The optimizer required is not licensed."
const MSK_RES_ERR_OPTIMIZER_LICENSE = Rescode(1013)

"The license manager reported an error."
const MSK_RES_ERR_FLEXLM = Rescode(1014)

"The license server is not responding."
const MSK_RES_ERR_LICENSE_SERVER = Rescode(1015)

"Maximum number of licenses is reached."
const MSK_RES_ERR_LICENSE_MAX = Rescode(1016)

"The MOSEKLM license manager daemon is not up and running."
const MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON = Rescode(1017)

"A requested feature is not available in the license file(s)."
const MSK_RES_ERR_LICENSE_FEATURE = Rescode(1018)

"A requested license feature is not available for the required platform."
const MSK_RES_ERR_PLATFORM_NOT_LICENSED = Rescode(1019)

"The license system cannot allocate the memory required."
const MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE = Rescode(1020)

"MOSEK cannot connect to the license server."
const MSK_RES_ERR_LICENSE_CANNOT_CONNECT = Rescode(1021)

"The host ID specified in the license file does not match the host ID of the computer."
const MSK_RES_ERR_LICENSE_INVALID_HOSTID = Rescode(1025)

"The version specified in the checkout request is greater than the highest version number the daemon supports."
const MSK_RES_ERR_LICENSE_SERVER_VERSION = Rescode(1026)

"The license server does not support the requested feature."
const MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT = Rescode(1027)

"No SERVER lines in license file."
const MSK_RES_ERR_LICENSE_NO_SERVER_LINE = Rescode(1028)

"The dynamic link library is older than the specified version."
const MSK_RES_ERR_OLDER_DLL = Rescode(1035)

"The dynamic link library is newer than the specified version."
const MSK_RES_ERR_NEWER_DLL = Rescode(1036)

"A file cannot be linked to a stream in the DLL version."
const MSK_RES_ERR_LINK_FILE_DLL = Rescode(1040)

"Could not initialize a mutex."
const MSK_RES_ERR_THREAD_MUTEX_INIT = Rescode(1045)

"Could not lock a mutex."
const MSK_RES_ERR_THREAD_MUTEX_LOCK = Rescode(1046)

"Could not unlock a mutex."
const MSK_RES_ERR_THREAD_MUTEX_UNLOCK = Rescode(1047)

"Could not create a thread."
const MSK_RES_ERR_THREAD_CREATE = Rescode(1048)

"Could not initialize a condition."
const MSK_RES_ERR_THREAD_COND_INIT = Rescode(1049)

"Unknown error."
const MSK_RES_ERR_UNKNOWN = Rescode(1050)

"Out of space."
const MSK_RES_ERR_SPACE = Rescode(1051)

"An error occurred while opening a file."
const MSK_RES_ERR_FILE_OPEN = Rescode(1052)

"An error occurred while reading file."
const MSK_RES_ERR_FILE_READ = Rescode(1053)

"An error occurred while writing to a file."
const MSK_RES_ERR_FILE_WRITE = Rescode(1054)

"The data file format cannot be determined from the file name."
const MSK_RES_ERR_DATA_FILE_EXT = Rescode(1055)

"An invalid file name has been specified."
const MSK_RES_ERR_INVALID_FILE_NAME = Rescode(1056)

"An invalid file name has been specified."
const MSK_RES_ERR_INVALID_SOL_FILE_NAME = Rescode(1057)

"End of file reached."
const MSK_RES_ERR_END_OF_FILE = Rescode(1059)

"env is a null pointer."
const MSK_RES_ERR_NULL_ENV = Rescode(1060)

"task is a null pointer."
const MSK_RES_ERR_NULL_TASK = Rescode(1061)

"An invalid stream is referenced."
const MSK_RES_ERR_INVALID_STREAM = Rescode(1062)

"Environment is not initialized."
const MSK_RES_ERR_NO_INIT_ENV = Rescode(1063)

"The task is invalid."
const MSK_RES_ERR_INVALID_TASK = Rescode(1064)

"An argument to a function is unexpectedly a null pointer."
const MSK_RES_ERR_NULL_POINTER = Rescode(1065)

"Not all tasks associated with the environment have been deleted."
const MSK_RES_ERR_LIVING_TASKS = Rescode(1066)

"Error encountered in GZIP stream."
const MSK_RES_ERR_READ_GZIP = Rescode(1067)

"Error encountered in ZSTD stream."
const MSK_RES_ERR_READ_ZSTD = Rescode(1068)

"An all blank name has been specified."
const MSK_RES_ERR_BLANK_NAME = Rescode(1070)

"Duplicate names specified."
const MSK_RES_ERR_DUP_NAME = Rescode(1071)

"The name format string is invalid."
const MSK_RES_ERR_FORMAT_STRING = Rescode(1072)

"The sparsity included an index that was out of bounds of the shape."
const MSK_RES_ERR_SPARSITY_SPECIFICATION = Rescode(1073)

"Mismatching dimensions specified in arguments"
const MSK_RES_ERR_MISMATCHING_DIMENSION = Rescode(1074)

"An invalid objective name is specified."
const MSK_RES_ERR_INVALID_OBJ_NAME = Rescode(1075)

"An invalid constraint name is used."
const MSK_RES_ERR_INVALID_CON_NAME = Rescode(1076)

"An invalid variable name is used."
const MSK_RES_ERR_INVALID_VAR_NAME = Rescode(1077)

"An invalid cone name is used."
const MSK_RES_ERR_INVALID_CONE_NAME = Rescode(1078)

"An invalid symmetric matrix variable name is used."
const MSK_RES_ERR_INVALID_BARVAR_NAME = Rescode(1079)

"MOSEK is leaking memory."
const MSK_RES_ERR_SPACE_LEAKING = Rescode(1080)

"No available information about the space usage."
const MSK_RES_ERR_SPACE_NO_INFO = Rescode(1081)

"Invalid dimension specification"
const MSK_RES_ERR_DIMENSION_SPECIFICATION = Rescode(1082)

"Invalid axis names specification"
const MSK_RES_ERR_AXIS_NAME_SPECIFICATION = Rescode(1083)

"The specified format cannot be read."
const MSK_RES_ERR_READ_FORMAT = Rescode(1090)

"An error occurred while reading an MPS file."
const MSK_RES_ERR_MPS_FILE = Rescode(1100)

"Invalid field occurred while reading an MPS file."
const MSK_RES_ERR_MPS_INV_FIELD = Rescode(1101)

"An invalid marker has been specified in the MPS file."
const MSK_RES_ERR_MPS_INV_MARKER = Rescode(1102)

"An empty constraint name is used in an MPS file."
const MSK_RES_ERR_MPS_NULL_CON_NAME = Rescode(1103)

"An empty variable name is used in an MPS file."
const MSK_RES_ERR_MPS_NULL_VAR_NAME = Rescode(1104)

"An undefined constraint name occurred in an MPS file."
const MSK_RES_ERR_MPS_UNDEF_CON_NAME = Rescode(1105)

"An undefined variable name occurred in an MPS file."
const MSK_RES_ERR_MPS_UNDEF_VAR_NAME = Rescode(1106)

"An invalid constraint key occurred in an MPS file."
const MSK_RES_ERR_MPS_INVALID_CON_KEY = Rescode(1107)

"An invalid bound key occurred in an MPS file."
const MSK_RES_ERR_MPS_INVALID_BOUND_KEY = Rescode(1108)

"An invalid section name occurred in an MPS file."
const MSK_RES_ERR_MPS_INVALID_SEC_NAME = Rescode(1109)

"No objective is defined in an MPS file."
const MSK_RES_ERR_MPS_NO_OBJECTIVE = Rescode(1110)

"The non-zero elements in A corresponding to a variable in an MPS file must be specified consecutively."
const MSK_RES_ERR_MPS_SPLITTED_VAR = Rescode(1111)

"A constraint name is specified multiple times in the ROWS section in an MPS file."
const MSK_RES_ERR_MPS_MUL_CON_NAME = Rescode(1112)

"Multiple QSECTIONs are specified for a constraint."
const MSK_RES_ERR_MPS_MUL_QSEC = Rescode(1113)

"The Q term in the objective is specified multiple times."
const MSK_RES_ERR_MPS_MUL_QOBJ = Rescode(1114)

"The sections in an MPS file is not in the correct order."
const MSK_RES_ERR_MPS_INV_SEC_ORDER = Rescode(1115)

"Multiple CSECTIONs are given the same name."
const MSK_RES_ERR_MPS_MUL_CSEC = Rescode(1116)

"Invalid cone type specified in a  CSECTION."
const MSK_RES_ERR_MPS_CONE_TYPE = Rescode(1117)

"A variable is specified to be a member of several cones."
const MSK_RES_ERR_MPS_CONE_OVERLAP = Rescode(1118)

"A variable is repeated within the CSECTION."
const MSK_RES_ERR_MPS_CONE_REPEAT = Rescode(1119)

"A non symmetric matrix has been speciefied."
const MSK_RES_ERR_MPS_NON_SYMMETRIC_Q = Rescode(1120)

"Duplicate elements is specified in a Q matrix."
const MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT = Rescode(1121)

"An invalid objective sense is specified."
const MSK_RES_ERR_MPS_INVALID_OBJSENSE = Rescode(1122)

"A tab char occurred in field 2."
const MSK_RES_ERR_MPS_TAB_IN_FIELD2 = Rescode(1125)

"A tab char occurred in field 3."
const MSK_RES_ERR_MPS_TAB_IN_FIELD3 = Rescode(1126)

"A tab char occurred in field 5."
const MSK_RES_ERR_MPS_TAB_IN_FIELD5 = Rescode(1127)

"An invalid objective name is specified."
const MSK_RES_ERR_MPS_INVALID_OBJ_NAME = Rescode(1128)

"An invalid indicator key occurred in an MPS file."
const MSK_RES_ERR_MPS_INVALID_KEY = Rescode(1129)

"An invalid indicator constraint is used. It must not be a ranged constraint."
const MSK_RES_ERR_MPS_INVALID_INDICATOR_CONSTRAINT = Rescode(1130)

"An invalid indicator variable is specfied. It must be a binary variable."
const MSK_RES_ERR_MPS_INVALID_INDICATOR_VARIABLE = Rescode(1131)

"An invalid indicator value is specfied. It must be either 0 or 1."
const MSK_RES_ERR_MPS_INVALID_INDICATOR_VALUE = Rescode(1132)

"A quadratic constraint can be be an indicator constraint."
const MSK_RES_ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT = Rescode(1133)

"Syntax error in an OPF file"
const MSK_RES_ERR_OPF_SYNTAX = Rescode(1134)

"Premature end of file in an OPF file."
const MSK_RES_ERR_OPF_PREMATURE_EOF = Rescode(1136)

"Mismatched end-tag in OPF file"
const MSK_RES_ERR_OPF_MISMATCHED_TAG = Rescode(1137)

"Either upper or lower bound was specified twice in OPF file"
const MSK_RES_ERR_OPF_DUPLICATE_BOUND = Rescode(1138)

"Duplicate constraint name in OPF File"
const MSK_RES_ERR_OPF_DUPLICATE_CONSTRAINT_NAME = Rescode(1139)

"Invalid cone type in OPF File"
const MSK_RES_ERR_OPF_INVALID_CONE_TYPE = Rescode(1140)

"Invalid number of parameters in start-tag in OPF File"
const MSK_RES_ERR_OPF_INCORRECT_TAG_PARAM = Rescode(1141)

"Invalid start-tag in OPF File"
const MSK_RES_ERR_OPF_INVALID_TAG = Rescode(1142)

"Same variable appears in multiple cones in OPF File"
const MSK_RES_ERR_OPF_DUPLICATE_CONE_ENTRY = Rescode(1143)

"The problem is too large to be correctly loaded"
const MSK_RES_ERR_OPF_TOO_LARGE = Rescode(1144)

"Dual solution values are not allowed in OPF File"
const MSK_RES_ERR_OPF_DUAL_INTEGER_SOLUTION = Rescode(1146)

"The problem cannot be written to an LP formatted file."
const MSK_RES_ERR_LP_EMPTY = Rescode(1151)

"An invalid name is created while writing an MPS file."
const MSK_RES_ERR_WRITE_MPS_INVALID_NAME = Rescode(1153)

"A variable name is invalid when used in an LP formatted file."
const MSK_RES_ERR_LP_INVALID_VAR_NAME = Rescode(1154)

"Empty variable names cannot be written to OPF files."
const MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME = Rescode(1156)

"Syntax error in an LP file."
const MSK_RES_ERR_LP_FILE_FORMAT = Rescode(1157)

"Expected a number in LP file"
const MSK_RES_ERR_LP_EXPECTED_NUMBER = Rescode(1158)

"Syntax error in LP fil. Possibly missing End tag."
const MSK_RES_ERR_READ_LP_MISSING_END_TAG = Rescode(1159)

"An indicator variable was not declared binary"
const MSK_RES_ERR_LP_INDICATOR_VAR = Rescode(1160)

"Expected an objective section in LP file"
const MSK_RES_ERR_LP_EXPECTED_OBJECTIVE = Rescode(1161)

"Expected constraint relation"
const MSK_RES_ERR_LP_EXPECTED_CONSTRAINT_RELATION = Rescode(1162)

"Constraint has ambiguous or invalid bound"
const MSK_RES_ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND = Rescode(1163)

"Duplicate section"
const MSK_RES_ERR_LP_DUPLICATE_SECTION = Rescode(1164)

"Duplicate section"
const MSK_RES_ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED = Rescode(1165)

"An error occurred while writing file"
const MSK_RES_ERR_WRITING_FILE = Rescode(1166)

"An invalid name occurred in a solution file."
const MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE = Rescode(1170)

"Syntax error in an JSON data"
const MSK_RES_ERR_JSON_SYNTAX = Rescode(1175)

"Error in JSON string."
const MSK_RES_ERR_JSON_STRING = Rescode(1176)

"Invalid number entry - wrong type or value overflow."
const MSK_RES_ERR_JSON_NUMBER_OVERFLOW = Rescode(1177)

"Error in an JSON Task file"
const MSK_RES_ERR_JSON_FORMAT = Rescode(1178)

"Inconsistent data in JSON Task file"
const MSK_RES_ERR_JSON_DATA = Rescode(1179)

"Missing data section in JSON task file."
const MSK_RES_ERR_JSON_MISSING_DATA = Rescode(1180)

"Incompatible item"
const MSK_RES_ERR_PTF_INCOMPATIBILITY = Rescode(1181)

"Undefined symbol referenced"
const MSK_RES_ERR_PTF_UNDEFINED_ITEM = Rescode(1182)

"Inconsistent size of item"
const MSK_RES_ERR_PTF_INCONSISTENCY = Rescode(1183)

"Syntax error in an PTF file"
const MSK_RES_ERR_PTF_FORMAT = Rescode(1184)

"Incorrect length of arguments."
const MSK_RES_ERR_ARGUMENT_LENNEQ = Rescode(1197)

"Incorrect argument type."
const MSK_RES_ERR_ARGUMENT_TYPE = Rescode(1198)

"Incorrect number of function arguments."
const MSK_RES_ERR_NUM_ARGUMENTS = Rescode(1199)

"A function argument is incorrect."
const MSK_RES_ERR_IN_ARGUMENT = Rescode(1200)

"A function argument is of incorrect dimension."
const MSK_RES_ERR_ARGUMENT_DIMENSION = Rescode(1201)

"The size of the n-dimensional shape is too large."
const MSK_RES_ERR_SHAPE_IS_TOO_LARGE = Rescode(1202)

"An index in an argument is too small."
const MSK_RES_ERR_INDEX_IS_TOO_SMALL = Rescode(1203)

"An index in an argument is too large."
const MSK_RES_ERR_INDEX_IS_TOO_LARGE = Rescode(1204)

"An index in an argument is is unique."
const MSK_RES_ERR_INDEX_IS_NOT_UNIQUE = Rescode(1205)

"A parameter name is not correct."
const MSK_RES_ERR_PARAM_NAME = Rescode(1206)

"A parameter name is not correct."
const MSK_RES_ERR_PARAM_NAME_DOU = Rescode(1207)

"A parameter name is not correct."
const MSK_RES_ERR_PARAM_NAME_INT = Rescode(1208)

"A parameter name is not correct."
const MSK_RES_ERR_PARAM_NAME_STR = Rescode(1209)

"Parameter index is out of range."
const MSK_RES_ERR_PARAM_INDEX = Rescode(1210)

"A parameter value is too large."
const MSK_RES_ERR_PARAM_IS_TOO_LARGE = Rescode(1215)

"A parameter value is too small."
const MSK_RES_ERR_PARAM_IS_TOO_SMALL = Rescode(1216)

"A parameter value string is incorrect."
const MSK_RES_ERR_PARAM_VALUE_STR = Rescode(1217)

"A parameter type is invalid."
const MSK_RES_ERR_PARAM_TYPE = Rescode(1218)

"A double information index is out of range for the specified type."
const MSK_RES_ERR_INF_DOU_INDEX = Rescode(1219)

"An integer information index is out of range for the specified type."
const MSK_RES_ERR_INF_INT_INDEX = Rescode(1220)

"An index in an array argument is too small."
const MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL = Rescode(1221)

"An index in an array argument is too large."
const MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE = Rescode(1222)

"A long integer information index is out of range for the specified type."
const MSK_RES_ERR_INF_LINT_INDEX = Rescode(1225)

"The value of a argument is too small."
const MSK_RES_ERR_ARG_IS_TOO_SMALL = Rescode(1226)

"The value of a argument is too large."
const MSK_RES_ERR_ARG_IS_TOO_LARGE = Rescode(1227)

"whichsol is invalid."
const MSK_RES_ERR_INVALID_WHICHSOL = Rescode(1228)

"A double information name is invalid."
const MSK_RES_ERR_INF_DOU_NAME = Rescode(1230)

"An integer information name is invalid."
const MSK_RES_ERR_INF_INT_NAME = Rescode(1231)

"The information type is invalid."
const MSK_RES_ERR_INF_TYPE = Rescode(1232)

"A long integer information name is invalid."
const MSK_RES_ERR_INF_LINT_NAME = Rescode(1234)

"An index is out of range."
const MSK_RES_ERR_INDEX = Rescode(1235)

"The solution defined by whichsol does not exists."
const MSK_RES_ERR_WHICHSOL = Rescode(1236)

"The solution number  solemn does not exists."
const MSK_RES_ERR_SOLITEM = Rescode(1237)

"whichitem is unacceptable."
const MSK_RES_ERR_WHICHITEM_NOT_ALLOWED = Rescode(1238)

"Invalid maximum number of constraints specified."
const MSK_RES_ERR_MAXNUMCON = Rescode(1240)

"The maximum number of variables limit is too small."
const MSK_RES_ERR_MAXNUMVAR = Rescode(1241)

"The maximum number of semidefinite variables limit is too small."
const MSK_RES_ERR_MAXNUMBARVAR = Rescode(1242)

"Too small maximum number of non-zeros for the Q matrices is specified."
const MSK_RES_ERR_MAXNUMQNZ = Rescode(1243)

"The maximum number of non-zeros specified is too small."
const MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ = Rescode(1245)

"A specified index is invalid."
const MSK_RES_ERR_INVALID_IDX = Rescode(1246)

"A specified index is invalid."
const MSK_RES_ERR_INVALID_MAX_NUM = Rescode(1247)

"The value of whichsol is not allowed."
const MSK_RES_ERR_UNALLOWED_WHICHSOL = Rescode(1248)

"Maximum number of constraints limit is exceeded."
const MSK_RES_ERR_NUMCONLIM = Rescode(1250)

"Maximum number of variables limit is exceeded."
const MSK_RES_ERR_NUMVARLIM = Rescode(1251)

"Too small maximum number of non-zeros in A specified."
const MSK_RES_ERR_TOO_SMALL_MAXNUMANZ = Rescode(1252)

"aptre[j] is strictly smaller than aptrb[j] for some j."
const MSK_RES_ERR_INV_APTRE = Rescode(1253)

"An element in A is defined multiple times."
const MSK_RES_ERR_MUL_A_ELEMENT = Rescode(1254)

"Invalid bound key."
const MSK_RES_ERR_INV_BK = Rescode(1255)

"Invalid bound key is specified for a constraint."
const MSK_RES_ERR_INV_BKC = Rescode(1256)

"An invalid bound key is specified for a variable."
const MSK_RES_ERR_INV_BKX = Rescode(1257)

"An invalid variable type is specified for a variable."
const MSK_RES_ERR_INV_VAR_TYPE = Rescode(1258)

"Problem type does not match the chosen optimizer."
const MSK_RES_ERR_SOLVER_PROBTYPE = Rescode(1259)

"Empty objective range."
const MSK_RES_ERR_OBJECTIVE_RANGE = Rescode(1260)

"Invalid response code."
const MSK_RES_ERR_INV_RESCODE = Rescode(1261)

"Invalid integer information item."
const MSK_RES_ERR_INV_IINF = Rescode(1262)

"Invalid long integer information item."
const MSK_RES_ERR_INV_LIINF = Rescode(1263)

"Invalid double information item."
const MSK_RES_ERR_INV_DINF = Rescode(1264)

"Invalid basis is specified."
const MSK_RES_ERR_BASIS = Rescode(1266)

"Invalid value in skc encountered."
const MSK_RES_ERR_INV_SKC = Rescode(1267)

"Invalid value in skx encountered."
const MSK_RES_ERR_INV_SKX = Rescode(1268)

"Invalid status key string encountered."
const MSK_RES_ERR_INV_SK_STR = Rescode(1269)

"Invalid status key code encountered."
const MSK_RES_ERR_INV_SK = Rescode(1270)

"Invalid cone type string encountered."
const MSK_RES_ERR_INV_CONE_TYPE_STR = Rescode(1271)

"Invalid cone type code encountered."
const MSK_RES_ERR_INV_CONE_TYPE = Rescode(1272)

"Invalid value in skn encountered."
const MSK_RES_ERR_INV_SKN = Rescode(1274)

"Invalid surplus."
const MSK_RES_ERR_INVALID_SURPLUS = Rescode(1275)

"An invalid name item code is used."
const MSK_RES_ERR_INV_NAME_ITEM = Rescode(1280)

"An invalid problem item is used."
const MSK_RES_ERR_PRO_ITEM = Rescode(1281)

"Invalid format type."
const MSK_RES_ERR_INVALID_FORMAT_TYPE = Rescode(1283)

"Invalid firsti."
const MSK_RES_ERR_FIRSTI = Rescode(1285)

"Invalid lasti."
const MSK_RES_ERR_LASTI = Rescode(1286)

"Invalid firstj."
const MSK_RES_ERR_FIRSTJ = Rescode(1287)

"Invalid lastj."
const MSK_RES_ERR_LASTJ = Rescode(1288)

"A maximum length that is too small has been specified."
const MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL = Rescode(1289)

"The model contains a nonlinear equality."
const MSK_RES_ERR_NONLINEAR_EQUALITY = Rescode(1290)

"The optimization problem is nonconvex."
const MSK_RES_ERR_NONCONVEX = Rescode(1291)

"The problem contains a nonlinear constraint with inite lower and upper bound."
const MSK_RES_ERR_NONLINEAR_RANGED = Rescode(1292)

"The quadratic constraint matrix is not PSD."
const MSK_RES_ERR_CON_Q_NOT_PSD = Rescode(1293)

"The quadratic constraint matrix is not NSD."
const MSK_RES_ERR_CON_Q_NOT_NSD = Rescode(1294)

"The quadratic coefficient matrix in the objective is not PSD."
const MSK_RES_ERR_OBJ_Q_NOT_PSD = Rescode(1295)

"The quadratic coefficient matrix in the objective is not NSD."
const MSK_RES_ERR_OBJ_Q_NOT_NSD = Rescode(1296)

"An invalid permutation array is specified."
const MSK_RES_ERR_ARGUMENT_PERM_ARRAY = Rescode(1299)

"An index of a non-existing cone has been specified."
const MSK_RES_ERR_CONE_INDEX = Rescode(1300)

"A cone with incorrect number of members is specified."
const MSK_RES_ERR_CONE_SIZE = Rescode(1301)

"One or more of variables in the cone to be added is already member of another cone."
const MSK_RES_ERR_CONE_OVERLAP = Rescode(1302)

"A variable is included multiple times in the cone."
const MSK_RES_ERR_CONE_REP_VAR = Rescode(1303)

"The value specified for maxnumcone is too small."
const MSK_RES_ERR_MAXNUMCONE = Rescode(1304)

"Invalid cone type specified."
const MSK_RES_ERR_CONE_TYPE = Rescode(1305)

"Invalid cone type specified."
const MSK_RES_ERR_CONE_TYPE_STR = Rescode(1306)

"The cone to be appended has one variable which is already member of another cone."
const MSK_RES_ERR_CONE_OVERLAP_APPEND = Rescode(1307)

"A variable cannot be removed because it will make a cone invalid."
const MSK_RES_ERR_REMOVE_CONE_VARIABLE = Rescode(1310)

"Trying to append a too big cone."
const MSK_RES_ERR_APPENDING_TOO_BIG_CONE = Rescode(1311)

"An invalid cone parameter."
const MSK_RES_ERR_CONE_PARAMETER = Rescode(1320)

"An invalid number is specified in a solution file."
const MSK_RES_ERR_SOL_FILE_INVALID_NUMBER = Rescode(1350)

"A huge value in absolute size is specified for an objective coefficient."
const MSK_RES_ERR_HUGE_C = Rescode(1375)

"A numerically huge value is specified for an element in A."
const MSK_RES_ERR_HUGE_AIJ = Rescode(1380)

"An element in the A matrix is specified twice."
const MSK_RES_ERR_DUPLICATE_AIJ = Rescode(1385)

"The lower bound specified is not a number (nan)."
const MSK_RES_ERR_LOWER_BOUND_IS_A_NAN = Rescode(1390)

"The upper bound specified is not a number (nan)."
const MSK_RES_ERR_UPPER_BOUND_IS_A_NAN = Rescode(1391)

"A numerically huge bound value is specified."
const MSK_RES_ERR_INFINITE_BOUND = Rescode(1400)

"Invalid value %d at qosubi."
const MSK_RES_ERR_INV_QOBJ_SUBI = Rescode(1401)

"Invalid value in qosubj."
const MSK_RES_ERR_INV_QOBJ_SUBJ = Rescode(1402)

"Invalid value in qoval."
const MSK_RES_ERR_INV_QOBJ_VAL = Rescode(1403)

"Invalid value in qcsubk."
const MSK_RES_ERR_INV_QCON_SUBK = Rescode(1404)

"Invalid value in qcsubi."
const MSK_RES_ERR_INV_QCON_SUBI = Rescode(1405)

"Invalid value in qcsubj."
const MSK_RES_ERR_INV_QCON_SUBJ = Rescode(1406)

"Invalid value in qcval."
const MSK_RES_ERR_INV_QCON_VAL = Rescode(1407)

"Invalid value in qcsubi."
const MSK_RES_ERR_QCON_SUBI_TOO_SMALL = Rescode(1408)

"Invalid value in qcsubi."
const MSK_RES_ERR_QCON_SUBI_TOO_LARGE = Rescode(1409)

"An element in the upper triangle of the quadratic term in the objective is specified."
const MSK_RES_ERR_QOBJ_UPPER_TRIANGLE = Rescode(1415)

"An element in the upper triangle of the quadratic term in a constraint."
const MSK_RES_ERR_QCON_UPPER_TRIANGLE = Rescode(1417)

"A fixed constraint/variable has been specified using the bound keys but the numerical bounds are different."
const MSK_RES_ERR_FIXED_BOUND_VALUES = Rescode(1420)

"A too small value for the A trucation value is specified."
const MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE = Rescode(1421)

"An invalid objective sense is specified."
const MSK_RES_ERR_INVALID_OBJECTIVE_SENSE = Rescode(1445)

"The objective sense has not been specified before the optimization."
const MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE = Rescode(1446)

"The solution item y is undefined."
const MSK_RES_ERR_Y_IS_UNDEFINED = Rescode(1449)

"An invalid floating value was used in some double data."
const MSK_RES_ERR_NAN_IN_DOUBLE_DATA = Rescode(1450)

"An infinite floating value was used in some double data."
const MSK_RES_ERR_INF_IN_DOUBLE_DATA = Rescode(1451)

"blc contains an invalid floating point value, i.e. a NaN."
const MSK_RES_ERR_NAN_IN_BLC = Rescode(1461)

"buc contains an invalid floating point value, i.e. a NaN."
const MSK_RES_ERR_NAN_IN_BUC = Rescode(1462)

"An invalid fixed term in the objective is speficied."
const MSK_RES_ERR_INVALID_CFIX = Rescode(1469)

"c contains an invalid floating point value, i.e. a NaN."
const MSK_RES_ERR_NAN_IN_C = Rescode(1470)

"blx contains an invalid floating point value, i.e. a NaN."
const MSK_RES_ERR_NAN_IN_BLX = Rescode(1471)

"bux contains an invalid floating point value, i.e. a NaN."
const MSK_RES_ERR_NAN_IN_BUX = Rescode(1472)

"a[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value."
const MSK_RES_ERR_INVALID_AIJ = Rescode(1473)

"c[j] contains an invalid floating point value, i.e. a NaN or an infinite value."
const MSK_RES_ERR_INVALID_CJ = Rescode(1474)

"A symmetric matrix contains an invalid floating point value, i.e. a NaN or an infinite value."
const MSK_RES_ERR_SYM_MAT_INVALID = Rescode(1480)

"A numerically huge value is specified for an element in E."
const MSK_RES_ERR_SYM_MAT_HUGE = Rescode(1482)

"Invalid problem type."
const MSK_RES_ERR_INV_PROBLEM = Rescode(1500)

"The problem contains both conic and nonlinear constraints."
const MSK_RES_ERR_MIXED_CONIC_AND_NL = Rescode(1501)

"The global optimizer can only be applied to problems without semidefinite variables."
const MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM = Rescode(1503)

"An invalid optimizer has been chosen for the problem."
const MSK_RES_ERR_INV_OPTIMIZER = Rescode(1550)

"No optimizer is available for the current class of integer optimization problems."
const MSK_RES_ERR_MIO_NO_OPTIMIZER = Rescode(1551)

"No optimizer is available for this class of optimization problems."
const MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE = Rescode(1552)

"An error occurred during the solution finalization."
const MSK_RES_ERR_FINAL_SOLUTION = Rescode(1560)

"Invalid first."
const MSK_RES_ERR_FIRST = Rescode(1570)

"Invalid last."
const MSK_RES_ERR_LAST = Rescode(1571)

"Invalid slice size specified."
const MSK_RES_ERR_SLICE_SIZE = Rescode(1572)

"Negative surplus."
const MSK_RES_ERR_NEGATIVE_SURPLUS = Rescode(1573)

"Cannot append a negative number."
const MSK_RES_ERR_NEGATIVE_APPEND = Rescode(1578)

"An error occurred during the postsolve."
const MSK_RES_ERR_POSTSOLVE = Rescode(1580)

"A computation produced an overflow."
const MSK_RES_ERR_OVERFLOW = Rescode(1590)

"No basic solution is defined."
const MSK_RES_ERR_NO_BASIS_SOL = Rescode(1600)

"The factorization of the basis is invalid."
const MSK_RES_ERR_BASIS_FACTOR = Rescode(1610)

"The basis is singular."
const MSK_RES_ERR_BASIS_SINGULAR = Rescode(1615)

"An error occurred while factorizing a matrix."
const MSK_RES_ERR_FACTOR = Rescode(1650)

"An optimization problem cannot be relaxed."
const MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX = Rescode(1700)

"The relaxed problem could not be solved to optimality."
const MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED = Rescode(1701)

"The upper bound is less than the lower bound for a variable or a constraint."
const MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND = Rescode(1702)

"The feasibility repair does not support the specified problem type."
const MSK_RES_ERR_REPAIR_INVALID_PROBLEM = Rescode(1710)

"Computation the optimal relaxation failed."
const MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED = Rescode(1711)

"A name is longer than the buffer that is supposed to hold it."
const MSK_RES_ERR_NAME_MAX_LEN = Rescode(1750)

"The name buffer is a null pointer."
const MSK_RES_ERR_NAME_IS_NULL = Rescode(1760)

"Invalid compression type."
const MSK_RES_ERR_INVALID_COMPRESSION = Rescode(1800)

"Invalid io mode."
const MSK_RES_ERR_INVALID_IOMODE = Rescode(1801)

"A certificate of primal infeasibility is not available."
const MSK_RES_ERR_NO_PRIMAL_INFEAS_CER = Rescode(2000)

"A certificate of dual infeasibility is not available."
const MSK_RES_ERR_NO_DUAL_INFEAS_CER = Rescode(2001)

"The required solution is not available."
const MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK = Rescode(2500)

"Invalid value in marki."
const MSK_RES_ERR_INV_MARKI = Rescode(2501)

"Invalid value in markj."
const MSK_RES_ERR_INV_MARKJ = Rescode(2502)

"Invalid numi."
const MSK_RES_ERR_INV_NUMI = Rescode(2503)

"Invalid numj."
const MSK_RES_ERR_INV_NUMJ = Rescode(2504)

"The Task file is incompatible with this platform."
const MSK_RES_ERR_TASK_INCOMPATIBLE = Rescode(2560)

"The Task file is invalid."
const MSK_RES_ERR_TASK_INVALID = Rescode(2561)

"Failed to write the task file."
const MSK_RES_ERR_TASK_WRITE = Rescode(2562)

"Could not compute the LU factors of the matrix within the maximum number of allowed tries."
const MSK_RES_ERR_LU_MAX_NUM_TRIES = Rescode(2800)

"An invalid UTF8 string is encountered."
const MSK_RES_ERR_INVALID_UTF8 = Rescode(2900)

"An invalid wchar string is encountered."
const MSK_RES_ERR_INVALID_WCHAR = Rescode(2901)

"No dual information is available for the integer solution."
const MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL = Rescode(2950)

"snx is not available for the basis solution."
const MSK_RES_ERR_NO_SNX_FOR_BAS_SOL = Rescode(2953)

"An internal error occurred."
const MSK_RES_ERR_INTERNAL = Rescode(3000)

"An input array was too short."
const MSK_RES_ERR_API_ARRAY_TOO_SMALL = Rescode(3001)

"Failed to connect a callback object."
const MSK_RES_ERR_API_CB_CONNECT = Rescode(3002)

"An internal error occurred in the API. Please report this problem."
const MSK_RES_ERR_API_FATAL_ERROR = Rescode(3005)

"Syntax error in sensitivity analysis file."
const MSK_RES_ERR_SEN_FORMAT = Rescode(3050)

"An undefined name was encountered in the sensitivity analysis file."
const MSK_RES_ERR_SEN_UNDEF_NAME = Rescode(3051)

"Index out of range in the sensitivity analysis file."
const MSK_RES_ERR_SEN_INDEX_RANGE = Rescode(3052)

"Analysis of upper bound requested for an index, where no upper bound exists."
const MSK_RES_ERR_SEN_BOUND_INVALID_UP = Rescode(3053)

"Analysis of lower bound requested for an index, where no lower bound exists."
const MSK_RES_ERR_SEN_BOUND_INVALID_LO = Rescode(3054)

"Invalid range given in the sensitivity file."
const MSK_RES_ERR_SEN_INDEX_INVALID = Rescode(3055)

"Syntax error in regexp or regexp longer than 1024."
const MSK_RES_ERR_SEN_INVALID_REGEXP = Rescode(3056)

"No optimal solution found to the original problem given for sensitivity analysis."
const MSK_RES_ERR_SEN_SOLUTION_STATUS = Rescode(3057)

"Numerical difficulties encountered performing the sensitivity analysis."
const MSK_RES_ERR_SEN_NUMERICAL = Rescode(3058)

"Sensitivity analysis cannot be performed for the specified problem."
const MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE = Rescode(3080)

"A step-size in an optimizer was unexpectedly unbounded."
const MSK_RES_ERR_UNB_STEP_SIZE = Rescode(3100)

"Some tasks related to this function call were identical. Unique tasks were expected."
const MSK_RES_ERR_IDENTICAL_TASKS = Rescode(3101)

"The code list data was invalid."
const MSK_RES_ERR_AD_INVALID_CODELIST = Rescode(3102)

"An internal unit test function failed."
const MSK_RES_ERR_INTERNAL_TEST_FAILED = Rescode(3500)

"The problem type is not supported by the XML format."
const MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE = Rescode(3600)

"Invalid AMPL stub."
const MSK_RES_ERR_INVALID_AMPL_STUB = Rescode(3700)

"A 64 bit integer could not be cast to a 32 bit integer."
const MSK_RES_ERR_INT64_TO_INT32_CAST = Rescode(3800)

"The computer contains more cpu cores than the license allows for."
const MSK_RES_ERR_SIZE_LICENSE_NUMCORES = Rescode(3900)

"The requested value is not defined for this solution type."
const MSK_RES_ERR_INFEAS_UNDEFINED = Rescode(3910)

"There is no barx available for the solution specified."
const MSK_RES_ERR_NO_BARX_FOR_SOLUTION = Rescode(3915)

"There is no bars available for the solution specified."
const MSK_RES_ERR_NO_BARS_FOR_SOLUTION = Rescode(3916)

"The dimension of a symmetric matrix variable has to be greater than 0."
const MSK_RES_ERR_BAR_VAR_DIM = Rescode(3920)

"A row index specified for sparse symmetric matrix is invalid."
const MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX = Rescode(3940)

"A column index specified for sparse symmetric matrix is invalid."
const MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX = Rescode(3941)

"Only the lower triangular part of sparse symmetric matrix should be specified."
const MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR = Rescode(3942)

"The numerical value specified in a sparse symmetric matrix is not a floating point value."
const MSK_RES_ERR_SYM_MAT_INVALID_VALUE = Rescode(3943)

"A value in a symmetric matric as been specified more than once."
const MSK_RES_ERR_SYM_MAT_DUPLICATE = Rescode(3944)

"A sparse symmetric matrix of invalid dimension is specified."
const MSK_RES_ERR_INVALID_SYM_MAT_DIM = Rescode(3950)

"An internal fatal error occurred in an interface function."
const MSK_RES_ERR_API_INTERNAL = Rescode(3999)

"The file format does not support a problem with symmetric matrix variables."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT = Rescode(4000)

"The file format does not support a problem with nonzero fixed term in c."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX = Rescode(4001)

"The file format does not support a problem with ranged constraints."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS = Rescode(4002)

"The file format does not support a problem with free constraints."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS = Rescode(4003)

"The file format does not support a problem with the simple cones (deprecated)."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES = Rescode(4005)

"The file format does not support a problem with quadratic terms."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS = Rescode(4006)

"The file format does not support a problem with nonlinear terms."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR = Rescode(4010)

"The file format does not support a problem with disjunctive constraints."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS = Rescode(4011)

"The file format does not support a problem with affine conic constraints."
const MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS = Rescode(4012)

"Two constraint names are identical."
const MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES = Rescode(4500)

"Two variable names are identical."
const MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES = Rescode(4501)

"Two barvariable names are identical."
const MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES = Rescode(4502)

"Two cone names are identical."
const MSK_RES_ERR_DUPLICATE_CONE_NAMES = Rescode(4503)

"Two domain names are identical."
const MSK_RES_ERR_DUPLICATE_DOMAIN_NAMES = Rescode(4504)

"Two disjunctive constraint names are identical."
const MSK_RES_ERR_DUPLICATE_DJC_NAMES = Rescode(4505)

"An array does not contain unique elements."
const MSK_RES_ERR_NON_UNIQUE_ARRAY = Rescode(5000)

"The value of a function argument is too small."
const MSK_RES_ERR_ARGUMENT_IS_TOO_SMALL = Rescode(5004)

"The value of a function argument is too large."
const MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE = Rescode(5005)

"A fatal error occurred in the mixed integer optimizer.  Please contact MOSEK support."
const MSK_RES_ERR_MIO_INTERNAL = Rescode(5010)

"An invalid problem type."
const MSK_RES_ERR_INVALID_PROBLEM_TYPE = Rescode(6000)

"Unhandled solution status."
const MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS = Rescode(6010)

"An element in the upper triangle of a lower triangular matrix is specified."
const MSK_RES_ERR_UPPER_TRIANGLE = Rescode(6020)

"A matrix is singular."
const MSK_RES_ERR_LAU_SINGULAR_MATRIX = Rescode(7000)

"A matrix is not positive definite."
const MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE = Rescode(7001)

"An invalid lower triangular matrix."
const MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX = Rescode(7002)

"An unknown error."
const MSK_RES_ERR_LAU_UNKNOWN = Rescode(7005)

"Invalid argument m."
const MSK_RES_ERR_LAU_ARG_M = Rescode(7010)

"Invalid argument n."
const MSK_RES_ERR_LAU_ARG_N = Rescode(7011)

"Invalid argument k."
const MSK_RES_ERR_LAU_ARG_K = Rescode(7012)

"Invalid argument transa."
const MSK_RES_ERR_LAU_ARG_TRANSA = Rescode(7015)

"Invalid argument transb."
const MSK_RES_ERR_LAU_ARG_TRANSB = Rescode(7016)

"Invalid argument uplo."
const MSK_RES_ERR_LAU_ARG_UPLO = Rescode(7017)

"Invalid argument trans."
const MSK_RES_ERR_LAU_ARG_TRANS = Rescode(7018)

"An invalid sparse symmetric matrix is specfified."
const MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX = Rescode(7019)

"An error occurred while parsing an CBF file."
const MSK_RES_ERR_CBF_PARSE = Rescode(7100)

"An invalid objective sense is specified."
const MSK_RES_ERR_CBF_OBJ_SENSE = Rescode(7101)

"An invalid objective sense is specified."
const MSK_RES_ERR_CBF_NO_VARIABLES = Rescode(7102)

"Too many constraints specified."
const MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS = Rescode(7103)

"Too many variables specified."
const MSK_RES_ERR_CBF_TOO_MANY_VARIABLES = Rescode(7104)

"No version specified."
const MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED = Rescode(7105)

"Invalid syntax."
const MSK_RES_ERR_CBF_SYNTAX = Rescode(7106)

"Duplicate OBJ keyword."
const MSK_RES_ERR_CBF_DUPLICATE_OBJ = Rescode(7107)

"Duplicate CON keyword."
const MSK_RES_ERR_CBF_DUPLICATE_CON = Rescode(7108)

"Duplicate VAR keyword."
const MSK_RES_ERR_CBF_DUPLICATE_VAR = Rescode(7110)

"Duplicate INT keyword."
const MSK_RES_ERR_CBF_DUPLICATE_INT = Rescode(7111)

"Invalid variable type."
const MSK_RES_ERR_CBF_INVALID_VAR_TYPE = Rescode(7112)

"Invalid constraint type."
const MSK_RES_ERR_CBF_INVALID_CON_TYPE = Rescode(7113)

"Invalid domain dimension."
const MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION = Rescode(7114)

"Duplicate index in OBJCOORD."
const MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD = Rescode(7115)

"Duplicate index in BCOORD."
const MSK_RES_ERR_CBF_DUPLICATE_BCOORD = Rescode(7116)

"Duplicate index in ACOORD."
const MSK_RES_ERR_CBF_DUPLICATE_ACOORD = Rescode(7117)

"Too few variables defined."
const MSK_RES_ERR_CBF_TOO_FEW_VARIABLES = Rescode(7118)

"Too few constraints defined."
const MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS = Rescode(7119)

"Too ints specified."
const MSK_RES_ERR_CBF_TOO_FEW_INTS = Rescode(7120)

"Too ints specified."
const MSK_RES_ERR_CBF_TOO_MANY_INTS = Rescode(7121)

"Invalid INT index."
const MSK_RES_ERR_CBF_INVALID_INT_INDEX = Rescode(7122)

"Unsupported feature is present."
const MSK_RES_ERR_CBF_UNSUPPORTED = Rescode(7123)

"Duplicate PSDVAR keyword."
const MSK_RES_ERR_CBF_DUPLICATE_PSDVAR = Rescode(7124)

"Invalid PSDVAR dimension."
const MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION = Rescode(7125)

"Too few variables defined."
const MSK_RES_ERR_CBF_TOO_FEW_PSDVAR = Rescode(7126)

"Invalid dimension of a exponential cone."
const MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION = Rescode(7127)

"Multiple POWCONES specified."
const MSK_RES_ERR_CBF_DUPLICATE_POW_CONES = Rescode(7130)

"Multiple POW*CONES specified."
const MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES = Rescode(7131)

"Invalid power specified."
const MSK_RES_ERR_CBF_INVALID_POWER = Rescode(7132)

"Power cone is too long."
const MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG = Rescode(7133)

"Invalid power cone index."
const MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX = Rescode(7134)

"Invalid power star cone index."
const MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX = Rescode(7135)

"An unhandled power cone type."
const MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE = Rescode(7136)

"An unhandled power star cone type."
const MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE = Rescode(7137)

"The power cone does not match with it definition."
const MSK_RES_ERR_CBF_POWER_CONE_MISMATCH = Rescode(7138)

"The power star cone does not match with it definition."
const MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH = Rescode(7139)

"Invalid number of cones."
const MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES = Rescode(7140)

"Invalid number of cones."
const MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES = Rescode(7141)

"Invalid number of OBJACOORD."
const MSK_RES_ERR_CBF_INVALID_NUM_OBJACOORD = Rescode(7150)

"Invalid number of OBJFCOORD."
const MSK_RES_ERR_CBF_INVALID_NUM_OBJFCOORD = Rescode(7151)

"Invalid number of ACOORD."
const MSK_RES_ERR_CBF_INVALID_NUM_ACOORD = Rescode(7152)

"Invalid number of BCOORD."
const MSK_RES_ERR_CBF_INVALID_NUM_BCOORD = Rescode(7153)

"Invalid number of FCOORD."
const MSK_RES_ERR_CBF_INVALID_NUM_FCOORD = Rescode(7155)

"Invalid number of HCOORD."
const MSK_RES_ERR_CBF_INVALID_NUM_HCOORD = Rescode(7156)

"Invalid number of DCOORD."
const MSK_RES_ERR_CBF_INVALID_NUM_DCOORD = Rescode(7157)

"Expected a key word."
const MSK_RES_ERR_CBF_EXPECTED_A_KEYWORD = Rescode(7158)

"Invalid number of PSDCON."
const MSK_RES_ERR_CBF_INVALID_NUM_PSDCON = Rescode(7200)

"Duplicate CON keyword."
const MSK_RES_ERR_CBF_DUPLICATE_PSDCON = Rescode(7201)

"Invalid PSDCON dimension."
const MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_PSDCON = Rescode(7202)

"Invalid PSDCON index."
const MSK_RES_ERR_CBF_INVALID_PSDCON_INDEX = Rescode(7203)

"Invalid PSDCON index."
const MSK_RES_ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX = Rescode(7204)

"Invalid PSDCON index."
const MSK_RES_ERR_CBF_INVALID_PSDCON_BLOCK_INDEX = Rescode(7205)

"The CHANGE section is not supported."
const MSK_RES_ERR_CBF_UNSUPPORTED_CHANGE = Rescode(7210)

"An invalid root optimizer was selected for the problem type."
const MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER = Rescode(7700)

"An invalid node optimizer was selected for the problem type."
const MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER = Rescode(7701)

"An invalid cone type occurs when writing a CPLEX formatted MPS file."
const MSK_RES_ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE = Rescode(7750)

"The matrix defining the quadratric part of constraint is not positive semidefinite."
const MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD = Rescode(7800)

"The quadratic constraint is an equality, thus not convex."
const MSK_RES_ERR_TOCONIC_CONSTRAINT_FX = Rescode(7801)

"The quadratic constraint has finite lower and upper bound, and therefore it is not convex."
const MSK_RES_ERR_TOCONIC_CONSTRAINT_RA = Rescode(7802)

"The constraint is not conic representable."
const MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC = Rescode(7803)

"The matrix defining the quadratric part of the objective function is not positive semidefinite."
const MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD = Rescode(7804)

"Failed to connect to remote solver server."
const MSK_RES_ERR_SERVER_CONNECT = Rescode(8000)

"Unexpected message or data from solver server."
const MSK_RES_ERR_SERVER_PROTOCOL = Rescode(8001)

"Server returned non-ok status code"
const MSK_RES_ERR_SERVER_STATUS = Rescode(8002)

"Invalid job ID"
const MSK_RES_ERR_SERVER_TOKEN = Rescode(8003)

"Invalid address"
const MSK_RES_ERR_SERVER_ADDRESS = Rescode(8004)

"Invalid TLS certificate format or path"
const MSK_RES_ERR_SERVER_CERTIFICATE = Rescode(8005)

"Failed to create TLS client"
const MSK_RES_ERR_SERVER_TLS_CLIENT = Rescode(8006)

"Invalid access token"
const MSK_RES_ERR_SERVER_ACCESS_TOKEN = Rescode(8007)

"The problem is too large."
const MSK_RES_ERR_SERVER_PROBLEM_SIZE = Rescode(8008)

"An element in a sparse matrix is specified twice."
const MSK_RES_ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX = Rescode(20050)

"An index is specified twice in an affine expression list."
const MSK_RES_ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST = Rescode(20060)

"An element in the F matrix is specified twice."
const MSK_RES_ERR_DUPLICATE_FIJ = Rescode(20100)

"f[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value."
const MSK_RES_ERR_INVALID_FIJ = Rescode(20101)

"A numerically huge value is specified for an element in F."
const MSK_RES_ERR_HUGE_FIJ = Rescode(20102)

"g contains an invalid floating point value, i.e. a NaN or an infinite value."
const MSK_RES_ERR_INVALID_G = Rescode(20103)

"b contains an invalid floating point value, i.e. a NaN or an infinite value."
const MSK_RES_ERR_INVALID_B = Rescode(20150)

"A domain index is invalid."
const MSK_RES_ERR_DOMAIN_INVALID_INDEX = Rescode(20400)

"A domain dimension is invalid."
const MSK_RES_ERR_DOMAIN_DIMENSION = Rescode(20401)

"A PSD domain dimension is invalid."
const MSK_RES_ERR_DOMAIN_DIMENSION_PSD = Rescode(20402)

"The function is only applicable to primal and dual power cone domains."
const MSK_RES_ERR_NOT_POWER_DOMAIN = Rescode(20403)

"Alpha contains an invalid floating point value, i.e. a NaN or an infinite value."
const MSK_RES_ERR_DOMAIN_POWER_INVALID_ALPHA = Rescode(20404)

"Alpha contains a negative value or zero."
const MSK_RES_ERR_DOMAIN_POWER_NEGATIVE_ALPHA = Rescode(20405)

"The value of nleft is too small or too large."
const MSK_RES_ERR_DOMAIN_POWER_NLEFT = Rescode(20406)

"An affine expression index is invalid."
const MSK_RES_ERR_AFE_INVALID_INDEX = Rescode(20500)

"A affine conic constraint index is invalid."
const MSK_RES_ERR_ACC_INVALID_INDEX = Rescode(20600)

"The index of an element in an affine conic constraint is invalid."
const MSK_RES_ERR_ACC_INVALID_ENTRY_INDEX = Rescode(20601)

"There is a mismatch between between the number of affine expressions and total dimension of the domain(s)."
const MSK_RES_ERR_ACC_AFE_DOMAIN_MISMATCH = Rescode(20602)

"A disjunctive constraint index is invalid."
const MSK_RES_ERR_DJC_INVALID_INDEX = Rescode(20700)

"An unsupported domain type has been used in a disjunctive constraint."
const MSK_RES_ERR_DJC_UNSUPPORTED_DOMAIN_TYPE = Rescode(20701)

"There is a mismatch between the number of affine expressions and total dimension of the domain(s)."
const MSK_RES_ERR_DJC_AFE_DOMAIN_MISMATCH = Rescode(20702)

"A termize is invalid."
const MSK_RES_ERR_DJC_INVALID_TERM_SIZE = Rescode(20703)

"There is a mismatch between the number of domains and the term sizes."
const MSK_RES_ERR_DJC_DOMAIN_TERMSIZE_MISMATCH = Rescode(20704)

"There total number of terms in all domains does not match."
const MSK_RES_ERR_DJC_TOTAL_NUM_TERMS_MISMATCH = Rescode(20705)

"The required solution is not defined."
const MSK_RES_ERR_UNDEF_SOLUTION = Rescode(22000)

"No doty is available."
const MSK_RES_ERR_NO_DOTY = Rescode(22010)

"The optimizer terminated at the maximum number of iterations."
const MSK_RES_TRM_MAX_ITERATIONS = Rescode(100000)

"The optimizer terminated at the maximum amount of time."
const MSK_RES_TRM_MAX_TIME = Rescode(100001)

"The optimizer terminated with an objective value outside the objective range."
const MSK_RES_TRM_OBJECTIVE_RANGE = Rescode(100002)

"The optimizer is terminated due to slow progress."
const MSK_RES_TRM_STALL = Rescode(100006)

"The user-defined progress callback function terminated the optimization."
const MSK_RES_TRM_USER_CALLBACK = Rescode(100007)

"The mixed-integer optimizer terminated as the maximum number of relaxations was reached."
const MSK_RES_TRM_MIO_NUM_RELAXS = Rescode(100008)

"The mixed-integer optimizer terminated as the maximum number of branches was reached."
const MSK_RES_TRM_MIO_NUM_BRANCHES = Rescode(100009)

"The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached."
const MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS = Rescode(100015)

"The optimizer terminated as the maximum number of set-backs was reached."
const MSK_RES_TRM_MAX_NUM_SETBACKS = Rescode(100020)

"The optimizer terminated due to a numerical problem."
const MSK_RES_TRM_NUMERICAL_PROBLEM = Rescode(100025)

"Lost a race."
const MSK_RES_TRM_LOST_RACE = Rescode(100027)

"The optimizer terminated due to some internal reason."
const MSK_RES_TRM_INTERNAL = Rescode(100030)

"The optimizer terminated for internal reasons."
const MSK_RES_TRM_INTERNAL_STOP = Rescode(100031)
tostr(v::Rescode) = if v.value == 0 "Mosek.MSK_RES_OK"
  elseif v.value == 50 "Mosek.MSK_RES_WRN_OPEN_PARAM_FILE"
  elseif v.value == 51 "Mosek.MSK_RES_WRN_LARGE_BOUND"
  elseif v.value == 52 "Mosek.MSK_RES_WRN_LARGE_LO_BOUND"
  elseif v.value == 53 "Mosek.MSK_RES_WRN_LARGE_UP_BOUND"
  elseif v.value == 54 "Mosek.MSK_RES_WRN_LARGE_CON_FX"
  elseif v.value == 57 "Mosek.MSK_RES_WRN_LARGE_CJ"
  elseif v.value == 62 "Mosek.MSK_RES_WRN_LARGE_AIJ"
  elseif v.value == 63 "Mosek.MSK_RES_WRN_ZERO_AIJ"
  elseif v.value == 65 "Mosek.MSK_RES_WRN_NAME_MAX_LEN"
  elseif v.value == 66 "Mosek.MSK_RES_WRN_SPAR_MAX_LEN"
  elseif v.value == 70 "Mosek.MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR"
  elseif v.value == 71 "Mosek.MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR"
  elseif v.value == 72 "Mosek.MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR"
  elseif v.value == 80 "Mosek.MSK_RES_WRN_LP_OLD_QUAD_FORMAT"
  elseif v.value == 85 "Mosek.MSK_RES_WRN_LP_DROP_VARIABLE"
  elseif v.value == 200 "Mosek.MSK_RES_WRN_NZ_IN_UPR_TRI"
  elseif v.value == 201 "Mosek.MSK_RES_WRN_DROPPED_NZ_QOBJ"
  elseif v.value == 250 "Mosek.MSK_RES_WRN_IGNORE_INTEGER"
  elseif v.value == 251 "Mosek.MSK_RES_WRN_NO_GLOBAL_OPTIMIZER"
  elseif v.value == 270 "Mosek.MSK_RES_WRN_MIO_INFEASIBLE_FINAL"
  elseif v.value == 300 "Mosek.MSK_RES_WRN_SOL_FILTER"
  elseif v.value == 350 "Mosek.MSK_RES_WRN_UNDEF_SOL_FILE_NAME"
  elseif v.value == 351 "Mosek.MSK_RES_WRN_SOL_FILE_IGNORED_CON"
  elseif v.value == 352 "Mosek.MSK_RES_WRN_SOL_FILE_IGNORED_VAR"
  elseif v.value == 400 "Mosek.MSK_RES_WRN_TOO_FEW_BASIS_VARS"
  elseif v.value == 405 "Mosek.MSK_RES_WRN_TOO_MANY_BASIS_VARS"
  elseif v.value == 500 "Mosek.MSK_RES_WRN_LICENSE_EXPIRE"
  elseif v.value == 501 "Mosek.MSK_RES_WRN_LICENSE_SERVER"
  elseif v.value == 502 "Mosek.MSK_RES_WRN_EMPTY_NAME"
  elseif v.value == 503 "Mosek.MSK_RES_WRN_USING_GENERIC_NAMES"
  elseif v.value == 504 "Mosek.MSK_RES_WRN_INVALID_MPS_NAME"
  elseif v.value == 505 "Mosek.MSK_RES_WRN_INVALID_MPS_OBJ_NAME"
  elseif v.value == 509 "Mosek.MSK_RES_WRN_LICENSE_FEATURE_EXPIRE"
  elseif v.value == 510 "Mosek.MSK_RES_WRN_PARAM_NAME_DOU"
  elseif v.value == 511 "Mosek.MSK_RES_WRN_PARAM_NAME_INT"
  elseif v.value == 512 "Mosek.MSK_RES_WRN_PARAM_NAME_STR"
  elseif v.value == 515 "Mosek.MSK_RES_WRN_PARAM_STR_VALUE"
  elseif v.value == 516 "Mosek.MSK_RES_WRN_PARAM_IGNORED_CMIO"
  elseif v.value == 705 "Mosek.MSK_RES_WRN_ZEROS_IN_SPARSE_ROW"
  elseif v.value == 710 "Mosek.MSK_RES_WRN_ZEROS_IN_SPARSE_COL"
  elseif v.value == 800 "Mosek.MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK"
  elseif v.value == 801 "Mosek.MSK_RES_WRN_ELIMINATOR_SPACE"
  elseif v.value == 802 "Mosek.MSK_RES_WRN_PRESOLVE_OUTOFSPACE"
  elseif v.value == 803 "Mosek.MSK_RES_WRN_PRESOLVE_PRIMAL_PERTUBATIONS"
  elseif v.value == 830 "Mosek.MSK_RES_WRN_WRITE_CHANGED_NAMES"
  elseif v.value == 831 "Mosek.MSK_RES_WRN_WRITE_DISCARDED_CFIX"
  elseif v.value == 850 "Mosek.MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES"
  elseif v.value == 851 "Mosek.MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES"
  elseif v.value == 852 "Mosek.MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES"
  elseif v.value == 853 "Mosek.MSK_RES_WRN_DUPLICATE_CONE_NAMES"
  elseif v.value == 854 "Mosek.MSK_RES_WRN_WRITE_LP_INVALID_VAR_NAMES"
  elseif v.value == 855 "Mosek.MSK_RES_WRN_WRITE_LP_DUPLICATE_VAR_NAMES"
  elseif v.value == 856 "Mosek.MSK_RES_WRN_WRITE_LP_INVALID_CON_NAMES"
  elseif v.value == 857 "Mosek.MSK_RES_WRN_WRITE_LP_DUPLICATE_CON_NAMES"
  elseif v.value == 900 "Mosek.MSK_RES_WRN_ANA_LARGE_BOUNDS"
  elseif v.value == 901 "Mosek.MSK_RES_WRN_ANA_C_ZERO"
  elseif v.value == 902 "Mosek.MSK_RES_WRN_ANA_EMPTY_COLS"
  elseif v.value == 903 "Mosek.MSK_RES_WRN_ANA_CLOSE_BOUNDS"
  elseif v.value == 904 "Mosek.MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS"
  elseif v.value == 930 "Mosek.MSK_RES_WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES"
  elseif v.value == 950 "Mosek.MSK_RES_WRN_NO_DUALIZER"
  elseif v.value == 960 "Mosek.MSK_RES_WRN_SYM_MAT_LARGE"
  elseif v.value == 970 "Mosek.MSK_RES_WRN_MODIFIED_DOUBLE_PARAMETER"
  elseif v.value == 980 "Mosek.MSK_RES_WRN_LARGE_FIJ"
  elseif v.value == 1000 "Mosek.MSK_RES_ERR_LICENSE"
  elseif v.value == 1001 "Mosek.MSK_RES_ERR_LICENSE_EXPIRED"
  elseif v.value == 1002 "Mosek.MSK_RES_ERR_LICENSE_VERSION"
  elseif v.value == 1003 "Mosek.MSK_RES_ERR_LICENSE_OLD_SERVER_VERSION"
  elseif v.value == 1005 "Mosek.MSK_RES_ERR_SIZE_LICENSE"
  elseif v.value == 1006 "Mosek.MSK_RES_ERR_PROB_LICENSE"
  elseif v.value == 1007 "Mosek.MSK_RES_ERR_FILE_LICENSE"
  elseif v.value == 1008 "Mosek.MSK_RES_ERR_MISSING_LICENSE_FILE"
  elseif v.value == 1010 "Mosek.MSK_RES_ERR_SIZE_LICENSE_CON"
  elseif v.value == 1011 "Mosek.MSK_RES_ERR_SIZE_LICENSE_VAR"
  elseif v.value == 1012 "Mosek.MSK_RES_ERR_SIZE_LICENSE_INTVAR"
  elseif v.value == 1013 "Mosek.MSK_RES_ERR_OPTIMIZER_LICENSE"
  elseif v.value == 1014 "Mosek.MSK_RES_ERR_FLEXLM"
  elseif v.value == 1015 "Mosek.MSK_RES_ERR_LICENSE_SERVER"
  elseif v.value == 1016 "Mosek.MSK_RES_ERR_LICENSE_MAX"
  elseif v.value == 1017 "Mosek.MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON"
  elseif v.value == 1018 "Mosek.MSK_RES_ERR_LICENSE_FEATURE"
  elseif v.value == 1019 "Mosek.MSK_RES_ERR_PLATFORM_NOT_LICENSED"
  elseif v.value == 1020 "Mosek.MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE"
  elseif v.value == 1021 "Mosek.MSK_RES_ERR_LICENSE_CANNOT_CONNECT"
  elseif v.value == 1025 "Mosek.MSK_RES_ERR_LICENSE_INVALID_HOSTID"
  elseif v.value == 1026 "Mosek.MSK_RES_ERR_LICENSE_SERVER_VERSION"
  elseif v.value == 1027 "Mosek.MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT"
  elseif v.value == 1028 "Mosek.MSK_RES_ERR_LICENSE_NO_SERVER_LINE"
  elseif v.value == 1035 "Mosek.MSK_RES_ERR_OLDER_DLL"
  elseif v.value == 1036 "Mosek.MSK_RES_ERR_NEWER_DLL"
  elseif v.value == 1040 "Mosek.MSK_RES_ERR_LINK_FILE_DLL"
  elseif v.value == 1045 "Mosek.MSK_RES_ERR_THREAD_MUTEX_INIT"
  elseif v.value == 1046 "Mosek.MSK_RES_ERR_THREAD_MUTEX_LOCK"
  elseif v.value == 1047 "Mosek.MSK_RES_ERR_THREAD_MUTEX_UNLOCK"
  elseif v.value == 1048 "Mosek.MSK_RES_ERR_THREAD_CREATE"
  elseif v.value == 1049 "Mosek.MSK_RES_ERR_THREAD_COND_INIT"
  elseif v.value == 1050 "Mosek.MSK_RES_ERR_UNKNOWN"
  elseif v.value == 1051 "Mosek.MSK_RES_ERR_SPACE"
  elseif v.value == 1052 "Mosek.MSK_RES_ERR_FILE_OPEN"
  elseif v.value == 1053 "Mosek.MSK_RES_ERR_FILE_READ"
  elseif v.value == 1054 "Mosek.MSK_RES_ERR_FILE_WRITE"
  elseif v.value == 1055 "Mosek.MSK_RES_ERR_DATA_FILE_EXT"
  elseif v.value == 1056 "Mosek.MSK_RES_ERR_INVALID_FILE_NAME"
  elseif v.value == 1057 "Mosek.MSK_RES_ERR_INVALID_SOL_FILE_NAME"
  elseif v.value == 1059 "Mosek.MSK_RES_ERR_END_OF_FILE"
  elseif v.value == 1060 "Mosek.MSK_RES_ERR_NULL_ENV"
  elseif v.value == 1061 "Mosek.MSK_RES_ERR_NULL_TASK"
  elseif v.value == 1062 "Mosek.MSK_RES_ERR_INVALID_STREAM"
  elseif v.value == 1063 "Mosek.MSK_RES_ERR_NO_INIT_ENV"
  elseif v.value == 1064 "Mosek.MSK_RES_ERR_INVALID_TASK"
  elseif v.value == 1065 "Mosek.MSK_RES_ERR_NULL_POINTER"
  elseif v.value == 1066 "Mosek.MSK_RES_ERR_LIVING_TASKS"
  elseif v.value == 1067 "Mosek.MSK_RES_ERR_READ_GZIP"
  elseif v.value == 1068 "Mosek.MSK_RES_ERR_READ_ZSTD"
  elseif v.value == 1070 "Mosek.MSK_RES_ERR_BLANK_NAME"
  elseif v.value == 1071 "Mosek.MSK_RES_ERR_DUP_NAME"
  elseif v.value == 1072 "Mosek.MSK_RES_ERR_FORMAT_STRING"
  elseif v.value == 1073 "Mosek.MSK_RES_ERR_SPARSITY_SPECIFICATION"
  elseif v.value == 1074 "Mosek.MSK_RES_ERR_MISMATCHING_DIMENSION"
  elseif v.value == 1075 "Mosek.MSK_RES_ERR_INVALID_OBJ_NAME"
  elseif v.value == 1076 "Mosek.MSK_RES_ERR_INVALID_CON_NAME"
  elseif v.value == 1077 "Mosek.MSK_RES_ERR_INVALID_VAR_NAME"
  elseif v.value == 1078 "Mosek.MSK_RES_ERR_INVALID_CONE_NAME"
  elseif v.value == 1079 "Mosek.MSK_RES_ERR_INVALID_BARVAR_NAME"
  elseif v.value == 1080 "Mosek.MSK_RES_ERR_SPACE_LEAKING"
  elseif v.value == 1081 "Mosek.MSK_RES_ERR_SPACE_NO_INFO"
  elseif v.value == 1082 "Mosek.MSK_RES_ERR_DIMENSION_SPECIFICATION"
  elseif v.value == 1083 "Mosek.MSK_RES_ERR_AXIS_NAME_SPECIFICATION"
  elseif v.value == 1090 "Mosek.MSK_RES_ERR_READ_FORMAT"
  elseif v.value == 1100 "Mosek.MSK_RES_ERR_MPS_FILE"
  elseif v.value == 1101 "Mosek.MSK_RES_ERR_MPS_INV_FIELD"
  elseif v.value == 1102 "Mosek.MSK_RES_ERR_MPS_INV_MARKER"
  elseif v.value == 1103 "Mosek.MSK_RES_ERR_MPS_NULL_CON_NAME"
  elseif v.value == 1104 "Mosek.MSK_RES_ERR_MPS_NULL_VAR_NAME"
  elseif v.value == 1105 "Mosek.MSK_RES_ERR_MPS_UNDEF_CON_NAME"
  elseif v.value == 1106 "Mosek.MSK_RES_ERR_MPS_UNDEF_VAR_NAME"
  elseif v.value == 1107 "Mosek.MSK_RES_ERR_MPS_INVALID_CON_KEY"
  elseif v.value == 1108 "Mosek.MSK_RES_ERR_MPS_INVALID_BOUND_KEY"
  elseif v.value == 1109 "Mosek.MSK_RES_ERR_MPS_INVALID_SEC_NAME"
  elseif v.value == 1110 "Mosek.MSK_RES_ERR_MPS_NO_OBJECTIVE"
  elseif v.value == 1111 "Mosek.MSK_RES_ERR_MPS_SPLITTED_VAR"
  elseif v.value == 1112 "Mosek.MSK_RES_ERR_MPS_MUL_CON_NAME"
  elseif v.value == 1113 "Mosek.MSK_RES_ERR_MPS_MUL_QSEC"
  elseif v.value == 1114 "Mosek.MSK_RES_ERR_MPS_MUL_QOBJ"
  elseif v.value == 1115 "Mosek.MSK_RES_ERR_MPS_INV_SEC_ORDER"
  elseif v.value == 1116 "Mosek.MSK_RES_ERR_MPS_MUL_CSEC"
  elseif v.value == 1117 "Mosek.MSK_RES_ERR_MPS_CONE_TYPE"
  elseif v.value == 1118 "Mosek.MSK_RES_ERR_MPS_CONE_OVERLAP"
  elseif v.value == 1119 "Mosek.MSK_RES_ERR_MPS_CONE_REPEAT"
  elseif v.value == 1120 "Mosek.MSK_RES_ERR_MPS_NON_SYMMETRIC_Q"
  elseif v.value == 1121 "Mosek.MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT"
  elseif v.value == 1122 "Mosek.MSK_RES_ERR_MPS_INVALID_OBJSENSE"
  elseif v.value == 1125 "Mosek.MSK_RES_ERR_MPS_TAB_IN_FIELD2"
  elseif v.value == 1126 "Mosek.MSK_RES_ERR_MPS_TAB_IN_FIELD3"
  elseif v.value == 1127 "Mosek.MSK_RES_ERR_MPS_TAB_IN_FIELD5"
  elseif v.value == 1128 "Mosek.MSK_RES_ERR_MPS_INVALID_OBJ_NAME"
  elseif v.value == 1129 "Mosek.MSK_RES_ERR_MPS_INVALID_KEY"
  elseif v.value == 1130 "Mosek.MSK_RES_ERR_MPS_INVALID_INDICATOR_CONSTRAINT"
  elseif v.value == 1131 "Mosek.MSK_RES_ERR_MPS_INVALID_INDICATOR_VARIABLE"
  elseif v.value == 1132 "Mosek.MSK_RES_ERR_MPS_INVALID_INDICATOR_VALUE"
  elseif v.value == 1133 "Mosek.MSK_RES_ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT"
  elseif v.value == 1134 "Mosek.MSK_RES_ERR_OPF_SYNTAX"
  elseif v.value == 1136 "Mosek.MSK_RES_ERR_OPF_PREMATURE_EOF"
  elseif v.value == 1137 "Mosek.MSK_RES_ERR_OPF_MISMATCHED_TAG"
  elseif v.value == 1138 "Mosek.MSK_RES_ERR_OPF_DUPLICATE_BOUND"
  elseif v.value == 1139 "Mosek.MSK_RES_ERR_OPF_DUPLICATE_CONSTRAINT_NAME"
  elseif v.value == 1140 "Mosek.MSK_RES_ERR_OPF_INVALID_CONE_TYPE"
  elseif v.value == 1141 "Mosek.MSK_RES_ERR_OPF_INCORRECT_TAG_PARAM"
  elseif v.value == 1142 "Mosek.MSK_RES_ERR_OPF_INVALID_TAG"
  elseif v.value == 1143 "Mosek.MSK_RES_ERR_OPF_DUPLICATE_CONE_ENTRY"
  elseif v.value == 1144 "Mosek.MSK_RES_ERR_OPF_TOO_LARGE"
  elseif v.value == 1146 "Mosek.MSK_RES_ERR_OPF_DUAL_INTEGER_SOLUTION"
  elseif v.value == 1151 "Mosek.MSK_RES_ERR_LP_EMPTY"
  elseif v.value == 1153 "Mosek.MSK_RES_ERR_WRITE_MPS_INVALID_NAME"
  elseif v.value == 1154 "Mosek.MSK_RES_ERR_LP_INVALID_VAR_NAME"
  elseif v.value == 1156 "Mosek.MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME"
  elseif v.value == 1157 "Mosek.MSK_RES_ERR_LP_FILE_FORMAT"
  elseif v.value == 1158 "Mosek.MSK_RES_ERR_LP_EXPECTED_NUMBER"
  elseif v.value == 1159 "Mosek.MSK_RES_ERR_READ_LP_MISSING_END_TAG"
  elseif v.value == 1160 "Mosek.MSK_RES_ERR_LP_INDICATOR_VAR"
  elseif v.value == 1161 "Mosek.MSK_RES_ERR_LP_EXPECTED_OBJECTIVE"
  elseif v.value == 1162 "Mosek.MSK_RES_ERR_LP_EXPECTED_CONSTRAINT_RELATION"
  elseif v.value == 1163 "Mosek.MSK_RES_ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND"
  elseif v.value == 1164 "Mosek.MSK_RES_ERR_LP_DUPLICATE_SECTION"
  elseif v.value == 1165 "Mosek.MSK_RES_ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED"
  elseif v.value == 1166 "Mosek.MSK_RES_ERR_WRITING_FILE"
  elseif v.value == 1170 "Mosek.MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE"
  elseif v.value == 1175 "Mosek.MSK_RES_ERR_JSON_SYNTAX"
  elseif v.value == 1176 "Mosek.MSK_RES_ERR_JSON_STRING"
  elseif v.value == 1177 "Mosek.MSK_RES_ERR_JSON_NUMBER_OVERFLOW"
  elseif v.value == 1178 "Mosek.MSK_RES_ERR_JSON_FORMAT"
  elseif v.value == 1179 "Mosek.MSK_RES_ERR_JSON_DATA"
  elseif v.value == 1180 "Mosek.MSK_RES_ERR_JSON_MISSING_DATA"
  elseif v.value == 1181 "Mosek.MSK_RES_ERR_PTF_INCOMPATIBILITY"
  elseif v.value == 1182 "Mosek.MSK_RES_ERR_PTF_UNDEFINED_ITEM"
  elseif v.value == 1183 "Mosek.MSK_RES_ERR_PTF_INCONSISTENCY"
  elseif v.value == 1184 "Mosek.MSK_RES_ERR_PTF_FORMAT"
  elseif v.value == 1197 "Mosek.MSK_RES_ERR_ARGUMENT_LENNEQ"
  elseif v.value == 1198 "Mosek.MSK_RES_ERR_ARGUMENT_TYPE"
  elseif v.value == 1199 "Mosek.MSK_RES_ERR_NUM_ARGUMENTS"
  elseif v.value == 1200 "Mosek.MSK_RES_ERR_IN_ARGUMENT"
  elseif v.value == 1201 "Mosek.MSK_RES_ERR_ARGUMENT_DIMENSION"
  elseif v.value == 1202 "Mosek.MSK_RES_ERR_SHAPE_IS_TOO_LARGE"
  elseif v.value == 1203 "Mosek.MSK_RES_ERR_INDEX_IS_TOO_SMALL"
  elseif v.value == 1204 "Mosek.MSK_RES_ERR_INDEX_IS_TOO_LARGE"
  elseif v.value == 1205 "Mosek.MSK_RES_ERR_INDEX_IS_NOT_UNIQUE"
  elseif v.value == 1206 "Mosek.MSK_RES_ERR_PARAM_NAME"
  elseif v.value == 1207 "Mosek.MSK_RES_ERR_PARAM_NAME_DOU"
  elseif v.value == 1208 "Mosek.MSK_RES_ERR_PARAM_NAME_INT"
  elseif v.value == 1209 "Mosek.MSK_RES_ERR_PARAM_NAME_STR"
  elseif v.value == 1210 "Mosek.MSK_RES_ERR_PARAM_INDEX"
  elseif v.value == 1215 "Mosek.MSK_RES_ERR_PARAM_IS_TOO_LARGE"
  elseif v.value == 1216 "Mosek.MSK_RES_ERR_PARAM_IS_TOO_SMALL"
  elseif v.value == 1217 "Mosek.MSK_RES_ERR_PARAM_VALUE_STR"
  elseif v.value == 1218 "Mosek.MSK_RES_ERR_PARAM_TYPE"
  elseif v.value == 1219 "Mosek.MSK_RES_ERR_INF_DOU_INDEX"
  elseif v.value == 1220 "Mosek.MSK_RES_ERR_INF_INT_INDEX"
  elseif v.value == 1221 "Mosek.MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL"
  elseif v.value == 1222 "Mosek.MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE"
  elseif v.value == 1225 "Mosek.MSK_RES_ERR_INF_LINT_INDEX"
  elseif v.value == 1226 "Mosek.MSK_RES_ERR_ARG_IS_TOO_SMALL"
  elseif v.value == 1227 "Mosek.MSK_RES_ERR_ARG_IS_TOO_LARGE"
  elseif v.value == 1228 "Mosek.MSK_RES_ERR_INVALID_WHICHSOL"
  elseif v.value == 1230 "Mosek.MSK_RES_ERR_INF_DOU_NAME"
  elseif v.value == 1231 "Mosek.MSK_RES_ERR_INF_INT_NAME"
  elseif v.value == 1232 "Mosek.MSK_RES_ERR_INF_TYPE"
  elseif v.value == 1234 "Mosek.MSK_RES_ERR_INF_LINT_NAME"
  elseif v.value == 1235 "Mosek.MSK_RES_ERR_INDEX"
  elseif v.value == 1236 "Mosek.MSK_RES_ERR_WHICHSOL"
  elseif v.value == 1237 "Mosek.MSK_RES_ERR_SOLITEM"
  elseif v.value == 1238 "Mosek.MSK_RES_ERR_WHICHITEM_NOT_ALLOWED"
  elseif v.value == 1240 "Mosek.MSK_RES_ERR_MAXNUMCON"
  elseif v.value == 1241 "Mosek.MSK_RES_ERR_MAXNUMVAR"
  elseif v.value == 1242 "Mosek.MSK_RES_ERR_MAXNUMBARVAR"
  elseif v.value == 1243 "Mosek.MSK_RES_ERR_MAXNUMQNZ"
  elseif v.value == 1245 "Mosek.MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ"
  elseif v.value == 1246 "Mosek.MSK_RES_ERR_INVALID_IDX"
  elseif v.value == 1247 "Mosek.MSK_RES_ERR_INVALID_MAX_NUM"
  elseif v.value == 1248 "Mosek.MSK_RES_ERR_UNALLOWED_WHICHSOL"
  elseif v.value == 1250 "Mosek.MSK_RES_ERR_NUMCONLIM"
  elseif v.value == 1251 "Mosek.MSK_RES_ERR_NUMVARLIM"
  elseif v.value == 1252 "Mosek.MSK_RES_ERR_TOO_SMALL_MAXNUMANZ"
  elseif v.value == 1253 "Mosek.MSK_RES_ERR_INV_APTRE"
  elseif v.value == 1254 "Mosek.MSK_RES_ERR_MUL_A_ELEMENT"
  elseif v.value == 1255 "Mosek.MSK_RES_ERR_INV_BK"
  elseif v.value == 1256 "Mosek.MSK_RES_ERR_INV_BKC"
  elseif v.value == 1257 "Mosek.MSK_RES_ERR_INV_BKX"
  elseif v.value == 1258 "Mosek.MSK_RES_ERR_INV_VAR_TYPE"
  elseif v.value == 1259 "Mosek.MSK_RES_ERR_SOLVER_PROBTYPE"
  elseif v.value == 1260 "Mosek.MSK_RES_ERR_OBJECTIVE_RANGE"
  elseif v.value == 1261 "Mosek.MSK_RES_ERR_INV_RESCODE"
  elseif v.value == 1262 "Mosek.MSK_RES_ERR_INV_IINF"
  elseif v.value == 1263 "Mosek.MSK_RES_ERR_INV_LIINF"
  elseif v.value == 1264 "Mosek.MSK_RES_ERR_INV_DINF"
  elseif v.value == 1266 "Mosek.MSK_RES_ERR_BASIS"
  elseif v.value == 1267 "Mosek.MSK_RES_ERR_INV_SKC"
  elseif v.value == 1268 "Mosek.MSK_RES_ERR_INV_SKX"
  elseif v.value == 1269 "Mosek.MSK_RES_ERR_INV_SK_STR"
  elseif v.value == 1270 "Mosek.MSK_RES_ERR_INV_SK"
  elseif v.value == 1271 "Mosek.MSK_RES_ERR_INV_CONE_TYPE_STR"
  elseif v.value == 1272 "Mosek.MSK_RES_ERR_INV_CONE_TYPE"
  elseif v.value == 1274 "Mosek.MSK_RES_ERR_INV_SKN"
  elseif v.value == 1275 "Mosek.MSK_RES_ERR_INVALID_SURPLUS"
  elseif v.value == 1280 "Mosek.MSK_RES_ERR_INV_NAME_ITEM"
  elseif v.value == 1281 "Mosek.MSK_RES_ERR_PRO_ITEM"
  elseif v.value == 1283 "Mosek.MSK_RES_ERR_INVALID_FORMAT_TYPE"
  elseif v.value == 1285 "Mosek.MSK_RES_ERR_FIRSTI"
  elseif v.value == 1286 "Mosek.MSK_RES_ERR_LASTI"
  elseif v.value == 1287 "Mosek.MSK_RES_ERR_FIRSTJ"
  elseif v.value == 1288 "Mosek.MSK_RES_ERR_LASTJ"
  elseif v.value == 1289 "Mosek.MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL"
  elseif v.value == 1290 "Mosek.MSK_RES_ERR_NONLINEAR_EQUALITY"
  elseif v.value == 1291 "Mosek.MSK_RES_ERR_NONCONVEX"
  elseif v.value == 1292 "Mosek.MSK_RES_ERR_NONLINEAR_RANGED"
  elseif v.value == 1293 "Mosek.MSK_RES_ERR_CON_Q_NOT_PSD"
  elseif v.value == 1294 "Mosek.MSK_RES_ERR_CON_Q_NOT_NSD"
  elseif v.value == 1295 "Mosek.MSK_RES_ERR_OBJ_Q_NOT_PSD"
  elseif v.value == 1296 "Mosek.MSK_RES_ERR_OBJ_Q_NOT_NSD"
  elseif v.value == 1299 "Mosek.MSK_RES_ERR_ARGUMENT_PERM_ARRAY"
  elseif v.value == 1300 "Mosek.MSK_RES_ERR_CONE_INDEX"
  elseif v.value == 1301 "Mosek.MSK_RES_ERR_CONE_SIZE"
  elseif v.value == 1302 "Mosek.MSK_RES_ERR_CONE_OVERLAP"
  elseif v.value == 1303 "Mosek.MSK_RES_ERR_CONE_REP_VAR"
  elseif v.value == 1304 "Mosek.MSK_RES_ERR_MAXNUMCONE"
  elseif v.value == 1305 "Mosek.MSK_RES_ERR_CONE_TYPE"
  elseif v.value == 1306 "Mosek.MSK_RES_ERR_CONE_TYPE_STR"
  elseif v.value == 1307 "Mosek.MSK_RES_ERR_CONE_OVERLAP_APPEND"
  elseif v.value == 1310 "Mosek.MSK_RES_ERR_REMOVE_CONE_VARIABLE"
  elseif v.value == 1311 "Mosek.MSK_RES_ERR_APPENDING_TOO_BIG_CONE"
  elseif v.value == 1320 "Mosek.MSK_RES_ERR_CONE_PARAMETER"
  elseif v.value == 1350 "Mosek.MSK_RES_ERR_SOL_FILE_INVALID_NUMBER"
  elseif v.value == 1375 "Mosek.MSK_RES_ERR_HUGE_C"
  elseif v.value == 1380 "Mosek.MSK_RES_ERR_HUGE_AIJ"
  elseif v.value == 1385 "Mosek.MSK_RES_ERR_DUPLICATE_AIJ"
  elseif v.value == 1390 "Mosek.MSK_RES_ERR_LOWER_BOUND_IS_A_NAN"
  elseif v.value == 1391 "Mosek.MSK_RES_ERR_UPPER_BOUND_IS_A_NAN"
  elseif v.value == 1400 "Mosek.MSK_RES_ERR_INFINITE_BOUND"
  elseif v.value == 1401 "Mosek.MSK_RES_ERR_INV_QOBJ_SUBI"
  elseif v.value == 1402 "Mosek.MSK_RES_ERR_INV_QOBJ_SUBJ"
  elseif v.value == 1403 "Mosek.MSK_RES_ERR_INV_QOBJ_VAL"
  elseif v.value == 1404 "Mosek.MSK_RES_ERR_INV_QCON_SUBK"
  elseif v.value == 1405 "Mosek.MSK_RES_ERR_INV_QCON_SUBI"
  elseif v.value == 1406 "Mosek.MSK_RES_ERR_INV_QCON_SUBJ"
  elseif v.value == 1407 "Mosek.MSK_RES_ERR_INV_QCON_VAL"
  elseif v.value == 1408 "Mosek.MSK_RES_ERR_QCON_SUBI_TOO_SMALL"
  elseif v.value == 1409 "Mosek.MSK_RES_ERR_QCON_SUBI_TOO_LARGE"
  elseif v.value == 1415 "Mosek.MSK_RES_ERR_QOBJ_UPPER_TRIANGLE"
  elseif v.value == 1417 "Mosek.MSK_RES_ERR_QCON_UPPER_TRIANGLE"
  elseif v.value == 1420 "Mosek.MSK_RES_ERR_FIXED_BOUND_VALUES"
  elseif v.value == 1421 "Mosek.MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE"
  elseif v.value == 1445 "Mosek.MSK_RES_ERR_INVALID_OBJECTIVE_SENSE"
  elseif v.value == 1446 "Mosek.MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE"
  elseif v.value == 1449 "Mosek.MSK_RES_ERR_Y_IS_UNDEFINED"
  elseif v.value == 1450 "Mosek.MSK_RES_ERR_NAN_IN_DOUBLE_DATA"
  elseif v.value == 1451 "Mosek.MSK_RES_ERR_INF_IN_DOUBLE_DATA"
  elseif v.value == 1461 "Mosek.MSK_RES_ERR_NAN_IN_BLC"
  elseif v.value == 1462 "Mosek.MSK_RES_ERR_NAN_IN_BUC"
  elseif v.value == 1469 "Mosek.MSK_RES_ERR_INVALID_CFIX"
  elseif v.value == 1470 "Mosek.MSK_RES_ERR_NAN_IN_C"
  elseif v.value == 1471 "Mosek.MSK_RES_ERR_NAN_IN_BLX"
  elseif v.value == 1472 "Mosek.MSK_RES_ERR_NAN_IN_BUX"
  elseif v.value == 1473 "Mosek.MSK_RES_ERR_INVALID_AIJ"
  elseif v.value == 1474 "Mosek.MSK_RES_ERR_INVALID_CJ"
  elseif v.value == 1480 "Mosek.MSK_RES_ERR_SYM_MAT_INVALID"
  elseif v.value == 1482 "Mosek.MSK_RES_ERR_SYM_MAT_HUGE"
  elseif v.value == 1500 "Mosek.MSK_RES_ERR_INV_PROBLEM"
  elseif v.value == 1501 "Mosek.MSK_RES_ERR_MIXED_CONIC_AND_NL"
  elseif v.value == 1503 "Mosek.MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM"
  elseif v.value == 1550 "Mosek.MSK_RES_ERR_INV_OPTIMIZER"
  elseif v.value == 1551 "Mosek.MSK_RES_ERR_MIO_NO_OPTIMIZER"
  elseif v.value == 1552 "Mosek.MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE"
  elseif v.value == 1560 "Mosek.MSK_RES_ERR_FINAL_SOLUTION"
  elseif v.value == 1570 "Mosek.MSK_RES_ERR_FIRST"
  elseif v.value == 1571 "Mosek.MSK_RES_ERR_LAST"
  elseif v.value == 1572 "Mosek.MSK_RES_ERR_SLICE_SIZE"
  elseif v.value == 1573 "Mosek.MSK_RES_ERR_NEGATIVE_SURPLUS"
  elseif v.value == 1578 "Mosek.MSK_RES_ERR_NEGATIVE_APPEND"
  elseif v.value == 1580 "Mosek.MSK_RES_ERR_POSTSOLVE"
  elseif v.value == 1590 "Mosek.MSK_RES_ERR_OVERFLOW"
  elseif v.value == 1600 "Mosek.MSK_RES_ERR_NO_BASIS_SOL"
  elseif v.value == 1610 "Mosek.MSK_RES_ERR_BASIS_FACTOR"
  elseif v.value == 1615 "Mosek.MSK_RES_ERR_BASIS_SINGULAR"
  elseif v.value == 1650 "Mosek.MSK_RES_ERR_FACTOR"
  elseif v.value == 1700 "Mosek.MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX"
  elseif v.value == 1701 "Mosek.MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED"
  elseif v.value == 1702 "Mosek.MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND"
  elseif v.value == 1710 "Mosek.MSK_RES_ERR_REPAIR_INVALID_PROBLEM"
  elseif v.value == 1711 "Mosek.MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED"
  elseif v.value == 1750 "Mosek.MSK_RES_ERR_NAME_MAX_LEN"
  elseif v.value == 1760 "Mosek.MSK_RES_ERR_NAME_IS_NULL"
  elseif v.value == 1800 "Mosek.MSK_RES_ERR_INVALID_COMPRESSION"
  elseif v.value == 1801 "Mosek.MSK_RES_ERR_INVALID_IOMODE"
  elseif v.value == 2000 "Mosek.MSK_RES_ERR_NO_PRIMAL_INFEAS_CER"
  elseif v.value == 2001 "Mosek.MSK_RES_ERR_NO_DUAL_INFEAS_CER"
  elseif v.value == 2500 "Mosek.MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK"
  elseif v.value == 2501 "Mosek.MSK_RES_ERR_INV_MARKI"
  elseif v.value == 2502 "Mosek.MSK_RES_ERR_INV_MARKJ"
  elseif v.value == 2503 "Mosek.MSK_RES_ERR_INV_NUMI"
  elseif v.value == 2504 "Mosek.MSK_RES_ERR_INV_NUMJ"
  elseif v.value == 2560 "Mosek.MSK_RES_ERR_TASK_INCOMPATIBLE"
  elseif v.value == 2561 "Mosek.MSK_RES_ERR_TASK_INVALID"
  elseif v.value == 2562 "Mosek.MSK_RES_ERR_TASK_WRITE"
  elseif v.value == 2800 "Mosek.MSK_RES_ERR_LU_MAX_NUM_TRIES"
  elseif v.value == 2900 "Mosek.MSK_RES_ERR_INVALID_UTF8"
  elseif v.value == 2901 "Mosek.MSK_RES_ERR_INVALID_WCHAR"
  elseif v.value == 2950 "Mosek.MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL"
  elseif v.value == 2953 "Mosek.MSK_RES_ERR_NO_SNX_FOR_BAS_SOL"
  elseif v.value == 3000 "Mosek.MSK_RES_ERR_INTERNAL"
  elseif v.value == 3001 "Mosek.MSK_RES_ERR_API_ARRAY_TOO_SMALL"
  elseif v.value == 3002 "Mosek.MSK_RES_ERR_API_CB_CONNECT"
  elseif v.value == 3005 "Mosek.MSK_RES_ERR_API_FATAL_ERROR"
  elseif v.value == 3050 "Mosek.MSK_RES_ERR_SEN_FORMAT"
  elseif v.value == 3051 "Mosek.MSK_RES_ERR_SEN_UNDEF_NAME"
  elseif v.value == 3052 "Mosek.MSK_RES_ERR_SEN_INDEX_RANGE"
  elseif v.value == 3053 "Mosek.MSK_RES_ERR_SEN_BOUND_INVALID_UP"
  elseif v.value == 3054 "Mosek.MSK_RES_ERR_SEN_BOUND_INVALID_LO"
  elseif v.value == 3055 "Mosek.MSK_RES_ERR_SEN_INDEX_INVALID"
  elseif v.value == 3056 "Mosek.MSK_RES_ERR_SEN_INVALID_REGEXP"
  elseif v.value == 3057 "Mosek.MSK_RES_ERR_SEN_SOLUTION_STATUS"
  elseif v.value == 3058 "Mosek.MSK_RES_ERR_SEN_NUMERICAL"
  elseif v.value == 3080 "Mosek.MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE"
  elseif v.value == 3100 "Mosek.MSK_RES_ERR_UNB_STEP_SIZE"
  elseif v.value == 3101 "Mosek.MSK_RES_ERR_IDENTICAL_TASKS"
  elseif v.value == 3102 "Mosek.MSK_RES_ERR_AD_INVALID_CODELIST"
  elseif v.value == 3500 "Mosek.MSK_RES_ERR_INTERNAL_TEST_FAILED"
  elseif v.value == 3600 "Mosek.MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE"
  elseif v.value == 3700 "Mosek.MSK_RES_ERR_INVALID_AMPL_STUB"
  elseif v.value == 3800 "Mosek.MSK_RES_ERR_INT64_TO_INT32_CAST"
  elseif v.value == 3900 "Mosek.MSK_RES_ERR_SIZE_LICENSE_NUMCORES"
  elseif v.value == 3910 "Mosek.MSK_RES_ERR_INFEAS_UNDEFINED"
  elseif v.value == 3915 "Mosek.MSK_RES_ERR_NO_BARX_FOR_SOLUTION"
  elseif v.value == 3916 "Mosek.MSK_RES_ERR_NO_BARS_FOR_SOLUTION"
  elseif v.value == 3920 "Mosek.MSK_RES_ERR_BAR_VAR_DIM"
  elseif v.value == 3940 "Mosek.MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX"
  elseif v.value == 3941 "Mosek.MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX"
  elseif v.value == 3942 "Mosek.MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR"
  elseif v.value == 3943 "Mosek.MSK_RES_ERR_SYM_MAT_INVALID_VALUE"
  elseif v.value == 3944 "Mosek.MSK_RES_ERR_SYM_MAT_DUPLICATE"
  elseif v.value == 3950 "Mosek.MSK_RES_ERR_INVALID_SYM_MAT_DIM"
  elseif v.value == 3999 "Mosek.MSK_RES_ERR_API_INTERNAL"
  elseif v.value == 4000 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT"
  elseif v.value == 4001 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX"
  elseif v.value == 4002 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS"
  elseif v.value == 4003 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS"
  elseif v.value == 4005 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES"
  elseif v.value == 4006 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS"
  elseif v.value == 4010 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR"
  elseif v.value == 4011 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS"
  elseif v.value == 4012 "Mosek.MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS"
  elseif v.value == 4500 "Mosek.MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES"
  elseif v.value == 4501 "Mosek.MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES"
  elseif v.value == 4502 "Mosek.MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES"
  elseif v.value == 4503 "Mosek.MSK_RES_ERR_DUPLICATE_CONE_NAMES"
  elseif v.value == 4504 "Mosek.MSK_RES_ERR_DUPLICATE_DOMAIN_NAMES"
  elseif v.value == 4505 "Mosek.MSK_RES_ERR_DUPLICATE_DJC_NAMES"
  elseif v.value == 5000 "Mosek.MSK_RES_ERR_NON_UNIQUE_ARRAY"
  elseif v.value == 5004 "Mosek.MSK_RES_ERR_ARGUMENT_IS_TOO_SMALL"
  elseif v.value == 5005 "Mosek.MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE"
  elseif v.value == 5010 "Mosek.MSK_RES_ERR_MIO_INTERNAL"
  elseif v.value == 6000 "Mosek.MSK_RES_ERR_INVALID_PROBLEM_TYPE"
  elseif v.value == 6010 "Mosek.MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS"
  elseif v.value == 6020 "Mosek.MSK_RES_ERR_UPPER_TRIANGLE"
  elseif v.value == 7000 "Mosek.MSK_RES_ERR_LAU_SINGULAR_MATRIX"
  elseif v.value == 7001 "Mosek.MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE"
  elseif v.value == 7002 "Mosek.MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX"
  elseif v.value == 7005 "Mosek.MSK_RES_ERR_LAU_UNKNOWN"
  elseif v.value == 7010 "Mosek.MSK_RES_ERR_LAU_ARG_M"
  elseif v.value == 7011 "Mosek.MSK_RES_ERR_LAU_ARG_N"
  elseif v.value == 7012 "Mosek.MSK_RES_ERR_LAU_ARG_K"
  elseif v.value == 7015 "Mosek.MSK_RES_ERR_LAU_ARG_TRANSA"
  elseif v.value == 7016 "Mosek.MSK_RES_ERR_LAU_ARG_TRANSB"
  elseif v.value == 7017 "Mosek.MSK_RES_ERR_LAU_ARG_UPLO"
  elseif v.value == 7018 "Mosek.MSK_RES_ERR_LAU_ARG_TRANS"
  elseif v.value == 7019 "Mosek.MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX"
  elseif v.value == 7100 "Mosek.MSK_RES_ERR_CBF_PARSE"
  elseif v.value == 7101 "Mosek.MSK_RES_ERR_CBF_OBJ_SENSE"
  elseif v.value == 7102 "Mosek.MSK_RES_ERR_CBF_NO_VARIABLES"
  elseif v.value == 7103 "Mosek.MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS"
  elseif v.value == 7104 "Mosek.MSK_RES_ERR_CBF_TOO_MANY_VARIABLES"
  elseif v.value == 7105 "Mosek.MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED"
  elseif v.value == 7106 "Mosek.MSK_RES_ERR_CBF_SYNTAX"
  elseif v.value == 7107 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_OBJ"
  elseif v.value == 7108 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_CON"
  elseif v.value == 7110 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_VAR"
  elseif v.value == 7111 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_INT"
  elseif v.value == 7112 "Mosek.MSK_RES_ERR_CBF_INVALID_VAR_TYPE"
  elseif v.value == 7113 "Mosek.MSK_RES_ERR_CBF_INVALID_CON_TYPE"
  elseif v.value == 7114 "Mosek.MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION"
  elseif v.value == 7115 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD"
  elseif v.value == 7116 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_BCOORD"
  elseif v.value == 7117 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_ACOORD"
  elseif v.value == 7118 "Mosek.MSK_RES_ERR_CBF_TOO_FEW_VARIABLES"
  elseif v.value == 7119 "Mosek.MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS"
  elseif v.value == 7120 "Mosek.MSK_RES_ERR_CBF_TOO_FEW_INTS"
  elseif v.value == 7121 "Mosek.MSK_RES_ERR_CBF_TOO_MANY_INTS"
  elseif v.value == 7122 "Mosek.MSK_RES_ERR_CBF_INVALID_INT_INDEX"
  elseif v.value == 7123 "Mosek.MSK_RES_ERR_CBF_UNSUPPORTED"
  elseif v.value == 7124 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_PSDVAR"
  elseif v.value == 7125 "Mosek.MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION"
  elseif v.value == 7126 "Mosek.MSK_RES_ERR_CBF_TOO_FEW_PSDVAR"
  elseif v.value == 7127 "Mosek.MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION"
  elseif v.value == 7130 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_POW_CONES"
  elseif v.value == 7131 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES"
  elseif v.value == 7132 "Mosek.MSK_RES_ERR_CBF_INVALID_POWER"
  elseif v.value == 7133 "Mosek.MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG"
  elseif v.value == 7134 "Mosek.MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX"
  elseif v.value == 7135 "Mosek.MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX"
  elseif v.value == 7136 "Mosek.MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE"
  elseif v.value == 7137 "Mosek.MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE"
  elseif v.value == 7138 "Mosek.MSK_RES_ERR_CBF_POWER_CONE_MISMATCH"
  elseif v.value == 7139 "Mosek.MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH"
  elseif v.value == 7140 "Mosek.MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES"
  elseif v.value == 7141 "Mosek.MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES"
  elseif v.value == 7150 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_OBJACOORD"
  elseif v.value == 7151 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_OBJFCOORD"
  elseif v.value == 7152 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_ACOORD"
  elseif v.value == 7153 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_BCOORD"
  elseif v.value == 7155 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_FCOORD"
  elseif v.value == 7156 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_HCOORD"
  elseif v.value == 7157 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_DCOORD"
  elseif v.value == 7158 "Mosek.MSK_RES_ERR_CBF_EXPECTED_A_KEYWORD"
  elseif v.value == 7200 "Mosek.MSK_RES_ERR_CBF_INVALID_NUM_PSDCON"
  elseif v.value == 7201 "Mosek.MSK_RES_ERR_CBF_DUPLICATE_PSDCON"
  elseif v.value == 7202 "Mosek.MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_PSDCON"
  elseif v.value == 7203 "Mosek.MSK_RES_ERR_CBF_INVALID_PSDCON_INDEX"
  elseif v.value == 7204 "Mosek.MSK_RES_ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX"
  elseif v.value == 7205 "Mosek.MSK_RES_ERR_CBF_INVALID_PSDCON_BLOCK_INDEX"
  elseif v.value == 7210 "Mosek.MSK_RES_ERR_CBF_UNSUPPORTED_CHANGE"
  elseif v.value == 7700 "Mosek.MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER"
  elseif v.value == 7701 "Mosek.MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER"
  elseif v.value == 7750 "Mosek.MSK_RES_ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE"
  elseif v.value == 7800 "Mosek.MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD"
  elseif v.value == 7801 "Mosek.MSK_RES_ERR_TOCONIC_CONSTRAINT_FX"
  elseif v.value == 7802 "Mosek.MSK_RES_ERR_TOCONIC_CONSTRAINT_RA"
  elseif v.value == 7803 "Mosek.MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC"
  elseif v.value == 7804 "Mosek.MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD"
  elseif v.value == 8000 "Mosek.MSK_RES_ERR_SERVER_CONNECT"
  elseif v.value == 8001 "Mosek.MSK_RES_ERR_SERVER_PROTOCOL"
  elseif v.value == 8002 "Mosek.MSK_RES_ERR_SERVER_STATUS"
  elseif v.value == 8003 "Mosek.MSK_RES_ERR_SERVER_TOKEN"
  elseif v.value == 8004 "Mosek.MSK_RES_ERR_SERVER_ADDRESS"
  elseif v.value == 8005 "Mosek.MSK_RES_ERR_SERVER_CERTIFICATE"
  elseif v.value == 8006 "Mosek.MSK_RES_ERR_SERVER_TLS_CLIENT"
  elseif v.value == 8007 "Mosek.MSK_RES_ERR_SERVER_ACCESS_TOKEN"
  elseif v.value == 8008 "Mosek.MSK_RES_ERR_SERVER_PROBLEM_SIZE"
  elseif v.value == 20050 "Mosek.MSK_RES_ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX"
  elseif v.value == 20060 "Mosek.MSK_RES_ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST"
  elseif v.value == 20100 "Mosek.MSK_RES_ERR_DUPLICATE_FIJ"
  elseif v.value == 20101 "Mosek.MSK_RES_ERR_INVALID_FIJ"
  elseif v.value == 20102 "Mosek.MSK_RES_ERR_HUGE_FIJ"
  elseif v.value == 20103 "Mosek.MSK_RES_ERR_INVALID_G"
  elseif v.value == 20150 "Mosek.MSK_RES_ERR_INVALID_B"
  elseif v.value == 20400 "Mosek.MSK_RES_ERR_DOMAIN_INVALID_INDEX"
  elseif v.value == 20401 "Mosek.MSK_RES_ERR_DOMAIN_DIMENSION"
  elseif v.value == 20402 "Mosek.MSK_RES_ERR_DOMAIN_DIMENSION_PSD"
  elseif v.value == 20403 "Mosek.MSK_RES_ERR_NOT_POWER_DOMAIN"
  elseif v.value == 20404 "Mosek.MSK_RES_ERR_DOMAIN_POWER_INVALID_ALPHA"
  elseif v.value == 20405 "Mosek.MSK_RES_ERR_DOMAIN_POWER_NEGATIVE_ALPHA"
  elseif v.value == 20406 "Mosek.MSK_RES_ERR_DOMAIN_POWER_NLEFT"
  elseif v.value == 20500 "Mosek.MSK_RES_ERR_AFE_INVALID_INDEX"
  elseif v.value == 20600 "Mosek.MSK_RES_ERR_ACC_INVALID_INDEX"
  elseif v.value == 20601 "Mosek.MSK_RES_ERR_ACC_INVALID_ENTRY_INDEX"
  elseif v.value == 20602 "Mosek.MSK_RES_ERR_ACC_AFE_DOMAIN_MISMATCH"
  elseif v.value == 20700 "Mosek.MSK_RES_ERR_DJC_INVALID_INDEX"
  elseif v.value == 20701 "Mosek.MSK_RES_ERR_DJC_UNSUPPORTED_DOMAIN_TYPE"
  elseif v.value == 20702 "Mosek.MSK_RES_ERR_DJC_AFE_DOMAIN_MISMATCH"
  elseif v.value == 20703 "Mosek.MSK_RES_ERR_DJC_INVALID_TERM_SIZE"
  elseif v.value == 20704 "Mosek.MSK_RES_ERR_DJC_DOMAIN_TERMSIZE_MISMATCH"
  elseif v.value == 20705 "Mosek.MSK_RES_ERR_DJC_TOTAL_NUM_TERMS_MISMATCH"
  elseif v.value == 22000 "Mosek.MSK_RES_ERR_UNDEF_SOLUTION"
  elseif v.value == 22010 "Mosek.MSK_RES_ERR_NO_DOTY"
  elseif v.value == 100000 "Mosek.MSK_RES_TRM_MAX_ITERATIONS"
  elseif v.value == 100001 "Mosek.MSK_RES_TRM_MAX_TIME"
  elseif v.value == 100002 "Mosek.MSK_RES_TRM_OBJECTIVE_RANGE"
  elseif v.value == 100006 "Mosek.MSK_RES_TRM_STALL"
  elseif v.value == 100007 "Mosek.MSK_RES_TRM_USER_CALLBACK"
  elseif v.value == 100008 "Mosek.MSK_RES_TRM_MIO_NUM_RELAXS"
  elseif v.value == 100009 "Mosek.MSK_RES_TRM_MIO_NUM_BRANCHES"
  elseif v.value == 100015 "Mosek.MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS"
  elseif v.value == 100020 "Mosek.MSK_RES_TRM_MAX_NUM_SETBACKS"
  elseif v.value == 100025 "Mosek.MSK_RES_TRM_NUMERICAL_PROBLEM"
  elseif v.value == 100027 "Mosek.MSK_RES_TRM_LOST_RACE"
  elseif v.value == 100030 "Mosek.MSK_RES_TRM_INTERNAL"
  elseif v.value == 100031 "Mosek.MSK_RES_TRM_INTERNAL_STOP"
  else "Mosek.Rescode(?)"
  end
const Rescode_members = Rescode[
    MSK_RES_OK,
    MSK_RES_WRN_OPEN_PARAM_FILE,
    MSK_RES_WRN_LARGE_BOUND,
    MSK_RES_WRN_LARGE_LO_BOUND,
    MSK_RES_WRN_LARGE_UP_BOUND,
    MSK_RES_WRN_LARGE_CON_FX,
    MSK_RES_WRN_LARGE_CJ,
    MSK_RES_WRN_LARGE_AIJ,
    MSK_RES_WRN_ZERO_AIJ,
    MSK_RES_WRN_NAME_MAX_LEN,
    MSK_RES_WRN_SPAR_MAX_LEN,
    MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR,
    MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR,
    MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR,
    MSK_RES_WRN_LP_OLD_QUAD_FORMAT,
    MSK_RES_WRN_LP_DROP_VARIABLE,
    MSK_RES_WRN_NZ_IN_UPR_TRI,
    MSK_RES_WRN_DROPPED_NZ_QOBJ,
    MSK_RES_WRN_IGNORE_INTEGER,
    MSK_RES_WRN_NO_GLOBAL_OPTIMIZER,
    MSK_RES_WRN_MIO_INFEASIBLE_FINAL,
    MSK_RES_WRN_SOL_FILTER,
    MSK_RES_WRN_UNDEF_SOL_FILE_NAME,
    MSK_RES_WRN_SOL_FILE_IGNORED_CON,
    MSK_RES_WRN_SOL_FILE_IGNORED_VAR,
    MSK_RES_WRN_TOO_FEW_BASIS_VARS,
    MSK_RES_WRN_TOO_MANY_BASIS_VARS,
    MSK_RES_WRN_LICENSE_EXPIRE,
    MSK_RES_WRN_LICENSE_SERVER,
    MSK_RES_WRN_EMPTY_NAME,
    MSK_RES_WRN_USING_GENERIC_NAMES,
    MSK_RES_WRN_INVALID_MPS_NAME,
    MSK_RES_WRN_INVALID_MPS_OBJ_NAME,
    MSK_RES_WRN_LICENSE_FEATURE_EXPIRE,
    MSK_RES_WRN_PARAM_NAME_DOU,
    MSK_RES_WRN_PARAM_NAME_INT,
    MSK_RES_WRN_PARAM_NAME_STR,
    MSK_RES_WRN_PARAM_STR_VALUE,
    MSK_RES_WRN_PARAM_IGNORED_CMIO,
    MSK_RES_WRN_ZEROS_IN_SPARSE_ROW,
    MSK_RES_WRN_ZEROS_IN_SPARSE_COL,
    MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK,
    MSK_RES_WRN_ELIMINATOR_SPACE,
    MSK_RES_WRN_PRESOLVE_OUTOFSPACE,
    MSK_RES_WRN_PRESOLVE_PRIMAL_PERTUBATIONS,
    MSK_RES_WRN_WRITE_CHANGED_NAMES,
    MSK_RES_WRN_WRITE_DISCARDED_CFIX,
    MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES,
    MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES,
    MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES,
    MSK_RES_WRN_DUPLICATE_CONE_NAMES,
    MSK_RES_WRN_WRITE_LP_INVALID_VAR_NAMES,
    MSK_RES_WRN_WRITE_LP_DUPLICATE_VAR_NAMES,
    MSK_RES_WRN_WRITE_LP_INVALID_CON_NAMES,
    MSK_RES_WRN_WRITE_LP_DUPLICATE_CON_NAMES,
    MSK_RES_WRN_ANA_LARGE_BOUNDS,
    MSK_RES_WRN_ANA_C_ZERO,
    MSK_RES_WRN_ANA_EMPTY_COLS,
    MSK_RES_WRN_ANA_CLOSE_BOUNDS,
    MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS,
    MSK_RES_WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES,
    MSK_RES_WRN_NO_DUALIZER,
    MSK_RES_WRN_SYM_MAT_LARGE,
    MSK_RES_WRN_MODIFIED_DOUBLE_PARAMETER,
    MSK_RES_WRN_LARGE_FIJ,
    MSK_RES_ERR_LICENSE,
    MSK_RES_ERR_LICENSE_EXPIRED,
    MSK_RES_ERR_LICENSE_VERSION,
    MSK_RES_ERR_LICENSE_OLD_SERVER_VERSION,
    MSK_RES_ERR_SIZE_LICENSE,
    MSK_RES_ERR_PROB_LICENSE,
    MSK_RES_ERR_FILE_LICENSE,
    MSK_RES_ERR_MISSING_LICENSE_FILE,
    MSK_RES_ERR_SIZE_LICENSE_CON,
    MSK_RES_ERR_SIZE_LICENSE_VAR,
    MSK_RES_ERR_SIZE_LICENSE_INTVAR,
    MSK_RES_ERR_OPTIMIZER_LICENSE,
    MSK_RES_ERR_FLEXLM,
    MSK_RES_ERR_LICENSE_SERVER,
    MSK_RES_ERR_LICENSE_MAX,
    MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON,
    MSK_RES_ERR_LICENSE_FEATURE,
    MSK_RES_ERR_PLATFORM_NOT_LICENSED,
    MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE,
    MSK_RES_ERR_LICENSE_CANNOT_CONNECT,
    MSK_RES_ERR_LICENSE_INVALID_HOSTID,
    MSK_RES_ERR_LICENSE_SERVER_VERSION,
    MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT,
    MSK_RES_ERR_LICENSE_NO_SERVER_LINE,
    MSK_RES_ERR_OLDER_DLL,
    MSK_RES_ERR_NEWER_DLL,
    MSK_RES_ERR_LINK_FILE_DLL,
    MSK_RES_ERR_THREAD_MUTEX_INIT,
    MSK_RES_ERR_THREAD_MUTEX_LOCK,
    MSK_RES_ERR_THREAD_MUTEX_UNLOCK,
    MSK_RES_ERR_THREAD_CREATE,
    MSK_RES_ERR_THREAD_COND_INIT,
    MSK_RES_ERR_UNKNOWN,
    MSK_RES_ERR_SPACE,
    MSK_RES_ERR_FILE_OPEN,
    MSK_RES_ERR_FILE_READ,
    MSK_RES_ERR_FILE_WRITE,
    MSK_RES_ERR_DATA_FILE_EXT,
    MSK_RES_ERR_INVALID_FILE_NAME,
    MSK_RES_ERR_INVALID_SOL_FILE_NAME,
    MSK_RES_ERR_END_OF_FILE,
    MSK_RES_ERR_NULL_ENV,
    MSK_RES_ERR_NULL_TASK,
    MSK_RES_ERR_INVALID_STREAM,
    MSK_RES_ERR_NO_INIT_ENV,
    MSK_RES_ERR_INVALID_TASK,
    MSK_RES_ERR_NULL_POINTER,
    MSK_RES_ERR_LIVING_TASKS,
    MSK_RES_ERR_READ_GZIP,
    MSK_RES_ERR_READ_ZSTD,
    MSK_RES_ERR_BLANK_NAME,
    MSK_RES_ERR_DUP_NAME,
    MSK_RES_ERR_FORMAT_STRING,
    MSK_RES_ERR_SPARSITY_SPECIFICATION,
    MSK_RES_ERR_MISMATCHING_DIMENSION,
    MSK_RES_ERR_INVALID_OBJ_NAME,
    MSK_RES_ERR_INVALID_CON_NAME,
    MSK_RES_ERR_INVALID_VAR_NAME,
    MSK_RES_ERR_INVALID_CONE_NAME,
    MSK_RES_ERR_INVALID_BARVAR_NAME,
    MSK_RES_ERR_SPACE_LEAKING,
    MSK_RES_ERR_SPACE_NO_INFO,
    MSK_RES_ERR_DIMENSION_SPECIFICATION,
    MSK_RES_ERR_AXIS_NAME_SPECIFICATION,
    MSK_RES_ERR_READ_FORMAT,
    MSK_RES_ERR_MPS_FILE,
    MSK_RES_ERR_MPS_INV_FIELD,
    MSK_RES_ERR_MPS_INV_MARKER,
    MSK_RES_ERR_MPS_NULL_CON_NAME,
    MSK_RES_ERR_MPS_NULL_VAR_NAME,
    MSK_RES_ERR_MPS_UNDEF_CON_NAME,
    MSK_RES_ERR_MPS_UNDEF_VAR_NAME,
    MSK_RES_ERR_MPS_INVALID_CON_KEY,
    MSK_RES_ERR_MPS_INVALID_BOUND_KEY,
    MSK_RES_ERR_MPS_INVALID_SEC_NAME,
    MSK_RES_ERR_MPS_NO_OBJECTIVE,
    MSK_RES_ERR_MPS_SPLITTED_VAR,
    MSK_RES_ERR_MPS_MUL_CON_NAME,
    MSK_RES_ERR_MPS_MUL_QSEC,
    MSK_RES_ERR_MPS_MUL_QOBJ,
    MSK_RES_ERR_MPS_INV_SEC_ORDER,
    MSK_RES_ERR_MPS_MUL_CSEC,
    MSK_RES_ERR_MPS_CONE_TYPE,
    MSK_RES_ERR_MPS_CONE_OVERLAP,
    MSK_RES_ERR_MPS_CONE_REPEAT,
    MSK_RES_ERR_MPS_NON_SYMMETRIC_Q,
    MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT,
    MSK_RES_ERR_MPS_INVALID_OBJSENSE,
    MSK_RES_ERR_MPS_TAB_IN_FIELD2,
    MSK_RES_ERR_MPS_TAB_IN_FIELD3,
    MSK_RES_ERR_MPS_TAB_IN_FIELD5,
    MSK_RES_ERR_MPS_INVALID_OBJ_NAME,
    MSK_RES_ERR_MPS_INVALID_KEY,
    MSK_RES_ERR_MPS_INVALID_INDICATOR_CONSTRAINT,
    MSK_RES_ERR_MPS_INVALID_INDICATOR_VARIABLE,
    MSK_RES_ERR_MPS_INVALID_INDICATOR_VALUE,
    MSK_RES_ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT,
    MSK_RES_ERR_OPF_SYNTAX,
    MSK_RES_ERR_OPF_PREMATURE_EOF,
    MSK_RES_ERR_OPF_MISMATCHED_TAG,
    MSK_RES_ERR_OPF_DUPLICATE_BOUND,
    MSK_RES_ERR_OPF_DUPLICATE_CONSTRAINT_NAME,
    MSK_RES_ERR_OPF_INVALID_CONE_TYPE,
    MSK_RES_ERR_OPF_INCORRECT_TAG_PARAM,
    MSK_RES_ERR_OPF_INVALID_TAG,
    MSK_RES_ERR_OPF_DUPLICATE_CONE_ENTRY,
    MSK_RES_ERR_OPF_TOO_LARGE,
    MSK_RES_ERR_OPF_DUAL_INTEGER_SOLUTION,
    MSK_RES_ERR_LP_EMPTY,
    MSK_RES_ERR_WRITE_MPS_INVALID_NAME,
    MSK_RES_ERR_LP_INVALID_VAR_NAME,
    MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME,
    MSK_RES_ERR_LP_FILE_FORMAT,
    MSK_RES_ERR_LP_EXPECTED_NUMBER,
    MSK_RES_ERR_READ_LP_MISSING_END_TAG,
    MSK_RES_ERR_LP_INDICATOR_VAR,
    MSK_RES_ERR_LP_EXPECTED_OBJECTIVE,
    MSK_RES_ERR_LP_EXPECTED_CONSTRAINT_RELATION,
    MSK_RES_ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND,
    MSK_RES_ERR_LP_DUPLICATE_SECTION,
    MSK_RES_ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED,
    MSK_RES_ERR_WRITING_FILE,
    MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE,
    MSK_RES_ERR_JSON_SYNTAX,
    MSK_RES_ERR_JSON_STRING,
    MSK_RES_ERR_JSON_NUMBER_OVERFLOW,
    MSK_RES_ERR_JSON_FORMAT,
    MSK_RES_ERR_JSON_DATA,
    MSK_RES_ERR_JSON_MISSING_DATA,
    MSK_RES_ERR_PTF_INCOMPATIBILITY,
    MSK_RES_ERR_PTF_UNDEFINED_ITEM,
    MSK_RES_ERR_PTF_INCONSISTENCY,
    MSK_RES_ERR_PTF_FORMAT,
    MSK_RES_ERR_ARGUMENT_LENNEQ,
    MSK_RES_ERR_ARGUMENT_TYPE,
    MSK_RES_ERR_NUM_ARGUMENTS,
    MSK_RES_ERR_IN_ARGUMENT,
    MSK_RES_ERR_ARGUMENT_DIMENSION,
    MSK_RES_ERR_SHAPE_IS_TOO_LARGE,
    MSK_RES_ERR_INDEX_IS_TOO_SMALL,
    MSK_RES_ERR_INDEX_IS_TOO_LARGE,
    MSK_RES_ERR_INDEX_IS_NOT_UNIQUE,
    MSK_RES_ERR_PARAM_NAME,
    MSK_RES_ERR_PARAM_NAME_DOU,
    MSK_RES_ERR_PARAM_NAME_INT,
    MSK_RES_ERR_PARAM_NAME_STR,
    MSK_RES_ERR_PARAM_INDEX,
    MSK_RES_ERR_PARAM_IS_TOO_LARGE,
    MSK_RES_ERR_PARAM_IS_TOO_SMALL,
    MSK_RES_ERR_PARAM_VALUE_STR,
    MSK_RES_ERR_PARAM_TYPE,
    MSK_RES_ERR_INF_DOU_INDEX,
    MSK_RES_ERR_INF_INT_INDEX,
    MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL,
    MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE,
    MSK_RES_ERR_INF_LINT_INDEX,
    MSK_RES_ERR_ARG_IS_TOO_SMALL,
    MSK_RES_ERR_ARG_IS_TOO_LARGE,
    MSK_RES_ERR_INVALID_WHICHSOL,
    MSK_RES_ERR_INF_DOU_NAME,
    MSK_RES_ERR_INF_INT_NAME,
    MSK_RES_ERR_INF_TYPE,
    MSK_RES_ERR_INF_LINT_NAME,
    MSK_RES_ERR_INDEX,
    MSK_RES_ERR_WHICHSOL,
    MSK_RES_ERR_SOLITEM,
    MSK_RES_ERR_WHICHITEM_NOT_ALLOWED,
    MSK_RES_ERR_MAXNUMCON,
    MSK_RES_ERR_MAXNUMVAR,
    MSK_RES_ERR_MAXNUMBARVAR,
    MSK_RES_ERR_MAXNUMQNZ,
    MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ,
    MSK_RES_ERR_INVALID_IDX,
    MSK_RES_ERR_INVALID_MAX_NUM,
    MSK_RES_ERR_UNALLOWED_WHICHSOL,
    MSK_RES_ERR_NUMCONLIM,
    MSK_RES_ERR_NUMVARLIM,
    MSK_RES_ERR_TOO_SMALL_MAXNUMANZ,
    MSK_RES_ERR_INV_APTRE,
    MSK_RES_ERR_MUL_A_ELEMENT,
    MSK_RES_ERR_INV_BK,
    MSK_RES_ERR_INV_BKC,
    MSK_RES_ERR_INV_BKX,
    MSK_RES_ERR_INV_VAR_TYPE,
    MSK_RES_ERR_SOLVER_PROBTYPE,
    MSK_RES_ERR_OBJECTIVE_RANGE,
    MSK_RES_ERR_INV_RESCODE,
    MSK_RES_ERR_INV_IINF,
    MSK_RES_ERR_INV_LIINF,
    MSK_RES_ERR_INV_DINF,
    MSK_RES_ERR_BASIS,
    MSK_RES_ERR_INV_SKC,
    MSK_RES_ERR_INV_SKX,
    MSK_RES_ERR_INV_SK_STR,
    MSK_RES_ERR_INV_SK,
    MSK_RES_ERR_INV_CONE_TYPE_STR,
    MSK_RES_ERR_INV_CONE_TYPE,
    MSK_RES_ERR_INV_SKN,
    MSK_RES_ERR_INVALID_SURPLUS,
    MSK_RES_ERR_INV_NAME_ITEM,
    MSK_RES_ERR_PRO_ITEM,
    MSK_RES_ERR_INVALID_FORMAT_TYPE,
    MSK_RES_ERR_FIRSTI,
    MSK_RES_ERR_LASTI,
    MSK_RES_ERR_FIRSTJ,
    MSK_RES_ERR_LASTJ,
    MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL,
    MSK_RES_ERR_NONLINEAR_EQUALITY,
    MSK_RES_ERR_NONCONVEX,
    MSK_RES_ERR_NONLINEAR_RANGED,
    MSK_RES_ERR_CON_Q_NOT_PSD,
    MSK_RES_ERR_CON_Q_NOT_NSD,
    MSK_RES_ERR_OBJ_Q_NOT_PSD,
    MSK_RES_ERR_OBJ_Q_NOT_NSD,
    MSK_RES_ERR_ARGUMENT_PERM_ARRAY,
    MSK_RES_ERR_CONE_INDEX,
    MSK_RES_ERR_CONE_SIZE,
    MSK_RES_ERR_CONE_OVERLAP,
    MSK_RES_ERR_CONE_REP_VAR,
    MSK_RES_ERR_MAXNUMCONE,
    MSK_RES_ERR_CONE_TYPE,
    MSK_RES_ERR_CONE_TYPE_STR,
    MSK_RES_ERR_CONE_OVERLAP_APPEND,
    MSK_RES_ERR_REMOVE_CONE_VARIABLE,
    MSK_RES_ERR_APPENDING_TOO_BIG_CONE,
    MSK_RES_ERR_CONE_PARAMETER,
    MSK_RES_ERR_SOL_FILE_INVALID_NUMBER,
    MSK_RES_ERR_HUGE_C,
    MSK_RES_ERR_HUGE_AIJ,
    MSK_RES_ERR_DUPLICATE_AIJ,
    MSK_RES_ERR_LOWER_BOUND_IS_A_NAN,
    MSK_RES_ERR_UPPER_BOUND_IS_A_NAN,
    MSK_RES_ERR_INFINITE_BOUND,
    MSK_RES_ERR_INV_QOBJ_SUBI,
    MSK_RES_ERR_INV_QOBJ_SUBJ,
    MSK_RES_ERR_INV_QOBJ_VAL,
    MSK_RES_ERR_INV_QCON_SUBK,
    MSK_RES_ERR_INV_QCON_SUBI,
    MSK_RES_ERR_INV_QCON_SUBJ,
    MSK_RES_ERR_INV_QCON_VAL,
    MSK_RES_ERR_QCON_SUBI_TOO_SMALL,
    MSK_RES_ERR_QCON_SUBI_TOO_LARGE,
    MSK_RES_ERR_QOBJ_UPPER_TRIANGLE,
    MSK_RES_ERR_QCON_UPPER_TRIANGLE,
    MSK_RES_ERR_FIXED_BOUND_VALUES,
    MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE,
    MSK_RES_ERR_INVALID_OBJECTIVE_SENSE,
    MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE,
    MSK_RES_ERR_Y_IS_UNDEFINED,
    MSK_RES_ERR_NAN_IN_DOUBLE_DATA,
    MSK_RES_ERR_INF_IN_DOUBLE_DATA,
    MSK_RES_ERR_NAN_IN_BLC,
    MSK_RES_ERR_NAN_IN_BUC,
    MSK_RES_ERR_INVALID_CFIX,
    MSK_RES_ERR_NAN_IN_C,
    MSK_RES_ERR_NAN_IN_BLX,
    MSK_RES_ERR_NAN_IN_BUX,
    MSK_RES_ERR_INVALID_AIJ,
    MSK_RES_ERR_INVALID_CJ,
    MSK_RES_ERR_SYM_MAT_INVALID,
    MSK_RES_ERR_SYM_MAT_HUGE,
    MSK_RES_ERR_INV_PROBLEM,
    MSK_RES_ERR_MIXED_CONIC_AND_NL,
    MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM,
    MSK_RES_ERR_INV_OPTIMIZER,
    MSK_RES_ERR_MIO_NO_OPTIMIZER,
    MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE,
    MSK_RES_ERR_FINAL_SOLUTION,
    MSK_RES_ERR_FIRST,
    MSK_RES_ERR_LAST,
    MSK_RES_ERR_SLICE_SIZE,
    MSK_RES_ERR_NEGATIVE_SURPLUS,
    MSK_RES_ERR_NEGATIVE_APPEND,
    MSK_RES_ERR_POSTSOLVE,
    MSK_RES_ERR_OVERFLOW,
    MSK_RES_ERR_NO_BASIS_SOL,
    MSK_RES_ERR_BASIS_FACTOR,
    MSK_RES_ERR_BASIS_SINGULAR,
    MSK_RES_ERR_FACTOR,
    MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX,
    MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED,
    MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND,
    MSK_RES_ERR_REPAIR_INVALID_PROBLEM,
    MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED,
    MSK_RES_ERR_NAME_MAX_LEN,
    MSK_RES_ERR_NAME_IS_NULL,
    MSK_RES_ERR_INVALID_COMPRESSION,
    MSK_RES_ERR_INVALID_IOMODE,
    MSK_RES_ERR_NO_PRIMAL_INFEAS_CER,
    MSK_RES_ERR_NO_DUAL_INFEAS_CER,
    MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK,
    MSK_RES_ERR_INV_MARKI,
    MSK_RES_ERR_INV_MARKJ,
    MSK_RES_ERR_INV_NUMI,
    MSK_RES_ERR_INV_NUMJ,
    MSK_RES_ERR_TASK_INCOMPATIBLE,
    MSK_RES_ERR_TASK_INVALID,
    MSK_RES_ERR_TASK_WRITE,
    MSK_RES_ERR_LU_MAX_NUM_TRIES,
    MSK_RES_ERR_INVALID_UTF8,
    MSK_RES_ERR_INVALID_WCHAR,
    MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL,
    MSK_RES_ERR_NO_SNX_FOR_BAS_SOL,
    MSK_RES_ERR_INTERNAL,
    MSK_RES_ERR_API_ARRAY_TOO_SMALL,
    MSK_RES_ERR_API_CB_CONNECT,
    MSK_RES_ERR_API_FATAL_ERROR,
    MSK_RES_ERR_SEN_FORMAT,
    MSK_RES_ERR_SEN_UNDEF_NAME,
    MSK_RES_ERR_SEN_INDEX_RANGE,
    MSK_RES_ERR_SEN_BOUND_INVALID_UP,
    MSK_RES_ERR_SEN_BOUND_INVALID_LO,
    MSK_RES_ERR_SEN_INDEX_INVALID,
    MSK_RES_ERR_SEN_INVALID_REGEXP,
    MSK_RES_ERR_SEN_SOLUTION_STATUS,
    MSK_RES_ERR_SEN_NUMERICAL,
    MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE,
    MSK_RES_ERR_UNB_STEP_SIZE,
    MSK_RES_ERR_IDENTICAL_TASKS,
    MSK_RES_ERR_AD_INVALID_CODELIST,
    MSK_RES_ERR_INTERNAL_TEST_FAILED,
    MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE,
    MSK_RES_ERR_INVALID_AMPL_STUB,
    MSK_RES_ERR_INT64_TO_INT32_CAST,
    MSK_RES_ERR_SIZE_LICENSE_NUMCORES,
    MSK_RES_ERR_INFEAS_UNDEFINED,
    MSK_RES_ERR_NO_BARX_FOR_SOLUTION,
    MSK_RES_ERR_NO_BARS_FOR_SOLUTION,
    MSK_RES_ERR_BAR_VAR_DIM,
    MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX,
    MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX,
    MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR,
    MSK_RES_ERR_SYM_MAT_INVALID_VALUE,
    MSK_RES_ERR_SYM_MAT_DUPLICATE,
    MSK_RES_ERR_INVALID_SYM_MAT_DIM,
    MSK_RES_ERR_API_INTERNAL,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS,
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS,
    MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES,
    MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES,
    MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES,
    MSK_RES_ERR_DUPLICATE_CONE_NAMES,
    MSK_RES_ERR_DUPLICATE_DOMAIN_NAMES,
    MSK_RES_ERR_DUPLICATE_DJC_NAMES,
    MSK_RES_ERR_NON_UNIQUE_ARRAY,
    MSK_RES_ERR_ARGUMENT_IS_TOO_SMALL,
    MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE,
    MSK_RES_ERR_MIO_INTERNAL,
    MSK_RES_ERR_INVALID_PROBLEM_TYPE,
    MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS,
    MSK_RES_ERR_UPPER_TRIANGLE,
    MSK_RES_ERR_LAU_SINGULAR_MATRIX,
    MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE,
    MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX,
    MSK_RES_ERR_LAU_UNKNOWN,
    MSK_RES_ERR_LAU_ARG_M,
    MSK_RES_ERR_LAU_ARG_N,
    MSK_RES_ERR_LAU_ARG_K,
    MSK_RES_ERR_LAU_ARG_TRANSA,
    MSK_RES_ERR_LAU_ARG_TRANSB,
    MSK_RES_ERR_LAU_ARG_UPLO,
    MSK_RES_ERR_LAU_ARG_TRANS,
    MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX,
    MSK_RES_ERR_CBF_PARSE,
    MSK_RES_ERR_CBF_OBJ_SENSE,
    MSK_RES_ERR_CBF_NO_VARIABLES,
    MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS,
    MSK_RES_ERR_CBF_TOO_MANY_VARIABLES,
    MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED,
    MSK_RES_ERR_CBF_SYNTAX,
    MSK_RES_ERR_CBF_DUPLICATE_OBJ,
    MSK_RES_ERR_CBF_DUPLICATE_CON,
    MSK_RES_ERR_CBF_DUPLICATE_VAR,
    MSK_RES_ERR_CBF_DUPLICATE_INT,
    MSK_RES_ERR_CBF_INVALID_VAR_TYPE,
    MSK_RES_ERR_CBF_INVALID_CON_TYPE,
    MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION,
    MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD,
    MSK_RES_ERR_CBF_DUPLICATE_BCOORD,
    MSK_RES_ERR_CBF_DUPLICATE_ACOORD,
    MSK_RES_ERR_CBF_TOO_FEW_VARIABLES,
    MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS,
    MSK_RES_ERR_CBF_TOO_FEW_INTS,
    MSK_RES_ERR_CBF_TOO_MANY_INTS,
    MSK_RES_ERR_CBF_INVALID_INT_INDEX,
    MSK_RES_ERR_CBF_UNSUPPORTED,
    MSK_RES_ERR_CBF_DUPLICATE_PSDVAR,
    MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION,
    MSK_RES_ERR_CBF_TOO_FEW_PSDVAR,
    MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION,
    MSK_RES_ERR_CBF_DUPLICATE_POW_CONES,
    MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES,
    MSK_RES_ERR_CBF_INVALID_POWER,
    MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG,
    MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX,
    MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX,
    MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE,
    MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE,
    MSK_RES_ERR_CBF_POWER_CONE_MISMATCH,
    MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH,
    MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES,
    MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES,
    MSK_RES_ERR_CBF_INVALID_NUM_OBJACOORD,
    MSK_RES_ERR_CBF_INVALID_NUM_OBJFCOORD,
    MSK_RES_ERR_CBF_INVALID_NUM_ACOORD,
    MSK_RES_ERR_CBF_INVALID_NUM_BCOORD,
    MSK_RES_ERR_CBF_INVALID_NUM_FCOORD,
    MSK_RES_ERR_CBF_INVALID_NUM_HCOORD,
    MSK_RES_ERR_CBF_INVALID_NUM_DCOORD,
    MSK_RES_ERR_CBF_EXPECTED_A_KEYWORD,
    MSK_RES_ERR_CBF_INVALID_NUM_PSDCON,
    MSK_RES_ERR_CBF_DUPLICATE_PSDCON,
    MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_PSDCON,
    MSK_RES_ERR_CBF_INVALID_PSDCON_INDEX,
    MSK_RES_ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX,
    MSK_RES_ERR_CBF_INVALID_PSDCON_BLOCK_INDEX,
    MSK_RES_ERR_CBF_UNSUPPORTED_CHANGE,
    MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER,
    MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER,
    MSK_RES_ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE,
    MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD,
    MSK_RES_ERR_TOCONIC_CONSTRAINT_FX,
    MSK_RES_ERR_TOCONIC_CONSTRAINT_RA,
    MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC,
    MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD,
    MSK_RES_ERR_SERVER_CONNECT,
    MSK_RES_ERR_SERVER_PROTOCOL,
    MSK_RES_ERR_SERVER_STATUS,
    MSK_RES_ERR_SERVER_TOKEN,
    MSK_RES_ERR_SERVER_ADDRESS,
    MSK_RES_ERR_SERVER_CERTIFICATE,
    MSK_RES_ERR_SERVER_TLS_CLIENT,
    MSK_RES_ERR_SERVER_ACCESS_TOKEN,
    MSK_RES_ERR_SERVER_PROBLEM_SIZE,
    MSK_RES_ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX,
    MSK_RES_ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST,
    MSK_RES_ERR_DUPLICATE_FIJ,
    MSK_RES_ERR_INVALID_FIJ,
    MSK_RES_ERR_HUGE_FIJ,
    MSK_RES_ERR_INVALID_G,
    MSK_RES_ERR_INVALID_B,
    MSK_RES_ERR_DOMAIN_INVALID_INDEX,
    MSK_RES_ERR_DOMAIN_DIMENSION,
    MSK_RES_ERR_DOMAIN_DIMENSION_PSD,
    MSK_RES_ERR_NOT_POWER_DOMAIN,
    MSK_RES_ERR_DOMAIN_POWER_INVALID_ALPHA,
    MSK_RES_ERR_DOMAIN_POWER_NEGATIVE_ALPHA,
    MSK_RES_ERR_DOMAIN_POWER_NLEFT,
    MSK_RES_ERR_AFE_INVALID_INDEX,
    MSK_RES_ERR_ACC_INVALID_INDEX,
    MSK_RES_ERR_ACC_INVALID_ENTRY_INDEX,
    MSK_RES_ERR_ACC_AFE_DOMAIN_MISMATCH,
    MSK_RES_ERR_DJC_INVALID_INDEX,
    MSK_RES_ERR_DJC_UNSUPPORTED_DOMAIN_TYPE,
    MSK_RES_ERR_DJC_AFE_DOMAIN_MISMATCH,
    MSK_RES_ERR_DJC_INVALID_TERM_SIZE,
    MSK_RES_ERR_DJC_DOMAIN_TERMSIZE_MISMATCH,
    MSK_RES_ERR_DJC_TOTAL_NUM_TERMS_MISMATCH,
    MSK_RES_ERR_UNDEF_SOLUTION,
    MSK_RES_ERR_NO_DOTY,
    MSK_RES_TRM_MAX_ITERATIONS,
    MSK_RES_TRM_MAX_TIME,
    MSK_RES_TRM_OBJECTIVE_RANGE,
    MSK_RES_TRM_STALL,
    MSK_RES_TRM_USER_CALLBACK,
    MSK_RES_TRM_MIO_NUM_RELAXS,
    MSK_RES_TRM_MIO_NUM_BRANCHES,
    MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS,
    MSK_RES_TRM_MAX_NUM_SETBACKS,
    MSK_RES_TRM_NUMERICAL_PROBLEM,
    MSK_RES_TRM_LOST_RACE,
    MSK_RES_TRM_INTERNAL,
    MSK_RES_TRM_INTERNAL_STOP ]
members(::Type{Rescode}) = Rescode_members
Base.length(::Type{Rescode}) = 545
Base.convert(::Type{Int},x::Rescode) = Int(x.value)
"""
    Rescodetype

Response code type

* `MSK_RESPONSE_OK`. The response code is OK.
* `MSK_RESPONSE_WRN`. The response code is a warning.
* `MSK_RESPONSE_TRM`. The response code is an optimizer termination status.
* `MSK_RESPONSE_ERR`. The response code is an error.
* `MSK_RESPONSE_UNK`. The response code does not belong to any class.
"""
struct Rescodetype <: MosekEnum
  value :: Int32
end # rescodetype

"The response code is OK."
const MSK_RESPONSE_OK = Rescodetype(0)

"The response code is a warning."
const MSK_RESPONSE_WRN = Rescodetype(1)

"The response code is an optimizer termination status."
const MSK_RESPONSE_TRM = Rescodetype(2)

"The response code is an error."
const MSK_RESPONSE_ERR = Rescodetype(3)

"The response code does not belong to any class."
const MSK_RESPONSE_UNK = Rescodetype(4)
tostr(v::Rescodetype) = if v.value == 0 "Mosek.MSK_RESPONSE_OK"
  elseif v.value == 1 "Mosek.MSK_RESPONSE_WRN"
  elseif v.value == 2 "Mosek.MSK_RESPONSE_TRM"
  elseif v.value == 3 "Mosek.MSK_RESPONSE_ERR"
  elseif v.value == 4 "Mosek.MSK_RESPONSE_UNK"
  else "Mosek.Rescodetype(?)"
  end
const Rescodetype_members = Rescodetype[
    MSK_RESPONSE_OK,
    MSK_RESPONSE_WRN,
    MSK_RESPONSE_TRM,
    MSK_RESPONSE_ERR,
    MSK_RESPONSE_UNK ]
members(::Type{Rescodetype}) = Rescodetype_members
Base.length(::Type{Rescodetype}) = 5
Base.convert(::Type{Int},x::Rescodetype) = Int(x.value)
"""
    Scalingtype

Scaling type

* `MSK_SCALING_FREE`. The optimizer chooses the scaling heuristic.
* `MSK_SCALING_NONE`. No scaling is performed.
"""
struct Scalingtype <: MosekEnum
  value :: Int32
end # scalingtype

"The optimizer chooses the scaling heuristic."
const MSK_SCALING_FREE = Scalingtype(0)

"No scaling is performed."
const MSK_SCALING_NONE = Scalingtype(1)
tostr(v::Scalingtype) = if v.value == 0 "Mosek.MSK_SCALING_FREE"
  elseif v.value == 1 "Mosek.MSK_SCALING_NONE"
  else "Mosek.Scalingtype(?)"
  end
const Scalingtype_members = Scalingtype[
    MSK_SCALING_FREE,
    MSK_SCALING_NONE ]
members(::Type{Scalingtype}) = Scalingtype_members
Base.length(::Type{Scalingtype}) = 2
Base.convert(::Type{Int},x::Scalingtype) = Int(x.value)
"""
    Scalingmethod

Scaling method

* `MSK_SCALING_METHOD_POW2`. Scales only with power of 2 leaving the mantissa untouched.
* `MSK_SCALING_METHOD_FREE`. The optimizer chooses the scaling heuristic.
"""
struct Scalingmethod <: MosekEnum
  value :: Int32
end # scalingmethod

"Scales only with power of 2 leaving the mantissa untouched."
const MSK_SCALING_METHOD_POW2 = Scalingmethod(0)

"The optimizer chooses the scaling heuristic."
const MSK_SCALING_METHOD_FREE = Scalingmethod(1)
tostr(v::Scalingmethod) = if v.value == 0 "Mosek.MSK_SCALING_METHOD_POW2"
  elseif v.value == 1 "Mosek.MSK_SCALING_METHOD_FREE"
  else "Mosek.Scalingmethod(?)"
  end
const Scalingmethod_members = Scalingmethod[
    MSK_SCALING_METHOD_POW2,
    MSK_SCALING_METHOD_FREE ]
members(::Type{Scalingmethod}) = Scalingmethod_members
Base.length(::Type{Scalingmethod}) = 2
Base.convert(::Type{Int},x::Scalingmethod) = Int(x.value)
"""
    Sensitivitytype

Sensitivity types

* `MSK_SENSITIVITY_TYPE_BASIS`. Basis sensitivity analysis is performed.
"""
struct Sensitivitytype <: MosekEnum
  value :: Int32
end # sensitivitytype

"Basis sensitivity analysis is performed."
const MSK_SENSITIVITY_TYPE_BASIS = Sensitivitytype(0)
tostr(v::Sensitivitytype) = if v.value == 0 "Mosek.MSK_SENSITIVITY_TYPE_BASIS"
  else "Mosek.Sensitivitytype(?)"
  end
const Sensitivitytype_members = Sensitivitytype[
    MSK_SENSITIVITY_TYPE_BASIS ]
members(::Type{Sensitivitytype}) = Sensitivitytype_members
Base.length(::Type{Sensitivitytype}) = 1
Base.convert(::Type{Int},x::Sensitivitytype) = Int(x.value)
"""
    Simseltype

Simplex selection strategy

* `MSK_SIM_SELECTION_FREE`. The optimizer chooses the pricing strategy.
* `MSK_SIM_SELECTION_FULL`. The optimizer uses full pricing.
* `MSK_SIM_SELECTION_ASE`. The optimizer uses approximate steepest-edge pricing.
* `MSK_SIM_SELECTION_DEVEX`. The optimizer uses devex steepest-edge pricing.
* `MSK_SIM_SELECTION_SE`. The optimizer uses steepest-edge selection.
* `MSK_SIM_SELECTION_PARTIAL`. The optimizer uses a partial selection approach.
"""
struct Simseltype <: MosekEnum
  value :: Int32
end # simseltype

"The optimizer chooses the pricing strategy."
const MSK_SIM_SELECTION_FREE = Simseltype(0)

"The optimizer uses full pricing."
const MSK_SIM_SELECTION_FULL = Simseltype(1)

"The optimizer uses approximate steepest-edge pricing."
const MSK_SIM_SELECTION_ASE = Simseltype(2)

"The optimizer uses devex steepest-edge pricing."
const MSK_SIM_SELECTION_DEVEX = Simseltype(3)

"The optimizer uses steepest-edge selection."
const MSK_SIM_SELECTION_SE = Simseltype(4)

"The optimizer uses a partial selection approach."
const MSK_SIM_SELECTION_PARTIAL = Simseltype(5)
tostr(v::Simseltype) = if v.value == 0 "Mosek.MSK_SIM_SELECTION_FREE"
  elseif v.value == 1 "Mosek.MSK_SIM_SELECTION_FULL"
  elseif v.value == 2 "Mosek.MSK_SIM_SELECTION_ASE"
  elseif v.value == 3 "Mosek.MSK_SIM_SELECTION_DEVEX"
  elseif v.value == 4 "Mosek.MSK_SIM_SELECTION_SE"
  elseif v.value == 5 "Mosek.MSK_SIM_SELECTION_PARTIAL"
  else "Mosek.Simseltype(?)"
  end
const Simseltype_members = Simseltype[
    MSK_SIM_SELECTION_FREE,
    MSK_SIM_SELECTION_FULL,
    MSK_SIM_SELECTION_ASE,
    MSK_SIM_SELECTION_DEVEX,
    MSK_SIM_SELECTION_SE,
    MSK_SIM_SELECTION_PARTIAL ]
members(::Type{Simseltype}) = Simseltype_members
Base.length(::Type{Simseltype}) = 6
Base.convert(::Type{Int},x::Simseltype) = Int(x.value)
"""
    Solitem

Solution items

* `MSK_SOL_ITEM_XC`. Solution for the constraints.
* `MSK_SOL_ITEM_XX`. Variable solution.
* `MSK_SOL_ITEM_Y`. Lagrange multipliers for equations.
* `MSK_SOL_ITEM_SLC`. Lagrange multipliers for lower bounds on the constraints.
* `MSK_SOL_ITEM_SUC`. Lagrange multipliers for upper bounds on the constraints.
* `MSK_SOL_ITEM_SLX`. Lagrange multipliers for lower bounds on the variables.
* `MSK_SOL_ITEM_SUX`. Lagrange multipliers for upper bounds on the variables.
* `MSK_SOL_ITEM_SNX`. Lagrange multipliers corresponding to the conic constraints on the variables.
"""
struct Solitem <: MosekEnum
  value :: Int32
end # solitem

"Solution for the constraints."
const MSK_SOL_ITEM_XC = Solitem(0)

"Variable solution."
const MSK_SOL_ITEM_XX = Solitem(1)

"Lagrange multipliers for equations."
const MSK_SOL_ITEM_Y = Solitem(2)

"Lagrange multipliers for lower bounds on the constraints."
const MSK_SOL_ITEM_SLC = Solitem(3)

"Lagrange multipliers for upper bounds on the constraints."
const MSK_SOL_ITEM_SUC = Solitem(4)

"Lagrange multipliers for lower bounds on the variables."
const MSK_SOL_ITEM_SLX = Solitem(5)

"Lagrange multipliers for upper bounds on the variables."
const MSK_SOL_ITEM_SUX = Solitem(6)

"Lagrange multipliers corresponding to the conic constraints on the variables."
const MSK_SOL_ITEM_SNX = Solitem(7)
tostr(v::Solitem) = if v.value == 0 "Mosek.MSK_SOL_ITEM_XC"
  elseif v.value == 1 "Mosek.MSK_SOL_ITEM_XX"
  elseif v.value == 2 "Mosek.MSK_SOL_ITEM_Y"
  elseif v.value == 3 "Mosek.MSK_SOL_ITEM_SLC"
  elseif v.value == 4 "Mosek.MSK_SOL_ITEM_SUC"
  elseif v.value == 5 "Mosek.MSK_SOL_ITEM_SLX"
  elseif v.value == 6 "Mosek.MSK_SOL_ITEM_SUX"
  elseif v.value == 7 "Mosek.MSK_SOL_ITEM_SNX"
  else "Mosek.Solitem(?)"
  end
const Solitem_members = Solitem[
    MSK_SOL_ITEM_XC,
    MSK_SOL_ITEM_XX,
    MSK_SOL_ITEM_Y,
    MSK_SOL_ITEM_SLC,
    MSK_SOL_ITEM_SUC,
    MSK_SOL_ITEM_SLX,
    MSK_SOL_ITEM_SUX,
    MSK_SOL_ITEM_SNX ]
members(::Type{Solitem}) = Solitem_members
Base.length(::Type{Solitem}) = 8
Base.convert(::Type{Int},x::Solitem) = Int(x.value)
"""
    Solsta

Solution status keys

* `MSK_SOL_STA_UNKNOWN`. Status of the solution is unknown.
* `MSK_SOL_STA_OPTIMAL`. The solution is optimal.
* `MSK_SOL_STA_PRIM_FEAS`. The solution is primal feasible.
* `MSK_SOL_STA_DUAL_FEAS`. The solution is dual feasible.
* `MSK_SOL_STA_PRIM_AND_DUAL_FEAS`. The solution is both primal and dual feasible.
* `MSK_SOL_STA_PRIM_INFEAS_CER`. The solution is a certificate of primal infeasibility.
* `MSK_SOL_STA_DUAL_INFEAS_CER`. The solution is a certificate of dual infeasibility.
* `MSK_SOL_STA_PRIM_ILLPOSED_CER`. The solution is a certificate that the primal problem is illposed.
* `MSK_SOL_STA_DUAL_ILLPOSED_CER`. The solution is a certificate that the dual problem is illposed.
* `MSK_SOL_STA_INTEGER_OPTIMAL`. The primal solution is integer optimal.
"""
struct Solsta <: MosekEnum
  value :: Int32
end # solsta

"Status of the solution is unknown."
const MSK_SOL_STA_UNKNOWN = Solsta(0)

"The solution is optimal."
const MSK_SOL_STA_OPTIMAL = Solsta(1)

"The solution is primal feasible."
const MSK_SOL_STA_PRIM_FEAS = Solsta(2)

"The solution is dual feasible."
const MSK_SOL_STA_DUAL_FEAS = Solsta(3)

"The solution is both primal and dual feasible."
const MSK_SOL_STA_PRIM_AND_DUAL_FEAS = Solsta(4)

"The solution is a certificate of primal infeasibility."
const MSK_SOL_STA_PRIM_INFEAS_CER = Solsta(5)

"The solution is a certificate of dual infeasibility."
const MSK_SOL_STA_DUAL_INFEAS_CER = Solsta(6)

"The solution is a certificate that the primal problem is illposed."
const MSK_SOL_STA_PRIM_ILLPOSED_CER = Solsta(7)

"The solution is a certificate that the dual problem is illposed."
const MSK_SOL_STA_DUAL_ILLPOSED_CER = Solsta(8)

"The primal solution is integer optimal."
const MSK_SOL_STA_INTEGER_OPTIMAL = Solsta(9)
tostr(v::Solsta) = if v.value == 0 "Mosek.MSK_SOL_STA_UNKNOWN"
  elseif v.value == 1 "Mosek.MSK_SOL_STA_OPTIMAL"
  elseif v.value == 2 "Mosek.MSK_SOL_STA_PRIM_FEAS"
  elseif v.value == 3 "Mosek.MSK_SOL_STA_DUAL_FEAS"
  elseif v.value == 4 "Mosek.MSK_SOL_STA_PRIM_AND_DUAL_FEAS"
  elseif v.value == 5 "Mosek.MSK_SOL_STA_PRIM_INFEAS_CER"
  elseif v.value == 6 "Mosek.MSK_SOL_STA_DUAL_INFEAS_CER"
  elseif v.value == 7 "Mosek.MSK_SOL_STA_PRIM_ILLPOSED_CER"
  elseif v.value == 8 "Mosek.MSK_SOL_STA_DUAL_ILLPOSED_CER"
  elseif v.value == 9 "Mosek.MSK_SOL_STA_INTEGER_OPTIMAL"
  else "Mosek.Solsta(?)"
  end
const Solsta_members = Solsta[
    MSK_SOL_STA_UNKNOWN,
    MSK_SOL_STA_OPTIMAL,
    MSK_SOL_STA_PRIM_FEAS,
    MSK_SOL_STA_DUAL_FEAS,
    MSK_SOL_STA_PRIM_AND_DUAL_FEAS,
    MSK_SOL_STA_PRIM_INFEAS_CER,
    MSK_SOL_STA_DUAL_INFEAS_CER,
    MSK_SOL_STA_PRIM_ILLPOSED_CER,
    MSK_SOL_STA_DUAL_ILLPOSED_CER,
    MSK_SOL_STA_INTEGER_OPTIMAL ]
members(::Type{Solsta}) = Solsta_members
Base.length(::Type{Solsta}) = 10
Base.convert(::Type{Int},x::Solsta) = Int(x.value)
"""
    Soltype

Solution types

* `MSK_SOL_ITR`. The interior solution.
* `MSK_SOL_BAS`. The basic solution.
* `MSK_SOL_ITG`. The integer solution.
"""
struct Soltype <: MosekEnum
  value :: Int32
end # soltype

"The interior solution."
const MSK_SOL_ITR = Soltype(0)

"The basic solution."
const MSK_SOL_BAS = Soltype(1)

"The integer solution."
const MSK_SOL_ITG = Soltype(2)
tostr(v::Soltype) = if v.value == 0 "Mosek.MSK_SOL_ITR"
  elseif v.value == 1 "Mosek.MSK_SOL_BAS"
  elseif v.value == 2 "Mosek.MSK_SOL_ITG"
  else "Mosek.Soltype(?)"
  end
const Soltype_members = Soltype[
    MSK_SOL_ITR,
    MSK_SOL_BAS,
    MSK_SOL_ITG ]
members(::Type{Soltype}) = Soltype_members
Base.length(::Type{Soltype}) = 3
Base.convert(::Type{Int},x::Soltype) = Int(x.value)
"""
    Solveform

Solve primal or dual form

* `MSK_SOLVE_FREE`. The optimizer is free to solve either the primal or the dual problem.
* `MSK_SOLVE_PRIMAL`. The optimizer should solve the primal problem.
* `MSK_SOLVE_DUAL`. The optimizer should solve the dual problem.
"""
struct Solveform <: MosekEnum
  value :: Int32
end # solveform

"The optimizer is free to solve either the primal or the dual problem."
const MSK_SOLVE_FREE = Solveform(0)

"The optimizer should solve the primal problem."
const MSK_SOLVE_PRIMAL = Solveform(1)

"The optimizer should solve the dual problem."
const MSK_SOLVE_DUAL = Solveform(2)
tostr(v::Solveform) = if v.value == 0 "Mosek.MSK_SOLVE_FREE"
  elseif v.value == 1 "Mosek.MSK_SOLVE_PRIMAL"
  elseif v.value == 2 "Mosek.MSK_SOLVE_DUAL"
  else "Mosek.Solveform(?)"
  end
const Solveform_members = Solveform[
    MSK_SOLVE_FREE,
    MSK_SOLVE_PRIMAL,
    MSK_SOLVE_DUAL ]
members(::Type{Solveform}) = Solveform_members
Base.length(::Type{Solveform}) = 3
Base.convert(::Type{Int},x::Solveform) = Int(x.value)
"""
    Sparam

The enumeration type containing all string parameters.

* `MSK_SPAR_BAS_SOL_FILE_NAME`. Name of the bas solution file.
* `MSK_SPAR_DATA_FILE_NAME`. Data are read and written to this file.
* `MSK_SPAR_DEBUG_FILE_NAME`. MOSEK debug file.
* `MSK_SPAR_INT_SOL_FILE_NAME`. Name of the int solution file.
* `MSK_SPAR_ITR_SOL_FILE_NAME`. Name of the itr solution file.
* `MSK_SPAR_MIO_DEBUG_STRING`. For internal debugging purposes.
* `MSK_SPAR_PARAM_COMMENT_SIGN`. Solution file comment character.
* `MSK_SPAR_PARAM_READ_FILE_NAME`. Modifications to the parameter database is read from this file.
* `MSK_SPAR_PARAM_WRITE_FILE_NAME`. The parameter database is written to this file.
* `MSK_SPAR_READ_MPS_BOU_NAME`. Name of the BOUNDS vector used. An empty name means that the first BOUNDS vector is used.
* `MSK_SPAR_READ_MPS_OBJ_NAME`. Objective name in the MPS file.
* `MSK_SPAR_READ_MPS_RAN_NAME`. Name of the RANGE vector  used. An empty name means that the first RANGE vector is used.
* `MSK_SPAR_READ_MPS_RHS_NAME`. Name of the RHS used. An empty name means that the first RHS vector is used.
* `MSK_SPAR_REMOTE_OPTSERVER_HOST`. URL of the remote optimization server.
* `MSK_SPAR_REMOTE_TLS_CERT`. Known server certificates in PEM format
* `MSK_SPAR_REMOTE_TLS_CERT_PATH`. Path to known server certificates in PEM format
* `MSK_SPAR_SENSITIVITY_FILE_NAME`. Sensitivity report file name.
* `MSK_SPAR_SENSITIVITY_RES_FILE_NAME`. Name of the sensitivity report output file.
* `MSK_SPAR_SOL_FILTER_XC_LOW`. Solution file filter.
* `MSK_SPAR_SOL_FILTER_XC_UPR`. Solution file filter.
* `MSK_SPAR_SOL_FILTER_XX_LOW`. Solution file filter.
* `MSK_SPAR_SOL_FILTER_XX_UPR`. Solution file filter.
* `MSK_SPAR_STAT_KEY`. Key used when writing the summary file.
* `MSK_SPAR_STAT_NAME`. Name used when writing the statistics file.
* `MSK_SPAR_WRITE_LP_GEN_VAR_NAME`. Added variable names in the LP files.
"""
struct Sparam <: MosekEnum
  value :: Int32
end # sparam

"""
Name of the bas solution file.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_BAS_SOL_FILE_NAME = Sparam(0)

"""
Data are read and written to this file.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_DATA_FILE_NAME = Sparam(1)

"""
MOSEK debug file.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_DEBUG_FILE_NAME = Sparam(2)

"""
Name of the int solution file.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_INT_SOL_FILE_NAME = Sparam(3)

"""
Name of the itr solution file.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_ITR_SOL_FILE_NAME = Sparam(4)

"""
For internal debugging purposes.

Default value: "``"

Possible Values: Any valid string.

"""
const MSK_SPAR_MIO_DEBUG_STRING = Sparam(5)

"""
Solution file comment character.

Default value: "`%%`"

Possible Values: Any valid string.

"""
const MSK_SPAR_PARAM_COMMENT_SIGN = Sparam(6)

"""
Modifications to the parameter database is read from this file.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_PARAM_READ_FILE_NAME = Sparam(7)

"""
The parameter database is written to this file.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_PARAM_WRITE_FILE_NAME = Sparam(8)

"""
Name of the BOUNDS vector used. An empty name means that the first BOUNDS vector is used.

Default value: "``"

Possible Values: Any valid MPS name.

"""
const MSK_SPAR_READ_MPS_BOU_NAME = Sparam(9)

"""
Objective name in the MPS file.

Default value: "``"

Possible Values: Any valid MPS name.

"""
const MSK_SPAR_READ_MPS_OBJ_NAME = Sparam(10)

"""
Name of the RANGE vector  used. An empty name means that the first RANGE vector is used.

Default value: "``"

Possible Values: Any valid MPS name.

"""
const MSK_SPAR_READ_MPS_RAN_NAME = Sparam(11)

"""
Name of the RHS used. An empty name means that the first RHS vector is used.

Default value: "``"

Possible Values: Any valid MPS name.

"""
const MSK_SPAR_READ_MPS_RHS_NAME = Sparam(12)

"""
URL of the remote optimization server.

Default value: "``"

Possible Values: Any valid URL.

"""
const MSK_SPAR_REMOTE_OPTSERVER_HOST = Sparam(13)

"""
Known server certificates in PEM format

Default value: "``"

Possible Values: PEM files separated by new-lines.

"""
const MSK_SPAR_REMOTE_TLS_CERT = Sparam(14)

"""
Path to known server certificates in PEM format

Default value: "``"

Possible Values: Any valid path.

"""
const MSK_SPAR_REMOTE_TLS_CERT_PATH = Sparam(15)

"""
Sensitivity report file name.

Default value: "``"

Possible Values: Any valid string.

"""
const MSK_SPAR_SENSITIVITY_FILE_NAME = Sparam(16)

"""
Name of the sensitivity report output file.

Default value: "``"

Possible Values: Any valid string.

"""
const MSK_SPAR_SENSITIVITY_RES_FILE_NAME = Sparam(17)

"""
Solution file filter.

Default value: "``"

Possible Values: Any valid filter.

"""
const MSK_SPAR_SOL_FILTER_XC_LOW = Sparam(18)

"""
Solution file filter.

Default value: "``"

Possible Values: Any valid filter.

"""
const MSK_SPAR_SOL_FILTER_XC_UPR = Sparam(19)

"""
Solution file filter.

Default value: "``"

Possible Values: Any valid filter.

"""
const MSK_SPAR_SOL_FILTER_XX_LOW = Sparam(20)

"""
Solution file filter.

Default value: "``"

Possible Values: Any valid file name.

"""
const MSK_SPAR_SOL_FILTER_XX_UPR = Sparam(21)

"""
Key used when writing the summary file.

Default value: "``"

Possible Values: Any valid string.

"""
const MSK_SPAR_STAT_KEY = Sparam(22)

"""
Name used when writing the statistics file.

Default value: "``"

Possible Values: Any valid XML string.

"""
const MSK_SPAR_STAT_NAME = Sparam(23)

"""
Added variable names in the LP files.

Default value: "`xmskgen`"

Possible Values: Any valid string.

"""
const MSK_SPAR_WRITE_LP_GEN_VAR_NAME = Sparam(24)
tostr(v::Sparam) = if v.value == 0 "Mosek.MSK_SPAR_BAS_SOL_FILE_NAME"
  elseif v.value == 1 "Mosek.MSK_SPAR_DATA_FILE_NAME"
  elseif v.value == 2 "Mosek.MSK_SPAR_DEBUG_FILE_NAME"
  elseif v.value == 3 "Mosek.MSK_SPAR_INT_SOL_FILE_NAME"
  elseif v.value == 4 "Mosek.MSK_SPAR_ITR_SOL_FILE_NAME"
  elseif v.value == 5 "Mosek.MSK_SPAR_MIO_DEBUG_STRING"
  elseif v.value == 6 "Mosek.MSK_SPAR_PARAM_COMMENT_SIGN"
  elseif v.value == 7 "Mosek.MSK_SPAR_PARAM_READ_FILE_NAME"
  elseif v.value == 8 "Mosek.MSK_SPAR_PARAM_WRITE_FILE_NAME"
  elseif v.value == 9 "Mosek.MSK_SPAR_READ_MPS_BOU_NAME"
  elseif v.value == 10 "Mosek.MSK_SPAR_READ_MPS_OBJ_NAME"
  elseif v.value == 11 "Mosek.MSK_SPAR_READ_MPS_RAN_NAME"
  elseif v.value == 12 "Mosek.MSK_SPAR_READ_MPS_RHS_NAME"
  elseif v.value == 13 "Mosek.MSK_SPAR_REMOTE_OPTSERVER_HOST"
  elseif v.value == 14 "Mosek.MSK_SPAR_REMOTE_TLS_CERT"
  elseif v.value == 15 "Mosek.MSK_SPAR_REMOTE_TLS_CERT_PATH"
  elseif v.value == 16 "Mosek.MSK_SPAR_SENSITIVITY_FILE_NAME"
  elseif v.value == 17 "Mosek.MSK_SPAR_SENSITIVITY_RES_FILE_NAME"
  elseif v.value == 18 "Mosek.MSK_SPAR_SOL_FILTER_XC_LOW"
  elseif v.value == 19 "Mosek.MSK_SPAR_SOL_FILTER_XC_UPR"
  elseif v.value == 20 "Mosek.MSK_SPAR_SOL_FILTER_XX_LOW"
  elseif v.value == 21 "Mosek.MSK_SPAR_SOL_FILTER_XX_UPR"
  elseif v.value == 22 "Mosek.MSK_SPAR_STAT_KEY"
  elseif v.value == 23 "Mosek.MSK_SPAR_STAT_NAME"
  elseif v.value == 24 "Mosek.MSK_SPAR_WRITE_LP_GEN_VAR_NAME"
  else "Mosek.Sparam(?)"
  end
const Sparam_members = Sparam[
    MSK_SPAR_BAS_SOL_FILE_NAME,
    MSK_SPAR_DATA_FILE_NAME,
    MSK_SPAR_DEBUG_FILE_NAME,
    MSK_SPAR_INT_SOL_FILE_NAME,
    MSK_SPAR_ITR_SOL_FILE_NAME,
    MSK_SPAR_MIO_DEBUG_STRING,
    MSK_SPAR_PARAM_COMMENT_SIGN,
    MSK_SPAR_PARAM_READ_FILE_NAME,
    MSK_SPAR_PARAM_WRITE_FILE_NAME,
    MSK_SPAR_READ_MPS_BOU_NAME,
    MSK_SPAR_READ_MPS_OBJ_NAME,
    MSK_SPAR_READ_MPS_RAN_NAME,
    MSK_SPAR_READ_MPS_RHS_NAME,
    MSK_SPAR_REMOTE_OPTSERVER_HOST,
    MSK_SPAR_REMOTE_TLS_CERT,
    MSK_SPAR_REMOTE_TLS_CERT_PATH,
    MSK_SPAR_SENSITIVITY_FILE_NAME,
    MSK_SPAR_SENSITIVITY_RES_FILE_NAME,
    MSK_SPAR_SOL_FILTER_XC_LOW,
    MSK_SPAR_SOL_FILTER_XC_UPR,
    MSK_SPAR_SOL_FILTER_XX_LOW,
    MSK_SPAR_SOL_FILTER_XX_UPR,
    MSK_SPAR_STAT_KEY,
    MSK_SPAR_STAT_NAME,
    MSK_SPAR_WRITE_LP_GEN_VAR_NAME ]
members(::Type{Sparam}) = Sparam_members
Base.length(::Type{Sparam}) = 25
Base.convert(::Type{Int},x::Sparam) = Int(x.value)
"""
    Stakey

Status keys

* `MSK_SK_UNK`. The status for the constraint or variable is unknown.
* `MSK_SK_BAS`. The constraint or variable is in the basis.
* `MSK_SK_SUPBAS`. The constraint or variable is super basic.
* `MSK_SK_LOW`. The constraint or variable is at its lower bound.
* `MSK_SK_UPR`. The constraint or variable is at its upper bound.
* `MSK_SK_FIX`. The constraint or variable is fixed.
* `MSK_SK_INF`. The constraint or variable is infeasible in the bounds.
"""
struct Stakey <: MosekEnum
  value :: Int32
end # stakey

"The status for the constraint or variable is unknown."
const MSK_SK_UNK = Stakey(0)

"The constraint or variable is in the basis."
const MSK_SK_BAS = Stakey(1)

"The constraint or variable is super basic."
const MSK_SK_SUPBAS = Stakey(2)

"The constraint or variable is at its lower bound."
const MSK_SK_LOW = Stakey(3)

"The constraint or variable is at its upper bound."
const MSK_SK_UPR = Stakey(4)

"The constraint or variable is fixed."
const MSK_SK_FIX = Stakey(5)

"The constraint or variable is infeasible in the bounds."
const MSK_SK_INF = Stakey(6)
tostr(v::Stakey) = if v.value == 0 "Mosek.MSK_SK_UNK"
  elseif v.value == 1 "Mosek.MSK_SK_BAS"
  elseif v.value == 2 "Mosek.MSK_SK_SUPBAS"
  elseif v.value == 3 "Mosek.MSK_SK_LOW"
  elseif v.value == 4 "Mosek.MSK_SK_UPR"
  elseif v.value == 5 "Mosek.MSK_SK_FIX"
  elseif v.value == 6 "Mosek.MSK_SK_INF"
  else "Mosek.Stakey(?)"
  end
const Stakey_members = Stakey[
    MSK_SK_UNK,
    MSK_SK_BAS,
    MSK_SK_SUPBAS,
    MSK_SK_LOW,
    MSK_SK_UPR,
    MSK_SK_FIX,
    MSK_SK_INF ]
members(::Type{Stakey}) = Stakey_members
Base.length(::Type{Stakey}) = 7
Base.convert(::Type{Int},x::Stakey) = Int(x.value)
"""
    Startpointtype

Starting point types

* `MSK_STARTING_POINT_FREE`. The starting point is chosen automatically.
* `MSK_STARTING_POINT_GUESS`. The optimizer guesses a starting point.
* `MSK_STARTING_POINT_CONSTANT`. The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust.
"""
struct Startpointtype <: MosekEnum
  value :: Int32
end # startpointtype

"The starting point is chosen automatically."
const MSK_STARTING_POINT_FREE = Startpointtype(0)

"The optimizer guesses a starting point."
const MSK_STARTING_POINT_GUESS = Startpointtype(1)

"The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust."
const MSK_STARTING_POINT_CONSTANT = Startpointtype(2)
tostr(v::Startpointtype) = if v.value == 0 "Mosek.MSK_STARTING_POINT_FREE"
  elseif v.value == 1 "Mosek.MSK_STARTING_POINT_GUESS"
  elseif v.value == 2 "Mosek.MSK_STARTING_POINT_CONSTANT"
  else "Mosek.Startpointtype(?)"
  end
const Startpointtype_members = Startpointtype[
    MSK_STARTING_POINT_FREE,
    MSK_STARTING_POINT_GUESS,
    MSK_STARTING_POINT_CONSTANT ]
members(::Type{Startpointtype}) = Startpointtype_members
Base.length(::Type{Startpointtype}) = 3
Base.convert(::Type{Int},x::Startpointtype) = Int(x.value)
"""
    Streamtype

Stream types

* `MSK_STREAM_LOG`. Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream.
* `MSK_STREAM_MSG`. Message stream. Log information relating to performance and progress of the optimization is written to this stream.
* `MSK_STREAM_ERR`. Error stream. Error messages are written to this stream.
* `MSK_STREAM_WRN`. Warning stream. Warning messages are written to this stream.
"""
struct Streamtype <: MosekEnum
  value :: Int32
end # streamtype

"Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream."
const MSK_STREAM_LOG = Streamtype(0)

"Message stream. Log information relating to performance and progress of the optimization is written to this stream."
const MSK_STREAM_MSG = Streamtype(1)

"Error stream. Error messages are written to this stream."
const MSK_STREAM_ERR = Streamtype(2)

"Warning stream. Warning messages are written to this stream."
const MSK_STREAM_WRN = Streamtype(3)
tostr(v::Streamtype) = if v.value == 0 "Mosek.MSK_STREAM_LOG"
  elseif v.value == 1 "Mosek.MSK_STREAM_MSG"
  elseif v.value == 2 "Mosek.MSK_STREAM_ERR"
  elseif v.value == 3 "Mosek.MSK_STREAM_WRN"
  else "Mosek.Streamtype(?)"
  end
const Streamtype_members = Streamtype[
    MSK_STREAM_LOG,
    MSK_STREAM_MSG,
    MSK_STREAM_ERR,
    MSK_STREAM_WRN ]
members(::Type{Streamtype}) = Streamtype_members
Base.length(::Type{Streamtype}) = 4
Base.convert(::Type{Int},x::Streamtype) = Int(x.value)
"""
    Value

Integer values

* `MSK_LICENSE_BUFFER_LENGTH`. The length of a license key buffer.
* `MSK_MAX_STR_LEN`. Maximum string length allowed in MOSEK.
"""
struct Value <: MosekEnum
  value :: Int32
end # value

"The length of a license key buffer."
const MSK_LICENSE_BUFFER_LENGTH = Value(21)

"Maximum string length allowed in MOSEK."
const MSK_MAX_STR_LEN = Value(1024)
tostr(v::Value) = if v.value == 21 "Mosek.MSK_LICENSE_BUFFER_LENGTH"
  elseif v.value == 1024 "Mosek.MSK_MAX_STR_LEN"
  else "Mosek.Value(?)"
  end
const Value_members = Value[
    MSK_LICENSE_BUFFER_LENGTH,
    MSK_MAX_STR_LEN ]
members(::Type{Value}) = Value_members
Base.length(::Type{Value}) = 2
Base.convert(::Type{Int},x::Value) = Int(x.value)
"""
    Variabletype

Variable types

* `MSK_VAR_TYPE_CONT`. Is a continuous variable.
* `MSK_VAR_TYPE_INT`. Is an integer variable.
"""
struct Variabletype <: MosekEnum
  value :: Int32
end # variabletype

"Is a continuous variable."
const MSK_VAR_TYPE_CONT = Variabletype(0)

"Is an integer variable."
const MSK_VAR_TYPE_INT = Variabletype(1)
tostr(v::Variabletype) = if v.value == 0 "Mosek.MSK_VAR_TYPE_CONT"
  elseif v.value == 1 "Mosek.MSK_VAR_TYPE_INT"
  else "Mosek.Variabletype(?)"
  end
const Variabletype_members = Variabletype[
    MSK_VAR_TYPE_CONT,
    MSK_VAR_TYPE_INT ]
members(::Type{Variabletype}) = Variabletype_members
Base.length(::Type{Variabletype}) = 2
Base.convert(::Type{Int},x::Variabletype) = Int(x.value)
